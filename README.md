<!DOCTYPE html>
<!-- saved from url=(0052)https://www.gnu.org/software/guile/manual/guile.html -->
<html><!-- Created by GNU Texinfo 7.0.1, https://www.gnu.org/software/texinfo/ --><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<!-- This manual documents Guile version 3.0.9.

Copyright (C) 1996-1997, 2000-2005, 2009-2023 Free Software Foundation,
Inc. 

Copyright (C) 2021 Maxime Devos

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled "GNU Free
Documentation License." -->
<title>Guile Reference Manual</title>

<meta name="description" content="Guile Reference Manual">
<meta name="keywords" content="Guile Reference Manual">
<meta name="resource-type" content="document">
<meta name="distribution" content="global">
<meta name="Generator" content="makeinfo">
<meta name="viewport" content="width=device-width,initial-scale=1">

<link href="https://www.gnu.org/software/guile/manual/guile.html#Top" rel="start" title="Top">
<link href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel="index" title="Concept Index">
<link href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" rel="contents" title="Table of Contents">
<link href="https://www.gnu.org/software/guile/manual/index.html" rel="up" title="(dir)">
<link href="https://www.gnu.org/software/guile/manual/guile.html#Preface" rel="next" title="Preface">
<link href="https://www.gnu.org/software/guile/manual/index.html" rel="prev" title="(dir)">
<style type="text/css">
<!--
a.copiable-link {visibility: hidden; text-decoration: none; line-height: 0em}
a.summary-letter-printindex {text-decoration: none}
div.center {text-align:center}
div.display {margin-left: 3.2em}
div.example {margin-left: 3.2em}
kbd.kbd {font-style: oblique}
kbd.key {font-style: normal}
pre.display-preformatted {font-family: inherit}
span.r {font-family: initial; font-weight: normal; font-style: normal}
span.w-nolinebreak-text {white-space: nowrap}
span:hover a.copiable-link {visibility: visible}
strong.def-name {font-family: monospace; font-weight: bold; font-size: larger}
td.printindex-index-entry {vertical-align: top}
td.printindex-index-section {vertical-align: top}
th.entries-header-printindex {text-align:left}
th.sections-header-printindex {text-align:left}
ul.mark-bullet {list-style-type: disc}
ul.mark-none {list-style-type: none}
ul.toc-numbered-mark {list-style: none}
-->
</style>
<link rel="stylesheet" type="text/css" href="./README_files/manual.css">


</head>

<body lang="en">


















<div class="top-level-extent" id="Top">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Preface" accesskey="n" rel="next">Preface</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/index.html" accesskey="p" rel="prev">(dir)</a>, Up: <a href="https://www.gnu.org/software/guile/manual/index.html" accesskey="u" rel="up">(dir)</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h1 class="top" id="The-Guile-Reference-Manual">The Guile Reference Manual</h1>

<p>This manual documents Guile version 3.0.9.
</p>
<p>Copyright (C) 1996-1997, 2000-2005, 2009-2023 Free Software Foundation,
Inc. <br>
Copyright (C) 2021 Maxime Devos
</p>
<p>Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front-Cover Texts, and no Back-Cover Texts.  A
copy of the license is included in the section entitled “GNU Free
Documentation License.”
</p><br>




<div class="element-contents" id="SEC_Contents">
<h2 class="contents-heading">Table of Contents</h2>

<div class="contents">

<ul class="toc-numbered-mark">
  <li><a id="toc-Preface-1" href="https://www.gnu.org/software/guile/manual/guile.html#Preface">Preface</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Contributors-to-this-Manual" href="https://www.gnu.org/software/guile/manual/guile.html#Contributors">Contributors to this Manual</a></li>
    <li><a id="toc-The-Guile-License" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-License">The Guile License</a></li>
  </ul></li>
  <li><a id="toc-Introduction-1" href="https://www.gnu.org/software/guile/manual/guile.html#Introduction">1 Introduction</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Guile-and-Scheme-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-Scheme">1.1 Guile and Scheme</a></li>
    <li><a id="toc-Combining-with-C-Code" href="https://www.gnu.org/software/guile/manual/guile.html#Combining-with-C">1.2 Combining with C Code</a></li>
    <li><a id="toc-Guile-and-the-GNU-Project-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-the-GNU-Project">1.3 Guile and the GNU Project</a></li>
    <li><a id="toc-Interactive-Programming-1" href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Programming">1.4 Interactive Programming</a></li>
    <li><a id="toc-Supporting-Multiple-Languages-1" href="https://www.gnu.org/software/guile/manual/guile.html#Supporting-Multiple-Languages">1.5 Supporting Multiple Languages</a></li>
    <li><a id="toc-Obtaining-and-Installing-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#Obtaining-and-Installing-Guile">1.6 Obtaining and Installing Guile</a></li>
    <li><a id="toc-Organisation-of-this-Manual-1" href="https://www.gnu.org/software/guile/manual/guile.html#Organisation-of-this-Manual">1.7 Organisation of this Manual</a></li>
    <li><a id="toc-Typographical-Conventions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Typographical-Conventions">1.8 Typographical Conventions</a></li>
  </ul></li>
  <li><a id="toc-Hello-Guile_0021-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021">2 Hello Guile!</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Running-Guile-Interactively-1" href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Interactively">2.1 Running Guile Interactively</a></li>
    <li><a id="toc-Running-Guile-Scripts-1" href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Scripts">2.2 Running Guile Scripts</a></li>
    <li><a id="toc-Linking-Guile-into-Programs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-into-Programs">2.3 Linking Guile into Programs</a></li>
    <li><a id="toc-Writing-Guile-Extensions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Writing-Guile-Extensions">2.4 Writing Guile Extensions</a></li>
    <li><a id="toc-Using-the-Guile-Module-System-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System">2.5 Using the Guile Module System</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Using-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Modules">2.5.1 Using Modules</a></li>
      <li><a id="toc-Writing-new-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Writing-new-Modules">2.5.2 Writing new Modules</a></li>
      <li><a id="toc-Putting-Extensions-into-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Putting-Extensions-into-Modules">2.5.3 Putting Extensions into Modules</a></li>
    </ul></li>
    <li><a id="toc-Reporting-Bugs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Bugs">2.6 Reporting Bugs</a></li>
  </ul></li>
  <li><a id="toc-Hello-Scheme_0021-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021">3 Hello Scheme!</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Data-Types_002c-Values-and-Variables" href="https://www.gnu.org/software/guile/manual/guile.html#About-Data">3.1 Data Types, Values and Variables</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Latent-Typing-1" href="https://www.gnu.org/software/guile/manual/guile.html#Latent-Typing">3.1.1 Latent Typing</a></li>
      <li><a id="toc-Values-and-Variables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Values-and-Variables">3.1.2 Values and Variables</a></li>
      <li><a id="toc-Defining-and-Setting-Variables" href="https://www.gnu.org/software/guile/manual/guile.html#Definition">3.1.3 Defining and Setting Variables</a></li>
    </ul></li>
    <li><a id="toc-The-Representation-and-Use-of-Procedures" href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures">3.2 The Representation and Use of Procedures</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Procedures-as-Values-1" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-as-Values">3.2.1 Procedures as Values</a></li>
      <li><a id="toc-Simple-Procedure-Invocation" href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Invocation">3.2.2 Simple Procedure Invocation</a></li>
      <li><a id="toc-Creating-and-Using-a-New-Procedure" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-a-Procedure">3.2.3 Creating and Using a New Procedure</a></li>
      <li><a id="toc-Lambda-Alternatives-1" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda-Alternatives">3.2.4 Lambda Alternatives</a></li>
    </ul></li>
    <li><a id="toc-Expressions-and-Evaluation" href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions">3.3 Expressions and Evaluation</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Evaluating-Expressions-and-Executing-Programs" href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating">3.3.1 Evaluating Expressions and Executing Programs</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Evaluating-Literal-Data" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Literal">3.3.1.1 Evaluating Literal Data</a></li>
        <li><a id="toc-Evaluating-a-Variable-Reference" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Variable">3.3.1.2 Evaluating a Variable Reference</a></li>
        <li><a id="toc-Evaluating-a-Procedure-Invocation-Expression" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Procedure">3.3.1.3 Evaluating a Procedure Invocation Expression</a></li>
        <li><a id="toc-Evaluating-Special-Syntactic-Expressions" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Special">3.3.1.4 Evaluating Special Syntactic Expressions</a></li>
      </ul></li>
      <li><a id="toc-Tail-calls" href="https://www.gnu.org/software/guile/manual/guile.html#Tail-Calls">3.3.2 Tail calls</a></li>
      <li><a id="toc-Using-the-Guile-REPL" href="https://www.gnu.org/software/guile/manual/guile.html#The-REPL">3.3.3 Using the Guile REPL</a></li>
      <li><a id="toc-Summary-of-Common-Syntax" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Summary">3.3.4 Summary of Common Syntax</a></li>
    </ul></li>
    <li><a id="toc-The-Concept-of-Closure" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">3.4 The Concept of Closure</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Names_002c-Locations_002c-Values-and-Environments" href="https://www.gnu.org/software/guile/manual/guile.html#About-Environments">3.4.1 Names, Locations, Values and Environments</a></li>
      <li><a id="toc-Local-Variables-and-Environments" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Variables">3.4.2 Local Variables and Environments</a></li>
      <li><a id="toc-Environment-Chaining" href="https://www.gnu.org/software/guile/manual/guile.html#Chaining">3.4.3 Environment Chaining</a></li>
      <li><a id="toc-Lexical-Scope-1" href="https://www.gnu.org/software/guile/manual/guile.html#Lexical-Scope">3.4.4 Lexical Scope</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-An-Example-of-Non_002dLexical-Scoping" href="https://www.gnu.org/software/guile/manual/guile.html#Scoping-Example">3.4.4.1 An Example of Non-Lexical Scoping</a></li>
      </ul></li>
      <li><a id="toc-Closure-1" href="https://www.gnu.org/software/guile/manual/guile.html#Closure">3.4.5 Closure</a></li>
      <li><a id="toc-Example-1_003a-A-Serial-Number-Generator" href="https://www.gnu.org/software/guile/manual/guile.html#Serial-Number">3.4.6 Example 1: A Serial Number Generator</a></li>
      <li><a id="toc-Example-2_003a-A-Shared-Persistent-Variable" href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Variable">3.4.7 Example 2: A Shared Persistent Variable</a></li>
      <li><a id="toc-Example-3_003a-The-Callback-Closure-Problem" href="https://www.gnu.org/software/guile/manual/guile.html#Callback-Closure">3.4.8 Example 3: The Callback Closure Problem</a></li>
      <li><a id="toc-Example-4_003a-Object-Orientation" href="https://www.gnu.org/software/guile/manual/guile.html#OO-Closure">3.4.9 Example 4: Object Orientation</a></li>
    </ul></li>
    <li><a id="toc-Further-Reading-1" href="https://www.gnu.org/software/guile/manual/guile.html#Further-Reading">3.5 Further Reading</a></li>
  </ul></li>
  <li><a id="toc-Programming-in-Scheme-1" href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme">4 Programming in Scheme</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Guile_0027s-Implementation-of-Scheme" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scheme">4.1 Guile’s Implementation of Scheme</a></li>
    <li><a id="toc-Invoking-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile">4.2 Invoking Guile</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Command_002dline-Options-1" href="https://www.gnu.org/software/guile/manual/guile.html#Command_002dline-Options">4.2.1 Command-line Options</a></li>
      <li><a id="toc-Environment-Variables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Environment-Variables">4.2.2 Environment Variables</a></li>
    </ul></li>
    <li><a id="toc-Guile-Scripting-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting">4.3 Guile Scripting</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-The-Top-of-a-Script-File-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Top-of-a-Script-File">4.3.1 The Top of a Script File</a></li>
      <li><a id="toc-The-Meta-Switch-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch">4.3.2 The Meta Switch</a></li>
      <li><a id="toc-Command-Line-Handling-1" href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Handling">4.3.3 Command Line Handling</a></li>
      <li><a id="toc-Scripting-Examples-1" href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples">4.3.4 Scripting Examples</a></li>
    </ul></li>
    <li><a id="toc-Using-Guile-Interactively-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively">4.4 Using Guile Interactively</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-The-Init-File_002c-_007e_002f_002eguile" href="https://www.gnu.org/software/guile/manual/guile.html#Init-File">4.4.1 The Init File, <samp class="file">~/.guile</samp></a></li>
      <li><a id="toc-Readline-1" href="https://www.gnu.org/software/guile/manual/guile.html#Readline">4.4.2 Readline</a></li>
      <li><a id="toc-Value-History-1" href="https://www.gnu.org/software/guile/manual/guile.html#Value-History">4.4.3 Value History</a></li>
      <li><a id="toc-REPL-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands">4.4.4 REPL Commands</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Help-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Help-Commands">4.4.4.1 Help Commands</a></li>
        <li><a id="toc-Module-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Module-Commands">4.4.4.2 Module Commands</a></li>
        <li><a id="toc-Language-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Language-Commands">4.4.4.3 Language Commands</a></li>
        <li><a id="toc-Compile-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Compile-Commands">4.4.4.4 Compile Commands</a></li>
        <li><a id="toc-Profile-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Profile-Commands">4.4.4.5 Profile Commands</a></li>
        <li><a id="toc-Debug-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Commands">4.4.4.6 Debug Commands</a></li>
        <li><a id="toc-Inspect-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#Inspect-Commands">4.4.4.7 Inspect Commands</a></li>
        <li><a id="toc-System-Commands-1" href="https://www.gnu.org/software/guile/manual/guile.html#System-Commands">4.4.4.8 System Commands</a></li>
      </ul></li>
      <li><a id="toc-Error-Handling-1" href="https://www.gnu.org/software/guile/manual/guile.html#Error-Handling">4.4.5 Error Handling</a></li>
      <li><a id="toc-Interactive-Debugging-1" href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Debugging">4.4.6 Interactive Debugging</a></li>
    </ul></li>
    <li><a id="toc-Using-Guile-in-Emacs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-in-Emacs">4.5 Using Guile in Emacs</a></li>
    <li><a id="toc-Using-Guile-Tools-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Tools">4.6 Using Guile Tools</a></li>
    <li><a id="toc-Installing-Site-Packages-1" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">4.7 Installing Site Packages</a></li>
    <li><a id="toc-Distributing-Guile-Code-1" href="https://www.gnu.org/software/guile/manual/guile.html#Distributing-Guile-Code">4.8 Distributing Guile Code</a></li>
  </ul></li>
  <li><a id="toc-Programming-in-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C">5 Programming in C</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Parallel-Installations-1" href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Installations">5.1 Parallel Installations</a></li>
    <li><a id="toc-Linking-Programs-With-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile">5.2 Linking Programs With Guile</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Guile-Initialization-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Initialization-Functions">5.2.1 Guile Initialization Functions</a></li>
      <li><a id="toc-A-Sample-Guile-Main-Program-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Sample-Guile-Main-Program">5.2.2 A Sample Guile Main Program</a></li>
      <li><a id="toc-Building-the-Example-with-Make" href="https://www.gnu.org/software/guile/manual/guile.html#Building-the-Example-with-Make">5.2.3 Building the Example with Make</a></li>
      <li><a id="toc-Building-the-Example-with-Autoconf" href="https://www.gnu.org/software/guile/manual/guile.html#Building-the-Example-with-Autoconf">5.2.4 Building the Example with Autoconf</a></li>
    </ul></li>
    <li><a id="toc-Linking-Guile-with-Libraries-1" href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-with-Libraries">5.3 Linking Guile with Libraries</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-A-Sample-Guile-Extension-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Sample-Guile-Extension">5.3.1 A Sample Guile Extension</a></li>
    </ul></li>
    <li><a id="toc-General-concepts-for-using-libguile" href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts">5.4 General concepts for using libguile</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Dynamic-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Types">5.4.1 Dynamic Types</a></li>
      <li><a id="toc-Garbage-Collection-1" href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection">5.4.2 Garbage Collection</a></li>
      <li><a id="toc-Control-Flow-1" href="https://www.gnu.org/software/guile/manual/guile.html#Control-Flow">5.4.3 Control Flow</a></li>
      <li><a id="toc-Asynchronous-Signals-1" href="https://www.gnu.org/software/guile/manual/guile.html#Asynchronous-Signals">5.4.4 Asynchronous Signals</a></li>
      <li><a id="toc-Multi_002dThreading-1" href="https://www.gnu.org/software/guile/manual/guile.html#Multi_002dThreading">5.4.5 Multi-Threading</a></li>
    </ul></li>
    <li><a id="toc-Defining-New-Foreign-Object-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types">5.5 Defining New Foreign Object Types</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Defining-Foreign-Object-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Foreign-Object-Types">5.5.1 Defining Foreign Object Types</a></li>
      <li><a id="toc-Creating-Foreign-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Foreign-Objects">5.5.2 Creating Foreign Objects</a></li>
      <li><a id="toc-Type-Checking-of-Foreign-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Type-Checking-of-Foreign-Objects">5.5.3 Type Checking of Foreign Objects</a></li>
      <li><a id="toc-Foreign-Object-Memory-Management-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">5.5.4 Foreign Object Memory Management</a></li>
      <li><a id="toc-Foreign-Objects-and-Scheme-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects-and-Scheme">5.5.5 Foreign Objects and Scheme</a></li>
    </ul></li>
    <li><a id="toc-Function-Snarfing-1" href="https://www.gnu.org/software/guile/manual/guile.html#Function-Snarfing">5.6 Function Snarfing</a></li>
    <li><a id="toc-An-Overview-of-Guile-Programming" href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview">5.7 An Overview of Guile Programming</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-How-One-Might-Extend-Dia-Using-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia">5.7.1 How One Might Extend Dia Using Guile</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Deciding-Why-You-Want-to-Add-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objective">5.7.1.1 Deciding Why You Want to Add Guile</a></li>
        <li><a id="toc-Four-Steps-Required-to-Add-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Steps">5.7.1.2 Four Steps Required to Add Guile</a></li>
        <li><a id="toc-How-to-Represent-Dia-Data-in-Scheme" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objects">5.7.1.3 How to Represent Dia Data in Scheme</a></li>
        <li><a id="toc-Writing-Guile-Primitives-for-Dia" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Primitives">5.7.1.4 Writing Guile Primitives for Dia</a></li>
        <li><a id="toc-Providing-a-Hook-for-the-Evaluation-of-Scheme-Code" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Hook">5.7.1.5 Providing a Hook for the Evaluation of Scheme Code</a></li>
        <li><a id="toc-Top_002dlevel-Structure-of-Guile_002denabled-Dia" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Structure">5.7.1.6 Top-level Structure of Guile-enabled Dia</a></li>
        <li><a id="toc-Going-Further-with-Dia-and-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Advanced">5.7.1.7 Going Further with Dia and Guile</a></li>
      </ul></li>
      <li><a id="toc-Why-Scheme-is-More-Hackable-Than-C" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-vs-C">5.7.2 Why Scheme is More Hackable Than C</a></li>
      <li><a id="toc-Example_003a-Using-Guile-for-an-Application-Testbed" href="https://www.gnu.org/software/guile/manual/guile.html#Testbed-Example">5.7.3 Example: Using Guile for an Application Testbed</a></li>
      <li><a id="toc-A-Choice-of-Programming-Options" href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options">5.7.4 A Choice of Programming Options</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-What-Functionality-is-Already-Available_003f" href="https://www.gnu.org/software/guile/manual/guile.html#Available-Functionality">5.7.4.1 What Functionality is Already Available?</a></li>
        <li><a id="toc-Functional-and-Performance-Constraints" href="https://www.gnu.org/software/guile/manual/guile.html#Basic-Constraints">5.7.4.2 Functional and Performance Constraints</a></li>
        <li><a id="toc-Your-Preferred-Programming-Style" href="https://www.gnu.org/software/guile/manual/guile.html#Style-Choices">5.7.4.3 Your Preferred Programming Style</a></li>
        <li><a id="toc-What-Controls-Program-Execution_003f" href="https://www.gnu.org/software/guile/manual/guile.html#Program-Control">5.7.4.4 What Controls Program Execution?</a></li>
      </ul></li>
      <li><a id="toc-How-About-Application-Users_003f" href="https://www.gnu.org/software/guile/manual/guile.html#User-Programming">5.7.5 How About Application Users?</a></li>
    </ul></li>
    <li><a id="toc-Autoconf-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support">5.8 Autoconf Support</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Autoconf-Background-1" href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Background">5.8.1 Autoconf Background</a></li>
      <li><a id="toc-Autoconf-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Macros">5.8.2 Autoconf Macros</a></li>
      <li><a id="toc-Using-Autoconf-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Autoconf-Macros">5.8.3 Using Autoconf Macros</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-API-Reference-1" href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference">6 API Reference</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Overview-of-the-Guile-API" href="https://www.gnu.org/software/guile/manual/guile.html#API-Overview">6.1 Overview of the Guile API</a></li>
    <li><a id="toc-Deprecation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation">6.2 Deprecation</a></li>
    <li><a id="toc-The-SCM-Type-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type">6.3 The SCM Type</a></li>
    <li><a id="toc-Initializing-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#Initialization">6.4 Initializing Guile</a></li>
    <li><a id="toc-Snarfing-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Snarfing-Macros">6.5 Snarfing Macros</a></li>
    <li><a id="toc-Data-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types">6.6 Data Types</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Booleans-1" href="https://www.gnu.org/software/guile/manual/guile.html#Booleans">6.6.1 Booleans</a></li>
      <li><a id="toc-Numerical-data-types" href="https://www.gnu.org/software/guile/manual/guile.html#Numbers">6.6.2 Numerical data types</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Scheme_0027s-Numerical-_0060_0060Tower_0027_0027" href="https://www.gnu.org/software/guile/manual/guile.html#Numerical-Tower">6.6.2.1 Scheme’s Numerical “Tower”</a></li>
        <li><a id="toc-Integers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Integers">6.6.2.2 Integers</a></li>
        <li><a id="toc-Real-and-Rational-Numbers" href="https://www.gnu.org/software/guile/manual/guile.html#Reals-and-Rationals">6.6.2.3 Real and Rational Numbers</a></li>
        <li><a id="toc-Complex-Numbers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Complex-Numbers">6.6.2.4 Complex Numbers</a></li>
        <li><a id="toc-Exact-and-Inexact-Numbers" href="https://www.gnu.org/software/guile/manual/guile.html#Exactness">6.6.2.5 Exact and Inexact Numbers</a></li>
        <li><a id="toc-Read-Syntax-for-Numerical-Data" href="https://www.gnu.org/software/guile/manual/guile.html#Number-Syntax">6.6.2.6 Read Syntax for Numerical Data</a></li>
        <li><a id="toc-Operations-on-Integer-Values" href="https://www.gnu.org/software/guile/manual/guile.html#Integer-Operations">6.6.2.7 Operations on Integer Values</a></li>
        <li><a id="toc-Comparison-Predicates" href="https://www.gnu.org/software/guile/manual/guile.html#Comparison">6.6.2.8 Comparison Predicates</a></li>
        <li><a id="toc-Converting-Numbers-To-and-From-Strings" href="https://www.gnu.org/software/guile/manual/guile.html#Conversion">6.6.2.9 Converting Numbers To and From Strings</a></li>
        <li><a id="toc-Complex-Number-Operations" href="https://www.gnu.org/software/guile/manual/guile.html#Complex">6.6.2.10 Complex Number Operations</a></li>
        <li><a id="toc-Arithmetic-Functions" href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic">6.6.2.11 Arithmetic Functions</a></li>
        <li><a id="toc-Scientific-Functions" href="https://www.gnu.org/software/guile/manual/guile.html#Scientific">6.6.2.12 Scientific Functions</a></li>
        <li><a id="toc-Bitwise-Operations-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">6.6.2.13 Bitwise Operations</a></li>
        <li><a id="toc-Random-Number-Generation" href="https://www.gnu.org/software/guile/manual/guile.html#Random">6.6.2.14 Random Number Generation</a></li>
      </ul></li>
      <li><a id="toc-Characters-1" href="https://www.gnu.org/software/guile/manual/guile.html#Characters">6.6.3 Characters</a></li>
      <li><a id="toc-Character-Sets-1" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets">6.6.4 Character Sets</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Character-Set-Predicates_002fComparison-1" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Set-Predicates_002fComparison">6.6.4.1 Character Set Predicates/Comparison</a></li>
        <li><a id="toc-Iterating-Over-Character-Sets-1" href="https://www.gnu.org/software/guile/manual/guile.html#Iterating-Over-Character-Sets">6.6.4.2 Iterating Over Character Sets</a></li>
        <li><a id="toc-Creating-Character-Sets-1" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Character-Sets">6.6.4.3 Creating Character Sets</a></li>
        <li><a id="toc-Querying-Character-Sets-1" href="https://www.gnu.org/software/guile/manual/guile.html#Querying-Character-Sets">6.6.4.4 Querying Character Sets</a></li>
        <li><a id="toc-Character_002dSet-Algebra-1" href="https://www.gnu.org/software/guile/manual/guile.html#Character_002dSet-Algebra">6.6.4.5 Character-Set Algebra</a></li>
        <li><a id="toc-Standard-Character-Sets-1" href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Character-Sets">6.6.4.6 Standard Character Sets</a></li>
      </ul></li>
      <li><a id="toc-Strings-1" href="https://www.gnu.org/software/guile/manual/guile.html#Strings">6.6.5 Strings</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-String-Read-Syntax" href="https://www.gnu.org/software/guile/manual/guile.html#String-Syntax">6.6.5.1 String Read Syntax</a></li>
        <li><a id="toc-String-Predicates-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Predicates">6.6.5.2 String Predicates</a></li>
        <li><a id="toc-String-Constructors-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Constructors">6.6.5.3 String Constructors</a></li>
        <li><a id="toc-List_002fString-conversion" href="https://www.gnu.org/software/guile/manual/guile.html#List_002fString-Conversion">6.6.5.4 List/String conversion</a></li>
        <li><a id="toc-String-Selection-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Selection">6.6.5.5 String Selection</a></li>
        <li><a id="toc-String-Modification-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Modification">6.6.5.6 String Modification</a></li>
        <li><a id="toc-String-Comparison-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison">6.6.5.7 String Comparison</a></li>
        <li><a id="toc-String-Searching-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Searching">6.6.5.8 String Searching</a></li>
        <li><a id="toc-Alphabetic-Case-Mapping-1" href="https://www.gnu.org/software/guile/manual/guile.html#Alphabetic-Case-Mapping">6.6.5.9 Alphabetic Case Mapping</a></li>
        <li><a id="toc-Reversing-and-Appending-Strings-1" href="https://www.gnu.org/software/guile/manual/guile.html#Reversing-and-Appending-Strings">6.6.5.10 Reversing and Appending Strings</a></li>
        <li><a id="toc-Mapping_002c-Folding_002c-and-Unfolding" href="https://www.gnu.org/software/guile/manual/guile.html#Mapping-Folding-and-Unfolding">6.6.5.11 Mapping, Folding, and Unfolding</a></li>
        <li><a id="toc-Miscellaneous-String-Operations-1" href="https://www.gnu.org/software/guile/manual/guile.html#Miscellaneous-String-Operations">6.6.5.12 Miscellaneous String Operations</a></li>
        <li><a id="toc-Representing-Strings-as-Bytes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes">6.6.5.13 Representing Strings as Bytes</a></li>
        <li><a id="toc-Conversion-to_002ffrom-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Conversion-to_002ffrom-C">6.6.5.14 Conversion to/from C</a></li>
        <li><a id="toc-String-Internals-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Internals">6.6.5.15 String Internals</a></li>
      </ul></li>
      <li><a id="toc-Symbols-1" href="https://www.gnu.org/software/guile/manual/guile.html#Symbols">6.6.6 Symbols</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Symbols-as-Discrete-Data" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Data">6.6.6.1 Symbols as Discrete Data</a></li>
        <li><a id="toc-Symbols-as-Lookup-Keys" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Keys">6.6.6.2 Symbols as Lookup Keys</a></li>
        <li><a id="toc-Symbols-as-Denoting-Variables" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Variables">6.6.6.3 Symbols as Denoting Variables</a></li>
        <li><a id="toc-Operations-Related-to-Symbols" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Primitives">6.6.6.4 Operations Related to Symbols</a></li>
        <li><a id="toc-Extended-Read-Syntax-for-Symbols" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax">6.6.6.5 Extended Read Syntax for Symbols</a></li>
        <li><a id="toc-Uninterned-Symbols" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Uninterned">6.6.6.6 Uninterned Symbols</a></li>
      </ul></li>
      <li><a id="toc-Keywords-1" href="https://www.gnu.org/software/guile/manual/guile.html#Keywords">6.6.7 Keywords</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Why-Use-Keywords_003f-1" href="https://www.gnu.org/software/guile/manual/guile.html#Why-Use-Keywords_003f">6.6.7.1 Why Use Keywords?</a></li>
        <li><a id="toc-Coding-With-Keywords-1" href="https://www.gnu.org/software/guile/manual/guile.html#Coding-With-Keywords">6.6.7.2 Coding With Keywords</a></li>
        <li><a id="toc-Keyword-Read-Syntax-1" href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Read-Syntax">6.6.7.3 Keyword Read Syntax</a></li>
        <li><a id="toc-Keyword-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Procedures">6.6.7.4 Keyword Procedures</a></li>
      </ul></li>
      <li><a id="toc-Pairs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Pairs">6.6.8 Pairs</a></li>
      <li><a id="toc-Lists-1" href="https://www.gnu.org/software/guile/manual/guile.html#Lists">6.6.9 Lists</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-List-Read-Syntax" href="https://www.gnu.org/software/guile/manual/guile.html#List-Syntax">6.6.9.1 List Read Syntax</a></li>
        <li><a id="toc-List-Predicates-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Predicates">6.6.9.2 List Predicates</a></li>
        <li><a id="toc-List-Constructors-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Constructors">6.6.9.3 List Constructors</a></li>
        <li><a id="toc-List-Selection-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Selection">6.6.9.4 List Selection</a></li>
        <li><a id="toc-Append-and-Reverse" href="https://www.gnu.org/software/guile/manual/guile.html#Append_002fReverse">6.6.9.5 Append and Reverse</a></li>
        <li><a id="toc-List-Modification-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification">6.6.9.6 List Modification</a></li>
        <li><a id="toc-List-Searching-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching">6.6.9.7 List Searching</a></li>
        <li><a id="toc-List-Mapping-1" href="https://www.gnu.org/software/guile/manual/guile.html#List-Mapping">6.6.9.8 List Mapping</a></li>
      </ul></li>
      <li><a id="toc-Vectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Vectors">6.6.10 Vectors</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Read-Syntax-for-Vectors" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Syntax">6.6.10.1 Read Syntax for Vectors</a></li>
        <li><a id="toc-Dynamic-Vector-Creation-and-Validation" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Creation">6.6.10.2 Dynamic Vector Creation and Validation</a></li>
        <li><a id="toc-Accessing-and-Modifying-Vector-Contents" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessors">6.6.10.3 Accessing and Modifying Vector Contents</a></li>
        <li><a id="toc-Vector-Accessing-from-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C">6.6.10.4 Vector Accessing from C</a></li>
        <li><a id="toc-Uniform-Numeric-Vectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Uniform-Numeric-Vectors">6.6.10.5 Uniform Numeric Vectors</a></li>
      </ul></li>
      <li><a id="toc-Bit-Vectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bit-Vectors">6.6.11 Bit Vectors</a></li>
      <li><a id="toc-Bytevectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">6.6.12 Bytevectors</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Endianness" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Endianness">6.6.12.1 Endianness</a></li>
        <li><a id="toc-Manipulating-Bytevectors" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Manipulation">6.6.12.2 Manipulating Bytevectors</a></li>
        <li><a id="toc-Interpreting-Bytevector-Contents-as-Integers" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Integers">6.6.12.3 Interpreting Bytevector Contents as Integers</a></li>
        <li><a id="toc-Converting-Bytevectors-to_002ffrom-Integer-Lists" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-and-Integer-Lists">6.6.12.4 Converting Bytevectors to/from Integer Lists</a></li>
        <li><a id="toc-Interpreting-Bytevector-Contents-as-Floating-Point-Numbers" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Floats">6.6.12.5 Interpreting Bytevector Contents as Floating Point Numbers</a></li>
        <li><a id="toc-Interpreting-Bytevector-Contents-as-Unicode-Strings" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Strings">6.6.12.6 Interpreting Bytevector Contents as Unicode Strings</a></li>
        <li><a id="toc-Accessing-Bytevectors-with-the-Array-API" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Arrays">6.6.12.7 Accessing Bytevectors with the Array API</a></li>
        <li><a id="toc-Accessing-Bytevectors-with-the-SRFI_002d4-API" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Uniform-Vectors">6.6.12.8 Accessing Bytevectors with the SRFI-4 API</a></li>
        <li><a id="toc-Bytevector-Procedures-in-R7RS-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Procedures-in-R7RS">6.6.12.9 Bytevector Procedures in R7RS</a></li>
        <li><a id="toc-Bytevector-Slices-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Slices">6.6.12.10 Bytevector Slices</a></li>
      </ul></li>
      <li><a id="toc-Arrays-1" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">6.6.13 Arrays</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Array-Syntax-1" href="https://www.gnu.org/software/guile/manual/guile.html#Array-Syntax">6.6.13.1 Array Syntax</a></li>
        <li><a id="toc-Array-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Array-Procedures">6.6.13.2 Array Procedures</a></li>
        <li><a id="toc-Shared-Arrays-1" href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Arrays">6.6.13.3 Shared Arrays</a></li>
        <li><a id="toc-Arrays-as-arrays-of-arrays-1" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays-as-arrays-of-arrays">6.6.13.4 Arrays as arrays of arrays</a></li>
        <li><a id="toc-Accessing-Arrays-from-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Arrays-from-C">6.6.13.5 Accessing Arrays from C</a></li>
      </ul></li>
      <li><a id="toc-VLists-1" href="https://www.gnu.org/software/guile/manual/guile.html#VLists">6.6.14 VLists</a></li>
      <li><a id="toc-Record-Overview-1" href="https://www.gnu.org/software/guile/manual/guile.html#Record-Overview">6.6.15 Record Overview</a></li>
      <li><a id="toc-SRFI_002d9-Records-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records">6.6.16 SRFI-9 Records</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Non_002dtoplevel-Record-Definitions" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dtoplevel-Record-Definitions">Non-toplevel Record Definitions</a></li>
        <li><a id="toc-Custom-Printers" href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Printers">Custom Printers</a></li>
        <li><a id="toc-Functional-_0060_0060Setters_0027_0027" href="https://www.gnu.org/software/guile/manual/guile.html#Functional-_0060_0060Setters_0027_0027">Functional “Setters”</a></li>
      </ul></li>
      <li><a id="toc-Records-1" href="https://www.gnu.org/software/guile/manual/guile.html#Records">6.6.17 Records</a></li>
      <li><a id="toc-Structures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Structures">6.6.18 Structures</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Vtables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Vtables">6.6.18.1 Vtables</a></li>
        <li><a id="toc-Structure-Basics-1" href="https://www.gnu.org/software/guile/manual/guile.html#Structure-Basics">6.6.18.2 Structure Basics</a></li>
        <li><a id="toc-Vtable-Contents-1" href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents">6.6.18.3 Vtable Contents</a></li>
        <li><a id="toc-Meta_002dVtables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Meta_002dVtables">6.6.18.4 Meta-Vtables</a></li>
        <li><a id="toc-Vtable-Example-1" href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Example">6.6.18.5 Vtable Example</a></li>
      </ul></li>
      <li><a id="toc-Dictionary-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Dictionary-Types">6.6.19 Dictionary Types</a></li>
      <li><a id="toc-Association-Lists-1" href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists">6.6.20 Association Lists</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Alist-Key-Equality-1" href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Key-Equality">6.6.20.1 Alist Key Equality</a></li>
        <li><a id="toc-Adding-or-Setting-Alist-Entries-1" href="https://www.gnu.org/software/guile/manual/guile.html#Adding-or-Setting-Alist-Entries">6.6.20.2 Adding or Setting Alist Entries</a></li>
        <li><a id="toc-Retrieving-Alist-Entries-1" href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries">6.6.20.3 Retrieving Alist Entries</a></li>
        <li><a id="toc-Removing-Alist-Entries-1" href="https://www.gnu.org/software/guile/manual/guile.html#Removing-Alist-Entries">6.6.20.4 Removing Alist Entries</a></li>
        <li><a id="toc-Sloppy-Alist-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Sloppy-Alist-Functions">6.6.20.5 Sloppy Alist Functions</a></li>
        <li><a id="toc-Alist-Example-1" href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Example">6.6.20.6 Alist Example</a></li>
      </ul></li>
      <li><a id="toc-VList_002dBased-Hash-Lists-or-_0060_0060VHashes_0027_0027" href="https://www.gnu.org/software/guile/manual/guile.html#VHashes">6.6.21 VList-Based Hash Lists or “VHashes”</a></li>
      <li><a id="toc-Hash-Tables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">6.6.22 Hash Tables</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Hash-Table-Examples-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Examples">6.6.22.1 Hash Table Examples</a></li>
        <li><a id="toc-Hash-Table-Reference-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Reference">6.6.22.2 Hash Table Reference</a></li>
      </ul></li>
      <li><a id="toc-Other-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Other-Types">6.6.23 Other Types</a></li>
    </ul></li>
    <li><a id="toc-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures">6.7 Procedures</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Lambda_003a-Basic-Procedure-Creation" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">6.7.1 Lambda: Basic Procedure Creation</a></li>
      <li><a id="toc-Primitive-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures">6.7.2 Primitive Procedures</a></li>
      <li><a id="toc-Compiled-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures">6.7.3 Compiled Procedures</a></li>
      <li><a id="toc-Optional-Arguments-1" href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments">6.7.4 Optional Arguments</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-lambda_002a-and-define_002a_002e" href="https://www.gnu.org/software/guile/manual/guile.html#lambda_002a-and-define_002a">6.7.4.1 lambda* and define*.</a></li>
        <li><a id="toc-_0028ice_002d9-optargs_0029" href="https://www.gnu.org/software/guile/manual/guile.html#ice_002d9-optargs">6.7.4.2 (ice-9 optargs)</a></li>
      </ul></li>
      <li><a id="toc-Case_002dlambda-1" href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda">6.7.5 Case-lambda</a></li>
      <li><a id="toc-Higher_002dOrder-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions">6.7.6 Higher-Order Functions</a></li>
      <li><a id="toc-Procedure-Properties-and-Meta_002dinformation" href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties">6.7.7 Procedure Properties and Meta-information</a></li>
      <li><a id="toc-Procedures-with-Setters-1" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">6.7.8 Procedures with Setters</a></li>
      <li><a id="toc-Inlinable-Procedures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Inlinable-Procedures">6.7.9 Inlinable Procedures</a></li>
    </ul></li>
    <li><a id="toc-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Macros">6.8 Macros</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Defining-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Macros">6.8.1 Defining Macros</a></li>
      <li><a id="toc-Syntax_002drules-Macros" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules">6.8.2 Syntax-rules Macros</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Patterns" href="https://www.gnu.org/software/guile/manual/guile.html#Patterns">6.8.2.1 Patterns</a></li>
        <li><a id="toc-Hygiene" href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene">6.8.2.2 Hygiene</a></li>
        <li><a id="toc-Shorthands" href="https://www.gnu.org/software/guile/manual/guile.html#Shorthands">6.8.2.3 Shorthands</a></li>
        <li><a id="toc-Reporting-Syntax-Errors-in-Macros" href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Syntax-Errors-in-Macros">6.8.2.4 Reporting Syntax Errors in Macros</a></li>
        <li><a id="toc-Specifying-a-Custom-Ellipsis-Identifier" href="https://www.gnu.org/software/guile/manual/guile.html#Specifying-a-Custom-Ellipsis-Identifier">6.8.2.5 Specifying a Custom Ellipsis Identifier</a></li>
        <li><a id="toc-Further-Information" href="https://www.gnu.org/software/guile/manual/guile.html#Further-Information">6.8.2.6 Further Information</a></li>
      </ul></li>
      <li><a id="toc-Support-for-the-syntax_002dcase-System" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Case">6.8.3 Support for the <code class="code">syntax-case</code> System</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Why-syntax_002dcase_003f" href="https://www.gnu.org/software/guile/manual/guile.html#Why-syntax_002dcase_003f">6.8.3.1 Why <code class="code">syntax-case</code>?</a></li>
        <li><a id="toc-Custom-Ellipsis-Identifiers-for-syntax_002dcase-Macros" href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ellipsis-Identifiers-for-syntax_002dcase-Macros">6.8.3.2 Custom Ellipsis Identifiers for syntax-case Macros</a></li>
        <li><a id="toc-Syntax-objects-can-be-data-too" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-objects-can-be-data-too">6.8.3.3 Syntax objects can be data too</a></li>
      </ul></li>
      <li><a id="toc-Syntax-Transformer-Helpers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers">6.8.4 Syntax Transformer Helpers</a></li>
      <li><a id="toc-Lisp_002dstyle-Macro-Definitions" href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros">6.8.5 Lisp-style Macro Definitions</a></li>
      <li><a id="toc-Identifier-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Identifier-Macros">6.8.6 Identifier Macros</a></li>
      <li><a id="toc-Syntax-Parameters-1" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Parameters">6.8.7 Syntax Parameters</a></li>
      <li><a id="toc-Eval_002dwhen" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When">6.8.8 Eval-when</a></li>
      <li><a id="toc-Macro-Expansion-1" href="https://www.gnu.org/software/guile/manual/guile.html#Macro-Expansion">6.8.9 Macro Expansion</a></li>
      <li><a id="toc-Hygiene-and-the-Top_002dLevel-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene-and-the-Top_002dLevel">6.8.10 Hygiene and the Top-Level</a></li>
      <li><a id="toc-Internal-Macros-1" href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Macros">6.8.11 Internal Macros</a></li>
    </ul></li>
    <li><a id="toc-General-Utility-Functions" href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions">6.9 General Utility Functions</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Equality-1" href="https://www.gnu.org/software/guile/manual/guile.html#Equality">6.9.1 Equality</a></li>
      <li><a id="toc-Object-Properties-1" href="https://www.gnu.org/software/guile/manual/guile.html#Object-Properties">6.9.2 Object Properties</a></li>
      <li><a id="toc-Sorting-1" href="https://www.gnu.org/software/guile/manual/guile.html#Sorting">6.9.3 Sorting</a></li>
      <li><a id="toc-Copying-Deep-Structures" href="https://www.gnu.org/software/guile/manual/guile.html#Copying">6.9.4 Copying Deep Structures</a></li>
      <li><a id="toc-General-String-Conversion" href="https://www.gnu.org/software/guile/manual/guile.html#General-Conversion">6.9.5 General String Conversion</a></li>
      <li><a id="toc-Hooks-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hooks">6.9.6 Hooks</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Hook-Usage-by-Example" href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Example">6.9.6.1 Hook Usage by Example</a></li>
        <li><a id="toc-Hook-Reference-1" href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Reference">6.9.6.2 Hook Reference</a></li>
        <li><a id="toc-Hooks-For-C-Code_002e" href="https://www.gnu.org/software/guile/manual/guile.html#C-Hooks">6.9.6.3 Hooks For C Code.</a></li>
        <li><a id="toc-Hooks-for-Garbage-Collection" href="https://www.gnu.org/software/guile/manual/guile.html#GC-Hooks">6.9.6.4 Hooks for Garbage Collection</a></li>
        <li><a id="toc-Hooks-into-the-Guile-REPL" href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Hooks">6.9.6.5 Hooks into the Guile REPL</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Definitions-and-Variable-Bindings" href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs">6.10 Definitions and Variable Bindings</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Top-Level-Variable-Definitions" href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">6.10.1 Top Level Variable Definitions</a></li>
      <li><a id="toc-Local-Variable-Bindings" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">6.10.2 Local Variable Bindings</a></li>
      <li><a id="toc-Internal-definitions" href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">6.10.3 Internal definitions</a></li>
      <li><a id="toc-Querying-variable-bindings" href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection">6.10.4 Querying variable bindings</a></li>
      <li><a id="toc-Binding-multiple-return-values" href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Multiple-Values">6.10.5 Binding multiple return values</a></li>
    </ul></li>
    <li><a id="toc-Controlling-the-Flow-of-Program-Execution" href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms">6.11 Controlling the Flow of Program Execution</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Sequencing-and-Splicing" href="https://www.gnu.org/software/guile/manual/guile.html#begin">6.11.1 Sequencing and Splicing</a></li>
      <li><a id="toc-Simple-Conditional-Evaluation" href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals">6.11.2 Simple Conditional Evaluation</a></li>
      <li><a id="toc-Conditional-Evaluation-of-a-Sequence-of-Expressions" href="https://www.gnu.org/software/guile/manual/guile.html#and-or">6.11.3 Conditional Evaluation of a Sequence of Expressions</a></li>
      <li><a id="toc-Iteration-mechanisms" href="https://www.gnu.org/software/guile/manual/guile.html#while-do">6.11.4 Iteration mechanisms</a></li>
      <li><a id="toc-Prompts-1" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">6.11.5 Prompts</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Prompt-Primitives-1" href="https://www.gnu.org/software/guile/manual/guile.html#Prompt-Primitives">6.11.5.1 Prompt Primitives</a></li>
        <li><a id="toc-Shift_002c-Reset_002c-and-All-That" href="https://www.gnu.org/software/guile/manual/guile.html#Shift-and-Reset">6.11.5.2 Shift, Reset, and All That</a></li>
      </ul></li>
      <li><a id="toc-Continuations-1" href="https://www.gnu.org/software/guile/manual/guile.html#Continuations">6.11.6 Continuations</a></li>
      <li><a id="toc-Returning-and-Accepting-Multiple-Values" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">6.11.7 Returning and Accepting Multiple Values</a></li>
      <li><a id="toc-Exceptions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">6.11.8 Exceptions</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Exception-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Exception-Objects">6.11.8.1 Exception Objects</a></li>
        <li><a id="toc-Raising-and-Handling-Exceptions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions">6.11.8.2 Raising and Handling Exceptions</a></li>
        <li><a id="toc-Throw-and-Catch-1" href="https://www.gnu.org/software/guile/manual/guile.html#Throw-and-Catch">6.11.8.3 Throw and Catch</a></li>
        <li><a id="toc-Exceptions-and-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions-and-C">6.11.8.4 Exceptions and C</a></li>
      </ul></li>
      <li><a id="toc-Procedures-for-Signaling-Errors" href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting">6.11.9 Procedures for Signaling Errors</a></li>
      <li><a id="toc-Dynamic-Wind-1" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">6.11.10 Dynamic Wind</a></li>
      <li><a id="toc-Fluids-and-Dynamic-States-1" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">6.11.11 Fluids and Dynamic States</a></li>
      <li><a id="toc-Parameters-1" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">6.11.12 Parameters</a></li>
      <li><a id="toc-How-to-Handle-Errors" href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Errors">6.11.13 How to Handle Errors</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-C-Support" href="https://www.gnu.org/software/guile/manual/guile.html#C-Support">6.11.13.1 C Support</a></li>
        <li><a id="toc-Signalling-Type-Errors" href="https://www.gnu.org/software/guile/manual/guile.html#Signalling-Type-Errors">6.11.13.2 Signalling Type Errors</a></li>
      </ul></li>
      <li><a id="toc-Continuation-Barriers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Continuation-Barriers">6.11.14 Continuation Barriers</a></li>
    </ul></li>
    <li><a id="toc-Input-and-Output-1" href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output">6.12 Input and Output</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">6.12.1 Ports</a></li>
      <li><a id="toc-Binary-I_002fO-1" href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO">6.12.2 Binary I/O</a></li>
      <li><a id="toc-Encoding-1" href="https://www.gnu.org/software/guile/manual/guile.html#Encoding">6.12.3 Encoding</a></li>
      <li><a id="toc-Textual-I_002fO-1" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">6.12.4 Textual I/O</a></li>
      <li><a id="toc-Simple-Textual-Output" href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output">6.12.5 Simple Textual Output</a></li>
      <li><a id="toc-Buffering-1" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">6.12.6 Buffering</a></li>
      <li><a id="toc-Random-Access-1" href="https://www.gnu.org/software/guile/manual/guile.html#Random-Access">6.12.7 Random Access</a></li>
      <li><a id="toc-Line-Oriented-and-Delimited-Text" href="https://www.gnu.org/software/guile/manual/guile.html#Line_002fDelimited">6.12.8 Line Oriented and Delimited Text</a></li>
      <li><a id="toc-Default-Ports-for-Input_002c-Output-and-Errors" href="https://www.gnu.org/software/guile/manual/guile.html#Default-Ports">6.12.9 Default Ports for Input, Output and Errors</a></li>
      <li><a id="toc-Types-of-Port" href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types">6.12.10 Types of Port</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-File-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">6.12.10.1 File Ports</a></li>
        <li><a id="toc-Bytevector-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Ports">6.12.10.2 Bytevector Ports</a></li>
        <li><a id="toc-String-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#String-Ports">6.12.10.3 String Ports</a></li>
        <li><a id="toc-Custom-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ports">6.12.10.4 Custom Ports</a></li>
        <li><a id="toc-Soft-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports">6.12.10.5 Soft Ports</a></li>
        <li><a id="toc-Void-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#Void-Ports">6.12.10.6 Void Ports</a></li>
      </ul></li>
      <li><a id="toc-Venerable-Port-Interfaces-1" href="https://www.gnu.org/software/guile/manual/guile.html#Venerable-Port-Interfaces">6.12.11 Venerable Port Interfaces</a></li>
      <li><a id="toc-Using-Ports-from-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Ports-from-C">6.12.12 Using Ports from C</a></li>
      <li><a id="toc-Implementing-New-Port-Types-in-C" href="https://www.gnu.org/software/guile/manual/guile.html#I_002fO-Extensions">6.12.13 Implementing New Port Types in C</a></li>
      <li><a id="toc-Non_002dBlocking-I_002fO-1" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO">6.12.14 Non-Blocking I/O</a></li>
      <li><a id="toc-Handling-of-Unicode-Byte-Order-Marks" href="https://www.gnu.org/software/guile/manual/guile.html#BOM-Handling">6.12.15 Handling of Unicode Byte Order Marks</a></li>
    </ul></li>
    <li><a id="toc-Regular-Expressions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions">6.13 Regular Expressions</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Regexp-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions">6.13.1 Regexp Functions</a></li>
      <li><a id="toc-Match-Structures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures">6.13.2 Match Structures</a></li>
      <li><a id="toc-Backslash-Escapes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes">6.13.3 Backslash Escapes</a></li>
    </ul></li>
    <li><a id="toc-LALR_00281_0029-Parsing-1" href="https://www.gnu.org/software/guile/manual/guile.html#LALR_00281_0029-Parsing">6.14 LALR(1) Parsing</a></li>
    <li><a id="toc-PEG-Parsing-1" href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing">6.15 PEG Parsing</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-PEG-Syntax-Reference-1" href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Syntax-Reference">6.15.1 PEG Syntax Reference</a></li>
      <li><a id="toc-PEG-API-Reference-1" href="https://www.gnu.org/software/guile/manual/guile.html#PEG-API-Reference">6.15.2 PEG API Reference</a></li>
      <li><a id="toc-PEG-Tutorial-1" href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Tutorial">6.15.3 PEG Tutorial</a></li>
      <li><a id="toc-PEG-Internals-1" href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Internals">6.15.4 PEG Internals</a></li>
    </ul></li>
    <li><a id="toc-Reading-and-Evaluating-Scheme-Code" href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile">6.16 Reading and Evaluating Scheme Code</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Scheme-Syntax_003a-Standard-and-Guile-Extensions" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax">6.16.1 Scheme Syntax: Standard and Guile Extensions</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Expression-Syntax-1" href="https://www.gnu.org/software/guile/manual/guile.html#Expression-Syntax">6.16.1.1 Expression Syntax</a></li>
        <li><a id="toc-Comments-1" href="https://www.gnu.org/software/guile/manual/guile.html#Comments">6.16.1.2 Comments</a></li>
        <li><a id="toc-Block-Comments-1" href="https://www.gnu.org/software/guile/manual/guile.html#Block-Comments">6.16.1.3 Block Comments</a></li>
        <li><a id="toc-Case-Sensitivity-1" href="https://www.gnu.org/software/guile/manual/guile.html#Case-Sensitivity">6.16.1.4 Case Sensitivity</a></li>
        <li><a id="toc-Keyword-Syntax-1" href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Syntax">6.16.1.5 Keyword Syntax</a></li>
        <li><a id="toc-Reader-Extensions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Reader-Extensions">6.16.1.6 Reader Extensions</a></li>
      </ul></li>
      <li><a id="toc-Reading-Scheme-Code" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">6.16.2 Reading Scheme Code</a></li>
      <li><a id="toc-Reading-Scheme-Code_002c-For-the-Compiler" href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read">6.16.3 Reading Scheme Code, For the Compiler</a></li>
      <li><a id="toc-Writing-Scheme-Values" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write">6.16.4 Writing Scheme Values</a></li>
      <li><a id="toc-Procedures-for-On-the-Fly-Evaluation" href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">6.16.5 Procedures for On the Fly Evaluation</a></li>
      <li><a id="toc-Compiling-Scheme-Code" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">6.16.6 Compiling Scheme Code</a></li>
      <li><a id="toc-Loading-Scheme-Code-from-File" href="https://www.gnu.org/software/guile/manual/guile.html#Loading">6.16.7 Loading Scheme Code from File</a></li>
      <li><a id="toc-Load-Paths-1" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">6.16.8 Load Paths</a></li>
      <li><a id="toc-Character-Encoding-of-Source-Files-1" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files">6.16.9 Character Encoding of Source Files</a></li>
      <li><a id="toc-Delayed-Evaluation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Delayed-Evaluation">6.16.10 Delayed Evaluation</a></li>
      <li><a id="toc-Local-Evaluation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Evaluation">6.16.11 Local Evaluation</a></li>
      <li><a id="toc-Local-Inclusion-1" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Inclusion">6.16.12 Local Inclusion</a></li>
      <li><a id="toc-Sandboxed-Evaluation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Sandboxed-Evaluation">6.16.13 Sandboxed Evaluation</a></li>
      <li><a id="toc-REPL-Servers-1" href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Servers">6.16.14 REPL Servers</a></li>
      <li><a id="toc-Cooperative-REPL-Servers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Cooperative-REPL-Servers">6.16.15 Cooperative REPL Servers</a></li>
    </ul></li>
    <li><a id="toc-Memory-Management-and-Garbage-Collection" href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management">6.17 Memory Management and Garbage Collection</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Function-related-to-Garbage-Collection" href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection-Functions">6.17.1 Function related to Garbage Collection</a></li>
      <li><a id="toc-Memory-Blocks-1" href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Blocks">6.17.2 Memory Blocks</a></li>
      <li><a id="toc-Weak-References-1" href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References">6.17.3 Weak References</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Weak-hash-tables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Weak-hash-tables">6.17.3.1 Weak hash tables</a></li>
        <li><a id="toc-Weak-vectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Weak-vectors">6.17.3.2 Weak vectors</a></li>
      </ul></li>
      <li><a id="toc-Guardians-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guardians">6.17.4 Guardians</a></li>
    </ul></li>
    <li><a id="toc-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Modules">6.18 Modules</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-General-Information-about-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#General-Information-about-Modules">6.18.1 General Information about Modules</a></li>
      <li><a id="toc-Using-Guile-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules">6.18.2 Using Guile Modules</a></li>
      <li><a id="toc-Creating-Guile-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules">6.18.3 Creating Guile Modules</a></li>
      <li><a id="toc-Modules-and-the-File-System-1" href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System">6.18.4 Modules and the File System</a></li>
      <li><a id="toc-R6RS-Version-References-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References">6.18.5 R6RS Version References</a></li>
      <li><a id="toc-R6RS-Libraries-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Libraries">6.18.6 R6RS Libraries</a></li>
      <li><a id="toc-Variables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Variables">6.18.7 Variables</a></li>
      <li><a id="toc-Module-System-Reflection-1" href="https://www.gnu.org/software/guile/manual/guile.html#Module-System-Reflection">6.18.8 Module System Reflection</a></li>
      <li><a id="toc-Declarative-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Declarative-Modules">6.18.9 Declarative Modules</a></li>
      <li><a id="toc-Accessing-Modules-from-C-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Modules-from-C">6.18.10 Accessing Modules from C</a></li>
      <li><a id="toc-provide-and-require-1" href="https://www.gnu.org/software/guile/manual/guile.html#provide-and-require">6.18.11 provide and require</a></li>
      <li><a id="toc-Environments-1" href="https://www.gnu.org/software/guile/manual/guile.html#Environments">6.18.12 Environments</a></li>
    </ul></li>
    <li><a id="toc-Foreign-Function-Interface-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface">6.19 Foreign Function Interface</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Foreign-Libraries-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Libraries">6.19.1 Foreign Libraries</a></li>
      <li><a id="toc-Foreign-Extensions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions">6.19.2 Foreign Extensions</a></li>
      <li><a id="toc-Foreign-Pointers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Pointers">6.19.3 Foreign Pointers</a></li>
      <li><a id="toc-Foreign-Types-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Types">6.19.4 Foreign Types</a></li>
      <li><a id="toc-Foreign-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Functions">6.19.5 Foreign Functions</a></li>
      <li><a id="toc-Void-Pointers-and-Byte-Access-1" href="https://www.gnu.org/software/guile/manual/guile.html#Void-Pointers-and-Byte-Access">6.19.6 Void Pointers and Byte Access</a></li>
      <li><a id="toc-Foreign-Structs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Structs">6.19.7 Foreign Structs</a></li>
      <li><a id="toc-More-Foreign-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#More-Foreign-Functions">6.19.8 More Foreign Functions</a></li>
    </ul></li>
    <li><a id="toc-Foreign-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">6.20 Foreign Objects</a></li>
    <li><a id="toc-Smobs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Smobs">6.21 Smobs</a></li>
    <li><a id="toc-Threads_002c-Mutexes_002c-Asyncs-and-Dynamic-Roots" href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling">6.22 Threads, Mutexes, Asyncs and Dynamic Roots</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Threads-1" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">6.22.1 Threads</a></li>
      <li><a id="toc-Thread_002dLocal-Variables" href="https://www.gnu.org/software/guile/manual/guile.html#Thread-Local-Variables">6.22.2 Thread-Local Variables</a></li>
      <li><a id="toc-Asynchronous-Interrupts" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">6.22.3 Asynchronous Interrupts</a></li>
      <li><a id="toc-Atomics-1" href="https://www.gnu.org/software/guile/manual/guile.html#Atomics">6.22.4 Atomics</a></li>
      <li><a id="toc-Mutexes-and-Condition-Variables-1" href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables">6.22.5 Mutexes and Condition Variables</a></li>
      <li><a id="toc-Blocking-in-Guile-Mode" href="https://www.gnu.org/software/guile/manual/guile.html#Blocking">6.22.6 Blocking in Guile Mode</a></li>
      <li><a id="toc-Futures-1" href="https://www.gnu.org/software/guile/manual/guile.html#Futures">6.22.7 Futures</a></li>
      <li><a id="toc-Parallel-forms" href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Forms">6.22.8 Parallel forms</a></li>
    </ul></li>
    <li><a id="toc-Configuration_002c-Features-and-Runtime-Options" href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config">6.23 Configuration, Features and Runtime Options</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Configuration_002c-Build-and-Installation" href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config">6.23.1 Configuration, Build and Installation</a></li>
      <li><a id="toc-Feature-Tracking-1" href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking">6.23.2 Feature Tracking</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Feature-Manipulation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Manipulation">6.23.2.1 Feature Manipulation</a></li>
        <li><a id="toc-Common-Feature-Symbols-1" href="https://www.gnu.org/software/guile/manual/guile.html#Common-Feature-Symbols">6.23.2.2 Common Feature Symbols</a></li>
      </ul></li>
      <li><a id="toc-Runtime-Options-1" href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Options">6.23.3 Runtime Options</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Examples-of-option-use" href="https://www.gnu.org/software/guile/manual/guile.html#Examples-of-option-use">6.23.3.1 Examples of option use</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Support-for-Other-Languages" href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages">6.24 Support for Other Languages</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Using-Other-Languages-1" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Other-Languages">6.24.1 Using Other Languages</a></li>
      <li><a id="toc-Emacs-Lisp-1" href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp">6.24.2 Emacs Lisp</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Nil-1" href="https://www.gnu.org/software/guile/manual/guile.html#Nil">6.24.2.1 Nil</a></li>
        <li><a id="toc-Dynamic-Binding-1" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Binding">6.24.2.2 Dynamic Binding</a></li>
        <li><a id="toc-Other-Elisp-Features-1" href="https://www.gnu.org/software/guile/manual/guile.html#Other-Elisp-Features">6.24.2.3 Other Elisp Features</a></li>
      </ul></li>
      <li><a id="toc-ECMAScript-1" href="https://www.gnu.org/software/guile/manual/guile.html#ECMAScript">6.24.3 ECMAScript</a></li>
    </ul></li>
    <li><a id="toc-Support-for-Internationalization" href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization">6.25 Support for Internationalization</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Internationalization-with-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#i18n-Introduction">6.25.1 Internationalization with Guile</a></li>
      <li><a id="toc-Text-Collation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Text-Collation">6.25.2 Text Collation</a></li>
      <li><a id="toc-Character-Case-Mapping-1" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Case-Mapping">6.25.3 Character Case Mapping</a></li>
      <li><a id="toc-Number-Input-and-Output-1" href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output">6.25.4 Number Input and Output</a></li>
      <li><a id="toc-Accessing-Locale-Information-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information">6.25.5 Accessing Locale Information</a></li>
      <li><a id="toc-Gettext-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#Gettext-Support">6.25.6 Gettext Support</a></li>
    </ul></li>
    <li><a id="toc-Debugging-Infrastructure" href="https://www.gnu.org/software/guile/manual/guile.html#Debugging">6.26 Debugging Infrastructure</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Evaluation-and-the-Scheme-Stack" href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model">6.26.1 Evaluation and the Scheme Stack</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Stack-Capture-1" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Capture">6.26.1.1 Stack Capture</a></li>
        <li><a id="toc-Stacks-1" href="https://www.gnu.org/software/guile/manual/guile.html#Stacks">6.26.1.2 Stacks</a></li>
        <li><a id="toc-Frames-1" href="https://www.gnu.org/software/guile/manual/guile.html#Frames">6.26.1.3 Frames</a></li>
      </ul></li>
      <li><a id="toc-Source-Properties-1" href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties">6.26.2 Source Properties</a></li>
      <li><a id="toc-Programmatic-Error-Handling-1" href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling">6.26.3 Programmatic Error Handling</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Catching-Exceptions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Catching-Exceptions">6.26.3.1 Catching Exceptions</a></li>
        <li><a id="toc-Pre_002dUnwind-Debugging-1" href="https://www.gnu.org/software/guile/manual/guile.html#Pre_002dUnwind-Debugging">6.26.3.2 Pre-Unwind Debugging</a></li>
        <li><a id="toc-call_002dwith_002derror_002dhandling" href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Error-Handling">6.26.3.3 call-with-error-handling</a></li>
        <li><a id="toc-Stack-Overflow-1" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Overflow">6.26.3.4 Stack Overflow</a></li>
        <li><a id="toc-Debug-options" href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Options">6.26.3.5 Debug options</a></li>
      </ul></li>
      <li><a id="toc-Traps-1" href="https://www.gnu.org/software/guile/manual/guile.html#Traps">6.26.4 Traps</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-VM-Hooks-1" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks">6.26.4.1 VM Hooks</a></li>
        <li><a id="toc-Trap-Interface-1" href="https://www.gnu.org/software/guile/manual/guile.html#Trap-Interface">6.26.4.2 Trap Interface</a></li>
        <li><a id="toc-Low_002dLevel-Traps-1" href="https://www.gnu.org/software/guile/manual/guile.html#Low_002dLevel-Traps">6.26.4.3 Low-Level Traps</a></li>
        <li><a id="toc-Tracing-Traps-1" href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps">6.26.4.4 Tracing Traps</a></li>
        <li><a id="toc-Trap-States-1" href="https://www.gnu.org/software/guile/manual/guile.html#Trap-States">6.26.4.5 Trap States</a></li>
        <li><a id="toc-High_002dLevel-Traps-1" href="https://www.gnu.org/software/guile/manual/guile.html#High_002dLevel-Traps">6.26.4.6 High-Level Traps</a></li>
      </ul></li>
      <li><a id="toc-GDB-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#GDB-Support">6.26.5 GDB Support</a></li>
    </ul></li>
    <li><a id="toc-Code-Coverage-Reports" href="https://www.gnu.org/software/guile/manual/guile.html#Code-Coverage">6.27 Code Coverage Reports</a></li>
  </ul></li>
  <li><a id="toc-Guile-Modules-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules">7 Guile Modules</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-SLIB-1" href="https://www.gnu.org/software/guile/manual/guile.html#SLIB">7.1 SLIB</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-SLIB-installation-1" href="https://www.gnu.org/software/guile/manual/guile.html#SLIB-installation">7.1.1 SLIB installation</a></li>
      <li><a id="toc-JACAL-1" href="https://www.gnu.org/software/guile/manual/guile.html#JACAL">7.1.2 JACAL</a></li>
    </ul></li>
    <li><a id="toc-POSIX-System-Calls-and-Networking" href="https://www.gnu.org/software/guile/manual/guile.html#POSIX">7.2 <abbr class="acronym">POSIX</abbr> System Calls and Networking</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-POSIX-Interface-Conventions" href="https://www.gnu.org/software/guile/manual/guile.html#Conventions">7.2.1 <abbr class="acronym">POSIX</abbr> Interface Conventions</a></li>
      <li><a id="toc-Ports-and-File-Descriptors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors">7.2.2 Ports and File Descriptors</a></li>
      <li><a id="toc-File-System-1" href="https://www.gnu.org/software/guile/manual/guile.html#File-System">7.2.3 File System</a></li>
      <li><a id="toc-User-Information-1" href="https://www.gnu.org/software/guile/manual/guile.html#User-Information">7.2.4 User Information</a></li>
      <li><a id="toc-Time-1" href="https://www.gnu.org/software/guile/manual/guile.html#Time">7.2.5 Time</a></li>
      <li><a id="toc-Runtime-Environment-1" href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment">7.2.6 Runtime Environment</a></li>
      <li><a id="toc-Processes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">7.2.7 Processes</a></li>
      <li><a id="toc-Signals-1" href="https://www.gnu.org/software/guile/manual/guile.html#Signals">7.2.8 Signals</a></li>
      <li><a id="toc-Terminals-and-Ptys-1" href="https://www.gnu.org/software/guile/manual/guile.html#Terminals-and-Ptys">7.2.9 Terminals and Ptys</a></li>
      <li><a id="toc-Pipes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Pipes">7.2.10 Pipes</a></li>
      <li><a id="toc-Networking-1" href="https://www.gnu.org/software/guile/manual/guile.html#Networking">7.2.11 Networking</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Network-Address-Conversion-1" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion">7.2.11.1 Network Address Conversion</a></li>
        <li><a id="toc-Network-Databases-1" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases">7.2.11.2 Network Databases</a></li>
        <li><a id="toc-Network-Socket-Address-1" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">7.2.11.3 Network Socket Address</a></li>
        <li><a id="toc-Network-Sockets-and-Communication-1" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">7.2.11.4 Network Sockets and Communication</a></li>
        <li><a id="toc-Network-Socket-Examples" href="https://www.gnu.org/software/guile/manual/guile.html#Internet-Socket-Examples">7.2.11.5 Network Socket Examples</a></li>
      </ul></li>
      <li><a id="toc-System-Identification-1" href="https://www.gnu.org/software/guile/manual/guile.html#System-Identification">7.2.12 System Identification</a></li>
      <li><a id="toc-Locales-1" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">7.2.13 Locales</a></li>
      <li><a id="toc-Encryption-1" href="https://www.gnu.org/software/guile/manual/guile.html#Encryption">7.2.14 Encryption</a></li>
    </ul></li>
    <li><a id="toc-HTTP_002c-the-Web_002c-and-All-That" href="https://www.gnu.org/software/guile/manual/guile.html#Web">7.3 <abbr class="acronym">HTTP</abbr>, the Web, and All That</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Types-and-the-Web-1" href="https://www.gnu.org/software/guile/manual/guile.html#Types-and-the-Web">7.3.1 Types and the Web</a></li>
      <li><a id="toc-Universal-Resource-Identifiers" href="https://www.gnu.org/software/guile/manual/guile.html#URIs">7.3.2 Universal Resource Identifiers</a></li>
      <li><a id="toc-The-Hyper_002dText-Transfer-Protocol" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP">7.3.3 The Hyper-Text Transfer Protocol</a></li>
      <li><a id="toc-HTTP-Headers-1" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers">7.3.4 HTTP Headers</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-HTTP-Header-Types" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Header-Types">7.3.4.1 HTTP Header Types</a></li>
        <li><a id="toc-General-Headers" href="https://www.gnu.org/software/guile/manual/guile.html#General-Headers">7.3.4.2 General Headers</a></li>
        <li><a id="toc-Entity-Headers" href="https://www.gnu.org/software/guile/manual/guile.html#Entity-Headers">7.3.4.3 Entity Headers</a></li>
        <li><a id="toc-Request-Headers" href="https://www.gnu.org/software/guile/manual/guile.html#Request-Headers">7.3.4.4 Request Headers</a></li>
        <li><a id="toc-Response-Headers" href="https://www.gnu.org/software/guile/manual/guile.html#Response-Headers">7.3.4.5 Response Headers</a></li>
      </ul></li>
      <li><a id="toc-Transfer-Codings-1" href="https://www.gnu.org/software/guile/manual/guile.html#Transfer-Codings">7.3.5 Transfer Codings</a></li>
      <li><a id="toc-HTTP-Requests" href="https://www.gnu.org/software/guile/manual/guile.html#Requests">7.3.6 HTTP Requests</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-An-Important-Note-on-Character-Sets" href="https://www.gnu.org/software/guile/manual/guile.html#An-Important-Note-on-Character-Sets">7.3.6.1 An Important Note on Character Sets</a></li>
        <li><a id="toc-Request-API" href="https://www.gnu.org/software/guile/manual/guile.html#Request-API">7.3.6.2 Request API</a></li>
      </ul></li>
      <li><a id="toc-HTTP-Responses" href="https://www.gnu.org/software/guile/manual/guile.html#Responses">7.3.7 HTTP Responses</a></li>
      <li><a id="toc-Web-Client-1" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Client">7.3.8 Web Client</a></li>
      <li><a id="toc-Web-Server-1" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server">7.3.9 Web Server</a></li>
      <li><a id="toc-Web-Examples-1" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Examples">7.3.10 Web Examples</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Hello_002c-World_0021" href="https://www.gnu.org/software/guile/manual/guile.html#Hello_002c-World_0021">7.3.10.1 Hello, World!</a></li>
        <li><a id="toc-Inspecting-the-Request" href="https://www.gnu.org/software/guile/manual/guile.html#Inspecting-the-Request">7.3.10.2 Inspecting the Request</a></li>
        <li><a id="toc-Higher_002dLevel-Interfaces" href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dLevel-Interfaces">7.3.10.3 Higher-Level Interfaces</a></li>
        <li><a id="toc-Conclusion" href="https://www.gnu.org/software/guile/manual/guile.html#Conclusion">7.3.10.4 Conclusion</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-The-_0028ice_002d9-getopt_002dlong_0029-Module" href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong">7.4 The (ice-9 getopt-long) Module</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-A-Short-getopt_002dlong-Example" href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Example">7.4.1 A Short getopt-long Example</a></li>
      <li><a id="toc-How-to-Write-an-Option-Specification" href="https://www.gnu.org/software/guile/manual/guile.html#Option-Specification">7.4.2 How to Write an Option Specification</a></li>
      <li><a id="toc-Expected-Command-Line-Format" href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Format">7.4.3 Expected Command Line Format</a></li>
      <li><a id="toc-Reference-Documentation-for-getopt_002dlong" href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Reference">7.4.4 Reference Documentation for <code class="code">getopt-long</code></a></li>
      <li><a id="toc-Reference-Documentation-for-option_002dref" href="https://www.gnu.org/software/guile/manual/guile.html#option_002dref-Reference">7.4.5 Reference Documentation for <code class="code">option-ref</code></a></li>
    </ul></li>
    <li><a id="toc-SRFI-Support-Modules" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support">7.5 SRFI Support Modules</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-About-SRFI-Usage-1" href="https://www.gnu.org/software/guile/manual/guile.html#About-SRFI-Usage">7.5.1 About SRFI Usage</a></li>
      <li><a id="toc-SRFI_002d0-_002d-cond_002dexpand" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d0">7.5.2 SRFI-0 - cond-expand</a></li>
      <li><a id="toc-SRFI_002d1-_002d-List-library" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1">7.5.3 SRFI-1 - List library</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Constructors" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Constructors">7.5.3.1 Constructors</a></li>
        <li><a id="toc-Predicates" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Predicates">7.5.3.2 Predicates</a></li>
        <li><a id="toc-Selectors" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors">7.5.3.3 Selectors</a></li>
        <li><a id="toc-Length_002c-Append_002c-Concatenate_002c-etc_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Length-Append-etc">7.5.3.4 Length, Append, Concatenate, etc.</a></li>
        <li><a id="toc-Fold_002c-Unfold-_0026-Map" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Fold-and-Map">7.5.3.5 Fold, Unfold &amp; Map</a></li>
        <li><a id="toc-Filtering-and-Partitioning" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Filtering-and-Partitioning">7.5.3.6 Filtering and Partitioning</a></li>
        <li><a id="toc-Searching" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching">7.5.3.7 Searching</a></li>
        <li><a id="toc-Deleting" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Deleting">7.5.3.8 Deleting</a></li>
        <li><a id="toc-Association-Lists-2" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists">7.5.3.9 Association Lists</a></li>
        <li><a id="toc-Set-Operations-on-Lists" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Set-Operations">7.5.3.10 Set Operations on Lists</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d2-_002d-and_002dlet_002a" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d2">7.5.4 SRFI-2 - and-let*</a></li>
      <li><a id="toc-SRFI_002d4-_002d-Homogeneous-numeric-vector-datatypes" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4">7.5.5 SRFI-4 - Homogeneous numeric vector datatypes</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d4-_002d-Overview" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Overview">7.5.5.1 SRFI-4 - Overview</a></li>
        <li><a id="toc-SRFI_002d4-_002d-API" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-API">7.5.5.2 SRFI-4 - API</a></li>
        <li><a id="toc-SRFI_002d4-_002d-Relation-to-bytevectors" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-and-Bytevectors">7.5.5.3 SRFI-4 - Relation to bytevectors</a></li>
        <li><a id="toc-SRFI_002d4-_002d-Guile-extensions" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Extensions">7.5.5.4 SRFI-4 - Guile extensions</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d6-_002d-Basic-String-Ports" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d6">7.5.6 SRFI-6 - Basic String Ports</a></li>
      <li><a id="toc-SRFI_002d8-_002d-receive" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d8">7.5.7 SRFI-8 - receive</a></li>
      <li><a id="toc-SRFI_002d9-_002d-define_002drecord_002dtype" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9">7.5.8 SRFI-9 - define-record-type</a></li>
      <li><a id="toc-SRFI_002d10-_002d-Hash_002dComma-Reader-Extension" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d10">7.5.9 SRFI-10 - Hash-Comma Reader Extension</a></li>
      <li><a id="toc-SRFI_002d11-_002d-let_002dvalues" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d11">7.5.10 SRFI-11 - let-values</a></li>
      <li><a id="toc-SRFI_002d13-_002d-String-Library" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d13">7.5.11 SRFI-13 - String Library</a></li>
      <li><a id="toc-SRFI_002d14-_002d-Character_002dset-Library" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d14">7.5.12 SRFI-14 - Character-set Library</a></li>
      <li><a id="toc-SRFI_002d16-_002d-case_002dlambda" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d16">7.5.13 SRFI-16 - case-lambda</a></li>
      <li><a id="toc-SRFI_002d17-_002d-Generalized-set_0021" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d17">7.5.14 SRFI-17 - Generalized set!</a></li>
      <li><a id="toc-SRFI_002d18-_002d-Multithreading-support" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18">7.5.15 SRFI-18 - Multithreading support</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d18-Threads-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Threads">7.5.15.1 SRFI-18 Threads</a></li>
        <li><a id="toc-SRFI_002d18-Mutexes-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Mutexes">7.5.15.2 SRFI-18 Mutexes</a></li>
        <li><a id="toc-SRFI_002d18-Condition-variables-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Condition-variables">7.5.15.3 SRFI-18 Condition variables</a></li>
        <li><a id="toc-SRFI_002d18-Time-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time">7.5.15.4 SRFI-18 Time</a></li>
        <li><a id="toc-SRFI_002d18-Exceptions-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Exceptions">7.5.15.5 SRFI-18 Exceptions</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d19-_002d-Time_002fDate-Library" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19">7.5.16 SRFI-19 - Time/Date Library</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d19-Introduction-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Introduction">7.5.16.1 SRFI-19 Introduction</a></li>
        <li><a id="toc-SRFI_002d19-Time-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time">7.5.16.2 SRFI-19 Time</a></li>
        <li><a id="toc-SRFI_002d19-Date-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date">7.5.16.3 SRFI-19 Date</a></li>
        <li><a id="toc-SRFI_002d19-Time_002fDate-conversions-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time_002fDate-conversions">7.5.16.4 SRFI-19 Time/Date conversions</a></li>
        <li><a id="toc-SRFI_002d19-Date-to-string-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date-to-string">7.5.16.5 SRFI-19 Date to string</a></li>
        <li><a id="toc-SRFI_002d19-String-to-date-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-String-to-date">7.5.16.6 SRFI-19 String to date</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d23-_002d-Error-Reporting" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d23">7.5.17 SRFI-23 - Error Reporting</a></li>
      <li><a id="toc-SRFI_002d26-_002d-specializing-parameters" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d26">7.5.18 SRFI-26 - specializing parameters</a></li>
      <li><a id="toc-SRFI_002d27-_002d-Sources-of-Random-Bits" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27">7.5.19 SRFI-27 - Sources of Random Bits</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-The-Default-Random-Source" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Default-Random-Source">7.5.19.1 The Default Random Source</a></li>
        <li><a id="toc-Random-Sources" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Sources">7.5.19.2 Random Sources</a></li>
        <li><a id="toc-Obtaining-random-number-generator-procedures" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Number-Generators">7.5.19.3 Obtaining random number generator procedures</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d28-_002d-Basic-Format-Strings" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d28">7.5.20 SRFI-28 - Basic Format Strings</a></li>
      <li><a id="toc-SRFI_002d30-_002d-Nested-Multi_002dline-Comments" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d30">7.5.21 SRFI-30 - Nested Multi-line Comments</a></li>
      <li><a id="toc-SRFI_002d31-_002d-A-special-form-_0060rec_0027-for-recursive-evaluation" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d31">7.5.22 SRFI-31 - A special form ‘rec’ for recursive evaluation</a></li>
      <li><a id="toc-SRFI_002d34-_002d-Exception-handling-for-programs" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d34">7.5.23 SRFI-34 - Exception handling for programs</a></li>
      <li><a id="toc-SRFI_002d35-_002d-Conditions" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d35">7.5.24 SRFI-35 - Conditions</a></li>
      <li><a id="toc-SRFI_002d37-_002d-args_002dfold" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d37">7.5.25 SRFI-37 - args-fold</a></li>
      <li><a id="toc-SRFI_002d38-_002d-External-Representation-for-Data-With-Shared-Structure" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d38">7.5.26 SRFI-38 - External Representation for Data With Shared Structure</a></li>
      <li><a id="toc-SRFI_002d39-_002d-Parameters" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d39">7.5.27 SRFI-39 - Parameters</a></li>
      <li><a id="toc-SRFI_002d41-_002d-Streams" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d41">7.5.28 SRFI-41 - Streams</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d41-Stream-Fundamentals-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d41-Stream-Fundamentals">7.5.28.1 SRFI-41 Stream Fundamentals</a></li>
        <li><a id="toc-SRFI_002d41-Stream-Primitives-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d41-Stream-Primitives">7.5.28.2 SRFI-41 Stream Primitives</a></li>
        <li><a id="toc-SRFI_002d41-Stream-Library-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d41-Stream-Library">7.5.28.3 SRFI-41 Stream Library</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d42-_002d-Eager-Comprehensions" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d42">7.5.29 SRFI-42 - Eager Comprehensions</a></li>
      <li><a id="toc-SRFI_002d43-_002d-Vector-Library" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43">7.5.30 SRFI-43 - Vector Library</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d43-Constructors-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Constructors">7.5.30.1 SRFI-43 Constructors</a></li>
        <li><a id="toc-SRFI_002d43-Predicates-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Predicates">7.5.30.2 SRFI-43 Predicates</a></li>
        <li><a id="toc-SRFI_002d43-Selectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Selectors">7.5.30.3 SRFI-43 Selectors</a></li>
        <li><a id="toc-SRFI_002d43-Iteration-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Iteration">7.5.30.4 SRFI-43 Iteration</a></li>
        <li><a id="toc-SRFI_002d43-Searching-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Searching">7.5.30.5 SRFI-43 Searching</a></li>
        <li><a id="toc-SRFI_002d43-Mutators-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Mutators">7.5.30.6 SRFI-43 Mutators</a></li>
        <li><a id="toc-SRFI_002d43-Conversion-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43-Conversion">7.5.30.7 SRFI-43 Conversion</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d45-_002d-Primitives-for-Expressing-Iterative-Lazy-Algorithms" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d45">7.5.31 SRFI-45 - Primitives for Expressing Iterative Lazy Algorithms</a></li>
      <li><a id="toc-SRFI_002d46-Basic-syntax_002drules-Extensions" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d46">7.5.32 SRFI-46 Basic syntax-rules Extensions</a></li>
      <li><a id="toc-SRFI_002d55-_002d-Requiring-Features" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d55">7.5.33 SRFI-55 - Requiring Features</a></li>
      <li><a id="toc-SRFI_002d60-_002d-Integers-as-Bits" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d60">7.5.34 SRFI-60 - Integers as Bits</a></li>
      <li><a id="toc-SRFI_002d61-_002d-A-more-general-cond-clause" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d61">7.5.35 SRFI-61 - A more general <code class="code">cond</code> clause</a></li>
      <li><a id="toc-SRFI_002d62-_002d-S_002dexpression-comments_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d62">7.5.36 SRFI-62 - S-expression comments.</a></li>
      <li><a id="toc-SRFI_002d64-_002d-A-Scheme-API-for-test-suites_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d64">7.5.37 SRFI-64 - A Scheme API for test suites.</a></li>
      <li><a id="toc-SRFI_002d67-_002d-Compare-procedures" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d67">7.5.38 SRFI-67 - Compare procedures</a></li>
      <li><a id="toc-SRFI_002d69-_002d-Basic-hash-tables" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69">7.5.39 SRFI-69 - Basic hash tables</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Creating-hash-tables" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69-Creating-hash-tables">7.5.39.1 Creating hash tables</a></li>
        <li><a id="toc-Accessing-table-items" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69-Accessing-table-items">7.5.39.2 Accessing table items</a></li>
        <li><a id="toc-Table-properties" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69-Table-properties">7.5.39.3 Table properties</a></li>
        <li><a id="toc-Hash-table-algorithms" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69-Hash-table-algorithms">7.5.39.4 Hash table algorithms</a></li>
      </ul></li>
      <li><a id="toc-SRFI_002d71-_002d-Extended-let_002dsyntax-for-multiple-values" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d71">7.5.40 SRFI-71 - Extended let-syntax for multiple values</a></li>
      <li><a id="toc-SRFI_002d87-_003d_003e-in-case-clauses" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d87">7.5.41 SRFI-87 =&gt; in case clauses</a></li>
      <li><a id="toc-SRFI_002d88-Keyword-Objects" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d88">7.5.42 SRFI-88 Keyword Objects</a></li>
      <li><a id="toc-SRFI_002d98-Accessing-environment-variables_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d98">7.5.43 SRFI-98 Accessing environment variables.</a></li>
      <li><a id="toc-SRFI_002d105-Curly_002dinfix-expressions_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d105">7.5.44 SRFI-105 Curly-infix expressions.</a></li>
      <li><a id="toc-SRFI_002d111-Boxes_002e" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d111">7.5.45 SRFI-111 Boxes.</a></li>
      <li><a id="toc-Transducers" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171">7.5.46 Transducers</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-SRFI_002d171-General-Discussion-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171-General-Discussion">7.5.46.1 SRFI-171 General Discussion</a></li>
        <li><a id="toc-Applying-Transducers" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171-Applying-Transducers">7.5.46.2 Applying Transducers</a></li>
        <li><a id="toc-Reducers" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171-Reducers">7.5.46.3 Reducers</a></li>
        <li><a id="toc-Transducers-1" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171-Transducers">7.5.46.4 Transducers</a></li>
        <li><a id="toc-Helper-functions-for-writing-transducers" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171-Helpers">7.5.46.5 Helper functions for writing transducers</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-R6RS-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support">7.6 R6RS Support</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Incompatibilities-with-the-R6RS" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Incompatibilities">7.6.1 Incompatibilities with the R6RS</a></li>
      <li><a id="toc-R6RS-Standard-Libraries-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Standard-Libraries">7.6.2 R6RS Standard Libraries</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Library-Usage-1" href="https://www.gnu.org/software/guile/manual/guile.html#Library-Usage">7.6.2.1 Library Usage</a></li>
        <li><a id="toc-rnrs-base-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-base">7.6.2.2 rnrs base</a></li>
        <li><a id="toc-rnrs-unicode-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-unicode">7.6.2.3 rnrs unicode</a></li>
        <li><a id="toc-rnrs-bytevectors-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-bytevectors">7.6.2.4 rnrs bytevectors</a></li>
        <li><a id="toc-rnrs-lists-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-lists">7.6.2.5 rnrs lists</a></li>
        <li><a id="toc-rnrs-sorting-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-sorting">7.6.2.6 rnrs sorting</a></li>
        <li><a id="toc-rnrs-control-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-control">7.6.2.7 rnrs control</a></li>
        <li><a id="toc-R6RS-Records-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Records">7.6.2.8 R6RS Records</a></li>
        <li><a id="toc-rnrs-records-syntactic-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-records-syntactic">7.6.2.9 rnrs records syntactic</a></li>
        <li><a id="toc-rnrs-records-procedural-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-records-procedural">7.6.2.10 rnrs records procedural</a></li>
        <li><a id="toc-rnrs-records-inspection-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-records-inspection">7.6.2.11 rnrs records inspection</a></li>
        <li><a id="toc-rnrs-exceptions-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-exceptions">7.6.2.12 rnrs exceptions</a></li>
        <li><a id="toc-rnrs-conditions-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-conditions">7.6.2.13 rnrs conditions</a></li>
        <li><a id="toc-I_002fO-Conditions" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-I_002fO-Conditions">7.6.2.14 I/O Conditions</a></li>
        <li><a id="toc-Transcoders" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Transcoders">7.6.2.15 Transcoders</a></li>
        <li><a id="toc-rnrs-io-ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-io-ports">7.6.2.16 rnrs io ports</a></li>
        <li><a id="toc-R6RS-File-Ports-1" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-File-Ports">7.6.2.17 R6RS File Ports</a></li>
        <li><a id="toc-rnrs-io-simple-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-io-simple">7.6.2.18 rnrs io simple</a></li>
        <li><a id="toc-rnrs-files-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-files">7.6.2.19 rnrs files</a></li>
        <li><a id="toc-rnrs-programs-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-programs">7.6.2.20 rnrs programs</a></li>
        <li><a id="toc-rnrs-arithmetic-fixnums-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-arithmetic-fixnums">7.6.2.21 rnrs arithmetic fixnums</a></li>
        <li><a id="toc-rnrs-arithmetic-flonums-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-arithmetic-flonums">7.6.2.22 rnrs arithmetic flonums</a></li>
        <li><a id="toc-rnrs-arithmetic-bitwise-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-arithmetic-bitwise">7.6.2.23 rnrs arithmetic bitwise</a></li>
        <li><a id="toc-rnrs-syntax_002dcase-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-syntax_002dcase">7.6.2.24 rnrs syntax-case</a></li>
        <li><a id="toc-rnrs-hashtables-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-hashtables">7.6.2.25 rnrs hashtables</a></li>
        <li><a id="toc-rnrs-enums-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-enums">7.6.2.26 rnrs enums</a></li>
        <li><a id="toc-rnrs-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs">7.6.2.27 rnrs</a></li>
        <li><a id="toc-rnrs-eval-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-eval">7.6.2.28 rnrs eval</a></li>
        <li><a id="toc-rnrs-mutable_002dpairs-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-mutable_002dpairs">7.6.2.29 rnrs mutable-pairs</a></li>
        <li><a id="toc-rnrs-mutable_002dstrings-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-mutable_002dstrings">7.6.2.30 rnrs mutable-strings</a></li>
        <li><a id="toc-rnrs-r5rs-1" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-r5rs">7.6.2.31 rnrs r5rs</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-R7RS-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">7.7 R7RS Support</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Incompatibilities-with-the-R7RS" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Incompatibilities">7.7.1 Incompatibilities with the R7RS</a></li>
      <li><a id="toc-R7RS-Standard-Libraries-1" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Standard-Libraries">7.7.2 R7RS Standard Libraries</a></li>
    </ul></li>
    <li><a id="toc-Pattern-Matching-1" href="https://www.gnu.org/software/guile/manual/guile.html#Pattern-Matching">7.8 Pattern Matching</a></li>
    <li><a id="toc-Readline-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Support">7.9 Readline Support</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Loading-Readline-Support-1" href="https://www.gnu.org/software/guile/manual/guile.html#Loading-Readline-Support">7.9.1 Loading Readline Support</a></li>
      <li><a id="toc-Readline-Options-1" href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Options">7.9.2 Readline Options</a></li>
      <li><a id="toc-Readline-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Functions">7.9.3 Readline Functions</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Readline-Port" href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Port">7.9.3.1 Readline Port</a></li>
        <li><a id="toc-Completion" href="https://www.gnu.org/software/guile/manual/guile.html#Completion">7.9.3.2 Completion</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Pretty-Printing-1" href="https://www.gnu.org/software/guile/manual/guile.html#Pretty-Printing">7.10 Pretty Printing</a></li>
    <li><a id="toc-Formatted-Output-1" href="https://www.gnu.org/software/guile/manual/guile.html#Formatted-Output">7.11 Formatted Output</a></li>
    <li><a id="toc-File-Tree-Walk-1" href="https://www.gnu.org/software/guile/manual/guile.html#File-Tree-Walk">7.12 File Tree Walk</a></li>
    <li><a id="toc-Queues-1" href="https://www.gnu.org/software/guile/manual/guile.html#Queues">7.13 Queues</a></li>
    <li><a id="toc-Streams-1" href="https://www.gnu.org/software/guile/manual/guile.html#Streams">7.14 Streams</a></li>
    <li><a id="toc-Buffered-Input-1" href="https://www.gnu.org/software/guile/manual/guile.html#Buffered-Input">7.15 Buffered Input</a></li>
    <li><a id="toc-Expect-1" href="https://www.gnu.org/software/guile/manual/guile.html#Expect">7.16 Expect</a></li>
    <li><a id="toc-sxml_002dmatch_003a-Pattern-Matching-of-SXML" href="https://www.gnu.org/software/guile/manual/guile.html#sxml_002dmatch">7.17 <code class="code">sxml-match</code>: Pattern Matching of SXML</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Syntax" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax">Syntax</a></li>
      <li><a id="toc-Matching-XML-Elements" href="https://www.gnu.org/software/guile/manual/guile.html#Matching-XML-Elements">Matching XML Elements</a></li>
      <li><a id="toc-Ellipses-in-Patterns" href="https://www.gnu.org/software/guile/manual/guile.html#Ellipses-in-Patterns">Ellipses in Patterns</a></li>
      <li><a id="toc-Ellipses-in-Quasiquote_0027d-Output" href="https://www.gnu.org/software/guile/manual/guile.html#Ellipses-in-Quasiquote_0027d-Output">Ellipses in Quasiquote’d Output</a></li>
      <li><a id="toc-Matching-Nodesets" href="https://www.gnu.org/software/guile/manual/guile.html#Matching-Nodesets">Matching Nodesets</a></li>
      <li><a id="toc-Matching-the-_0060_0060Rest_0027_0027-of-a-Nodeset" href="https://www.gnu.org/software/guile/manual/guile.html#Matching-the-_0060_0060Rest_0027_0027-of-a-Nodeset">Matching the “Rest” of a Nodeset</a></li>
      <li><a id="toc-Matching-the-Unmatched-Attributes" href="https://www.gnu.org/software/guile/manual/guile.html#Matching-the-Unmatched-Attributes">Matching the Unmatched Attributes</a></li>
      <li><a id="toc-Default-Values-in-Attribute-Patterns" href="https://www.gnu.org/software/guile/manual/guile.html#Default-Values-in-Attribute-Patterns">Default Values in Attribute Patterns</a></li>
      <li><a id="toc-Guards-in-Patterns" href="https://www.gnu.org/software/guile/manual/guile.html#Guards-in-Patterns">Guards in Patterns</a></li>
      <li><a id="toc-Catamorphisms" href="https://www.gnu.org/software/guile/manual/guile.html#Catamorphisms">Catamorphisms</a></li>
      <li><a id="toc-Named_002dCatamorphisms" href="https://www.gnu.org/software/guile/manual/guile.html#Named_002dCatamorphisms">Named-Catamorphisms</a></li>
      <li><a id="toc-sxml_002dmatch_002dlet-and-sxml_002dmatch_002dlet_002a" href="https://www.gnu.org/software/guile/manual/guile.html#sxml_002dmatch_002dlet-and-sxml_002dmatch_002dlet_002a"><code class="code">sxml-match-let</code> and <code class="code">sxml-match-let*</code></a></li>
    </ul></li>
    <li><a id="toc-The-Scheme-shell-_0028scsh_0029-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-shell-_0028scsh_0029">7.18 The Scheme shell (scsh)</a></li>
    <li><a id="toc-Curried-Definitions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Curried-Definitions">7.19 Curried Definitions</a></li>
    <li><a id="toc-Statprof-1" href="https://www.gnu.org/software/guile/manual/guile.html#Statprof">7.20 Statprof</a></li>
    <li><a id="toc-SXML-1" href="https://www.gnu.org/software/guile/manual/guile.html#SXML">7.21 SXML</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-SXML-Overview-1" href="https://www.gnu.org/software/guile/manual/guile.html#SXML-Overview">7.21.1 SXML Overview</a></li>
      <li><a id="toc-Reading-and-Writing-XML-1" href="https://www.gnu.org/software/guile/manual/guile.html#Reading-and-Writing-XML">7.21.2 Reading and Writing XML</a></li>
      <li><a id="toc-SSAX_003a-A-Functional-XML-Parsing-Toolkit" href="https://www.gnu.org/software/guile/manual/guile.html#SSAX">7.21.3 SSAX: A Functional XML Parsing Toolkit</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-History-1" href="https://www.gnu.org/software/guile/manual/guile.html#History-1">7.21.3.1 History</a></li>
        <li><a id="toc-Implementation" href="https://www.gnu.org/software/guile/manual/guile.html#Implementation">7.21.3.2 Implementation</a></li>
        <li><a id="toc-Usage" href="https://www.gnu.org/software/guile/manual/guile.html#Usage">7.21.3.3 Usage</a></li>
      </ul></li>
      <li><a id="toc-Transforming-SXML-1" href="https://www.gnu.org/software/guile/manual/guile.html#Transforming-SXML">7.21.4 Transforming SXML</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview" href="https://www.gnu.org/software/guile/manual/guile.html#Overview">7.21.4.1 Overview</a></li>
        <li><a id="toc-Usage-1" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-1">7.21.4.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-SXML-Tree-Fold-1" href="https://www.gnu.org/software/guile/manual/guile.html#SXML-Tree-Fold">7.21.5 SXML Tree Fold</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-1" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-1">7.21.5.1 Overview</a></li>
        <li><a id="toc-Usage-2" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-2">7.21.5.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-SXPath-1" href="https://www.gnu.org/software/guile/manual/guile.html#SXPath">7.21.6 SXPath</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-2" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-2">7.21.6.1 Overview</a></li>
        <li><a id="toc-Basic-Converters-and-Applicators" href="https://www.gnu.org/software/guile/manual/guile.html#Basic-Converters-and-Applicators">7.21.6.2 Basic Converters and Applicators</a></li>
        <li><a id="toc-Converter-Combinators" href="https://www.gnu.org/software/guile/manual/guile.html#Converter-Combinators">7.21.6.3 Converter Combinators</a></li>
      </ul></li>
      <li><a id="toc-_0028sxml-ssax-input_002dparse_0029" href="https://www.gnu.org/software/guile/manual/guile.html#sxml-ssax-input_002dparse">7.21.7 (sxml ssax input-parse)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-3" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-3">7.21.7.1 Overview</a></li>
        <li><a id="toc-Usage-3" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-3">7.21.7.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028sxml-apply_002dtemplates_0029" href="https://www.gnu.org/software/guile/manual/guile.html#sxml-apply_002dtemplates">7.21.8 (sxml apply-templates)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-4" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-4">7.21.8.1 Overview</a></li>
        <li><a id="toc-Usage-4" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-4">7.21.8.2 Usage</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-Texinfo-Processing-1" href="https://www.gnu.org/software/guile/manual/guile.html#Texinfo-Processing">7.22 Texinfo Processing</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-_0028texinfo_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo">7.22.1 (texinfo)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-5" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-5">7.22.1.1 Overview</a></li>
        <li><a id="toc-Usage-5" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-5">7.22.1.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-docbook_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-docbook">7.22.2 (texinfo docbook)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-6" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-6">7.22.2.1 Overview</a></li>
        <li><a id="toc-Usage-6" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-6">7.22.2.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-html_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-html">7.22.3 (texinfo html)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-7" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-7">7.22.3.1 Overview</a></li>
        <li><a id="toc-Usage-7" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-7">7.22.3.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-indexing_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-indexing">7.22.4 (texinfo indexing)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-8" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-8">7.22.4.1 Overview</a></li>
        <li><a id="toc-Usage-8" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-8">7.22.4.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-string_002dutils_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-string_002dutils">7.22.5 (texinfo string-utils)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-9" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-9">7.22.5.1 Overview</a></li>
        <li><a id="toc-Usage-9" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-9">7.22.5.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-plain_002dtext_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-plain_002dtext">7.22.6 (texinfo plain-text)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-10" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-10">7.22.6.1 Overview</a></li>
        <li><a id="toc-Usage-10" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-10">7.22.6.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-serialize_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-serialize">7.22.7 (texinfo serialize)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-11" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-11">7.22.7.1 Overview</a></li>
        <li><a id="toc-Usage-11" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-11">7.22.7.2 Usage</a></li>
      </ul></li>
      <li><a id="toc-_0028texinfo-reflection_0029" href="https://www.gnu.org/software/guile/manual/guile.html#texinfo-reflection">7.22.8 (texinfo reflection)</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Overview-12" href="https://www.gnu.org/software/guile/manual/guile.html#Overview-12">7.22.8.1 Overview</a></li>
        <li><a id="toc-Usage-12" href="https://www.gnu.org/software/guile/manual/guile.html#Usage-12">7.22.8.2 Usage</a></li>
      </ul></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-GOOPS-1" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS">8 GOOPS</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-Copyright-Notice-1" href="https://www.gnu.org/software/guile/manual/guile.html#Copyright-Notice">8.1 Copyright Notice</a></li>
    <li><a id="toc-Class-Definition-1" href="https://www.gnu.org/software/guile/manual/guile.html#Class-Definition">8.2 Class Definition</a></li>
    <li><a id="toc-Instance-Creation-and-Slot-Access" href="https://www.gnu.org/software/guile/manual/guile.html#Instance-Creation">8.3 Instance Creation and Slot Access</a></li>
    <li><a id="toc-Slot-Options-1" href="https://www.gnu.org/software/guile/manual/guile.html#Slot-Options">8.4 Slot Options</a></li>
    <li><a id="toc-Illustrating-Slot-Description" href="https://www.gnu.org/software/guile/manual/guile.html#Slot-Description-Example">8.5 Illustrating Slot Description</a></li>
    <li><a id="toc-Methods-and-Generic-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Methods-and-Generic-Functions">8.6 Methods and Generic Functions</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Accessors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessors">8.6.1 Accessors</a></li>
      <li><a id="toc-Extending-Primitives-1" href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Primitives">8.6.2 Extending Primitives</a></li>
      <li><a id="toc-Merging-Generics-1" href="https://www.gnu.org/software/guile/manual/guile.html#Merging-Generics">8.6.3 Merging Generics</a></li>
      <li><a id="toc-Next_002dmethod-1" href="https://www.gnu.org/software/guile/manual/guile.html#Next_002dmethod">8.6.4 Next-method</a></li>
      <li><a id="toc-Generic-Function-and-Method-Examples-1" href="https://www.gnu.org/software/guile/manual/guile.html#Generic-Function-and-Method-Examples">8.6.5 Generic Function and Method Examples</a></li>
      <li><a id="toc-Handling-Invocation-Errors-1" href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Invocation-Errors">8.6.6 Handling Invocation Errors</a></li>
    </ul></li>
    <li><a id="toc-Inheritance-1" href="https://www.gnu.org/software/guile/manual/guile.html#Inheritance">8.7 Inheritance</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Class-Precedence-List-1" href="https://www.gnu.org/software/guile/manual/guile.html#Class-Precedence-List">8.7.1 Class Precedence List</a></li>
      <li><a id="toc-Sorting-Methods-1" href="https://www.gnu.org/software/guile/manual/guile.html#Sorting-Methods">8.7.2 Sorting Methods</a></li>
    </ul></li>
    <li><a id="toc-Introspection-1" href="https://www.gnu.org/software/guile/manual/guile.html#Introspection">8.8 Introspection</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Classes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Classes">8.8.1 Classes</a></li>
      <li><a id="toc-Instances-1" href="https://www.gnu.org/software/guile/manual/guile.html#Instances">8.8.2 Instances</a></li>
      <li><a id="toc-Slots-1" href="https://www.gnu.org/software/guile/manual/guile.html#Slots">8.8.3 Slots</a></li>
      <li><a id="toc-Generic-Functions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Generic-Functions">8.8.4 Generic Functions</a></li>
      <li><a id="toc-Accessing-Slots-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Slots">8.8.5 Accessing Slots</a></li>
    </ul></li>
    <li><a id="toc-Error-Handling-2" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS-Error-Handling">8.9 Error Handling</a></li>
    <li><a id="toc-GOOPS-Object-Miscellany-1" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS-Object-Miscellany">8.10 GOOPS Object Miscellany</a></li>
    <li><a id="toc-The-Metaobject-Protocol-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Metaobject-Protocol">8.11 The Metaobject Protocol</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Metaobjects-and-the-Metaobject-Protocol-1" href="https://www.gnu.org/software/guile/manual/guile.html#Metaobjects-and-the-Metaobject-Protocol">8.11.1 Metaobjects and the Metaobject Protocol</a></li>
      <li><a id="toc-Metaclasses-1" href="https://www.gnu.org/software/guile/manual/guile.html#Metaclasses">8.11.2 Metaclasses</a></li>
      <li><a id="toc-MOP-Specification-1" href="https://www.gnu.org/software/guile/manual/guile.html#MOP-Specification">8.11.3 MOP Specification</a></li>
      <li><a id="toc-Instance-Creation-Protocol-1" href="https://www.gnu.org/software/guile/manual/guile.html#Instance-Creation-Protocol">8.11.4 Instance Creation Protocol</a></li>
      <li><a id="toc-Class-Definition-Protocol-1" href="https://www.gnu.org/software/guile/manual/guile.html#Class-Definition-Protocol">8.11.5 Class Definition Protocol</a></li>
      <li><a id="toc-Customizing-Class-Definition-1" href="https://www.gnu.org/software/guile/manual/guile.html#Customizing-Class-Definition">8.11.6 Customizing Class Definition</a></li>
      <li><a id="toc-Method-Definition-1" href="https://www.gnu.org/software/guile/manual/guile.html#Method-Definition">8.11.7 Method Definition</a></li>
      <li><a id="toc-Method-Definition-Internals-1" href="https://www.gnu.org/software/guile/manual/guile.html#Method-Definition-Internals">8.11.8 Method Definition Internals</a></li>
      <li><a id="toc-Generic-Function-Internals-1" href="https://www.gnu.org/software/guile/manual/guile.html#Generic-Function-Internals">8.11.9 Generic Function Internals</a></li>
      <li><a id="toc-Generic-Function-Invocation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Generic-Function-Invocation">8.11.10 Generic Function Invocation</a></li>
    </ul></li>
    <li><a id="toc-Redefining-a-Class-1" href="https://www.gnu.org/software/guile/manual/guile.html#Redefining-a-Class">8.12 Redefining a Class</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Redefinable-Classes-1" href="https://www.gnu.org/software/guile/manual/guile.html#Redefinable-Classes">8.12.1 Redefinable Classes</a></li>
      <li><a id="toc-Default-Class-Redefinition-Behaviour-1" href="https://www.gnu.org/software/guile/manual/guile.html#Default-Class-Redefinition-Behaviour">8.12.2 Default Class Redefinition Behaviour</a></li>
      <li><a id="toc-Customizing-Class-Redefinition-1" href="https://www.gnu.org/software/guile/manual/guile.html#Customizing-Class-Redefinition">8.12.3 Customizing Class Redefinition</a></li>
    </ul></li>
    <li><a id="toc-Changing-the-Class-of-an-Instance-1" href="https://www.gnu.org/software/guile/manual/guile.html#Changing-the-Class-of-an-Instance">8.13 Changing the Class of an Instance</a></li>
  </ul></li>
  <li><a id="toc-Guile-Implementation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Implementation">9 Guile Implementation</a>
  <ul class="toc-numbered-mark">
    <li><a id="toc-A-Brief-History-of-Guile" href="https://www.gnu.org/software/guile/manual/guile.html#History">9.1 A Brief History of Guile</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-The-Emacs-Thesis-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Emacs-Thesis">9.1.1 The Emacs Thesis</a></li>
      <li><a id="toc-Early-Days-1" href="https://www.gnu.org/software/guile/manual/guile.html#Early-Days">9.1.2 Early Days</a></li>
      <li><a id="toc-A-Scheme-of-Many-Maintainers-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Scheme-of-Many-Maintainers">9.1.3 A Scheme of Many Maintainers</a></li>
      <li><a id="toc-A-Timeline-of-Selected-Guile-Releases-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Timeline-of-Selected-Guile-Releases">9.1.4 A Timeline of Selected Guile Releases</a></li>
      <li><a id="toc-Status_002c-or_003a-Your-Help-Needed" href="https://www.gnu.org/software/guile/manual/guile.html#Status">9.1.5 Status, or: Your Help Needed</a></li>
    </ul></li>
    <li><a id="toc-Data-Representation-1" href="https://www.gnu.org/software/guile/manual/guile.html#Data-Representation">9.2 Data Representation</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-A-Simple-Representation-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Simple-Representation">9.2.1 A Simple Representation</a></li>
      <li><a id="toc-Faster-Integers-1" href="https://www.gnu.org/software/guile/manual/guile.html#Faster-Integers">9.2.2 Faster Integers</a></li>
      <li><a id="toc-Cheaper-Pairs-1" href="https://www.gnu.org/software/guile/manual/guile.html#Cheaper-Pairs">9.2.3 Cheaper Pairs</a></li>
      <li><a id="toc-Conservative-Garbage-Collection" href="https://www.gnu.org/software/guile/manual/guile.html#Conservative-GC">9.2.4 Conservative Garbage Collection</a></li>
      <li><a id="toc-The-SCM-Type-in-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type-in-Guile">9.2.5 The SCM Type in Guile</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Relationship-Between-SCM-and-scm_005ft_005fbits-1" href="https://www.gnu.org/software/guile/manual/guile.html#Relationship-Between-SCM-and-scm_005ft_005fbits">9.2.5.1 Relationship Between <code class="code">SCM</code> and <code class="code">scm_t_bits</code></a></li>
        <li><a id="toc-Immediate-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Immediate-Objects">9.2.5.2 Immediate Objects</a></li>
        <li><a id="toc-Non_002dImmediate-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dImmediate-Objects">9.2.5.3 Non-Immediate Objects</a></li>
        <li><a id="toc-Allocating-Heap-Objects-1" href="https://www.gnu.org/software/guile/manual/guile.html#Allocating-Heap-Objects">9.2.5.4 Allocating Heap Objects</a></li>
        <li><a id="toc-Heap-Object-Type-Information-1" href="https://www.gnu.org/software/guile/manual/guile.html#Heap-Object-Type-Information">9.2.5.5 Heap Object Type Information</a></li>
        <li><a id="toc-Accessing-Heap-Object-Fields-1" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Heap-Object-Fields">9.2.5.6 Accessing Heap Object Fields</a></li>
      </ul></li>
    </ul></li>
    <li><a id="toc-A-Virtual-Machine-for-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#A-Virtual-Machine-for-Guile">9.3 A Virtual Machine for Guile</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Why-a-VM_003f-1" href="https://www.gnu.org/software/guile/manual/guile.html#Why-a-VM_003f">9.3.1 Why a VM?</a></li>
      <li><a id="toc-VM-Concepts-1" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Concepts">9.3.2 VM Concepts</a></li>
      <li><a id="toc-Stack-Layout-1" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Layout">9.3.3 Stack Layout</a></li>
      <li><a id="toc-Variables-and-the-VM-1" href="https://www.gnu.org/software/guile/manual/guile.html#Variables-and-the-VM">9.3.4 Variables and the VM</a></li>
      <li><a id="toc-Compiled-Procedures-are-VM-Programs" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Programs">9.3.5 Compiled Procedures are VM Programs</a></li>
      <li><a id="toc-Object-File-Format-1" href="https://www.gnu.org/software/guile/manual/guile.html#Object-File-Format">9.3.6 Object File Format</a></li>
      <li><a id="toc-Instruction-Set-1" href="https://www.gnu.org/software/guile/manual/guile.html#Instruction-Set">9.3.7 Instruction Set</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-Call-and-Return-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Call-and-Return-Instructions">9.3.7.1 Call and Return Instructions</a></li>
        <li><a id="toc-Function-Prologue-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Function-Prologue-Instructions">9.3.7.2 Function Prologue Instructions</a></li>
        <li><a id="toc-Shuffling-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Shuffling-Instructions">9.3.7.3 Shuffling Instructions</a></li>
        <li><a id="toc-Trampoline-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Trampoline-Instructions">9.3.7.4 Trampoline Instructions</a></li>
        <li><a id="toc-Non_002dLocal-Control-Flow-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dLocal-Control-Flow-Instructions">9.3.7.5 Non-Local Control Flow Instructions</a></li>
        <li><a id="toc-Instrumentation-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Instrumentation-Instructions">9.3.7.6 Instrumentation Instructions</a></li>
        <li><a id="toc-Intrinsic-Call-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Intrinsic-Call-Instructions">9.3.7.7 Intrinsic Call Instructions</a></li>
        <li><a id="toc-Constant-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Constant-Instructions">9.3.7.8 Constant Instructions</a></li>
        <li><a id="toc-Memory-Access-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Access-Instructions">9.3.7.9 Memory Access Instructions</a></li>
        <li><a id="toc-Atomic-Memory-Access-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Atomic-Memory-Access-Instructions">9.3.7.10 Atomic Memory Access Instructions</a></li>
        <li><a id="toc-Tagging-and-Untagging-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Tagging-and-Untagging-Instructions">9.3.7.11 Tagging and Untagging Instructions</a></li>
        <li><a id="toc-Integer-Arithmetic-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Integer-Arithmetic-Instructions">9.3.7.12 Integer Arithmetic Instructions</a></li>
        <li><a id="toc-Floating_002dPoint-Arithmetic-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Floating_002dPoint-Arithmetic-Instructions">9.3.7.13 Floating-Point Arithmetic Instructions</a></li>
        <li><a id="toc-Comparison-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Comparison-Instructions">9.3.7.14 Comparison Instructions</a></li>
        <li><a id="toc-Branch-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Branch-Instructions">9.3.7.15 Branch Instructions</a></li>
        <li><a id="toc-Raw-Memory-Access-Instructions-1" href="https://www.gnu.org/software/guile/manual/guile.html#Raw-Memory-Access-Instructions">9.3.7.16 Raw Memory Access Instructions</a></li>
      </ul></li>
      <li><a id="toc-Just_002dIn_002dTime-Native-Code-1" href="https://www.gnu.org/software/guile/manual/guile.html#Just_002dIn_002dTime-Native-Code">9.3.8 Just-In-Time Native Code</a></li>
    </ul></li>
    <li><a id="toc-Compiling-to-the-Virtual-Machine-1" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-to-the-Virtual-Machine">9.4 Compiling to the Virtual Machine</a>
    <ul class="toc-numbered-mark">
      <li><a id="toc-Compiler-Tower-1" href="https://www.gnu.org/software/guile/manual/guile.html#Compiler-Tower">9.4.1 Compiler Tower</a></li>
      <li><a id="toc-The-Scheme-Compiler-1" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-Compiler">9.4.2 The Scheme Compiler</a></li>
      <li><a id="toc-Tree_002dIL-1" href="https://www.gnu.org/software/guile/manual/guile.html#Tree_002dIL">9.4.3 Tree-IL</a></li>
      <li><a id="toc-Continuation_002dPassing-Style-1" href="https://www.gnu.org/software/guile/manual/guile.html#Continuation_002dPassing-Style">9.4.4 Continuation-Passing Style</a>
      <ul class="toc-numbered-mark">
        <li><a id="toc-An-Introduction-to-CPS-1" href="https://www.gnu.org/software/guile/manual/guile.html#An-Introduction-to-CPS">9.4.4.1 An Introduction to CPS</a></li>
        <li><a id="toc-CPS-in-Guile-1" href="https://www.gnu.org/software/guile/manual/guile.html#CPS-in-Guile">9.4.4.2 CPS in Guile</a></li>
        <li><a id="toc-Building-CPS-1" href="https://www.gnu.org/software/guile/manual/guile.html#Building-CPS">9.4.4.3 Building CPS</a></li>
        <li><a id="toc-CPS-Soup-1" href="https://www.gnu.org/software/guile/manual/guile.html#CPS-Soup">9.4.4.4 CPS Soup</a></li>
        <li><a id="toc-Compiling-CPS-1" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-CPS">9.4.4.5 Compiling CPS</a></li>
      </ul></li>
      <li><a id="toc-Bytecode-1" href="https://www.gnu.org/software/guile/manual/guile.html#Bytecode">9.4.5 Bytecode</a></li>
      <li><a id="toc-Writing-New-High_002dLevel-Languages-1" href="https://www.gnu.org/software/guile/manual/guile.html#Writing-New-High_002dLevel-Languages">9.4.6 Writing New High-Level Languages</a></li>
      <li><a id="toc-Extending-the-Compiler-1" href="https://www.gnu.org/software/guile/manual/guile.html#Extending-the-Compiler">9.4.7 Extending the Compiler</a></li>
    </ul></li>
  </ul></li>
  <li><a id="toc-GNU-Free-Documentation-License-1" href="https://www.gnu.org/software/guile/manual/guile.html#GNU-Free-Documentation-License">Appendix A GNU Free Documentation License</a></li>
  <li><a id="toc-Concept-Index-1" href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" rel="index">Concept Index</a></li>
  <li><a id="toc-Procedure-Index-1" href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Index" rel="index">Procedure Index</a></li>
  <li><a id="toc-Variable-Index-1" href="https://www.gnu.org/software/guile/manual/guile.html#Variable-Index" rel="index">Variable Index</a></li>
  <li><a id="toc-Type-Index-1" href="https://www.gnu.org/software/guile/manual/guile.html#Type-Index" rel="index">Type Index</a></li>
  <li><a id="toc-R5RS-Index-1" href="https://www.gnu.org/software/guile/manual/guile.html#R5RS-Index" rel="index">R5RS Index</a></li>
</ul>
</div>
</div>
<hr>
<div class="unnumbered-level-extent" id="Preface">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="n" rel="next">Introduction</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="unnumbered" id="Preface-1">Preface</h2>

<p>This manual describes how to use Guile, GNU’s Ubiquitous Intelligent
Language for Extensions.  It relates particularly to Guile version
3.0.9.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Contributors" accesskey="1">Contributors to this Manual</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-License" accesskey="2">The Guile License</a></li>
</ul>
<hr>
<div class="unnumberedsec-level-extent" id="Contributors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-License" accesskey="n" rel="next">The Guile License</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Preface" accesskey="u" rel="up">Preface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="unnumberedsec" id="Contributors-to-this-Manual">Contributors to this Manual</h3>

<p>Like Guile itself, the Guile reference manual is a living entity, cared
for by many people over a long period of time.  As such, it is hard to
identify individuals of whom to say “yes, this single person wrote the
manual.”
</p>
<p>Still, among the many contributions, some caretakers stand out.  First
among them is Neil Jerram, who has worked on this document for over ten
years.  Neil’s attention both to detail and to the big picture have made
a real difference in the understanding of a generation of Guile hackers.
</p>
<p>Next we should note Marius Vollmer’s effect on this document.  Marius
maintained Guile during a period in which Guile’s API was
clarified—put to the fire, so to speak—and he had the good sense to
effect the same change on the manual.
</p>
<p>Martin Grabmueller made substantial contributions throughout the manual
in preparation for the Guile 1.6 release, including filling out a lot of
the documentation of Scheme data types, control mechanisms and
procedures.  In addition, he wrote the documentation for Guile’s SRFI
modules and modules associated with the Guile REPL.
</p>
<p>Ludovic Courtès and Andy Wingo, who co-maintain Guile since 2010,
along with Mark Weaver, have also made their dent in the manual, writing
documentation for new modules and subsystems that arrived with Guile
2.0.  Ludovic, Andy, and Mark are also responsible for ensuring that the
existing text retains its relevance as Guile evolves.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Bugs">Reporting Bugs</a>, for more information on reporting problems in this manual.
</p>
<p>The content for the first versions of this manual incorporated and was
inspired by documents from Aubrey Jaffer, author of the SCM system on
which Guile was based, and from Tom Lord, Guile’s first maintainer.
Although most of this text has been rewritten, all of it was important,
and some of the structure remains.
</p>
<p>The manual for the first versions of Guile were largely written, edited,
and compiled by Mark Galassi and Jim Blandy.  In particular, Jim wrote
the original tutorial on Guile’s data representation and the C API for
accessing Guile objects.
</p>
<p>Significant portions were also contributed by Thien-Thi Nguyen, Kevin
Ryde, Mikael Djurfeldt, Christian Lynbech, Julian Graham, Gary Houston,
Tim Pierce, and a few dozen more.  You, reader, are most welcome to join
their esteemed ranks.  Visit Guile’s web site at
<a class="uref" href="http://www.gnu.org/software/guile/">http://www.gnu.org/software/guile/</a> to find out how to get
involved.
</p>

<hr>
</div>
<div class="unnumberedsec-level-extent" id="Guile-License">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Contributors" accesskey="p" rel="prev">Contributors to this Manual</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Preface" accesskey="u" rel="up">Preface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="unnumberedsec" id="The-Guile-License">The Guile License</h3>
<a class="index-entry-id" id="index-copying"></a>
<a class="index-entry-id" id="index-GPL"></a>
<a class="index-entry-id" id="index-LGPL"></a>
<a class="index-entry-id" id="index-license"></a>

<p>Guile is Free Software.  Guile is copyrighted, not public domain, and
there are restrictions on its distribution or redistribution, but
these restrictions are designed to permit everything a cooperating
person would want to do.
</p>
<ul class="itemize mark-bullet">
<li>The Guile library (libguile) and supporting files are published under
the terms of the GNU Lesser General Public License version 3 or later.
See the files <samp class="file">COPYING.LESSER</samp> and <samp class="file">COPYING</samp>.

</li><li>The Guile readline module is published under the terms of the GNU
General Public License version 3 or later.  See the file <samp class="file">COPYING</samp>.

</li><li>The manual you’re now reading is published under the terms of the GNU
Free Documentation License (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#GNU-Free-Documentation-License">GNU Free Documentation License</a>).
</li></ul>

<p>C code linking to the Guile library is subject to terms of that
library.  Basically such code may be published on any terms, provided
users can re-link against a new or modified version of Guile.
</p>
<p>C code linking to the Guile readline module is subject to the terms of
that module.  Basically such code must be published on Free terms.
</p>
<p>Scheme level code written to be run by Guile (but not derived from
Guile itself) is not restricted in any way, and may be published on any
terms.  We encourage authors to publish on Free terms.
</p>
<p>You must be aware there is no warranty whatsoever for Guile.  This is
described in full in the licenses.
</p>



<hr>
</div>
</div>
<div class="chapter-level-extent" id="Introduction">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="n" rel="next">Hello Guile!</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Preface" accesskey="p" rel="prev">Preface</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Introduction-1">1 Introduction</h2>

<p>Guile is an implementation of the Scheme programming language.  Scheme
(<a class="url" href="http://schemers.org/">http://schemers.org/</a>) is an elegant and conceptually simple
dialect of Lisp, originated by Guy Steele and Gerald Sussman, and since
evolved by the series of reports known as RnRS (the
Revised^n
Reports on Scheme).
</p>
<p>Unlike, for example, Python or Perl, Scheme has no benevolent
dictator.  There are many Scheme implementations, with different
characteristics and with communities and academic activities around
them, and the language develops as a result of the interplay between
these.  Guile’s particular characteristics are that
</p>
<ul class="itemize mark-bullet">
<li>it is easy to combine with other code written in C
</li><li>it has a historical and continuing connection with the GNU Project
</li><li>it emphasizes interactive and incremental programming
</li><li>it actually supports several languages, not just Scheme.
</li></ul>

<p>The next few sections explain what we mean by these points.  The sections after
that cover how you can obtain and install Guile, and the typographical
conventions that we use in this manual.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-Scheme" accesskey="1">Guile and Scheme</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Combining-with-C" accesskey="2">Combining with C Code</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-the-GNU-Project" accesskey="3">Guile and the GNU Project</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Programming" accesskey="4">Interactive Programming</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Supporting-Multiple-Languages" accesskey="5">Supporting Multiple Languages</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Obtaining-and-Installing-Guile" accesskey="6">Obtaining and Installing Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Organisation-of-this-Manual" accesskey="7">Organisation of this Manual</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Typographical-Conventions" accesskey="8">Typographical Conventions</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Guile-and-Scheme">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Combining-with-C" accesskey="n" rel="next">Combining with C Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Guile-and-Scheme-1">1.1 Guile and Scheme</h3>

<p>Guile implements Scheme as described in the
Revised^5
Report on the Algorithmic Language Scheme (usually known as
<abbr class="acronym">R5RS</abbr>), providing clean and general data and control
structures.  Guile goes beyond the rather austere language presented
in <abbr class="acronym">R5RS</abbr>, extending it with a module system, full access to
<abbr class="acronym">POSIX</abbr> system calls, networking support, multiple threads,
dynamic linking, a foreign function call interface, powerful string
processing, and many other features needed for programming in the real
world.
</p>
<p>In 2007, the Scheme community agreed upon and published R6RS, a
significant installment in the RnRS series.  R6RS expands the core
Scheme language, and standardises many non-core functions that
implementations—including Guile—have previously done in different
ways.  Over time, Guile has been updated to incorporate almost all of
the features of R6RS, and to adjust some existing features to conform to
the R6RS specification.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support">R6RS Support</a>, for full details.
</p>
<p>In parallel to official standardization efforts, the SRFI process
(<a class="url" href="http://srfi.schemers.org/">http://srfi.schemers.org/</a>) standardises interfaces for many
practical needs, such as multithreaded programming and multidimensional
arrays.  Guile supports many SRFIs, as documented in detail in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support">SRFI Support Modules</a>.
</p>
<p>The process that led to the R6RS standard brought a split in the Scheme
community to the surface.  The implementors that wrote R6RS considered
that it was impossible to write useful, portable programs in R5RS, and
that only an ambitious standard could solve this problem.  However, part
of the Scheme world saw the R6RS effort as too broad, and as having
included some components that would never be adopted by more
minimalistic Scheme implementations.  This second group succeeded in
taking control of the official Scheme standardization track and in 2013
released a more limited R7RS, essentially consisting of R5RS, plus a
module system.  Guile supports R7RS also.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">R7RS Support</a>.
</p>
<p>With R6RS and R7RS, the unified Scheme standardization process appears
to have more or less run its course.  There will continue to be more
code written in terms of both systems, and modules defined using the
SRFI process, and Guile will support both.  However for future
directions, Guile takes inspiration from other related language
communities: Racket, Clojure, Concurrent ML, and so on.
</p>
<p>In summary, Guile supports writing and running code written to the R5RS,
R6RS, and R7RS Scheme standards, and also supports a number of SRFI
modules.  However for most users, until a need for cross-implementation
portability has been identified, we recommend using the parts of Guile
that are useful in solving the problem at hand, regardless of whether
they proceed from a standard or whether they are Guile-specific.
</p>

<hr>
</div>
<div class="section-level-extent" id="Combining-with-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-the-GNU-Project" accesskey="n" rel="next">Guile and the GNU Project</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-Scheme" accesskey="p" rel="prev">Guile and Scheme</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Combining-with-C-Code">1.2 Combining with C Code</h3>

<p>Like a shell, Guile can run interactively—reading expressions from the user,
evaluating them, and displaying the results—or as a script interpreter,
reading and executing Scheme code from a file.  Guile also provides an object
library, <em class="dfn">libguile</em>, that allows other applications to easily incorporate a
complete Scheme interpreter.  An application can then use Guile as an extension
language, a clean and powerful configuration language, or as multi-purpose
“glue”, connecting primitives provided by the application.  It is easy to call
Scheme code from C code and vice versa, giving the application designer full
control of how and when to invoke the interpreter.  Applications can add new
functions, data types, control structures, and even syntax to Guile, creating a
domain-specific language tailored to the task at hand, but based on a robust
language design.
</p>
<p>This kind of combination is helped by four aspects of Guile’s design
and history.  First is that Guile has always been targeted as an
extension language.  Hence its C API has always been of great
importance, and has been developed accordingly.  Second and third are
rather technical points—that Guile uses conservative garbage
collection, and that it implements the Scheme concept of continuations
by copying and reinstating the C stack—but whose practical
consequence is that most existing C code can be glued into Guile as
is, without needing modifications to cope with strange Scheme
execution flows.  Last is the module system, which helps extensions to
coexist without stepping on each others’ toes.
</p>
<p>Guile’s module system allows one to break up a large program into
manageable sections with well-defined interfaces between them.
Modules may contain a mixture of interpreted and compiled code; Guile
can use either static or dynamic linking to incorporate compiled code.
Modules also encourage developers to package up useful collections of
routines for general distribution; as of this writing, one can find
Emacs interfaces, database access routines, compilers, <abbr class="acronym">GUI</abbr>
toolkit interfaces, and <abbr class="acronym">HTTP</abbr> client functions, among others.
</p>
<hr>
</div>
<div class="section-level-extent" id="Guile-and-the-GNU-Project">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Programming" accesskey="n" rel="next">Interactive Programming</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Combining-with-C" accesskey="p" rel="prev">Combining with C Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Guile-and-the-GNU-Project-1">1.3 Guile and the GNU Project</h3>

<p>Guile was conceived by the GNU Project following the fantastic success
of Emacs Lisp as an extension language within Emacs.  Just as Emacs
Lisp allowed complete and unanticipated applications to be written
within the Emacs environment, the idea was that Guile should do the
same for other GNU Project applications.  This remains true today.
</p>
<p>The idea of extensibility is closely related to the GNU project’s
primary goal, that of promoting software freedom.  Software freedom
means that people receiving a software package can modify or enhance
it to their own desires, including in ways that may not have occurred
at all to the software’s original developers.  For programs written in
a compiled language like C, this freedom covers modifying and
rebuilding the C code; but if the program also provides an extension
language, that is usually a much friendlier and lower-barrier-of-entry
way for the user to start making their own changes.
</p>
<p>Guile is now used by GNU project applications such as AutoGen, Lilypond, Denemo,
Mailutils, TeXmacs and Gnucash, and we hope that there will be many more in
future.
</p>
<hr>
</div>
<div class="section-level-extent" id="Interactive-Programming">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Supporting-Multiple-Languages" accesskey="n" rel="next">Supporting Multiple Languages</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-and-the-GNU-Project" accesskey="p" rel="prev">Guile and the GNU Project</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Interactive-Programming-1">1.4 Interactive Programming</h3>

<p>Non-free software has no interest in its users being able to see how it works.
They are supposed to just accept it, or to report problems and hope that the
source code owners will choose to work on them.
</p>
<p>Free software aims to work reliably just as much as non-free software does, but
it should also empower its users by making its workings available.  This is
useful for many reasons, including education, auditing and enhancements, as well
as for debugging problems.
</p>
<p>The ideal free software system achieves this by making it easy for interested
users to see the source code for a feature that they are using, and to follow
through that source code step-by-step, as it runs.  In Emacs, good examples of
this are the source code hyperlinks in the help system, and <code class="code">edebug</code>.
Then, for bonus points and maximising the ability for the user to experiment
quickly with code changes, the system should allow parts of the source code to
be modified and reloaded into the running program, to take immediate effect.
</p>
<p>Guile is designed for this kind of interactive programming, and this
distinguishes it from many Scheme implementations that instead prioritise
running a fixed Scheme program as fast as possible—because there are
tradeoffs between performance and the ability to modify parts of an already
running program.  There are faster Schemes than Guile, but Guile is a GNU
project and so prioritises the GNU vision of programming freedom and
experimentation.
</p>
<hr>
</div>
<div class="section-level-extent" id="Supporting-Multiple-Languages">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Obtaining-and-Installing-Guile" accesskey="n" rel="next">Obtaining and Installing Guile</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Programming" accesskey="p" rel="prev">Interactive Programming</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Supporting-Multiple-Languages-1">1.5 Supporting Multiple Languages</h3>

<p>Since the 2.0 release, Guile’s architecture supports compiling any language to
its core virtual machine bytecode, and Scheme is just one of the supported
languages.  Other supported languages are Emacs Lisp, ECMAScript (commonly known
as Javascript) and Brainfuck, and work is under discussion for Lua, Ruby and
Python.
</p>
<p>This means that users can program applications which use Guile in the language
of their choice, rather than having the tastes of the application’s author
imposed on them.
</p>
<hr>
</div>
<div class="section-level-extent" id="Obtaining-and-Installing-Guile">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Organisation-of-this-Manual" accesskey="n" rel="next">Organisation of this Manual</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Supporting-Multiple-Languages" accesskey="p" rel="prev">Supporting Multiple Languages</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Obtaining-and-Installing-Guile-1">1.6 Obtaining and Installing Guile</h3>

<p>Guile can be obtained from the main GNU archive site
<a class="url" href="ftp://ftp.gnu.org/">ftp://ftp.gnu.org</a> or any of its mirrors.  The file will be named
guile-<var class="var">version</var>.tar.gz.  The current version is 3.0.9, so the
file you should grab is:
</p>
<p><a class="url" href="ftp://ftp.gnu.org/gnu/guile/guile-3.0.9.tar.gz">ftp://ftp.gnu.org/gnu/guile/guile-3.0.9.tar.gz</a>
</p>
<p>To unbundle Guile use the instruction
</p>
<div class="example">
<pre class="example-preformatted">zcat guile-3.0.9.tar.gz | tar xvf -
</pre></div>

<p>which will create a directory called <samp class="file">guile-3.0.9</samp> with
all the sources.  You can look at the file <samp class="file">INSTALL</samp> for detailed
instructions on how to build and install Guile, but you should be able
to just do
</p>
<div class="example">
<pre class="example-preformatted">cd guile-3.0.9
./configure
make
make install
</pre></div>

<p>This will install the Guile executable <samp class="file">guile</samp>, the Guile library
<samp class="file">libguile</samp> and various associated header files and support libraries. It
will also install the Guile reference manual.
</p>

<p>Since this manual frequently refers to the Scheme “standard”, also
known as R5RS, or the
“Revised^5 Report on the Algorithmic Language Scheme”,
we have included the report in the Guile distribution; see
<a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Top">Introduction</a> in <cite class="cite">Revised(5) Report on the Algorithmic
Language Scheme</cite>.
This will also be installed in your info directory.
</p>
<hr>
</div>
<div class="section-level-extent" id="Organisation-of-this-Manual">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Typographical-Conventions" accesskey="n" rel="next">Typographical Conventions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Obtaining-and-Installing-Guile" accesskey="p" rel="prev">Obtaining and Installing Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Organisation-of-this-Manual-1">1.7 Organisation of this Manual</h3>

<p>The rest of this manual is organised into the following chapters.
</p>
<dl class="table">
<dt><strong class="strong">Chapter 2: Hello Guile!</strong></dt>
<dd><p>A whirlwind tour shows how Guile can be used interactively and as
a script interpreter, how to link Guile into your own applications,
and how to write modules of interpreted and compiled code for use with
Guile.  Everything introduced here is documented again and in full by
the later parts of the manual.
</p>
</dd>
<dt><strong class="strong">Chapter 3: Hello Scheme!</strong></dt>
<dd><p>For readers new to Scheme, this chapter provides an introduction to the basic
ideas of the Scheme language.  This material would apply to any Scheme
implementation and so does not make reference to anything Guile-specific.
</p>
</dd>
<dt><strong class="strong">Chapter 4: Programming in Scheme</strong></dt>
<dd><p>Provides an overview of programming in Scheme with Guile.  It covers how to
invoke the <code class="code">guile</code> program from the command-line and how to write scripts
in Scheme.  It also introduces the extensions that Guile offers beyond standard
Scheme.
</p>
</dd>
<dt><strong class="strong">Chapter 5: Programming in C</strong></dt>
<dd><p>Provides an overview of how to use Guile in a C program.  It
discusses the fundamental concepts that you need to understand to
access the features of Guile, such as dynamic types and the garbage
collector.  It explains in a tutorial like manner how to define new
data types and functions for the use by Scheme programs.
</p>
</dd>
<dt><strong class="strong">Chapter 6: Guile API Reference</strong></dt>
<dd><p>This part of the manual documents the Guile <abbr class="acronym">API</abbr> in
functionality-based groups with the Scheme and C interfaces presented
side by side.
</p>
</dd>
<dt><strong class="strong">Chapter 7: Guile Modules</strong></dt>
<dd><p>Describes some important modules, distributed as part of the Guile
distribution, that extend the functionality provided by the Guile
Scheme core.
</p>
</dd>
<dt><strong class="strong">Chapter 8: GOOPS</strong></dt>
<dd><p>Describes GOOPS, an object oriented extension to Guile that provides
classes, multiple inheritance and generic functions.
</p>
</dd>
</dl>

<hr>
</div>
<div class="section-level-extent" id="Typographical-Conventions">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Organisation-of-this-Manual" accesskey="p" rel="prev">Organisation of this Manual</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="u" rel="up">Introduction</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Typographical-Conventions-1">1.8 Typographical Conventions</h3>

<p>In examples and procedure descriptions and all other places where the
evaluation of Scheme expression is shown, we use some notation for
denoting the output and evaluation results of expressions.
</p>
<p>The symbol ‘<samp class="samp">⇒</samp>’ is used to tell which value is returned by
an evaluation:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(+ 1 2)
⇒ 3
</pre></div>

<p>Some procedures produce some output besides returning a value.  This
is denoted by the symbol ‘<samp class="samp">-|</samp>’.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(begin (display 1) (newline) 'hooray)
-| 1
⇒ hooray
</pre></div>

<p>As you can see, this code prints ‘<samp class="samp">1</samp>’ (denoted by
‘<samp class="samp">-|</samp>’), and returns <code class="code">hooray</code> (denoted by
‘<samp class="samp">⇒</samp>’).
</p>




<hr>
</div>
</div>
<div class="chapter-level-extent" id="Hello-Guile_0021">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="n" rel="next">Hello Scheme!</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Introduction" accesskey="p" rel="prev">Introduction</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter section-level-set-chapter" id="Hello-Guile_0021-1">2 Hello Guile!</h2>

<p>This chapter presents a quick tour of all the ways that Guile can be
used.  There are additional examples in the <samp class="file">examples/</samp>
directory in the Guile source distribution.  It also explains how best to report
any problems that you find.
</p>
<p>The following examples assume that Guile has been installed in
<code class="code">/usr/local/</code>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Interactively" accesskey="1">Running Guile Interactively</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Scripts" accesskey="2">Running Guile Scripts</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-into-Programs" accesskey="3">Linking Guile into Programs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-Guile-Extensions" accesskey="4">Writing Guile Extensions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="5">Using the Guile Module System</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Bugs" accesskey="6">Reporting Bugs</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Running-Guile-Interactively">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Scripts" accesskey="n" rel="next">Running Guile Scripts</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section subsection-level-set-section" id="Running-Guile-Interactively-1">2.1 Running Guile Interactively</h3>

<p>In its simplest form, Guile acts as an interactive interpreter for the
Scheme programming language, reading and evaluating Scheme expressions
the user enters from the terminal.  Here is a sample interaction between
Guile and a user; the user’s input appears after the <code class="code">$</code> and
<code class="code">scheme@(guile-user)&gt;</code> prompts:
</p>
<div class="example">
<pre class="example-preformatted">$ guile
scheme@(guile-user)&gt; (+ 1 2 3)                ; add some numbers
$1 = 6
scheme@(guile-user)&gt; (define (factorial n)    ; define a function
                       (if (zero? n) 1 (* n (factorial (- n 1)))))
scheme@(guile-user)&gt; (factorial 20)
$2 = 2432902008176640000
scheme@(guile-user)&gt; (getpwnam "root")        ; look in /etc/passwd
$3 = #("root" "x" 0 0 "root" "/root" "/bin/bash")
scheme@(guile-user)&gt; <kbd class="kbd">C-d</kbd>
$
</pre></div>


<hr>
</div>
<div class="section-level-extent" id="Running-Guile-Scripts">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-into-Programs" accesskey="n" rel="next">Linking Guile into Programs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Interactively" accesskey="p" rel="prev">Running Guile Interactively</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section subsection-level-set-section" id="Running-Guile-Scripts-1">2.2 Running Guile Scripts</h3>

<p>Like AWK, Perl, or any shell, Guile can interpret script files.  A Guile
script is simply a file of Scheme code with some extra information at
the beginning which tells the operating system how to invoke Guile, and
then tells Guile how to handle the Scheme code.
</p>
<p>Here is a trivial Guile script.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting">Guile Scripting</a>, for more details.
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile -s
!#
(display "Hello, world!")
(newline)
</pre></div>


<hr>
</div>
<div class="section-level-extent" id="Linking-Guile-into-Programs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-Guile-Extensions" accesskey="n" rel="next">Writing Guile Extensions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Running-Guile-Scripts" accesskey="p" rel="prev">Running Guile Scripts</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section subsection-level-set-section" id="Linking-Guile-into-Programs-1">2.3 Linking Guile into Programs</h3>

<p>The Guile interpreter is available as an object library, to be linked
into applications using Scheme as a configuration or extension
language.
</p>
<p>Here is <samp class="file">simple-guile.c</samp>, source code for a program that will
produce a complete Guile interpreter.  In addition to all usual
functions provided by Guile, it will also offer the function
<code class="code">my-hostname</code>.
</p>
<div class="example">
<pre class="example-preformatted">#include &lt;stdlib.h&gt;
#include &lt;libguile.h&gt;

static SCM
my_hostname (void)
{
  char *s = getenv ("HOSTNAME");
  if (s == NULL)
    return SCM_BOOL_F;
  else
    return scm_from_locale_string (s);
}

static void
inner_main (void *data, int argc, char **argv)
{
  scm_c_define_gsubr ("my-hostname", 0, 0, 0, my_hostname);
  scm_shell (argc, argv);
}

int
main (int argc, char **argv)
{
  scm_boot_guile (argc, argv, inner_main, 0);
  return 0; /* never reached */
}
</pre></div>

<p>When Guile is correctly installed on your system, the above program
can be compiled and linked like this:
</p>
<div class="example">
<pre class="example-preformatted">$ gcc -o simple-guile simple-guile.c \
    `pkg-config --cflags --libs guile-3.0`
</pre></div>

<p>When it is run, it behaves just like the <code class="code">guile</code> program except
that you can also call the new <code class="code">my-hostname</code> function.
</p>
<div class="example">
<pre class="example-preformatted">$ ./simple-guile
scheme@(guile-user)&gt; (+ 1 2 3)
$1 = 6
scheme@(guile-user)&gt; (my-hostname)
"burns"
</pre></div>

<hr>
</div>
<div class="section-level-extent" id="Writing-Guile-Extensions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="n" rel="next">Using the Guile Module System</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-into-Programs" accesskey="p" rel="prev">Linking Guile into Programs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section subsection-level-set-section" id="Writing-Guile-Extensions-1">2.4 Writing Guile Extensions</h3>

<p>You can link Guile into your program and make Scheme available to the
users of your program.  You can also link your library into Guile and
make its functionality available to all users of Guile.
</p>
<p>A library that is linked into Guile is called an <em class="dfn">extension</em>, but it
really just is an ordinary object library.
</p>
<p>The following example shows how to write a simple extension for Guile
that makes the <code class="code">j0</code> function available to Scheme code.
</p>
<div class="example smallexample">
<pre class="example-preformatted">#include &lt;math.h&gt;
#include &lt;libguile.h&gt;

SCM
j0_wrapper (SCM x)
{
  return scm_from_double (j0 (scm_to_double (x)));
}

void
init_bessel ()
{
  scm_c_define_gsubr ("j0", 1, 0, 0, j0_wrapper);
}
</pre></div>

<p>This C source file needs to be compiled into a shared library.  Here is
how to do it on GNU/Linux:
</p>
<div class="example smallexample">
<pre class="example-preformatted">gcc `pkg-config --cflags guile-3.0` \
  -shared -o libguile-bessel.so -fPIC bessel.c
</pre></div>

<p>For creating shared libraries portably, we recommend the use of GNU
Libtool (see <a data-manual="libtool" href="http://www.gnu.org/software/libtool/manual/libtool.html#Top">Introduction</a> in <cite class="cite">GNU Libtool</cite>).
</p>
<p>A shared library can be loaded into a running Guile process with the
function <code class="code">load-extension</code>.  The <code class="code">j0</code> is then immediately
available:
</p>
<div class="example smallexample">
<pre class="example-preformatted">$ guile
scheme@(guile-user)&gt; (load-extension "./libguile-bessel" "init_bessel")
scheme@(guile-user)&gt; (j0 2)
$1 = 0.223890779141236
</pre></div>

<p>For more on how to install your extension, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">Installing Site Packages</a>.
</p>

<hr>
</div>
<div class="section-level-extent" id="Using-the-Guile-Module-System">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Bugs" accesskey="n" rel="next">Reporting Bugs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-Guile-Extensions" accesskey="p" rel="prev">Writing Guile Extensions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section subsection-level-set-section" id="Using-the-Guile-Module-System-1">2.5 Using the Guile Module System</h3>

<p>Guile has support for dividing a program into <em class="dfn">modules</em>.  By using
modules, you can group related code together and manage the
composition of complete programs from largely independent parts.
</p>
<p>For more details on the module system beyond this introductory material,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Modules">Modules</a>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Modules" accesskey="1">Using Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-new-Modules" accesskey="2">Writing new Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Putting-Extensions-into-Modules" accesskey="3">Putting Extensions into Modules</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Using-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-new-Modules" accesskey="n" rel="next">Writing new Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="u" rel="up">Using the Guile Module System</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection subsubsection-level-set-subsection" id="Using-Modules-1">2.5.1 Using Modules</h4>

<p>Guile comes with a lot of useful modules, for example for string
processing or command line parsing.  Additionally, there exist many
Guile modules written by other Guile hackers, but which have to be
installed manually.
</p>
<p>Here is a sample interactive session that shows how to use the
<code class="code">(ice-9 popen)</code> module which provides the means for communicating
with other processes over pipes together with the <code class="code">(ice-9
rdelim)</code> module that provides the function <code class="code">read-line</code>.
</p>
<div class="example smallexample">
<pre class="example-preformatted">$ guile
scheme@(guile-user)&gt; (use-modules (ice-9 popen))
scheme@(guile-user)&gt; (use-modules (ice-9 rdelim))
scheme@(guile-user)&gt; (define p (open-input-pipe "ls -l"))
scheme@(guile-user)&gt; (read-line p)
$1 = "total 30"
scheme@(guile-user)&gt; (read-line p)
$2 = "drwxr-sr-x    2 mgrabmue mgrabmue     1024 Mar 29 19:57 CVS"
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="Writing-new-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Putting-Extensions-into-Modules" accesskey="n" rel="next">Putting Extensions into Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Modules" accesskey="p" rel="prev">Using Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="u" rel="up">Using the Guile Module System</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection subsubsection-level-set-subsection" id="Writing-new-Modules-1">2.5.2 Writing new Modules</h4>

<p>You can create new modules using the syntactic form
<code class="code">define-module</code>.  All definitions following this form until the
next <code class="code">define-module</code> are placed into the new module.
</p>
<p>One module is usually placed into one file, and that file is installed
in a location where Guile can automatically find it.  The following
session shows a simple example.
</p>
<div class="example smallexample">
<pre class="example-preformatted">$ cat /usr/local/share/guile/site/foo/bar.scm

(define-module (foo bar)
  #:export (frob))

(define (frob x) (* 2 x))

$ guile
scheme@(guile-user)&gt; (use-modules (foo bar))
scheme@(guile-user)&gt; (frob 12)
$1 = 24
</pre></div>

<p>For more on how to install your module, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">Installing Site Packages</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Putting-Extensions-into-Modules">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Writing-new-Modules" accesskey="p" rel="prev">Writing new Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="u" rel="up">Using the Guile Module System</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection subsubsection-level-set-subsection" id="Putting-Extensions-into-Modules-1">2.5.3 Putting Extensions into Modules</h4>

<p>In addition to Scheme code you can also put things that are defined in
C into a module.
</p>
<p>You do this by writing a small Scheme file that defines the module and
call <code class="code">load-extension</code> directly in the body of the module.
</p>
<div class="example smallexample">
<pre class="example-preformatted">$ cat /usr/local/share/guile/site/math/bessel.scm

(define-module (math bessel)
  #:export (j0))

(load-extension "libguile-bessel" "init_bessel")

$ file /usr/local/lib/guile/3.0/extensions/libguile-bessel.so
… ELF 32-bit LSB shared object …
$ guile
scheme@(guile-user)&gt; (use-modules (math bessel))
scheme@(guile-user)&gt; (j0 2)
$1 = 0.223890779141236
</pre></div>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions">Foreign Extensions</a>, for more information.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="Reporting-Bugs">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-the-Guile-Module-System" accesskey="p" rel="prev">Using the Guile Module System</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="u" rel="up">Hello Guile!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Reporting-Bugs-1">2.6 Reporting Bugs</h3>

<p>Any problems with the installation should be reported to
<a class="email" href="mailto:bug-guile@gnu.org">bug-guile@gnu.org</a>.
</p>
<p>If you find a bug in Guile, please report it to the Guile developers, so
they can fix it.  They may also be able to suggest workarounds when it
is not possible for you to apply the bug-fix or install a new version of
Guile yourself.
</p>
<p>Before sending in bug reports, please check with the following list that
you really have found a bug.
</p>
<ul class="itemize mark-bullet">
<li>Whenever documentation and actual behavior differ, you have certainly
found a bug, either in the documentation or in the program.

</li><li>When Guile crashes, it is a bug.

</li><li>When Guile hangs or takes forever to complete a task, it is a bug.

</li><li>When calculations produce wrong results, it is a bug.

</li><li>When Guile signals an error for valid Scheme programs, it is a bug.

</li><li>When Guile does not signal an error for invalid Scheme programs, it may
be a bug, unless this is explicitly documented.

</li><li>When some part of the documentation is not clear and does not make sense
to you even after re-reading the section, it is a bug.
</li></ul>

<p>Before reporting the bug, check whether any programs you have loaded
into Guile, including your <samp class="file">.guile</samp> file, set any variables that
may affect the functioning of Guile.  Also, see whether the problem
happens in a freshly started Guile without loading your <samp class="file">.guile</samp>
file (start Guile with the <code class="code">-q</code> switch to prevent loading the init
file).  If the problem does <em class="emph">not</em> occur then, you must report the
precise contents of any programs that you must load into Guile in order
to cause the problem to occur.
</p>
<p>When you write a bug report, please make sure to include as much of the
information described below in the report.  If you can’t figure out some
of the items, it is not a problem, but the more information we get, the
more likely we can diagnose and fix the bug.
</p>
<ul class="itemize mark-bullet">
<li>The version number of Guile. You can get this information from invoking
‘<samp class="samp">guile --version</samp>’ at your shell, or calling <code class="code">(version)</code> from
within Guile.

</li><li>Your machine type, as determined by the <code class="code">config.guess</code> shell
script. If you have a Guile checkout, this file is located in
<code class="code">build-aux</code>; otherwise you can fetch the latest version from
<a class="uref" href="http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD">http://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess;hb=HEAD</a>.

<div class="example">
<pre class="example-preformatted">$ build-aux/config.guess
x86_64-unknown-linux-gnu
</pre></div>

</li><li>If you installed Guile from a binary package, the version of that
package. On systems that use RPM, use <code class="code">rpm -qa | grep guile</code>. On systems
that use DPKG, <code class="code">dpkg -l | grep guile</code>. 

</li><li>If you built Guile yourself, the build configuration that you used:

<div class="example">
<pre class="example-preformatted">$ ./config.status --config
'--enable-error-on-warning' '--disable-deprecated'...
</pre></div>

</li><li>A complete description of how to reproduce the bug.

<p>If you have a Scheme program that produces the bug, please include it in
the bug report. If your program is too big to include, please try to
reduce your code to a minimal test case.
</p>
<p>If you can reproduce your problem at the REPL, that is best. Give a
transcript of the expressions you typed at the REPL.
</p>
</li><li>A description of the incorrect behavior.  For example, "The Guile
process gets a fatal signal," or, "The resulting output is as follows,
which I think is wrong."

<p>If the manifestation of the bug is a Guile error message, it is
important to report the precise text of the error message, and a
backtrace showing how the Scheme program arrived at the error. This can
be done using the <code class="code">,backtrace</code> command in Guile’s debugger.
</p></li></ul>

<p>If your bug causes Guile to crash, additional information from a
low-level debugger such as GDB might be helpful. If you have built Guile
yourself, you can run Guile under GDB via the
<code class="code">meta/gdb-uninstalled-guile</code> script. Instead of invoking Guile as
usual, invoke the wrapper script, type <code class="code">run</code> to start the process,
then <code class="code">backtrace</code> when the crash comes. Include that backtrace in
your report.
</p>




<hr>
</div>
</div>
<div class="chapter-level-extent" id="Hello-Scheme_0021">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="n" rel="next">Programming in Scheme</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Guile_0021" accesskey="p" rel="prev">Hello Guile!</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Hello-Scheme_0021-1">3 Hello Scheme!</h2>

<p>In this chapter, we introduce the basic concepts that underpin the
elegance and power of the Scheme language.
</p>
<p>Readers who already possess a background knowledge of Scheme may happily
skip this chapter.  For the reader who is new to the language, however,
the following discussions on data, procedures, expressions and closure
are designed to provide a minimum level of Scheme understanding that is
more or less assumed by the chapters that follow.
</p>
<p>The style of this introductory material aims about halfway between the terse
precision of R5RS and the discursiveness of existing Scheme tutorials.  For
pointers to useful Scheme resources on the web, please see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Further-Reading">Further Reading</a>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-Data" accesskey="1">Data Types, Values and Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="2">The Representation and Use of Procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="3">Expressions and Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="4">The Concept of Closure</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Further-Reading" accesskey="5">Further Reading</a></li>
</ul>
<hr>
<div class="section-level-extent" id="About-Data">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="n" rel="next">The Representation and Use of Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="u" rel="up">Hello Scheme!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Data-Types_002c-Values-and-Variables">3.1 Data Types, Values and Variables</h3>

<p>This section discusses the representation of data types and values, what
it means for Scheme to be a <em class="dfn">latently typed</em> language, and the role
of variables.  We conclude by introducing the Scheme syntaxes for
defining a new variable, and for changing the value of an existing
variable.
</p> 


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Latent-Typing" accesskey="1">Latent Typing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Values-and-Variables" accesskey="2">Values and Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Definition" accesskey="3">Defining and Setting Variables</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Latent-Typing">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Values-and-Variables" accesskey="n" rel="next">Values and Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Data" accesskey="u" rel="up">Data Types, Values and Variables</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Latent-Typing-1">3.1.1 Latent Typing</h4>

<p>The term <em class="dfn">latent typing</em> is used to describe a computer language,
such as Scheme, for which you cannot, <em class="emph">in general</em>, simply look at
a program’s source code and determine what type of data will be
associated with a particular variable, or with the result of a
particular expression.
</p>
<p>Sometimes, of course, you <em class="emph">can</em> tell from the code what the type of
an expression will be.  If you have a line in your program that sets the
variable <code class="code">x</code> to the numeric value 1, you can be certain that,
immediately after that line has executed (and in the absence of multiple
threads), <code class="code">x</code> has the numeric value 1.  Or if you write a procedure
that is designed to concatenate two strings, it is likely that the rest
of your application will always invoke this procedure with two string
parameters, and quite probable that the procedure would go wrong in some
way if it was ever invoked with parameters that were not both strings.
</p>
<p>Nevertheless, the point is that there is nothing in Scheme which
requires the procedure parameters always to be strings, or <code class="code">x</code>
always to hold a numeric value, and there is no way of declaring in your
program that such constraints should always be obeyed.  In the same
vein, there is no way to declare the expected type of a procedure’s
return value.
</p>
<p>Instead, the types of variables and expressions are only known – in
general – at run time.  If you <em class="emph">need</em> to check at some point that
a value has the expected type, Scheme provides run time procedures that
you can invoke to do so.  But equally, it can be perfectly valid for two
separate invocations of the same procedure to specify arguments with
different types, and to return values with different types.
</p>
<p>The next subsection explains what this means in practice, for the ways
that Scheme programs use data types, values and variables.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Values-and-Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Definition" accesskey="n" rel="next">Defining and Setting Variables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Latent-Typing" accesskey="p" rel="prev">Latent Typing</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Data" accesskey="u" rel="up">Data Types, Values and Variables</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Values-and-Variables-1">3.1.2 Values and Variables</h4>

<p>Scheme provides many data types that you can use to represent your data.
Primitive types include characters, strings, numbers and procedures.
Compound types, which allow a group of primitive and compound values to
be stored together, include lists, pairs, vectors and multi-dimensional
arrays.  In addition, Guile allows applications to define their own data
types, with the same status as the built-in standard Scheme types.
</p>
<p>As a Scheme program runs, values of all types pop in and out of
existence.  Sometimes values are stored in variables, but more commonly
they pass seamlessly from being the result of one computation to being
one of the parameters for the next.
</p>
<p>Consider an example.  A string value is created because the interpreter
reads in a literal string from your program’s source code.  Then a
numeric value is created as the result of calculating the length of the
string.  A second numeric value is created by doubling the calculated
length.  Finally the program creates a list with two elements – the
doubled length and the original string itself – and stores this list in
a program variable.
</p>
<p>All of the values involved here – in fact, all values in Scheme –
carry their type with them.  In other words, every value “knows,” at
runtime, what kind of value it is.  A number, a string, a list,
whatever.
</p>
<p>A variable, on the other hand, has no fixed type.  A variable –
<code class="code">x</code>, say – is simply the name of a location – a box – in which
you can store any kind of Scheme value.  So the same variable in a
program may hold a number at one moment, a list of procedures the next,
and later a pair of strings.  The “type” of a variable – insofar as
the idea is meaningful at all – is simply the type of whatever value
the variable happens to be storing at a particular moment.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Definition">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Values-and-Variables" accesskey="p" rel="prev">Values and Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Data" accesskey="u" rel="up">Data Types, Values and Variables</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Defining-and-Setting-Variables">3.1.3 Defining and Setting Variables</h4>

<p>To define a new variable, you use Scheme’s <code class="code">define</code> syntax like
this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define <var class="var">variable-name</var> <var class="var">value</var>)
</pre></div>

<p>This makes a new variable called <var class="var">variable-name</var> and stores
<var class="var">value</var> in it as the variable’s initial value.  For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">;; Make a variable `x' with initial numeric value 1.
(define x 1)

;; Make a variable `organization' with an initial string value.
(define organization "Free Software Foundation")
</pre></div>

<p>(In Scheme, a semicolon marks the beginning of a comment that continues
until the end of the line.  So the lines beginning <code class="code">;;</code> are
comments.)
</p>
<p>Changing the value of an already existing variable is very similar,
except that <code class="code">define</code> is replaced by the Scheme syntax <code class="code">set!</code>,
like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! <var class="var">variable-name</var> <var class="var">new-value</var>)
</pre></div>

<p>Remember that variables do not have fixed types, so <var class="var">new-value</var> may
have a completely different type from whatever was previously stored in
the location named by <var class="var">variable-name</var>.  Both of the following
examples are therefore correct.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">;; Change the value of `x' to 5.
(set! x 5)

;; Change the value of `organization' to the FSF's street number.
(set! organization 545)
</pre></div>

<p>In these examples, <var class="var">value</var> and <var class="var">new-value</var> are literal numeric
or string values.  In general, however, <var class="var">value</var> and <var class="var">new-value</var>
can be any Scheme expression.  Even though we have not yet covered the
forms that Scheme expressions can take (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions">Expressions and Evaluation</a>), you
can probably guess what the following <code class="code">set!</code> example does…
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! x (+ x 1))
</pre></div>

<p>(Note: this is not a complete description of <code class="code">define</code> and
<code class="code">set!</code>, because we need to introduce some other aspects of Scheme
before the missing pieces can be filled in.  If, however, you are
already familiar with the structure of Scheme, you may like to read
about those missing pieces immediately by jumping ahead to the following
references.
</p>
<ul class="itemize mark-bullet">
<li><a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda-Alternatives">Lambda Alternatives</a>, to read about an alternative form of the
<code class="code">define</code> syntax that can be used when defining new procedures.

</li><li><a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</a>, to read about an alternative form of the
<code class="code">set!</code> syntax that helps with changing a single value in the depths
of a compound data structure.)

</li><li>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">Internal definitions</a>, to read about using <code class="code">define</code> other
than at top level in a Scheme program, including a discussion of when it
works to use <code class="code">define</code> rather than <code class="code">set!</code> to change the value
of an existing variable.
</li></ul>


<hr>
</div>
</div>
<div class="section-level-extent" id="About-Procedures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="n" rel="next">Expressions and Evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Data" accesskey="p" rel="prev">Data Types, Values and Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="u" rel="up">Hello Scheme!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-Representation-and-Use-of-Procedures">3.2 The Representation and Use of Procedures</h3>

<p>This section introduces the basics of using and creating Scheme
procedures.  It discusses the representation of procedures as just
another kind of Scheme value, and shows how procedure invocation
expressions are constructed.  We then explain how <code class="code">lambda</code> is used
to create new procedures, and conclude by presenting the various
shorthand forms of <code class="code">define</code> that can be used instead of writing an
explicit <code class="code">lambda</code> expression.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-as-Values" accesskey="1">Procedures as Values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Invocation" accesskey="2">Simple Procedure Invocation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-a-Procedure" accesskey="3">Creating and Using a New Procedure</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Lambda-Alternatives" accesskey="4">Lambda Alternatives</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Procedures-as-Values">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Invocation" accesskey="n" rel="next">Simple Procedure Invocation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="u" rel="up">The Representation and Use of Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Procedures-as-Values-1">3.2.1 Procedures as Values</h4>

<p>One of the great simplifications of Scheme is that a procedure is just
another type of value, and that procedure values can be passed around
and stored in variables in exactly the same way as, for example, strings
and lists.  When we talk about a built-in standard Scheme procedure such
as <code class="code">open-input-file</code>, what we actually mean is that there is a
pre-defined top level variable called <code class="code">open-input-file</code>, whose
value is a procedure that implements what R5RS says that
<code class="code">open-input-file</code> should do.
</p>
<p>Note that this is quite different from many dialects of Lisp —
including Emacs Lisp — in which a program can use the same name with
two quite separate meanings: one meaning identifies a Lisp function,
while the other meaning identifies a Lisp variable, whose value need
have nothing to do with the function that is associated with the first
meaning.  In these dialects, functions and variables are said to live in
different <em class="dfn">namespaces</em>.
</p>
<p>In Scheme, on the other hand, all names belong to a single unified
namespace, and the variables that these names identify can hold any kind
of Scheme value, including procedure values.
</p>
<p>One consequence of the “procedures as values” idea is that, if you
don’t happen to like the standard name for a Scheme procedure, you can
change it.
</p>
<p>For example, <code class="code">call-with-current-continuation</code> is a very important
standard Scheme procedure, but it also has a very long name!  So, many
programmers use the following definition to assign the same procedure
value to the more convenient name <code class="code">call/cc</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define call/cc call-with-current-continuation)
</pre></div>

<p>Let’s understand exactly how this works.  The definition creates a new
variable <code class="code">call/cc</code>, and then sets its value to the value of the
variable <code class="code">call-with-current-continuation</code>; the latter value is a
procedure that implements the behaviour that R5RS specifies under the
name “call-with-current-continuation”.  So <code class="code">call/cc</code> ends up
holding this value as well.
</p>
<p>Now that <code class="code">call/cc</code> holds the required procedure value, you could
choose to use <code class="code">call-with-current-continuation</code> for a completely
different purpose, or just change its value so that you will get an
error if you accidentally use <code class="code">call-with-current-continuation</code> as a
procedure in your program rather than <code class="code">call/cc</code>.  For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! call-with-current-continuation "Not a procedure any more!")
</pre></div>

<p>Or you could just leave <code class="code">call-with-current-continuation</code> as it was.
It’s perfectly fine for more than one variable to hold the same
procedure value.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Simple-Invocation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-a-Procedure" accesskey="n" rel="next">Creating and Using a New Procedure</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-as-Values" accesskey="p" rel="prev">Procedures as Values</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="u" rel="up">The Representation and Use of Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Simple-Procedure-Invocation">3.2.2 Simple Procedure Invocation</h4>

<p>A procedure invocation in Scheme is written like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">procedure</var> [<var class="var">arg1</var> [<var class="var">arg2</var> …]])
</pre></div>

<p>In this expression, <var class="var">procedure</var> can be any Scheme expression whose
value is a procedure.  Most commonly, however, <var class="var">procedure</var> is simply
the name of a variable whose value is a procedure.
</p>
<p>For example, <code class="code">string-append</code> is a standard Scheme procedure whose
behaviour is to concatenate together all the arguments, which are
expected to be strings, that it is given.  So the expression
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-append "/home" "/" "andrew")
</pre></div>

<p>is a procedure invocation whose result is the string value
<code class="code">"/home/andrew"</code>.
</p>
<p>Similarly, <code class="code">string-length</code> is a standard Scheme procedure that
returns the length of a single string argument, so
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-length "abc")
</pre></div>

<p>is a procedure invocation whose result is the numeric value 3.
</p>
<p>Each of the parameters in a procedure invocation can itself be any
Scheme expression.  Since a procedure invocation is itself a type of
expression, we can put these two examples together to get
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-length (string-append "/home" "/" "andrew"))
</pre></div>

<p>— a procedure invocation whose result is the numeric value 12.
</p>
<p>(You may be wondering what happens if the two examples are combined the
other way round.  If we do this, we can make a procedure invocation
expression that is <em class="emph">syntactically</em> correct:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-append "/home" (string-length "abc"))
</pre></div>

<p>but when this expression is executed, it will cause an error, because
the result of <code class="code">(string-length "abc")</code> is a numeric value, and
<code class="code">string-append</code> is not designed to accept a numeric value as one of
its arguments.)
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Creating-a-Procedure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lambda-Alternatives" accesskey="n" rel="next">Lambda Alternatives</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Invocation" accesskey="p" rel="prev">Simple Procedure Invocation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="u" rel="up">The Representation and Use of Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Creating-and-Using-a-New-Procedure">3.2.3 Creating and Using a New Procedure</h4>

<p>Scheme has lots of standard procedures, and Guile provides all of these
via predefined top level variables.  All of these standard procedures
are documented in the later chapters of this reference manual.
</p>
<p>Before very long, though, you will want to create new procedures that
encapsulate aspects of your own applications’ functionality.  To do
this, you can use the famous <code class="code">lambda</code> syntax.
</p>
<p>For example, the value of the following Scheme expression
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda (name address) <var class="var">body</var> …)
</pre></div>

<p>is a newly created procedure that takes two arguments:  <code class="code">name</code> and
<code class="code">address</code>.  The behaviour of the new procedure is determined by the
sequence of expressions and definitions in the <var class="var">body</var> of the
procedure definition.  (Typically, <var class="var">body</var> would use the arguments in
some way, or else there wouldn’t be any point in giving them to the
procedure.)  When invoked, the new procedure returns a value that is the
value of the last expression in the <var class="var">body</var>.
</p>
<p>To make things more concrete, let’s suppose that the two arguments are
both strings, and that the purpose of this procedure is to form a
combined string that includes these arguments.  Then the full lambda
expression might look like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda (name address)
  (string-append "Name=" name ":Address=" address))
</pre></div>

<p>We noted in the previous subsection that the <var class="var">procedure</var> part of a
procedure invocation expression can be any Scheme expression whose value
is a procedure.  But that’s exactly what a lambda expression is!  So we
can use a lambda expression directly in a procedure invocation, like
this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((lambda (name address)
   (string-append "Name=" name ":Address=" address))
 "FSF"
 "Cambridge") 
</pre></div>

<p>This is a valid procedure invocation expression, and its result is the
string:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">"Name=FSF:Address=Cambridge"
</pre></div>

<p>It is more common, though, to store the procedure value in a variable —
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define make-combined-string
  (lambda (name address)
    (string-append "Name=" name ":Address=" address)))
</pre></div>

<p>— and then to use the variable name in the procedure invocation:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-combined-string "FSF" "Cambridge") 
</pre></div>

<p>Which has exactly the same result.
</p>
<p>It’s important to note that procedures created using <code class="code">lambda</code> have
exactly the same status as the standard built in Scheme procedures, and
can be invoked, passed around, and stored in variables in exactly the
same ways.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Lambda-Alternatives">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-a-Procedure" accesskey="p" rel="prev">Creating and Using a New Procedure</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="u" rel="up">The Representation and Use of Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Lambda-Alternatives-1">3.2.4 Lambda Alternatives</h4>

<p>Since it is so common in Scheme programs to want to create a procedure
and then store it in a variable, there is an alternative form of the
<code class="code">define</code> syntax that allows you to do just that.
</p>
<p>A <code class="code">define</code> expression of the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (<var class="var">name</var> [<var class="var">arg1</var> [<var class="var">arg2</var> …]])
  <var class="var">body</var> …)
</pre></div>

<p>is exactly equivalent to the longer form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define <var class="var">name</var>
  (lambda ([<var class="var">arg1</var> [<var class="var">arg2</var> …]])
    <var class="var">body</var> …))
</pre></div>

<p>So, for example, the definition of <code class="code">make-combined-string</code> in the
previous subsection could equally be written:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-combined-string name address)
  (string-append "Name=" name ":Address=" address))
</pre></div>

<p>This kind of procedure definition creates a procedure that requires
exactly the expected number of arguments.  There are two further forms
of the <code class="code">lambda</code> expression, which create a procedure that can
accept a variable number of arguments:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda (<var class="var">arg1</var> … . <var class="var">args</var>) <var class="var">body</var> …)

(lambda <var class="var">args</var> <var class="var">body</var> …)
</pre></div>

<p>The corresponding forms of the alternative <code class="code">define</code> syntax are:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (<var class="var">name</var> <var class="var">arg1</var> … . <var class="var">args</var>) <var class="var">body</var> …)

(define (<var class="var">name</var> . <var class="var">args</var>) <var class="var">body</var> …)
</pre></div>

<p>For details on how these forms work, see See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a>.
</p>
<p>Prior to Guile 2.0, Guile provided an extension to <code class="code">define</code> syntax
that allowed you to nest the previous extension up to an arbitrary
depth. These are no longer provided by default, and instead have been
moved to <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Curried-Definitions">Curried Definitions</a>.
</p>
<p>(It could be argued that the alternative <code class="code">define</code> forms are rather
confusing, especially for newcomers to the Scheme language, as they hide
both the role of <code class="code">lambda</code> and the fact that procedures are values
that are stored in variables in the same way as any other kind of value.
On the other hand, they are very convenient, and they are also a good
example of another of Scheme’s powerful features: the ability to specify
arbitrary syntactic transformations at run time, which can be applied to
subsequently read input.)
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="About-Expressions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="n" rel="next">The Concept of Closure</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Procedures" accesskey="p" rel="prev">The Representation and Use of Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="u" rel="up">Hello Scheme!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Expressions-and-Evaluation">3.3 Expressions and Evaluation</h3>

<p>So far, we have met expressions that <em class="emph">do</em> things, such as the
<code class="code">define</code> expressions that create and initialize new variables, and
we have also talked about expressions that have <em class="emph">values</em>, for
example the value of the procedure invocation expression:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-append "/home" "/" "andrew")
</pre></div>

<p>but we haven’t yet been precise about what causes an expression like
this procedure invocation to be reduced to its “value”, or how the
processing of such expressions relates to the execution of a Scheme
program as a whole.
</p>
<p>This section clarifies what we mean by an expression’s value, by
introducing the idea of <em class="dfn">evaluation</em>.  It discusses the side effects
that evaluation can have, explains how each of the various types of
Scheme expression is evaluated, and describes the behaviour and use of
the Guile REPL as a mechanism for exploring evaluation.  The section
concludes with a very brief summary of Scheme’s common syntactic
expressions.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="1">Evaluating Expressions and Executing Programs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Tail-Calls" accesskey="2">Tail calls</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#The-REPL" accesskey="3">Using the Guile REPL</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Summary" accesskey="4">Summary of Common Syntax</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Evaluating">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Tail-Calls" accesskey="n" rel="next">Tail calls</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="u" rel="up">Expressions and Evaluation</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Evaluating-Expressions-and-Executing-Programs">3.3.1 Evaluating Expressions and Executing Programs</h4>

<p>In Scheme, the process of executing an expression is known as
<em class="dfn">evaluation</em>.  Evaluation has two kinds of result:
</p>
<ul class="itemize mark-bullet">
<li>the <em class="dfn">value</em> of the evaluated expression

</li><li>the <em class="dfn">side effects</em> of the evaluation, which consist of any effects of
evaluating the expression that are not represented by the value.
</li></ul>

<p>Of the expressions that we have met so far, <code class="code">define</code> and
<code class="code">set!</code> expressions have side effects — the creation or
modification of a variable — but no value; <code class="code">lambda</code> expressions
have values — the newly constructed procedures — but no side
effects; and procedure invocation expressions, in general, have either
values, or side effects, or both.
</p>
<p>It is tempting to try to define more intuitively what we mean by
“value” and “side effects”, and what the difference between them is.
In general, though, this is extremely difficult.  It is also
unnecessary; instead, we can quite happily define the behaviour of a
Scheme program by specifying how Scheme executes a program as a whole,
and then by describing the value and side effects of evaluation for each
type of expression individually.
</p>
<p>So, some<a class="footnote" id="DOCF1" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT1"><sup>1</sup></a> definitions…
</p>
<ul class="itemize mark-bullet">
<li>A Scheme program consists of a sequence of expressions.

</li><li>A Scheme interpreter executes the program by evaluating these
expressions in order, one by one.

</li><li>An expression can be

<ul class="itemize mark-bullet">
<li>a piece of literal data, such as a number <code class="code">2.3</code> or a string
<code class="code">"Hello world!"</code>
</li><li>a variable name
</li><li>a procedure invocation expression
</li><li>one of Scheme’s special syntactic expressions.
</li></ul>
</li></ul>

<p>The following subsections describe how each of these types of expression
is evaluated.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Literal" accesskey="1">Evaluating Literal Data</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Variable" accesskey="2">Evaluating a Variable Reference</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Procedure" accesskey="3">Evaluating a Procedure Invocation Expression</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Special" accesskey="4">Evaluating Special Syntactic Expressions</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Eval-Literal">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Variable" accesskey="n" rel="next">Evaluating a Variable Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="u" rel="up">Evaluating Expressions and Executing Programs</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Evaluating-Literal-Data">3.3.1.1 Evaluating Literal Data</h4>

<p>When a literal data expression is evaluated, the value of the expression
is simply the value that the expression describes.  The evaluation of a
literal data expression has no side effects.
</p>
<p>So, for example, 
</p>
<ul class="itemize mark-bullet">
<li>the value of the expression <code class="code">"abc"</code> is the string value
<code class="code">"abc"</code>

</li><li>the value of the expression <code class="code">3+4i</code> is the complex number 3 + 4i

</li><li>the value of the expression <code class="code">#(1 2 3)</code> is a three-element vector
containing the numeric values 1, 2 and 3.
</li></ul>

<p>For any data type which can be expressed literally like this, the syntax
of the literal data expression for that data type — in other words,
what you need to write in your code to indicate a literal value of that
type — is known as the data type’s <em class="dfn">read syntax</em>.  This manual
specifies the read syntax for each such data type in the section that
describes that data type.
</p>
<p>Some data types do not have a read syntax.  Procedures, for example,
cannot be expressed as literal data; they must be created using a
<code class="code">lambda</code> expression (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-a-Procedure">Creating and Using a New Procedure</a>) or implicitly
using the shorthand form of <code class="code">define</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda-Alternatives">Lambda Alternatives</a>).
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Eval-Variable">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Procedure" accesskey="n" rel="next">Evaluating a Procedure Invocation Expression</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Literal" accesskey="p" rel="prev">Evaluating Literal Data</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="u" rel="up">Evaluating Expressions and Executing Programs</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Evaluating-a-Variable-Reference">3.3.1.2 Evaluating a Variable Reference</h4>

<p>When an expression that consists simply of a variable name is evaluated,
the value of the expression is the value of the named variable.  The
evaluation of a variable reference expression has no side effects.
</p>
<p>So, after
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define key "Paul Evans")
</pre></div>

<p>the value of the expression <code class="code">key</code> is the string value <code class="code">"Paul
Evans"</code>.  If <var class="var">key</var> is then modified by
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! key 3.74)
</pre></div>

<p>the value of the expression <code class="code">key</code> is the numeric value 3.74.
</p>
<p>If there is no variable with the specified name, evaluation of the
variable reference expression signals an error.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Eval-Procedure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Special" accesskey="n" rel="next">Evaluating Special Syntactic Expressions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Variable" accesskey="p" rel="prev">Evaluating a Variable Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="u" rel="up">Evaluating Expressions and Executing Programs</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Evaluating-a-Procedure-Invocation-Expression">3.3.1.3 Evaluating a Procedure Invocation Expression</h4>

<p>This is where evaluation starts getting interesting!  As already noted,
a procedure invocation expression has the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">procedure</var> [<var class="var">arg1</var> [<var class="var">arg2</var> …]])
</pre></div>

<p>where <var class="var">procedure</var> must be an expression whose value, when evaluated,
is a procedure.
</p>
<p>The evaluation of a procedure invocation expression like this proceeds
by
</p>
<ul class="itemize mark-bullet">
<li>evaluating individually the expressions <var class="var">procedure</var>, <var class="var">arg1</var>,
<var class="var">arg2</var>, and so on

</li><li>calling the procedure that is the value of the <var class="var">procedure</var>
expression with the list of values obtained from the evaluations of
<var class="var">arg1</var>, <var class="var">arg2</var> etc. as its parameters.
</li></ul>

<p>For a procedure defined in Scheme, “calling the procedure with the list
of values as its parameters” means binding the values to the
procedure’s formal parameters and then evaluating the sequence of
expressions that make up the body of the procedure definition.  The
value of the procedure invocation expression is the value of the last
evaluated expression in the procedure body.  The side effects of calling
the procedure are the combination of the side effects of the sequence of
evaluations of expressions in the procedure body.
</p>
<p>For a built-in procedure, the value and side-effects of calling the
procedure are best described by that procedure’s documentation.
</p>
<p>Note that the complete side effects of evaluating a procedure invocation
expression consist not only of the side effects of the procedure call,
but also of any side effects of the preceding evaluation of the
expressions <var class="var">procedure</var>, <var class="var">arg1</var>, <var class="var">arg2</var>, and so on.
</p>
<p>To illustrate this, let’s look again at the procedure invocation
expression:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-length (string-append "/home" "/" "andrew"))
</pre></div>

<p>In the outermost expression, <var class="var">procedure</var> is <code class="code">string-length</code> and
<var class="var">arg1</var> is <code class="code">(string-append "/home" "/" "andrew")</code>.
</p>
<ul class="itemize mark-bullet">
<li>Evaluation of <code class="code">string-length</code>, which is a variable, gives a
procedure value that implements the expected behaviour for
“string-length”.

</li><li>Evaluation of <code class="code">(string-append "/home" "/" "andrew")</code>, which is
another procedure invocation expression, means evaluating each of

<ul class="itemize mark-bullet">
<li><code class="code">string-append</code>, which gives a procedure value that implements the
expected behaviour for “string-append”

</li><li><code class="code">"/home"</code>, which gives the string value <code class="code">"/home"</code>

</li><li><code class="code">"/"</code>, which gives the string value <code class="code">"/"</code>

</li><li><code class="code">"andrew"</code>, which gives the string value <code class="code">"andrew"</code>
</li></ul>

<p>and then invoking the procedure value with this list of string values as
its arguments.  The resulting value is a single string value that is the
concatenation of all the arguments, namely <code class="code">"/home/andrew"</code>.
</p></li></ul>

<p>In the evaluation of the outermost expression, the interpreter can now
invoke the procedure value obtained from <var class="var">procedure</var> with the value
obtained from <var class="var">arg1</var> as its arguments.  The resulting value is a
numeric value that is the length of the argument string, which is 12.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Eval-Special">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-Procedure" accesskey="p" rel="prev">Evaluating a Procedure Invocation Expression</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="u" rel="up">Evaluating Expressions and Executing Programs</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Evaluating-Special-Syntactic-Expressions">3.3.1.4 Evaluating Special Syntactic Expressions</h4>

<p>When a procedure invocation expression is evaluated, the procedure and
<em class="emph">all</em> the argument expressions must be evaluated before the
procedure can be invoked.  Special syntactic expressions are special
because they are able to manipulate their arguments in an unevaluated
form, and can choose whether to evaluate any or all of the argument
expressions.
</p>
<p>Why is this needed?  Consider a program fragment that asks the user
whether or not to delete a file, and then deletes the file if the user
answers yes.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(if (string=? (read-answer "Should I delete this file?")
              "yes")
    (delete-file file))
</pre></div>

<p>If the outermost <code class="code">(if …)</code> expression here was a procedure
invocation expression, the expression <code class="code">(delete-file file)</code>, whose
side effect is to actually delete a file, would already have been
evaluated before the <code class="code">if</code> procedure even got invoked!  Clearly this
is no use — the whole point of an <code class="code">if</code> expression is that the
<em class="dfn">consequent</em> expression is only evaluated if the condition of the
<code class="code">if</code> expression is “true”.
</p>
<p>Therefore <code class="code">if</code> must be special syntax, not a procedure.  Other
special syntaxes that we have already met are <code class="code">define</code>, <code class="code">set!</code>
and <code class="code">lambda</code>.  <code class="code">define</code> and <code class="code">set!</code> are syntax because
they need to know the variable <em class="emph">name</em> that is given as the first
argument in a <code class="code">define</code> or <code class="code">set!</code> expression, not that
variable’s value.  <code class="code">lambda</code> is syntax because it does not
immediately evaluate the expressions that define the procedure body;
instead it creates a procedure object that incorporates these
expressions so that they can be evaluated in the future, when that
procedure is invoked.
</p>
<p>The rules for evaluating each special syntactic expression are specified
individually for each special syntax.  For a summary of standard special
syntax, see See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Summary">Summary of Common Syntax</a>.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Tail-Calls">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-REPL" accesskey="n" rel="next">Using the Guile REPL</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluating" accesskey="p" rel="prev">Evaluating Expressions and Executing Programs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="u" rel="up">Expressions and Evaluation</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Tail-calls">3.3.2 Tail calls</h4>
<a class="index-entry-id" id="index-tail-calls"></a>
<a class="index-entry-id" id="index-recursion"></a>

<p>Scheme is “properly tail recursive”, meaning that tail calls or
recursions from certain contexts do not consume stack space or other
resources and can therefore be used on arbitrarily large data or for
an arbitrarily long calculation.  Consider for example,
</p>
<div class="example">
<pre class="example-preformatted">(define (foo n)
  (display n)
  (newline)
  (foo (1+ n)))

(foo 1)
-|
1
2
3
…
</pre></div>

<p><code class="code">foo</code> prints numbers infinitely, starting from the given <var class="var">n</var>.
It’s implemented by printing <var class="var">n</var> then recursing to itself to print
<em class="math"><var class="var">n</var>+1</em> and so on.  This recursion is a tail call, it’s the
last thing done, and in Scheme such tail calls can be made without
limit.
</p>
<p>Or consider a case where a value is returned, a version of the SRFI-1
<code class="code">last</code> function (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors">Selectors</a>) returning the last
element of a list,
</p>
<div class="example">
<pre class="example-preformatted">(define (my-last lst)
  (if (null? (cdr lst))
      (car lst)
      (my-last (cdr lst))))

(my-last '(1 2 3)) ⇒ 3      
</pre></div>

<p>If the list has more than one element, <code class="code">my-last</code> applies itself
to the <code class="code">cdr</code>.  This recursion is a tail call, there’s no code
after it, and the return value is the return value from that call.  In
Scheme this can be used on an arbitrarily long list argument.
</p>
<br>
<p>A proper tail call is only available from certain contexts, namely the
following special form positions,
</p>
<ul class="itemize mark-bullet">
<li><code class="code">and</code> — last expression

</li><li><code class="code">begin</code> — last expression
     
</li><li><code class="code">case</code> — last expression in each clause

</li><li><code class="code">cond</code> — last expression in each clause, and the call to a
<code class="code">=&gt;</code> procedure is a tail call

</li><li><code class="code">do</code> — last result expression

</li><li><code class="code">if</code> — “true” and “false” leg expressions

</li><li><code class="code">lambda</code> — last expression in body

</li><li><code class="code">let</code>, <code class="code">let*</code>, <code class="code">letrec</code>, <code class="code">let-syntax</code>,
<code class="code">letrec-syntax</code> — last expression in body

</li><li><code class="code">or</code> — last expression
</li></ul>

<p>The following core functions make tail calls,
</p>
<ul class="itemize mark-bullet">
<li><code class="code">apply</code> — tail call to given procedure

</li><li><code class="code">call-with-current-continuation</code> — tail call to the procedure
receiving the new continuation

</li><li><code class="code">call-with-values</code> — tail call to the values-receiving
procedure

</li><li><code class="code">eval</code> — tail call to evaluate the form

</li><li><code class="code">string-any</code>, <code class="code">string-every</code> — tail call to predicate on
the last character (if that point is reached)
</li></ul>

<br>
<p>The above are just core functions and special forms.  Tail calls in
other modules are described with the relevant documentation, for
example SRFI-1 <code class="code">any</code> and <code class="code">every</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching">Searching</a>).
</p>
<p>It will be noted there are a lot of places which could potentially be
tail calls, for instance the last call in a <code class="code">for-each</code>, but only
those explicitly described are guaranteed.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="The-REPL">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Summary" accesskey="n" rel="next">Summary of Common Syntax</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Tail-Calls" accesskey="p" rel="prev">Tail calls</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="u" rel="up">Expressions and Evaluation</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Using-the-Guile-REPL">3.3.3 Using the Guile REPL</h4>

<p>If you start Guile without specifying a particular program for it to
execute, Guile enters its standard Read Evaluate Print Loop — or
<em class="dfn">REPL</em> for short.  In this mode, Guile repeatedly reads in the next
Scheme expression that the user types, evaluates it, and prints the
resulting value.
</p>
<p>The REPL is a useful mechanism for exploring the evaluation behaviour
described in the previous subsection.  If you type <code class="code">string-append</code>,
for example, the REPL replies <code class="code">#&lt;primitive-procedure
string-append&gt;</code>, illustrating the relationship between the variable
<code class="code">string-append</code> and the procedure value stored in that variable.
</p>
<p>In this manual, the notation ⇒ is used to mean “evaluates
to”.  Wherever you see an example of the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted"><var class="var">expression</var>
⇒
<var class="var">result</var>
</pre></div>

<p>feel free to try it out yourself by typing <var class="var">expression</var> into the
REPL and checking that it gives the expected <var class="var">result</var>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Syntax-Summary">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-REPL" accesskey="p" rel="prev">Using the Guile REPL</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="u" rel="up">Expressions and Evaluation</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Summary-of-Common-Syntax">3.3.4 Summary of Common Syntax</h4>

<p>This subsection lists the most commonly used Scheme syntactic
expressions, simply so that you will recognize common special syntax
when you see it.  For a full description of each of these syntaxes,
follow the appropriate reference.
</p>
<p><code class="code">lambda</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a>) is used to construct procedure objects.
</p>
<p><code class="code">define</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level Variable Definitions</a>) is used to create a new variable and
set its initial value.
</p>
<p><code class="code">set!</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level Variable Definitions</a>) is used to modify an existing variable’s
value.
</p>
<p><code class="code">let</code>, <code class="code">let*</code> and <code class="code">letrec</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>)
create an inner lexical environment for the evaluation of a sequence of
expressions, in which a specified set of local variables is bound to the
values of a corresponding set of expressions.  For an introduction to
environments, see See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The Concept of Closure</a>.
</p>
<p><code class="code">begin</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#begin">Sequencing and Splicing</a>) executes a sequence of expressions in order
and returns the value of the last expression.  Note that this is not the
same as a procedure which returns its last argument, because the
evaluation of a procedure invocation expression does not guarantee to
evaluate the arguments in order.
</p>
<p><code class="code">if</code> and <code class="code">cond</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals">Simple Conditional Evaluation</a>) provide conditional
evaluation of argument expressions depending on whether one or more
conditions evaluate to “true” or “false”.
</p>
<p><code class="code">case</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals">Simple Conditional Evaluation</a>) provides conditional evaluation of
argument expressions depending on whether a variable has one of a
specified group of values.
</p>
<p><code class="code">and</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#and-or">Conditional Evaluation of a Sequence of Expressions</a>) executes a sequence of expressions in order
until either there are no expressions left, or one of them evaluates to
“false”.
</p>
<p><code class="code">or</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#and-or">Conditional Evaluation of a Sequence of Expressions</a>) executes a sequence of expressions in order
until either there are no expressions left, or one of them evaluates to
“true”.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="About-Closure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Further-Reading" accesskey="n" rel="next">Further Reading</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Expressions" accesskey="p" rel="prev">Expressions and Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="u" rel="up">Hello Scheme!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-Concept-of-Closure">3.4 The Concept of Closure</h3>

<a class="index-entry-id" id="index-closure"></a>

<p>The concept of <em class="dfn">closure</em> is the idea that a lambda expression
“captures” the variable bindings that are in lexical scope at the
point where the lambda expression occurs.  The procedure created by the
lambda expression can refer to and mutate the captured bindings, and the
values of those bindings persist between procedure calls.
</p>
<p>This section explains and explores the various parts of this idea in
more detail.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-Environments" accesskey="1">Names, Locations, Values and Environments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Variables" accesskey="2">Local Variables and Environments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Chaining" accesskey="3">Environment Chaining</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Lexical-Scope" accesskey="4">Lexical Scope</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Closure" accesskey="5">Closure</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Serial-Number" accesskey="6">Example 1: A Serial Number Generator</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Variable" accesskey="7">Example 2: A Shared Persistent Variable</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Callback-Closure" accesskey="8">Example 3: The Callback Closure Problem</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#OO-Closure" accesskey="9">Example 4: Object Orientation</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="About-Environments">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Variables" accesskey="n" rel="next">Local Variables and Environments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Names_002c-Locations_002c-Values-and-Environments">3.4.1 Names, Locations, Values and Environments</h4>

<a class="index-entry-id" id="index-location"></a>
<a class="index-entry-id" id="index-environment"></a>
<a class="index-entry-id" id="index-vcell"></a>
<a class="index-entry-id" id="index-top-level-environment"></a>
<a class="index-entry-id" id="index-environment_002c-top-level"></a>

<p>We said earlier that a variable name in a Scheme program is associated
with a location in which any kind of Scheme value may be stored.
(Incidentally, the term “vcell” is often used in Lisp and Scheme
circles as an alternative to “location”.)  Thus part of what we mean
when we talk about “creating a variable” is in fact establishing an
association between a name, or identifier, that is used by the Scheme
program code, and the variable location to which that name refers.
Although the value that is stored in that location may change, the
location to which a given name refers is always the same.
</p>
<p>We can illustrate this by breaking down the operation of the
<code class="code">define</code> syntax into three parts: <code class="code">define</code>
</p>
<ul class="itemize mark-bullet">
<li>creates a new location

</li><li>establishes an association between that location and the name specified
as the first argument of the <code class="code">define</code> expression

</li><li>stores in that location the value obtained by evaluating the second
argument of the <code class="code">define</code> expression.
</li></ul>

<p>A collection of associations between names and locations is called an
<em class="dfn">environment</em>.  When you create a top level variable in a program
using <code class="code">define</code>, the name-location association for that variable is
added to the “top level” environment.  The “top level” environment
also includes name-location associations for all the procedures that are
supplied by standard Scheme.
</p>
<p>It is also possible to create environments other than the top level one,
and to create variable bindings, or name-location associations, in those
environments.  This ability is a key ingredient in the concept of
closure; the next subsection shows how it is done.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Local-Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Chaining" accesskey="n" rel="next">Environment Chaining</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Environments" accesskey="p" rel="prev">Names, Locations, Values and Environments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Local-Variables-and-Environments">3.4.2 Local Variables and Environments</h4>

<a class="index-entry-id" id="index-local-variable"></a>
<a class="index-entry-id" id="index-variable_002c-local"></a>
<a class="index-entry-id" id="index-local-environment"></a>
<a class="index-entry-id" id="index-environment_002c-local"></a>

<p>We have seen how to create top level variables using the <code class="code">define</code>
syntax (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Definition">Defining and Setting Variables</a>).  It is often useful to create variables
that are more limited in their scope, typically as part of a procedure
body.  In Scheme, this is done using the <code class="code">let</code> syntax, or one of
its modified forms <code class="code">let*</code> and <code class="code">letrec</code>.  These syntaxes are
described in full later in the manual (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>).  Here
our purpose is to illustrate their use just enough that we can see how
local variables work.
</p>
<p>For example, the following code uses a local variable <code class="code">s</code> to
simplify the computation of the area of a triangle given the lengths of
its three sides.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define a 5.3)
(define b 4.7)
(define c 2.8)

(define area
  (let ((s (/ (+ a b c) 2)))
    (sqrt (* s (- s a) (- s b) (- s c)))))
</pre></div>

<p>The effect of the <code class="code">let</code> expression is to create a new environment
and, within this environment, an association between the name <code class="code">s</code>
and a new location whose initial value is obtained by evaluating
<code class="code">(/ (+ a b c) 2)</code>.  The expressions in the body of the <code class="code">let</code>,
namely <code class="code">(sqrt (* s (- s a) (- s b) (- s c)))</code>, are then evaluated
in the context of the new environment, and the value of the last
expression evaluated becomes the value of the whole <code class="code">let</code>
expression, and therefore the value of the variable <code class="code">area</code>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Chaining">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lexical-Scope" accesskey="n" rel="next">Lexical Scope</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Variables" accesskey="p" rel="prev">Local Variables and Environments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Environment-Chaining">3.4.3 Environment Chaining</h4>

<a class="index-entry-id" id="index-shadowing-an-imported-variable-binding"></a>
<a class="index-entry-id" id="index-chaining-environments"></a>

<p>In the example of the previous subsection, we glossed over an important
point.  The body of the <code class="code">let</code> expression in that example refers not
only to the local variable <code class="code">s</code>, but also to the top level variables
<code class="code">a</code>, <code class="code">b</code>, <code class="code">c</code> and <code class="code">sqrt</code>.  (<code class="code">sqrt</code> is the
standard Scheme procedure for calculating a square root.)  If the body
of the <code class="code">let</code> expression is evaluated in the context of the
<em class="emph">local</em> <code class="code">let</code> environment, how does the evaluation get at the
values of these top level variables?
</p>
<p>The answer is that the local environment created by a <code class="code">let</code>
expression automatically has a reference to its containing environment
— in this case the top level environment — and that the Scheme
interpreter automatically looks for a variable binding in the containing
environment if it doesn’t find one in the local environment.  More
generally, every environment except for the top level one has a
reference to its containing environment, and the interpreter keeps
searching back up the chain of environments — from most local to top
level — until it either finds a variable binding for the required
identifier or exhausts the chain.
</p>
<p>This description also determines what happens when there is more than
one variable binding with the same name.  Suppose, continuing the
example of the previous subsection, that there was also a pre-existing
top level variable <code class="code">s</code> created by the expression:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s "Some beans, my lord!")
</pre></div>

<p>Then both the top level environment and the local <code class="code">let</code> environment
would contain bindings for the name <code class="code">s</code>.  When evaluating code
within the <code class="code">let</code> body, the interpreter looks first in the local
<code class="code">let</code> environment, and so finds the binding for <code class="code">s</code> created by
the <code class="code">let</code> syntax.  Even though this environment has a reference to
the top level environment, which also has a binding for <code class="code">s</code>, the
interpreter doesn’t get as far as looking there.  When evaluating code
outside the <code class="code">let</code> body, the interpreter looks up variable names in
the top level environment, so the name <code class="code">s</code> refers to the top level
variable.
</p>
<p>Within the <code class="code">let</code> body, the binding for <code class="code">s</code> in the local
environment is said to <em class="dfn">shadow</em> the binding for <code class="code">s</code> in the top
level environment.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Lexical-Scope">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Closure" accesskey="n" rel="next">Closure</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Chaining" accesskey="p" rel="prev">Environment Chaining</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Lexical-Scope-1">3.4.4 Lexical Scope</h4>

<p>The rules that we have just been describing are the details of how
Scheme implements “lexical scoping”.  This subsection takes a brief
diversion to explain what lexical scope means in general and to present
an example of non-lexical scoping.
</p>
<p>“Lexical scope” in general is the idea that
</p>
<ul class="itemize mark-bullet">
<li>an identifier at a particular place in a program always refers to the
same variable location — where “always” means “every time that the
containing expression is executed”, and that

</li><li>the variable location to which it refers can be determined by static
examination of the source code context in which that identifier appears,
without having to consider the flow of execution through the program as
a whole.
</li></ul>

<p>In practice, lexical scoping is the norm for most programming languages,
and probably corresponds to what you would intuitively consider to be
“normal”.  You may even be wondering how the situation could possibly
— and usefully — be otherwise.  To demonstrate that another kind of
scoping is possible, therefore, and to compare it against lexical
scoping, the following subsection presents an example of non-lexical
scoping and examines in detail how its behavior differs from the
corresponding lexically scoped code.
</p>
                                   

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scoping-Example" accesskey="1">An Example of Non-Lexical Scoping</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Scoping-Example">
<div class="nav-panel">
<p>
Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lexical-Scope" accesskey="u" rel="up">Lexical Scope</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="An-Example-of-Non_002dLexical-Scoping">3.4.4.1 An Example of Non-Lexical Scoping</h4>

<p>To demonstrate that non-lexical scoping does exist and can be useful, we
present the following example from Emacs Lisp, which is a “dynamically
scoped” language.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defvar currency-abbreviation "USD")

(defun currency-string (units hundredths)
  (concat currency-abbreviation
          (number-to-string units)
          "."
          (number-to-string hundredths)))

(defun french-currency-string (units hundredths)
  (let ((currency-abbreviation "FRF"))
    (currency-string units hundredths)))
</pre></div>

<p>The question to focus on here is: what does the identifier
<code class="code">currency-abbreviation</code> refer to in the <code class="code">currency-string</code>
function?  The answer, in Emacs Lisp, is that all variable bindings go
onto a single stack, and that <code class="code">currency-abbreviation</code> refers to the
topmost binding from that stack which has the name
“currency-abbreviation”.  The binding that is created by the
<code class="code">defvar</code> form, to the value <code class="code">"USD"</code>, is only relevant if none
of the code that calls <code class="code">currency-string</code> rebinds the name
“currency-abbreviation” in the meanwhile.
</p>
<p>The second function <code class="code">french-currency-string</code> works precisely by
taking advantage of this behaviour.  It creates a new binding for the
name “currency-abbreviation” which overrides the one established by
the <code class="code">defvar</code> form.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">;; Note!  This is Emacs Lisp evaluation, not Scheme!
(french-currency-string 33 44)
⇒
"FRF33.44"
</pre></div>

<p>Now let’s look at the corresponding, <em class="emph">lexically scoped</em> Scheme
code:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define currency-abbreviation "USD")

(define (currency-string units hundredths)
  (string-append currency-abbreviation
                 (number-&gt;string units)
                 "."
                 (number-&gt;string hundredths)))

(define (french-currency-string units hundredths)
  (let ((currency-abbreviation "FRF"))
    (currency-string units hundredths)))
</pre></div>

<p>According to the rules of lexical scoping, the
<code class="code">currency-abbreviation</code> in <code class="code">currency-string</code> refers to the
variable location in the innermost environment at that point in the code
which has a binding for <code class="code">currency-abbreviation</code>, which is the
variable location in the top level environment created by the preceding
<code class="code">(define currency-abbreviation …)</code> expression.
</p>
<p>In Scheme, therefore, the <code class="code">french-currency-string</code> procedure does
not work as intended.  The variable binding that it creates for
“currency-abbreviation” is purely local to the code that forms the
body of the <code class="code">let</code> expression.  Since this code doesn’t directly use
the name “currency-abbreviation” at all, the binding is pointless.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(french-currency-string 33 44)
⇒
"USD33.44"
</pre></div>

<p>This begs the question of how the Emacs Lisp behaviour can be
implemented in Scheme.  In general, this is a design question whose
answer depends upon the problem that is being addressed.  In this case,
the best answer may be that <code class="code">currency-string</code> should be
redesigned so that it can take an optional third argument.  This third
argument, if supplied, is interpreted as a currency abbreviation that
overrides the default.
</p>
<p>It is possible to change <code class="code">french-currency-string</code> so that it mostly
works without changing <code class="code">currency-string</code>, but the fix is inelegant,
and susceptible to interrupts that could leave the
<code class="code">currency-abbreviation</code> variable in the wrong state:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (french-currency-string units hundredths)
  (set! currency-abbreviation "FRF")
  (let ((result (currency-string units hundredths)))
    (set! currency-abbreviation "USD")
    result))
</pre></div>

<p>The key point here is that the code does not create any local binding
for the identifier <code class="code">currency-abbreviation</code>, so all occurrences of
this identifier refer to the top level variable.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Closure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Serial-Number" accesskey="n" rel="next">Example 1: A Serial Number Generator</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lexical-Scope" accesskey="p" rel="prev">Lexical Scope</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Closure-1">3.4.5 Closure</h4>

<p>Consider a <code class="code">let</code> expression that doesn’t contain any
<code class="code">lambda</code>s:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((s (/ (+ a b c) 2)))
  (sqrt (* s (- s a) (- s b) (- s c))))
</pre></div>

<p>When the Scheme interpreter evaluates this, it
</p>
<ul class="itemize mark-bullet">
<li>creates a new environment with a reference to the environment that was
current when it encountered the <code class="code">let</code>

</li><li>creates a variable binding for <code class="code">s</code> in the new environment, with
value given by <code class="code">(/ (+ a b c) 2)</code>

</li><li>evaluates the expression in the body of the <code class="code">let</code> in the context of
the new local environment, and remembers the value <code class="code">V</code>

</li><li>forgets the local environment

</li><li>continues evaluating the expression that contained the <code class="code">let</code>, using
the value <code class="code">V</code> as the value of the <code class="code">let</code> expression, in the
context of the containing environment.
</li></ul>

<p>After the <code class="code">let</code> expression has been evaluated, the local
environment that was created is simply forgotten, and there is no longer
any way to access the binding that was created in this environment.  If
the same code is evaluated again, it will follow the same steps again,
creating a second new local environment that has no connection with the
first, and then forgetting this one as well.
</p>
<p>If the <code class="code">let</code> body contains a <code class="code">lambda</code> expression, however, the
local environment is <em class="emph">not</em> forgotten.  Instead, it becomes
associated with the procedure that is created by the <code class="code">lambda</code>
expression, and is reinstated every time that that procedure is called.
In detail, this works as follows.
</p>
<ul class="itemize mark-bullet">
<li>When the Scheme interpreter evaluates a <code class="code">lambda</code> expression, to
create a procedure object, it stores the current environment as part of
the procedure definition.

</li><li>Then, whenever that procedure is called, the interpreter reinstates the
environment that is stored in the procedure definition and evaluates the
procedure body within the context of that environment.
</li></ul>

<p>The result is that the procedure body is always evaluated in the context
of the environment that was current when the procedure was created.
</p>
<p>This is what is meant by <em class="dfn">closure</em>.  The next few subsections
present examples that explore the usefulness of this concept.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Serial-Number">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Variable" accesskey="n" rel="next">Example 2: A Shared Persistent Variable</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Closure" accesskey="p" rel="prev">Closure</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Example-1_003a-A-Serial-Number-Generator">3.4.6 Example 1: A Serial Number Generator</h4>

<p>This example uses closure to create a procedure with a variable binding
that is private to the procedure, like a local variable, but whose value
persists between procedure calls.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-serial-number-generator)
  (let ((current-serial-number 0))
    (lambda ()
      (set! current-serial-number (+ current-serial-number 1))
      current-serial-number)))

(define entry-sn-generator (make-serial-number-generator))

(entry-sn-generator)
⇒
1

(entry-sn-generator)
⇒
2
</pre></div>

<p>When <code class="code">make-serial-number-generator</code> is called, it creates a local
environment with a binding for <code class="code">current-serial-number</code> whose
initial value is 0, then, within this environment, creates a procedure.
The local environment is stored within the created procedure object and
so persists for the lifetime of the created procedure.
</p>
<p>Every time the created procedure is invoked, it increments the value of
the <code class="code">current-serial-number</code> binding in the captured environment and
then returns the current value.
</p>
<p>Note that <code class="code">make-serial-number-generator</code> can be called again to
create a second serial number generator that is independent of the
first.  Every new invocation of <code class="code">make-serial-number-generator</code>
creates a new local <code class="code">let</code> environment and returns a new procedure
object with an association to this environment.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Shared-Variable">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Callback-Closure" accesskey="n" rel="next">Example 3: The Callback Closure Problem</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Serial-Number" accesskey="p" rel="prev">Example 1: A Serial Number Generator</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Example-2_003a-A-Shared-Persistent-Variable">3.4.7 Example 2: A Shared Persistent Variable</h4>

<p>This example uses closure to create two procedures, <code class="code">get-balance</code>
and <code class="code">deposit</code>, that both refer to the same captured local
environment so that they can both access the <code class="code">balance</code> variable
binding inside that environment.  The value of this variable binding
persists between calls to either procedure.
</p>
<p>Note that the captured <code class="code">balance</code> variable binding is private to
these two procedures: it is not directly accessible to any other code.
It can only be accessed indirectly via <code class="code">get-balance</code> or
<code class="code">deposit</code>, as illustrated by the <code class="code">withdraw</code> procedure.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define get-balance #f)
(define deposit #f)

(let ((balance 0))
  (set! get-balance
        (lambda ()
          balance))
  (set! deposit
        (lambda (amount)
          (set! balance (+ balance amount))
          balance)))

(define (withdraw amount)
  (deposit (- amount)))

(get-balance)
⇒
0

(deposit 50)
⇒
50

(withdraw 75)
⇒
-25
</pre></div>

<p>An important detail here is that the <code class="code">get-balance</code> and
<code class="code">deposit</code> variables must be set up by <code class="code">define</code>ing them at top
level and then <code class="code">set!</code>ing their values inside the <code class="code">let</code> body.
Using <code class="code">define</code> within the <code class="code">let</code> body would not work: this
would create variable bindings within the local <code class="code">let</code> environment
that would not be accessible at top level.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Callback-Closure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#OO-Closure" accesskey="n" rel="next">Example 4: Object Orientation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Variable" accesskey="p" rel="prev">Example 2: A Shared Persistent Variable</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Example-3_003a-The-Callback-Closure-Problem">3.4.8 Example 3: The Callback Closure Problem</h4>

<p>A frequently used programming model for library code is to allow an
application to register a callback function for the library to call when
some particular event occurs.  It is often useful for the application to
make several such registrations using the same callback function, for
example if several similar library events can be handled using the same
application code, but the need then arises to distinguish the callback
function calls that are associated with one callback registration from
those that are associated with different callback registrations.
</p>
<p>In languages without the ability to create functions dynamically, this
problem is usually solved by passing a <code class="code">user_data</code> parameter on the
registration call, and including the value of this parameter as one of
the parameters on the callback function.  Here is an example of
declarations using this solution in C:
</p>
<div class="example">
<pre class="example-preformatted">typedef void (event_handler_t) (int event_type,
                                void *user_data);

void register_callback (int event_type,
                        event_handler_t *handler,
                        void *user_data);
</pre></div>

<p>In Scheme, closure can be used to achieve the same functionality without
requiring the library code to store a <code class="code">user-data</code> for each callback
registration.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">;; In the library:

(define (register-callback event-type handler-proc)
  …)

;; In the application:

(define (make-handler event-type user-data)
  (lambda ()
    …
    &lt;code referencing event-type and user-data&gt;
    …))

(register-callback event-type
                   (make-handler event-type …))
</pre></div>

<p>As far as the library is concerned, <code class="code">handler-proc</code> is a procedure
with no arguments, and all the library has to do is call it when the
appropriate event occurs.  From the application’s point of view, though,
the handler procedure has used closure to capture an environment that
includes all the context that the handler code needs —
<code class="code">event-type</code> and <code class="code">user-data</code> — to handle the event
correctly.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="OO-Closure">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Callback-Closure" accesskey="p" rel="prev">Example 3: The Callback Closure Problem</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="u" rel="up">The Concept of Closure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Example-4_003a-Object-Orientation">3.4.9 Example 4: Object Orientation</h4>

<p>Closure is the capture of an environment, containing persistent variable
bindings, within the definition of a procedure or a set of related
procedures.  This is rather similar to the idea in some object oriented
languages of encapsulating a set of related data variables inside an
“object”, together with a set of “methods” that operate on the
encapsulated data.  The following example shows how closure can be used
to emulate the ideas of objects, methods and encapsulation in Scheme.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-account)
  (let ((balance 0))
    (define (get-balance)
      balance)
    (define (deposit amount)
      (set! balance (+ balance amount))
      balance)
    (define (withdraw amount)
      (deposit (- amount)))

    (lambda args
      (apply
        (case (car args)
          ((get-balance) get-balance)
          ((deposit) deposit)
          ((withdraw) withdraw)
          (else (error "Invalid method!")))
        (cdr args)))))
</pre></div>

<p>Each call to <code class="code">make-account</code> creates and returns a new procedure,
created by the expression in the example code that begins “(lambda
args”.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define my-account (make-account))

my-account
⇒
#&lt;procedure args&gt;
</pre></div>

<p>This procedure acts as an account object with methods
<code class="code">get-balance</code>, <code class="code">deposit</code> and <code class="code">withdraw</code>.  To apply one of
the methods to the account, you call the procedure with a symbol
indicating the required method as the first parameter, followed by any
other parameters that are required by that method.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(my-account 'get-balance)
⇒
0

(my-account 'withdraw 5)
⇒
-5

(my-account 'deposit 396)
⇒
391

(my-account 'get-balance)
⇒
391
</pre></div>

<p>Note how, in this example, both the current balance and the helper
procedures <code class="code">get-balance</code>, <code class="code">deposit</code> and <code class="code">withdraw</code>, used
to implement the guts of the account object’s methods, are all stored in
variable bindings within the private local environment captured by the
<code class="code">lambda</code> expression that creates the account object procedure.
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="Further-Reading">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure" accesskey="p" rel="prev">The Concept of Closure</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="u" rel="up">Hello Scheme!</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Further-Reading-1">3.5 Further Reading</h3>

<ul class="itemize mark-bullet">
<li>The website <a class="url" href="http://www.schemers.org/">http://www.schemers.org/</a> is a good starting point for
all things Scheme.

</li><li>Dorai Sitaram’s online Scheme tutorial, <em class="dfn">Teach Yourself Scheme in
Fixnum Days</em>, at
<a class="url" href="http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html">http://www.ccs.neu.edu/home/dorai/t-y-scheme/t-y-scheme.html</a>.
Includes a nice explanation of continuations.

</li><li>The complete text of <em class="dfn">Structure and Interpretation of Computer
Programs</em>, the classic introduction to computer science and Scheme by
Hal Abelson, Jerry Sussman and Julie Sussman, is now available online at
<a class="url" href="http://mitpress.mit.edu/sicp/sicp.html">http://mitpress.mit.edu/sicp/sicp.html</a>.  This site also provides
teaching materials related to the book, and all the source code used in
the book, in a form suitable for loading and running.
</li></ul>



<hr>
</div>
</div>
<div class="chapter-level-extent" id="Programming-in-Scheme">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="n" rel="next">Programming in C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hello-Scheme_0021" accesskey="p" rel="prev">Hello Scheme!</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Programming-in-Scheme-1">4 Programming in Scheme</h2>

<p>Guile’s core language is Scheme, and a lot can be achieved simply by using Guile
to write and run Scheme programs — as opposed to having to dive into C code.
In this part of the manual, we explain how to use Guile in this mode, and
describe the tools that Guile provides to help you with script writing,
debugging, and packaging your programs for distribution.
</p>
<p>For detailed reference information on the variables, functions, and so
on that make up Guile’s application programming interface (API), see
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference">API Reference</a>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scheme" accesskey="1">Guile’s Implementation of Scheme</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile" accesskey="2">Invoking Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="3">Guile Scripting</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="4">Using Guile Interactively</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-in-Emacs" accesskey="5">Using Guile in Emacs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Tools" accesskey="6">Using Guile Tools</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages" accesskey="7">Installing Site Packages</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Distributing-Guile-Code" accesskey="8">Distributing Guile Code</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Guile-Scheme">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile" accesskey="n" rel="next">Invoking Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Guile_0027s-Implementation-of-Scheme">4.1 Guile’s Implementation of Scheme</h3>

<p>Guile’s core language is Scheme, which is specified and described in the
series of reports known as <em class="dfn">RnRS</em>.  <em class="dfn">RnRS</em> is shorthand for the
<em class="dfn">Revised^n Report on the Algorithmic Language Scheme</em>.
Guile complies fully with R5RS (see <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Top">Introduction</a> in <cite class="cite">R5RS</cite>),
and is largely compliant with R6RS and R7RS.
</p>
<p>Guile also has many extensions that go beyond these reports.  Some of
the areas where Guile extends standard Scheme are:
</p>
<ul class="itemize mark-bullet">
<li>Guile’s interactive documentation system

</li><li>Guile’s support for POSIX-compliant network programming

</li><li>GOOPS – Guile’s framework for object oriented programming.
</li></ul>



<hr>
</div>
<div class="section-level-extent" id="Invoking-Guile">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="n" rel="next">Guile Scripting</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scheme" accesskey="p" rel="prev">Guile’s Implementation of Scheme</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Invoking-Guile-1">4.2 Invoking Guile</h3>
<a class="index-entry-id" id="index-invocation"></a>

<p>Many features of Guile depend on and can be changed by information that
the user provides either before or when Guile is started.  Below is a
description of what information to provide and how to provide it.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Command_002dline-Options" accesskey="1">Command-line Options</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Environment-Variables" accesskey="2">Environment Variables</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Command_002dline-Options">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Environment-Variables" accesskey="n" rel="next">Environment Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile" accesskey="u" rel="up">Invoking Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Command_002dline-Options-1">4.2.1 Command-line Options</h4>
<a class="index-entry-id" id="index-Command_002dline-Options"></a>
<a class="index-entry-id" id="index-command_002dline-arguments"></a>
<a class="index-entry-id" id="index-arguments-_0028command-line_0029"></a>
<a class="index-entry-id" id="index-options-_0028command-line_0029"></a>
<a class="index-entry-id" id="index-switches-_0028command-line_0029"></a>
<a class="index-entry-id" id="index-startup-_0028command_002dline-arguments_0029"></a>
<a class="index-entry-id" id="index-invocation-_0028command_002dline-arguments_0029"></a>

<p>Here we describe Guile’s command-line processing in detail.  Guile
processes its arguments from left to right, recognizing the switches
described below.  For examples, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples">Scripting Examples</a>.
</p>
<dl class="table">
<dt id="index-script-mode"><span><code class="code"><var class="var">script</var> <var class="var">arg...</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-script-mode"> ¶</a></span></dt>
<dt><code class="code">-s <var class="var">script</var> <var class="var">arg...</var></code></dt>
<dd><p>By default, Guile will read a file named on the command line as a
script.  Any command-line arguments <var class="var">arg...</var> following <var class="var">script</var>
become the script’s arguments; the <code class="code">command-line</code> function returns
a list of strings of the form <code class="code">(<var class="var">script</var> <var class="var">arg...</var>)</code>.
</p>
<p>It is possible to name a file using a leading hyphen, for example,
<samp class="file">-myfile.scm</samp>.  In this case, the file name must be preceded by
<samp class="option">-s</samp> to tell Guile that a (script) file is being named.
</p>
<p>Scripts are read and evaluated as Scheme source code just as the
<code class="code">load</code> function would.  After loading <var class="var">script</var>, Guile exits.
</p>
</dd>
<dt id="index-evaluate-expression_002c-command_002dline-argument"><span><code class="code">-c <var class="var">expr</var> <var class="var">arg...</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-evaluate-expression_002c-command_002dline-argument"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">expr</var> as Scheme code, and then exit.  Any command-line
arguments <var class="var">arg...</var> following <var class="var">expr</var> become command-line
arguments; the <code class="code">command-line</code> function returns a list of strings of
the form <code class="code">(<var class="var">guile</var> <var class="var">arg...</var>)</code>, where <var class="var">guile</var> is the
path of the Guile executable.
</p>
</dd>
<dt><code class="code">-- <var class="var">arg...</var></code></dt>
<dd><p>Run interactively, prompting the user for expressions and evaluating
them.  Any command-line arguments <var class="var">arg...</var> following the <samp class="option">--</samp>
become command-line arguments for the interactive session; the
<code class="code">command-line</code> function returns a list of strings of the form
<code class="code">(<var class="var">guile</var> <var class="var">arg...</var>)</code>, where <var class="var">guile</var> is the path of the
Guile executable.
</p>
</dd>
<dt><code class="code">-L <var class="var">directory</var></code></dt>
<dd><p>Add <var class="var">directory</var> to the front of Guile’s module load path.  The given
directories are searched in the order given on the command line and
before any directories in the <code class="env">GUILE_LOAD_PATH</code> environment
variable.  Paths added here are <em class="emph">not</em> in effect during execution of
the user’s <samp class="file">.guile</samp> file.
</p>
</dd>
<dt><code class="code">-C <var class="var">directory</var></code></dt>
<dd><p>Like <samp class="option">-L</samp>, but adjusts the load path for <em class="emph">compiled</em> files.
</p>
</dd>
<dt><code class="code">-x <var class="var">extension</var></code></dt>
<dd><p>Add <var class="var">extension</var> to the front of Guile’s load extension list
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths"><code class="code">%load-extensions</code></a>).  The specified extensions
are tried in the order given on the command line, and before the default
load extensions.  Extensions added here are <em class="emph">not</em> in effect during
execution of the user’s <samp class="file">.guile</samp> file.
</p>
</dd>
<dt><code class="code">-l <var class="var">file</var></code></dt>
<dd><p>Load Scheme source code from <var class="var">file</var>, and continue processing the
command line.
</p>
</dd>
<dt><code class="code">-e <var class="var">function</var></code></dt>
<dd><p>Make <var class="var">function</var> the <em class="dfn">entry point</em> of the script.  After loading
the script file (with <samp class="option">-s</samp>) or evaluating the expression (with
<samp class="option">-c</samp>), apply <var class="var">function</var> to a list containing the program name
and the command-line arguments—the list provided by the
<code class="code">command-line</code> function.
</p>
<p>A <samp class="option">-e</samp> switch can appear anywhere in the argument list, but Guile
always invokes the <var class="var">function</var> as the <em class="emph">last</em> action it performs.
This is weird, but because of the way script invocation works under
POSIX, the <samp class="option">-s</samp> option must always come last in the list.
</p>
<p>The <var class="var">function</var> is most often a simple symbol that names a function
that is defined in the script.  It can also be of the form <code class="code">(@
<var class="var">module-name</var> <var class="var">symbol</var>)</code>, and in that case, the symbol is
looked up in the module named <var class="var">module-name</var>.
</p>
<p>As a shorthand you can use the form <code class="code">(symbol ...)</code>, that is, a list
of only symbols that doesn’t start with <code class="code">@</code>.  It is equivalent to
<code class="code">(@ <var class="var">module-name</var> main)</code>, where <var class="var">module-name</var> is
<code class="code">(symbol ...)</code> form.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules">Using Guile Modules</a> and <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples">Scripting Examples</a>.
</p>
</dd>
<dt><code class="code">-ds</code></dt>
<dd><p>Treat a final <samp class="option">-s</samp> option as if it occurred at this point in the
command line; load the script here.
</p>
<p>This switch is necessary because, although the POSIX script invocation
mechanism effectively requires the <samp class="option">-s</samp> option to appear last, the
programmer may well want to run the script before other actions
requested on the command line.  For examples, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples">Scripting Examples</a>.
</p>
</dd>
<dt><code class="code">\</code></dt>
<dd><p>Read more command-line arguments, starting from the second line of the
script file.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch">The Meta Switch</a>.
</p>
</dd>
<dt id="index-loading-srfi-modules-_0028command-line_0029"><span><code class="code">--use-srfi=<var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-loading-srfi-modules-_0028command-line_0029"> ¶</a></span></dt>
<dd><p>The option <samp class="option">--use-srfi</samp> expects a comma-separated list of numbers,
each representing a SRFI module to be loaded into the interpreter
before evaluating a script file or starting the REPL.  Additionally,
the feature identifier for the loaded SRFIs is recognized by
the procedure <code class="code">cond-expand</code> when this option is used.
</p>
<p>Here is an example that loads the modules SRFI-8 (’receive’) and SRFI-13
(’string library’) before the GUILE interpreter is started:
</p>
<div class="example">
<pre class="example-preformatted">guile --use-srfi=8,13
</pre></div>

</dd>
<dt id="index-r6rs-_0028command-line_0029"><span><code class="code">--r6rs</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-r6rs-_0028command-line_0029"> ¶</a></span></dt>
<dd><p>Adapt Guile’s initial environment to better support R6RS.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Incompatibilities">Incompatibilities with the R6RS</a>, for some caveats.
</p>
</dd>
<dt id="index-r7rs-_0028command-line_0029"><span><code class="code">--r7rs</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-r7rs-_0028command-line_0029"> ¶</a></span></dt>
<dd><p>Adapt Guile’s initial environment to better support R7RS.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Incompatibilities">Incompatibilities with the R7RS</a>, for some caveats.
</p>
</dd>
<dt id="index-debugging-virtual-machine-_0028command-line_0029"><span><code class="code">--debug</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debugging-virtual-machine-_0028command-line_0029"> ¶</a></span></dt>
<dd><p>Start with the debugging virtual machine (VM) engine.  Using the
debugging VM will enable support for VM hooks, which are needed for
tracing, breakpoints, and accurate call counts when profiling.  The
debugging VM is slower than the regular VM, though, by about ten
percent.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks">VM Hooks</a>, for more information.
</p>
<p>By default, the debugging VM engine is only used when entering an
interactive session.  When executing a script with <samp class="option">-s</samp> or
<samp class="option">-c</samp>, the normal, faster VM is used by default.
</p>

</dd>
<dt id="index-debugging-virtual-machine-_0028command-line_0029-1"><span><code class="code">--no-debug</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debugging-virtual-machine-_0028command-line_0029-1"> ¶</a></span></dt>
<dd><p>Do not use the debugging VM engine, even when entering an interactive
session.
</p>
<p>Note that, despite the name, Guile running with <samp class="option">--no-debug</samp>
<em class="emph">does</em> support the usual debugging facilities, such as printing a
detailed backtrace upon error.  The only difference with
<samp class="option">--debug</samp> is lack of support for VM hooks and the facilities that
build upon it (see above).
</p>
</dd>
<dt id="index-init-file_002c-not-loading"><span><code class="code">-q</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-init-file_002c-not-loading"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-_002eguile-file_002c-not-loading"></a>
<p>Do not load the initialization file, <samp class="file">.guile</samp>.  This option only
has an effect when running interactively; running scripts does not load
the <samp class="file">.guile</samp> file.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Init-File">The Init File, <samp class="file">~/.guile</samp></a>.
</p>
</dd>
<dt><code class="code">--listen[=<var class="var">p</var>]</code></dt>
<dd><p>While this program runs, listen on a local port or a path for REPL
clients.  If <var class="var">p</var> starts with a number, it is assumed to be a local
port on which to listen.  If it starts with a forward slash, it is
assumed to be the file name of a UNIX domain socket on which to listen.
</p>
<p>If <var class="var">p</var> is not given, the default is local port 37146.  If you look
at it upside down, it almost spells “Guile”.  If you have netcat
installed, you should be able to <kbd class="kbd">nc localhost 37146</kbd> and get a
Guile prompt.  Alternately you can fire up Emacs and connect to the
process; see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-in-Emacs">Using Guile in Emacs</a> for more details.
</p>
<blockquote class="quotation">
<p><b class="b">Note:</b> Opening a port allows anyone who can connect to that port to do anything
Guile can do, as the user
that the Guile process is running as.  Do not use <samp class="option">--listen</samp> on
multi-user machines.  Of course, if you do not pass <samp class="option">--listen</samp> to
Guile, no port will be opened.
</p>
<p>Guile protects against the
<a class="uref" href="https://en.wikipedia.org/wiki/Inter-protocol_exploitation"><em class="dfn">HTTP inter-protocol exploitation attack</em></a>, a scenario whereby an
attacker can, <i class="i">via</i> an HTML page, cause a web browser to send data to
TCP servers listening on a loopback interface or private network.
Nevertheless, you are advised to use UNIX domain sockets, as in
<code class="code">--listen=/some/local/file</code>, whenever possible.
</p></blockquote>

<p>That said, <samp class="option">--listen</samp> is great for interactive debugging and
development.
</p>


</dd>
<dt><code class="code">--auto-compile</code></dt>
<dd><p>Compile source files automatically (default behavior).
</p>


</dd>
<dt><code class="code">--fresh-auto-compile</code></dt>
<dd><p>Treat the auto-compilation cache as invalid, forcing recompilation.
</p>


</dd>
<dt><code class="code">--no-auto-compile</code></dt>
<dd><p>Disable automatic source file compilation.
</p>


</dd>
<dt><code class="code">--language=<var class="var">lang</var></code></dt>
<dd><p>For the remainder of the command line arguments, assume that files
mentioned with <code class="code">-l</code> and expressions passed with <code class="code">-c</code> are
written in <var class="var">lang</var>.  <var class="var">lang</var> must be the name of one of the
languages supported by the compiler (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiler-Tower">Compiler Tower</a>).  When run
interactively, set the REPL’s language to <var class="var">lang</var> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively">Using Guile Interactively</a>).
</p>
<p>The default language is <code class="code">scheme</code>; other interesting values include
<code class="code">elisp</code> (for Emacs Lisp), and <code class="code">ecmascript</code>.
</p>
<p>The example below shows the evaluation of expressions in Scheme, Emacs
Lisp, and ECMAScript:
</p>
<div class="example">
<pre class="example-preformatted">guile -c "(apply + '(1 2))"
guile --language=elisp -c "(= (funcall (symbol-function '+) 1 2) 3)"
guile --language=ecmascript -c '(function (x) { return x * x; })(2);'
</pre></div>

<p>To load a file written in Scheme and one written in Emacs Lisp, and then
start a Scheme REPL, type:
</p>
<div class="example">
<pre class="example-preformatted">guile -l foo.scm --language=elisp -l foo.el --language=scheme
</pre></div>



</dd>
<dt><code class="code">-h<span class="r">, </span>--help</code></dt>
<dd><p>Display help on invoking Guile, and then exit.
</p>
</dd>
<dt><code class="code">-v<span class="r">, </span>--version</code></dt>
<dd><p>Display the current version of Guile, and then exit.
</p>
</dd>
</dl>

<hr>
</div>
<div class="subsection-level-extent" id="Environment-Variables">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Command_002dline-Options" accesskey="p" rel="prev">Command-line Options</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile" accesskey="u" rel="up">Invoking Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Environment-Variables-1">4.2.2 Environment Variables</h4>
<a class="index-entry-id" id="index-environment-variables"></a>
<a class="index-entry-id" id="index-shell"></a>
<a class="index-entry-id" id="index-initialization"></a>
<p>The <em class="dfn">environment</em> is a feature of the operating system; it consists
of a collection of variables with names and values.  Each variable is
called an <em class="dfn">environment variable</em> (or, sometimes, a “shell
variable”); environment variable names are case-sensitive, and it is
conventional to use upper-case letters only.  The values are all text
strings, even those that are written as numerals.  (Note that here we
are referring to names and values that are defined in the operating
system shell from which Guile is invoked.  This is not the same as a
Scheme environment that is defined within a running instance of Guile.
For a description of Scheme environments, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Environments">Names, Locations, Values and Environments</a>.)
</p>   
<p>How to set environment variables before starting Guile depends on the
operating system and, especially, the shell that you are using.  For
example, here is how to tell Guile to provide detailed warning messages
about deprecated features by setting <code class="env">GUILE_WARN_DEPRECATED</code> using
Bash:
</p>
<div class="example">
<pre class="example-preformatted">$ export GUILE_WARN_DEPRECATED="detailed"
$ guile
</pre></div>

<p>Or, detailed warnings can be turned on for a single invocation using:
</p>
<div class="example">
<pre class="example-preformatted">$ env GUILE_WARN_DEPRECATED="detailed" guile
</pre></div>

<p>If you wish to retrieve or change the value of the shell environment
variables that affect the run-time behavior of Guile from within a
running instance of Guile, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment">Runtime Environment</a>.
</p>
<p>Here are the environment variables that affect the run-time behavior of
Guile:
</p>
<dl class="table">
<dt id="index-GUILE_005fAUTO_005fCOMPILE"><span><code class="env">GUILE_AUTO_COMPILE</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fAUTO_005fCOMPILE"> ¶</a></span></dt>
<dd><p>This is a flag that can be used to tell Guile whether or not to compile
Scheme source files automatically.  Starting with Guile 2.0, Scheme
source files will be compiled automatically, by default.
</p>
<p>If a compiled (<samp class="file">.go</samp>) file corresponding to a <samp class="file">.scm</samp> file is
not found or is not newer than the <samp class="file">.scm</samp> file, the <samp class="file">.scm</samp>
file will be compiled on the fly, and the resulting <samp class="file">.go</samp> file
stored away.  An advisory note will be printed on the console.
</p>
<p>Compiled files will be stored in the directory
<samp class="file">$XDG_CACHE_HOME/guile/ccache</samp>, where <code class="env">XDG_CACHE_HOME</code>
defaults to the directory <samp class="file">$HOME/.cache</samp>.  This directory will be
created if it does not already exist.
</p>
<p>Note that this mechanism depends on the timestamp of the <samp class="file">.go</samp> file
being newer than that of the <samp class="file">.scm</samp> file; if the <samp class="file">.scm</samp> or
<samp class="file">.go</samp> files are moved after installation, care should be taken to
preserve their original timestamps.
</p>
<p>Set <code class="env">GUILE_AUTO_COMPILE</code> to zero (0), to prevent Scheme files from
being compiled automatically.  Set this variable to “fresh” to tell
Guile to compile Scheme files whether they are newer than the compiled
files or not.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>.
</p>
</dd>
<dt id="index-GUILE_005fHISTORY-1"><span><code class="env">GUILE_HISTORY</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fHISTORY-1"> ¶</a></span></dt>
<dd><p>This variable names the file that holds the Guile REPL command history.
You can specify a different history file by setting this environment
variable.  By default, the history file is <samp class="file">$HOME/.guile_history</samp>.
</p>
</dd>
<dt id="index-GUILE_005fINSTALL_005fLOCALE"><span><code class="env">GUILE_INSTALL_LOCALE</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fINSTALL_005fLOCALE"> ¶</a></span></dt>
<dd><p>This is a flag that can be used to tell Guile whether or not to install
the current locale at startup, via a call to <code class="code">(setlocale LC_ALL
"")</code><a class="footnote" id="DOCF2" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT2"><sup>2</sup></a>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>, for more
information on locales.
</p>
<p>You may explicitly indicate that you do not want to install
the locale by setting <code class="env">GUILE_INSTALL_LOCALE</code> to <code class="code">0</code>, or
explicitly enable it by setting the variable to <code class="code">1</code>.
</p>
<p>Usually, installing the current locale is the right thing to do.  It
allows Guile to correctly parse and print strings with non-ASCII
characters.  Therefore, this option is on by default.
</p>
</dd>
<dt id="index-GUILE_005fLOAD_005fCOMPILED_005fPATH"><span><code class="env">GUILE_LOAD_COMPILED_PATH</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fLOAD_005fCOMPILED_005fPATH"> ¶</a></span></dt>
<dd><p>This variable may be used to augment the path that is searched for
compiled Scheme files (<samp class="file">.go</samp> files) when loading.  Its value should
be a colon-separated list of directories.  If it contains the special
path component <code class="code">...</code> (ellipsis), then the default path is put in
place of the ellipsis, otherwise the default path is placed at the end.
The result is stored in <code class="code">%load-compiled-path</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>).
</p>
<p>Here is an example using the Bash shell that adds the current directory,
<samp class="file">.</samp>, and the relative directory <samp class="file">../my-library</samp> to
<code class="code">%load-compiled-path</code>:
</p>
<div class="example">
<pre class="example-preformatted">$ export GUILE_LOAD_COMPILED_PATH=".:../my-library"
$ guile -c '(display %load-compiled-path) (newline)'
(. ../my-library /usr/local/lib/guile/3.0/ccache)
</pre></div>

</dd>
<dt id="index-GUILE_005fLOAD_005fPATH"><span><code class="env">GUILE_LOAD_PATH</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fLOAD_005fPATH"> ¶</a></span></dt>
<dd><p>This variable may be used to augment the path that is searched for
Scheme files when loading.  Its value should be a colon-separated list
of directories.  If it contains the special path component <code class="code">...</code>
(ellipsis), then the default path is put in place of the ellipsis,
otherwise the default path is placed at the end.  The result is stored
in <code class="code">%load-path</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>).
</p>
<p>Here is an example using the Bash shell that prepends the current
directory to <code class="code">%load-path</code>, and adds the relative directory
<samp class="file">../srfi</samp> to the end:
</p>
<div class="example">
<pre class="example-preformatted">$ env GUILE_LOAD_PATH=".:...:../srfi" \
guile -c '(display %load-path) (newline)'
(. /usr/local/share/guile/3.0 \
/usr/local/share/guile/site/3.0 \
/usr/local/share/guile/site \
/usr/local/share/guile \
../srfi)
</pre></div>

<p>(Note: The line breaks, above, are for documentation purposes only, and
not required in the actual example.)
</p>
</dd>
<dt id="index-GUILE_005fEXTENSIONS_005fPATH"><span><code class="env">GUILE_EXTENSIONS_PATH</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fEXTENSIONS_005fPATH"> ¶</a></span></dt>
<dd><p>This variable may be used to augment the path that is searched for
foreign libraries via <code class="code">load-extension</code>, <code class="code">dynamic-link</code>,
<code class="code">load-foreign-library</code>, or the like.  Its value should be a
colon-separated (semicolon on Windows) list of directories.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Libraries">Foreign Libraries</a>.
</p>
</dd>
<dt id="index-GUILE_005fWARN_005fDEPRECATED"><span><code class="env">GUILE_WARN_DEPRECATED</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fWARN_005fDEPRECATED"> ¶</a></span></dt>
<dd><p>As Guile evolves, some features will be eliminated or replaced by newer
features.  To help users migrate their code as this evolution occurs,
Guile will issue warning messages about code that uses features that
have been marked for eventual elimination.  <code class="env">GUILE_WARN_DEPRECATED</code>
can be set to “no” to tell Guile not to display these warning
messages, or set to “detailed” to tell Guile to display more lengthy
messages describing the warning.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation">Deprecation</a>.
</p>
</dd>
<dt id="index-HOME"><span><code class="env">HOME</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-HOME"> ¶</a></span></dt>
<dd><p>Guile uses the environment variable <code class="env">HOME</code>, the name of your home
directory, to locate various files, such as <samp class="file">.guile</samp> or
<samp class="file">.guile_history</samp>.
</p>
</dd>
<dt id="index-GUILE_005fJIT_005fTHRESHOLD"><span><code class="env">GUILE_JIT_THRESHOLD</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fJIT_005fTHRESHOLD"> ¶</a></span></dt>
<dd><p>Guile has a just-in-time (JIT) code generator that makes running Guile
code fast.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Just_002dIn_002dTime-Native-Code">Just-In-Time Native Code</a>, for more.  The unit of code
generation is the function.  Each function has its own counter that gets
incremented when the function is called and at each loop iteration in
the function.  When the counter exceeds the <code class="env">GUILE_JIT_THRESHOLD</code>,
the function will get JIT-compiled.  Set <code class="env">GUILE_JIT_THRESHOLD</code> to
<code class="code">-1</code> to disable JIT compilation, or <code class="code">0</code> to eagerly JIT-compile
each function as it’s first seen.
</p>
</dd>
<dt id="index-GUILE_005fJIT_005fLOG"><span><code class="env">GUILE_JIT_LOG</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fJIT_005fLOG"> ¶</a></span></dt>
<dd><p>Set to <code class="code">1</code>, <code class="code">2</code>, or <code class="code">3</code> to give increasing amounts of
logging for JIT compilation events.  Used for debugging.
</p>
</dd>
<dt id="index-GUILE_005fJIT_005fSTOP_005fAFTER"><span><code class="env">GUILE_JIT_STOP_AFTER</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fJIT_005fSTOP_005fAFTER"> ¶</a></span></dt>
<dd><p>Though we have tested the JIT compiler as well as we can, it’s possible
that it has bugs.  If you suspect that Guile’s JIT compiler is causing
your program to fail, set <code class="env">GUILE_JIT_STOP_AFTER</code> to a positive
integer indicating the maximum number of functions to JIT-compile.  By
bisecting over the value of <code class="env">GUILE_JIT_STOP_AFTER</code>, you can pinpoint
the precise function that is being miscompiled.
</p>
</dd>
</dl>


<hr>
</div>
</div>
<div class="section-level-extent" id="Guile-Scripting">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="n" rel="next">Using Guile Interactively</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile" accesskey="p" rel="prev">Invoking Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Guile-Scripting-1">4.3 Guile Scripting</h3>

<p>Like AWK, Perl, or any shell, Guile can interpret script files.  A Guile
script is simply a file of Scheme code with some extra information at
the beginning which tells the operating system how to invoke Guile, and
then tells Guile how to handle the Scheme code.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#The-Top-of-a-Script-File" accesskey="1">The Top of a Script File</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch" accesskey="2">The Meta Switch</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Handling" accesskey="3">Command Line Handling</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples" accesskey="4">Scripting Examples</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="The-Top-of-a-Script-File">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch" accesskey="n" rel="next">The Meta Switch</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="u" rel="up">Guile Scripting</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="The-Top-of-a-Script-File-1">4.3.1 The Top of a Script File</h4>

<p>The first line of a Guile script must tell the operating system to use
Guile to evaluate the script, and then tell Guile how to go about doing
that.  Here is the simplest case:
</p>
<ul class="itemize mark-bullet">
<li>The first two characters of the file must be ‘<samp class="samp">#!</samp>’.

<p>The operating system interprets this to mean that the rest of the line
is the name of an executable that can interpret the script.  Guile,
however, interprets these characters as the beginning of a multi-line
comment, terminated by the characters ‘<samp class="samp">!#</samp>’ on a line by themselves.
(This is an extension to the syntax described in R5RS, added to support
shell scripts.)
</p>
</li><li>Immediately after those two characters must come the full pathname to
the Guile interpreter.  On most systems, this would be
‘<samp class="samp">/usr/local/bin/guile</samp>’.

</li><li>Then must come a space, followed by a command-line argument to pass to
Guile; this should be ‘<samp class="samp">-s</samp>’.  This switch tells Guile to run a
script, instead of soliciting the user for input from the terminal.
There are more elaborate things one can do here; see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch">The Meta Switch</a>.

</li><li>Follow this with a newline.

</li><li>The second line of the script should contain only the characters
‘<samp class="samp">!#</samp>’ — just like the top of the file, but reversed.  The
operating system never reads this far, but Guile treats this as the end
of the comment begun on the first line by the ‘<samp class="samp">#!</samp>’ characters.

</li><li>If this source code file is not ASCII or ISO-8859-1 encoded, a coding
declaration such as <code class="code">coding: utf-8</code> should appear in a comment
somewhere in the first five lines of the file: see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files">Character Encoding of Source Files</a>.

</li><li>The rest of the file should be a Scheme program.

</li></ul>

<p>Guile reads the program, evaluating expressions in the order that they
appear.  Upon reaching the end of the file, Guile exits.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="The-Meta-Switch">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Handling" accesskey="n" rel="next">Command Line Handling</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-Top-of-a-Script-File" accesskey="p" rel="prev">The Top of a Script File</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="u" rel="up">Guile Scripting</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="The-Meta-Switch-1">4.3.2 The Meta Switch</h4>

<p>Guile’s command-line switches allow the programmer to describe
reasonably complicated actions in scripts.  Unfortunately, the POSIX
script invocation mechanism only allows one argument to appear on the
‘<samp class="samp">#!</samp>’ line after the path to the Guile executable, and imposes
arbitrary limits on that argument’s length.  Suppose you wrote a script
starting like this:
</p><div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile -e main -s
!#
(define (main args)
  (map (lambda (arg) (display arg) (display " "))
       (cdr args))
  (newline))
</pre></div>
<p>The intended meaning is clear: load the file, and then call <code class="code">main</code>
on the command-line arguments.  However, the system will treat
everything after the Guile path as a single argument — the string
<code class="code">"-e main -s"</code> — which is not what we want.
</p>
<p>As a workaround, the meta switch <code class="code">\</code> allows the Guile programmer to
specify an arbitrary number of options without patching the kernel.  If
the first argument to Guile is <code class="code">\</code>, Guile will open the script file
whose name follows the <code class="code">\</code>, parse arguments starting from the
file’s second line (according to rules described below), and substitute
them for the <code class="code">\</code> switch.
</p>
<p>Working in concert with the meta switch, Guile treats the characters
‘<samp class="samp">#!</samp>’ as the beginning of a comment which extends through the next
line containing only the characters ‘<samp class="samp">!#</samp>’.  This sort of comment may
appear anywhere in a Guile program, but it is most useful at the top of
a file, meshing magically with the POSIX script invocation mechanism.
</p>
<p>Thus, consider a script named <samp class="file">/u/jimb/ekko</samp> which starts like this:
</p><div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile \
-e main -s
!#
(define (main args)
        (map (lambda (arg) (display arg) (display " "))
             (cdr args))
        (newline))
</pre></div>

<p>Suppose a user invokes this script as follows:
</p><div class="example">
<pre class="example-preformatted">$ /u/jimb/ekko a b c
</pre></div>

<p>Here’s what happens:
</p><ul class="itemize mark-bullet">
<li>the operating system recognizes the ‘<samp class="samp">#!</samp>’ token at the top of the
file, and rewrites the command line to:
<div class="example">
<pre class="example-preformatted">/usr/local/bin/guile \ /u/jimb/ekko a b c
</pre></div>
<p>This is the usual behavior, prescribed by POSIX.
</p>
</li><li>When Guile sees the first two arguments, <code class="code">\ /u/jimb/ekko</code>, it opens
<samp class="file">/u/jimb/ekko</samp>, parses the three arguments <code class="code">-e</code>, <code class="code">main</code>,
and <code class="code">-s</code> from it, and substitutes them for the <code class="code">\</code> switch.
Thus, Guile’s command line now reads:
<div class="example">
<pre class="example-preformatted">/usr/local/bin/guile -e main -s /u/jimb/ekko a b c
</pre></div>

</li><li>Guile then processes these switches: it loads <samp class="file">/u/jimb/ekko</samp> as a
file of Scheme code (treating the first three lines as a comment), and
then performs the application <code class="code">(main "/u/jimb/ekko" "a" "b" "c")</code>.

</li></ul>


<p>When Guile sees the meta switch <code class="code">\</code>, it parses command-line
argument from the script file according to the following rules:
</p><ul class="itemize mark-bullet">
<li>Each space character terminates an argument.  This means that two
spaces in a row introduce an argument <code class="code">""</code>.

</li><li>The tab character is not permitted (unless you quote it with the
backslash character, as described below), to avoid confusion.

</li><li>The newline character terminates the sequence of arguments, and will
also terminate a final non-empty argument.  (However, a newline
following a space will not introduce a final empty-string argument;
it only terminates the argument list.)

</li><li>The backslash character is the escape character.  It escapes backslash,
space, tab, and newline.  The ANSI C escape sequences like <code class="code">\n</code> and
<code class="code">\t</code> are also supported.  These produce argument constituents; the
two-character combination <code class="code">\n</code> doesn’t act like a terminating
newline.  The escape sequence <code class="code">\<var class="var">NNN</var></code> for exactly three octal
digits reads as the character whose ASCII code is <var class="var">NNN</var>.  As above,
characters produced this way are argument constituents.  Backslash
followed by other characters is not allowed.

</li></ul>


<hr>
</div>
<div class="subsection-level-extent" id="Command-Line-Handling">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scripting-Examples" accesskey="n" rel="next">Scripting Examples</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch" accesskey="p" rel="prev">The Meta Switch</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="u" rel="up">Guile Scripting</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Command-Line-Handling-1">4.3.3 Command Line Handling</h4>


<p>The ability to accept and handle command line arguments is very
important when writing Guile scripts to solve particular problems, such
as extracting information from text files or interfacing with existing
command line applications.  This chapter describes how Guile makes
command line arguments available to a Guile script, and the utilities
that Guile provides to help with the processing of command line
arguments.
</p>
<p>When a Guile script is invoked, Guile makes the command line arguments
accessible via the procedure <code class="code">command-line</code>, which returns the
arguments as a list of strings.
</p>
<p>For example, if the script
</p>
<div class="example">
<pre class="example-preformatted">#! /usr/local/bin/guile -s
!#
(write (command-line))
(newline)
</pre></div>

<p>is saved in a file <samp class="file">cmdline-test.scm</samp> and invoked using the command
line <code class="code">./cmdline-test.scm bar.txt -o foo -frumple grob</code>, the output
is
</p>
<div class="example">
<pre class="example-preformatted">("./cmdline-test.scm" "bar.txt" "-o" "foo" "-frumple" "grob")
</pre></div>

<p>If the script invocation includes a <code class="code">-e</code> option, specifying a
procedure to call after loading the script, Guile will call that
procedure with <code class="code">(command-line)</code> as its argument.  So a script that
uses <code class="code">-e</code> doesn’t need to refer explicitly to <code class="code">command-line</code>
in its code.  For example, the script above would have identical
behaviour if it was written instead like this:
</p>
<div class="example">
<pre class="example-preformatted">#! /usr/local/bin/guile \
-e main -s
!#
(define (main args)
  (write args)
  (newline))
</pre></div>

<p>(Note the use of the meta switch <code class="code">\</code> so that the script invocation
can include more than one Guile option: See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Meta-Switch">The Meta Switch</a>.)
</p>
<p>These scripts use the <code class="code">#!</code> POSIX convention so that they can be
executed using their own file names directly, as in the example command
line <code class="code">./cmdline-test.scm bar.txt -o foo -frumple grob</code>.  But they
can also be executed by typing out the implied Guile command line in
full, as in:
</p>
<div class="example">
<pre class="example-preformatted">$ guile -s ./cmdline-test.scm bar.txt -o foo -frumple grob
</pre></div>

<p>or
</p>
<div class="example">
<pre class="example-preformatted">$ guile -e main -s ./cmdline-test2.scm bar.txt -o foo -frumple grob
</pre></div>

<p>Even when a script is invoked using this longer form, the arguments that
the script receives are the same as if it had been invoked using the
short form.  Guile ensures that the <code class="code">(command-line)</code> or <code class="code">-e</code>
arguments are independent of how the script is invoked, by stripping off
the arguments that Guile itself processes.
</p>
<p>A script is free to parse and handle its command line arguments in any
way that it chooses.  Where the set of possible options and arguments is
complex, however, it can get tricky to extract all the options, check
the validity of given arguments, and so on.  This task can be greatly
simplified by taking advantage of the module <code class="code">(ice-9 getopt-long)</code>,
which is distributed with Guile, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong">The (ice-9 getopt-long) Module</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Scripting-Examples">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Handling" accesskey="p" rel="prev">Command Line Handling</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="u" rel="up">Guile Scripting</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Scripting-Examples-1">4.3.4 Scripting Examples</h4>

<p>To start with, here are some examples of invoking Guile directly:
</p>
<dl class="table">
<dt><code class="code">guile -- a b c</code></dt>
<dd><p>Run Guile interactively; <code class="code">(command-line)</code> will return <br>
<code class="code">("/usr/local/bin/guile" "a" "b" "c")</code>.
</p>
</dd>
<dt><code class="code">guile -s /u/jimb/ex2 a b c</code></dt>
<dd><p>Load the file <samp class="file">/u/jimb/ex2</samp>; <code class="code">(command-line)</code> will return <br>
<code class="code">("/u/jimb/ex2" "a" "b" "c")</code>.
</p>
</dd>
<dt><code class="code">guile -c '(write %load-path) (newline)'</code></dt>
<dd><p>Write the value of the variable <code class="code">%load-path</code>, print a newline,
and exit.
</p>
</dd>
<dt><code class="code">guile -e main -s /u/jimb/ex4 foo</code></dt>
<dd><p>Load the file <samp class="file">/u/jimb/ex4</samp>, and then call the function
<code class="code">main</code>, passing it the list <code class="code">("/u/jimb/ex4" "foo")</code>.
</p>
</dd>
<dt><code class="code">guile -e '(ex4)' -s /u/jimb/ex4.scm foo</code></dt>
<dd><p>Load the file <samp class="file">/u/jimb/ex4.scm</samp>, and then call the function
<code class="code">main</code> from the module ’(ex4)’, passing it the list
<code class="code">("/u/jimb/ex4" "foo")</code>.
</p>
</dd>
<dt><code class="code">guile -l first -ds -l last -s script</code></dt>
<dd><p>Load the files <samp class="file">first</samp>, <samp class="file">script</samp>, and <samp class="file">last</samp>, in that
order.  The <code class="code">-ds</code> switch says when to process the <code class="code">-s</code>
switch.  For a more motivated example, see the scripts below.
</p>
</dd>
</dl>


<p>Here is a very simple Guile script:
</p><div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile -s
!#
(display "Hello, world!")
(newline)
</pre></div>
<p>The first line marks the file as a Guile script.  When the user invokes
it, the system runs <samp class="file">/usr/local/bin/guile</samp> to interpret the script,
passing <code class="code">-s</code>, the script’s filename, and any arguments given to the
script as command-line arguments.  When Guile sees <code class="code">-s
<var class="var">script</var></code>, it loads <var class="var">script</var>.  Thus, running this program
produces the output:
</p><div class="example">
<pre class="example-preformatted">Hello, world!
</pre></div>

<p>Here is a script which prints the factorial of its argument:
</p><div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile -s
!#
(define (fact n)
  (if (zero? n) 1
    (* n (fact (- n 1)))))

(display (fact (string-&gt;number (cadr (command-line)))))
(newline)
</pre></div>
<p>In action:
</p><div class="example">
<pre class="example-preformatted">$ ./fact 5
120
$
</pre></div>

<p>However, suppose we want to use the definition of <code class="code">fact</code> in this
file from another script.  We can’t simply <code class="code">load</code> the script file,
and then use <code class="code">fact</code>’s definition, because the script will try to
compute and display a factorial when we load it.  To avoid this problem,
we might write the script this way:
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile \
-e main -s
!#
(define (fact n)
  (if (zero? n) 1
    (* n (fact (- n 1)))))

(define (main args)
  (display (fact (string-&gt;number (cadr args))))
  (newline))
</pre></div>
<p>This version packages the actions the script should perform in a
function, <code class="code">main</code>.  This allows us to load the file purely for its
definitions, without any extraneous computation taking place.  Then we
used the meta switch <code class="code">\</code> and the entry point switch <code class="code">-e</code> to
tell Guile to call <code class="code">main</code> after loading the script.
</p><div class="example">
<pre class="example-preformatted">$ ./fact 50
30414093201713378043612608166064768844377641568960512000000000000
</pre></div>

<p>Suppose that we now want to write a script which computes the
<code class="code">choose</code> function: given a set of <var class="var">m</var> distinct objects,
<code class="code">(choose <var class="var">n</var> <var class="var">m</var>)</code> is the number of distinct subsets
containing <var class="var">n</var> objects each.  It’s easy to write <code class="code">choose</code> given
<code class="code">fact</code>, so we might write the script this way:
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile \
-l fact -e main -s
!#
(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string-&gt;number (cadr args)))
        (m (string-&gt;number (caddr args))))
    (display (choose n m))
    (newline)))
</pre></div>

<p>The command-line arguments here tell Guile to first load the file
<samp class="file">fact</samp>, and then run the script, with <code class="code">main</code> as the entry
point.  In other words, the <code class="code">choose</code> script can use definitions
made in the <code class="code">fact</code> script.  Here are some sample runs:
</p><div class="example">
<pre class="example-preformatted">$ ./choose 0 4
1
$ ./choose 1 4
4
$ ./choose 2 4
6
$ ./choose 3 4
4
$ ./choose 4 4
1
$ ./choose 50 100
100891344545564193334812497256
</pre></div>

<p>To call a specific procedure from a given module, we can use the special
form <code class="code">(@ (<var class="var">module</var>) <var class="var">procedure</var>)</code>:
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile \
-l fact -e (@ (fac) main) -s
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string-&gt;number (cadr args)))
        (m (string-&gt;number (caddr args))))
    (display (choose n m))
    (newline)))
</pre></div>

<p>We can use <code class="code">@@</code> to invoke non-exported procedures.  For exported
procedures, we can simplify this call with the shorthand
<code class="code">(<var class="var">module</var>)</code>:
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/local/bin/guile \
-l fact -e (fac) -s
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string-&gt;number (cadr args)))
        (m (string-&gt;number (caddr args))))
    (display (choose n m))
    (newline)))
</pre></div>

<p>For maximum portability, we can instead use the shell to execute
<code class="command">guile</code> with specified command line arguments.  Here we need to
take care to quote the command arguments correctly:
</p>
<div class="example">
<pre class="example-preformatted">#!/usr/bin/env sh
exec guile -l fact -e '(@ (fac) main)' -s "$0" "$@"
!#
(define-module (fac)
  #:export (main))

(define (choose n m)
  (/ (fact m) (* (fact (- m n)) (fact n))))

(define (main args)
  (let ((n (string-&gt;number (cadr args)))
        (m (string-&gt;number (caddr args))))
    (display (choose n m))
    (newline)))
</pre></div>

<p>Finally, seasoned scripters are probably missing a mention of
subprocesses.  In Bash, for example, most shell scripts run other
programs like <code class="code">sed</code> or the like to do the actual work.
</p>
<p>In Guile it’s often possible get everything done within Guile itself, so
do give that a try first.  But if you just need to run a program and
wait for it to finish, use <code class="code">system*</code>.  If you need to run a
sub-program and capture its output, or give it input, use
<code class="code">open-pipe</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>, and See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Pipes">Pipes</a>, for more
information.
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="Using-Guile-Interactively">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-in-Emacs" accesskey="n" rel="next">Using Guile in Emacs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting" accesskey="p" rel="prev">Guile Scripting</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Using-Guile-Interactively-1">4.4 Using Guile Interactively</h3>

<p>When you start up Guile by typing just <code class="code">guile</code>, without a
<code class="code">-c</code> argument or the name of a script to execute, you get an
interactive interpreter where you can enter Scheme expressions, and
Guile will evaluate them and print the results for you.  Here are some
simple examples.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (+ 3 4 5)
$1 = 12
scheme@(guile-user)&gt; (display "Hello world!\n")
Hello world!
scheme@(guile-user)&gt; (values 'a 'b)
$2 = a
$3 = b
</pre></div>

<p>This mode of use is called a <em class="dfn">REPL</em>, which is short for
“Read-Eval-Print Loop”, because the Guile interpreter first reads the
expression that you have typed, then evaluates it, and then prints the
result.
</p>
<p>The prompt shows you what language and module you are in. In this case, the
current language is <code class="code">scheme</code>, and the current module is
<code class="code">(guile-user)</code>. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages">Support for Other Languages</a>, for more information on Guile’s
support for languages other than Scheme.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Init-File" accesskey="1">The Init File, <samp class="file">~/.guile</samp></a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Readline" accesskey="2">Readline</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Value-History" accesskey="3">Value History</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="4">REPL Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Handling" accesskey="5">Error Handling</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Debugging" accesskey="6">Interactive Debugging</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Init-File">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Readline" accesskey="n" rel="next">Readline</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="The-Init-File_002c-_007e_002f_002eguile">4.4.1 The Init File, <samp class="file">~/.guile</samp></h4>

<a class="index-entry-id" id="index-_002eguile"></a>
<p>When run interactively, Guile will load a local initialization file from
<samp class="file">~/.guile</samp>.  This file should contain Scheme expressions for
evaluation.
</p>
<p>This facility lets the user customize their interactive Guile
environment, pulling in extra modules or parameterizing the REPL
implementation.
</p>
<p>To run Guile without loading the init file, use the <code class="code">-q</code>
command-line option.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Readline">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Value-History" accesskey="n" rel="next">Value History</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Init-File" accesskey="p" rel="prev">The Init File, <samp class="file">~/.guile</samp></a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Readline-1">4.4.2 Readline</h4>

<p>To make it easier for you to repeat and vary previously entered
expressions, or to edit the expression that you’re typing in, Guile
can use the GNU Readline library.  This is not enabled by default
because of licensing reasons, but all you need to activate Readline is
the following pair of lines.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (use-modules (ice-9 readline))
scheme@(guile-user)&gt; (activate-readline)
</pre></div>

<p>It’s a good idea to put these two lines (without the
<code class="code">scheme@(guile-user)&gt;</code> prompts) in your <samp class="file">.guile</samp> file.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Init-File">The Init File, <samp class="file">~/.guile</samp></a>, for more on <samp class="file">.guile</samp>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Value-History">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="n" rel="next">REPL Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Readline" accesskey="p" rel="prev">Readline</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Value-History-1">4.4.3 Value History</h4>

<p>Just as Readline helps you to reuse a previous input line, <em class="dfn">value
history</em> allows you to use the <em class="emph">result</em> of a previous evaluation in
a new expression.  When value history is enabled, each evaluation result
is automatically assigned to the next in the sequence of variables
<code class="code">$1</code>, <code class="code">$2</code>, ….  You can then use these variables in
subsequent expressions.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (iota 10)
$1 = (0 1 2 3 4 5 6 7 8 9)
scheme@(guile-user)&gt; (apply * (cdr $1))
$2 = 362880
scheme@(guile-user)&gt; (sqrt $2)
$3 = 602.3952191045344
scheme@(guile-user)&gt; (cons $2 $1)
$4 = (362880 0 1 2 3 4 5 6 7 8 9)
</pre></div>

<p>Value history is enabled by default, because Guile’s REPL imports the
<code class="code">(ice-9 history)</code> module. Value history may be turned off or on within the
repl, using the options interface:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; ,option value-history #f
scheme@(guile-user)&gt; 'foo
foo
scheme@(guile-user)&gt; ,option value-history #t
scheme@(guile-user)&gt; 'bar
$5 = bar
</pre></div>

<p>Note that previously recorded values are still accessible, even if value history
is off. In rare cases, these references to past computations can cause Guile to
use too much memory. One may clear these values, possibly enabling garbage
collection, via the <code class="code">clear-value-history!</code> procedure, described below.
</p>
<p>The programmatic interface to value history is in a module:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 history))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-value_002dhistory_002denabled_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">value-history-enabled?</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-value_002dhistory_002denabled_003f"> ¶</a></span></dt>
<dd><p>Return true if value history is enabled, or false otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-enable_002dvalue_002dhistory_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">enable-value-history!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-enable_002dvalue_002dhistory_0021"> ¶</a></span></dt>
<dd><p>Turn on value history, if it was off.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-disable_002dvalue_002dhistory_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">disable-value-history!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-disable_002dvalue_002dhistory_0021"> ¶</a></span></dt>
<dd><p>Turn off value history, if it was on.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-clear_002dvalue_002dhistory_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">clear-value-history!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-clear_002dvalue_002dhistory_0021"> ¶</a></span></dt>
<dd><p>Clear the value history. If the stored values are not captured by some other
data structure or closure, they may then be reclaimed by the garbage collector.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="REPL-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Handling" accesskey="n" rel="next">Error Handling</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Value-History" accesskey="p" rel="prev">Value History</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="REPL-Commands-1">4.4.4 REPL Commands</h4>

<a class="index-entry-id" id="index-commands"></a>
<p>The REPL exists to read expressions, evaluate them, and then print their
results. But sometimes one wants to tell the REPL to evaluate an
expression in a different way, or to do something else altogether. A
user can affect the way the REPL works with a <em class="dfn">REPL command</em>.
</p>
<p>The previous section had an example of a command, in the form of
<code class="code">,option</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; ,option value-history #t
</pre></div>

<p>Commands are distinguished from expressions by their initial comma
(‘<samp class="samp">,</samp>’). Since a comma cannot begin an expression in most languages,
it is an effective indicator to the REPL that the following text forms a
command, not an expression.
</p>
<p>REPL commands are convenient because they are always there. Even if the
current module doesn’t have a binding for <code class="code">pretty-print</code>, one can
always <code class="code">,pretty-print</code>.
</p>
<p>The following sections document the various commands, grouped together
by functionality. Many of the commands have abbreviations; see the
online help (<code class="code">,help</code>) for more information.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Help-Commands" accesskey="1">Help Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Module-Commands" accesskey="2">Module Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Language-Commands" accesskey="3">Language Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Compile-Commands" accesskey="4">Compile Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Profile-Commands" accesskey="5">Profile Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Commands" accesskey="6">Debug Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Inspect-Commands" accesskey="7">Inspect Commands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#System-Commands" accesskey="8">System Commands</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Help-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Module-Commands" accesskey="n" rel="next">Module Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Help-Commands-1">4.4.4.1 Help Commands</h4>

<p>When Guile starts interactively, it notifies the user that help can be
had by typing ‘<samp class="samp">,help</samp>’. Indeed, <code class="code">help</code> is a command, and a
particularly useful one, as it allows the user to discover the rest of
the commands.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-help"><span class="category-def">REPL Command: </span><span><strong class="def-name">help</strong> <var class="def-var-arguments">[<code class="code">all</code> | group | <code class="code">[-c]</code> command]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-help"> ¶</a></span></dt>
<dd><p>Show help.
</p>
<p>With one argument, tries to look up the argument as a group name, giving
help on that group if successful. Otherwise tries to look up the
argument as a command, giving help on the command.
</p>
<p>If there is a command whose name is also a group name, use the ‘<samp class="samp">-c
<var class="var">command</var></samp>’ form to give help on the command instead of the group.
</p>
<p>Without any argument, a list of help commands and command groups
are displayed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-show"><span class="category-def">REPL Command: </span><span><strong class="def-name">show</strong> <var class="def-var-arguments">[topic]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-show"> ¶</a></span></dt>
<dd><p>Gives information about Guile.
</p>
<p>With one argument, tries to show a particular piece of information;
currently supported topics are ‘warranty’ (or ‘w’), ‘copying’ (or ‘c’),
and ‘version’ (or ‘v’).
</p>
<p>Without any argument, a list of topics is displayed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-apropos"><span class="category-def">REPL Command: </span><span><strong class="def-name">apropos</strong> <var class="def-var-arguments">regexp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-apropos"> ¶</a></span></dt>
<dd><p>Find bindings/modules/packages.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-describe"><span class="category-def">REPL Command: </span><span><strong class="def-name">describe</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-describe"> ¶</a></span></dt>
<dd><p>Show description/documentation.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Module-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Language-Commands" accesskey="n" rel="next">Language Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Help-Commands" accesskey="p" rel="prev">Help Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Module-Commands-1">4.4.4.2 Module Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-module"><span class="category-def">REPL Command: </span><span><strong class="def-name">module</strong> <var class="def-var-arguments">[module]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module"> ¶</a></span></dt>
<dd><p>Change modules / Show current module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-import"><span class="category-def">REPL Command: </span><span><strong class="def-name">import</strong> <var class="def-var-arguments">module …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-import"> ¶</a></span></dt>
<dd><p>Import modules / List those imported.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-load-1"><span class="category-def">REPL Command: </span><span><strong class="def-name">load</strong> <var class="def-var-arguments">file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load-1"> ¶</a></span></dt>
<dd><p>Load a file in the current module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-reload"><span class="category-def">REPL Command: </span><span><strong class="def-name">reload</strong> <var class="def-var-arguments">[module]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reload"> ¶</a></span></dt>
<dd><p>Reload the given module, or the current module if none was given.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-binding"><span class="category-def">REPL Command: </span><span><strong class="def-name">binding</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding"> ¶</a></span></dt>
<dd><p>List current bindings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-in"><span class="category-def">REPL Command: </span><span><strong class="def-name">in</strong> <var class="def-var-arguments">module expression</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-in"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-in-1"><span class="category-def">REPL Command: </span><span><strong class="def-name">in</strong> <var class="def-var-arguments">module command arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-in-1"> ¶</a></span></dt>
<dd><p>Evaluate an expression, or alternatively, execute another meta-command
in the context of a module.  For example, ‘<samp class="samp">,in (foo bar) ,binding</samp>’
will show the bindings in the module <code class="code">(foo bar)</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Language-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compile-Commands" accesskey="n" rel="next">Compile Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Module-Commands" accesskey="p" rel="prev">Module Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Language-Commands-1">4.4.4.3 Language Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-language"><span class="category-def">REPL Command: </span><span><strong class="def-name">language</strong> <var class="def-var-arguments">language</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-language"> ¶</a></span></dt>
<dd><p>Change languages.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Compile-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Profile-Commands" accesskey="n" rel="next">Profile Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Language-Commands" accesskey="p" rel="prev">Language Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Compile-Commands-1">4.4.4.4 Compile Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-compile"><span class="category-def">REPL Command: </span><span><strong class="def-name">compile</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compile"> ¶</a></span></dt>
<dd><p>Generate compiled code.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-compile_002dfile"><span class="category-def">REPL Command: </span><span><strong class="def-name">compile-file</strong> <var class="def-var-arguments">file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compile_002dfile"> ¶</a></span></dt>
<dd><p>Compile a file.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-expand"><span class="category-def">REPL Command: </span><span><strong class="def-name">expand</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-expand"> ¶</a></span></dt>
<dd><p>Expand any macros in a form.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-optimize"><span class="category-def">REPL Command: </span><span><strong class="def-name">optimize</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-optimize"> ¶</a></span></dt>
<dd><p>Run the optimizer on a piece of code and print the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-disassemble"><span class="category-def">REPL Command: </span><span><strong class="def-name">disassemble</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-disassemble"> ¶</a></span></dt>
<dd><p>Disassemble a compiled procedure.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-disassemble_002dfile"><span class="category-def">REPL Command: </span><span><strong class="def-name">disassemble-file</strong> <var class="def-var-arguments">file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-disassemble_002dfile"> ¶</a></span></dt>
<dd><p>Disassemble a file.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Profile-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Commands" accesskey="n" rel="next">Debug Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compile-Commands" accesskey="p" rel="prev">Compile Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Profile-Commands-1">4.4.4.5 Profile Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-time-3"><span class="category-def">REPL Command: </span><span><strong class="def-name">time</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time-3"> ¶</a></span></dt>
<dd><p>Time execution.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-profile"><span class="category-def">REPL Command: </span><span><strong class="def-name">profile</strong> <var class="def-var-arguments">exp [#:hz hz=100]   [#:count-calls? count-calls?=#f] [#:display-style display-style=list]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-profile"> ¶</a></span></dt>
<dd><p>Profile execution of an expression.  This command compiled <var class="var">exp</var> and
then runs it within the statprof profiler, passing all keyword options
to the <code class="code">statprof</code> procedure.  For more on statprof and on the the
options available to this command, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Statprof">Statprof</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trace"><span class="category-def">REPL Command: </span><span><strong class="def-name">trace</strong> <var class="def-var-arguments">exp [#:width w] [#:max-indent i]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trace"> ¶</a></span></dt>
<dd><p>Trace execution.
</p>
<p>By default, the trace will limit its width to the width of your
terminal, or <var class="var">width</var> if specified.  Nested procedure invocations
will be printed farther to the right, though if the width of the
indentation passes the <var class="var">max-indent</var>, the indentation is abbreviated.
</p></dd></dl>

<p>These REPL commands can also be called as regular functions in scheme
code on including the <code class="code">(ice-9 time)</code> module.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Debug-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Inspect-Commands" accesskey="n" rel="next">Inspect Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Profile-Commands" accesskey="p" rel="prev">Profile Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Debug-Commands-1">4.4.4.6 Debug Commands</h4>

<p>These debugging commands are only available within a recursive REPL;
they do not work at the top level.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-backtrace"><span class="category-def">REPL Command: </span><span><strong class="def-name">backtrace</strong> <var class="def-var-arguments">[count] [#:width w] [#:full? f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-backtrace"> ¶</a></span></dt>
<dd><p>Print a backtrace.
</p>
<p>Print a backtrace of all stack frames, or innermost <var class="var">count</var> frames.
If <var class="var">count</var> is negative, the last <var class="var">count</var> frames will be shown.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-up"><span class="category-def">REPL Command: </span><span><strong class="def-name">up</strong> <var class="def-var-arguments">[count]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-up"> ¶</a></span></dt>
<dd><p>Select a calling stack frame.
</p>
<p>Select and print stack frames that called this one.
An argument says how many frames up to go.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-down"><span class="category-def">REPL Command: </span><span><strong class="def-name">down</strong> <var class="def-var-arguments">[count]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-down"> ¶</a></span></dt>
<dd><p>Select a called stack frame.
</p>
<p>Select and print stack frames called by this one.
An argument says how many frames down to go.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame"><span class="category-def">REPL Command: </span><span><strong class="def-name">frame</strong> <var class="def-var-arguments">[idx]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame"> ¶</a></span></dt>
<dd><p>Show a frame.
</p>
<p>Show the selected frame.  With an argument, select a frame by index,
then show it.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locals"><span class="category-def">REPL Command: </span><span><strong class="def-name">locals</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locals"> ¶</a></span></dt>
<dd><p>Show local variables.
</p>
<p>Show locally-bound variables in the selected frame.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-error_002dmessage"><span class="category-def">REPL Command: </span><span><strong class="def-name">error-message</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error_002dmessage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-error"><span class="category-def">REPL Command: </span><span><strong class="def-name">error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error"> ¶</a></span></dt>
<dd><p>Show error message.
</p>
<p>Display the message associated with the error that started the current
debugging REPL.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-registers"><span class="category-def">REPL Command: </span><span><strong class="def-name">registers</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-registers"> ¶</a></span></dt>
<dd><p>Show the VM registers associated with the current frame.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Layout">Stack Layout</a>, for more information on VM stack frames.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-width"><span class="category-def">REPL Command: </span><span><strong class="def-name">width</strong> <var class="def-var-arguments">[cols]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-width"> ¶</a></span></dt>
<dd><p>Sets the number of display columns in the output of <code class="code">,backtrace</code>
and <code class="code">,locals</code> to <var class="var">cols</var>.  If <var class="var">cols</var> is not given, the width
of the terminal is used.
</p></dd></dl>

<p>The next 3 commands work at any REPL.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-break"><span class="category-def">REPL Command: </span><span><strong class="def-name">break</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-break"> ¶</a></span></dt>
<dd><p>Set a breakpoint at <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-break_002dat_002dsource"><span class="category-def">REPL Command: </span><span><strong class="def-name">break-at-source</strong> <var class="def-var-arguments">file line</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-break_002dat_002dsource"> ¶</a></span></dt>
<dd><p>Set a breakpoint at the given source location.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tracepoint"><span class="category-def">REPL Command: </span><span><strong class="def-name">tracepoint</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tracepoint"> ¶</a></span></dt>
<dd><p>Set a tracepoint on the given procedure. This will cause all calls to
the procedure to print out a tracing message. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps">Tracing Traps</a>, for
more information.
</p></dd></dl>

<p>The rest of the commands in this subsection all apply only when the
stack is <em class="dfn">continuable</em> — in other words when it makes sense for
the program that the stack comes from to continue running.  Usually this
means that the program stopped because of a trap or a breakpoint.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-step"><span class="category-def">REPL Command: </span><span><strong class="def-name">step</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-step"> ¶</a></span></dt>
<dd><p>Tell the debugged program to step to the next source location.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-next"><span class="category-def">REPL Command: </span><span><strong class="def-name">next</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-next"> ¶</a></span></dt>
<dd><p>Tell the debugged program to step to the next source location in the
same frame.  (See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Traps">Traps</a> for the details of how this works.)
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-finish"><span class="category-def">REPL Command: </span><span><strong class="def-name">finish</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-finish"> ¶</a></span></dt>
<dd><p>Tell the program being debugged to continue running until the completion
of the current stack frame, and at that time to print the result and
reenter the REPL.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Inspect-Commands">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#System-Commands" accesskey="n" rel="next">System Commands</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Commands" accesskey="p" rel="prev">Debug Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Inspect-Commands-1">4.4.4.7 Inspect Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-inspect"><span class="category-def">REPL Command: </span><span><strong class="def-name">inspect</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inspect"> ¶</a></span></dt>
<dd><p>Inspect the result(s) of evaluating <var class="var">exp</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pretty_002dprint"><span class="category-def">REPL Command: </span><span><strong class="def-name">pretty-print</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pretty_002dprint"> ¶</a></span></dt>
<dd><p>Pretty-print the result(s) of evaluating <var class="var">exp</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="System-Commands">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Inspect-Commands" accesskey="p" rel="prev">Inspect Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="u" rel="up">REPL Commands</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="System-Commands-1">4.4.4.8 System Commands</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-gc"><span class="category-def">REPL Command: </span><span><strong class="def-name">gc</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gc"> ¶</a></span></dt>
<dd><p>Garbage collection.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-statistics"><span class="category-def">REPL Command: </span><span><strong class="def-name">statistics</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-statistics"> ¶</a></span></dt>
<dd><p>Display statistics.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-option"><span class="category-def">REPL Command: </span><span><strong class="def-name">option</strong> <var class="def-var-arguments">[name] [exp]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option"> ¶</a></span></dt>
<dd><p>With no arguments, lists all options.  With one argument, shows the
current value of the <var class="var">name</var> option.  With two arguments, sets the
<var class="var">name</var> option to the result of evaluating the Scheme expression
<var class="var">exp</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-quit"><span class="category-def">REPL Command: </span><span><strong class="def-name">quit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quit"> ¶</a></span></dt>
<dd><p>Quit this session.
</p></dd></dl>

<p>Current REPL options include:
</p>
<dl class="table">
<dt><code class="code">compile-options</code></dt>
<dd><p>The options used when compiling expressions entered at the REPL.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for more on compilation options.
</p></dd>
<dt><code class="code">interp</code></dt>
<dd><p>Whether to interpret or compile expressions given at the REPL, if such a
choice is available.  Off by default (indicating compilation).
</p></dd>
<dt><code class="code">prompt</code></dt>
<dd><p>A customized REPL prompt.  <code class="code">#f</code> by default, indicating the default
prompt.
</p></dd>
<dt><code class="code">print</code></dt>
<dd><p>A procedure of two arguments used to print the result of evaluating each
expression.  The arguments are the current REPL and the value to print.
By default, <code class="code">#f</code>, to use the default procedure.
</p></dd>
<dt><code class="code">value-history</code></dt>
<dd><p>Whether value history is on or not.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Value-History">Value History</a>.
</p></dd>
<dt><code class="code">on-error</code></dt>
<dd><p>What to do when an error happens.  By default, <code class="code">debug</code>, meaning to
enter the debugger.  Other values include <code class="code">backtrace</code>, to show a
backtrace without entering the debugger, or <code class="code">report</code>, to simply
show a short error printout.
</p></dd>
</dl>

<p>Default values for REPL options may be set using
<code class="code">repl-default-option-set!</code> from <code class="code">(system repl common)</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-repl_002ddefault_002doption_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">repl-default-option-set!</strong> <var class="def-var-arguments">key value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-repl_002ddefault_002doption_002dset_0021"> ¶</a></span></dt>
<dd><p>Set the default value of a REPL option.  This function is particularly
useful in a user’s init file.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Init-File">The Init File, <samp class="file">~/.guile</samp></a>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Error-Handling">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Interactive-Debugging" accesskey="n" rel="next">Interactive Debugging</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Commands" accesskey="p" rel="prev">REPL Commands</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Error-Handling-1">4.4.5 Error Handling</h4>

<p>When code being evaluated from the REPL hits an error, Guile enters a
new prompt, allowing you to inspect the context of the error.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (map string-append '("a" "b") '("c" #\d))
ERROR: In procedure string-append:
ERROR: Wrong type (expecting string): #\d
Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt;
</pre></div>

<p>The new prompt runs inside the old one, in the dynamic context of the
error.  It is a recursive REPL, augmented with a reified representation
of the stack, ready for debugging.
</p>
<p><code class="code">,backtrace</code> (abbreviated <code class="code">,bt</code>) displays the Scheme call
stack at the point where the error occurred:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; ,bt
           1 (map #&lt;procedure string-append _&gt; ("a" "b") ("c" #\d))
           0 (string-append "b" #\d)
</pre></div>

<p>In the above example, the backtrace doesn’t have much source
information, as <code class="code">map</code> and <code class="code">string-append</code> are both
primitives. But in the general case, the space on the left of the
backtrace indicates the line and column in which a given procedure calls
another.
</p>
<p>You can exit a recursive REPL in the same way that you exit any REPL:
via ‘<samp class="samp">(quit)</samp>’, ‘<samp class="samp">,quit</samp>’ (abbreviated ‘<samp class="samp">,q</samp>’), or
<kbd class="kbd">C-d</kbd>, among other options.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Interactive-Debugging">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Handling" accesskey="p" rel="prev">Error Handling</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="u" rel="up">Using Guile Interactively</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Interactive-Debugging-1">4.4.6 Interactive Debugging</h4>

<p>A recursive debugging REPL exposes a number of other meta-commands that
inspect the state of the computation at the time of the error. These
commands allow you to
</p>
<ul class="itemize mark-bullet">
<li>display the Scheme call stack at the point where the error occurred;

</li><li>move up and down the call stack, to see in detail the expression being
evaluated, or the procedure being applied, in each <em class="dfn">frame</em>; and

</li><li>examine the values of variables and expressions in the context of each
frame.
</li></ul>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Commands">Debug Commands</a>, for documentation of the individual
commands. This section aims to give more of a walkthrough of a typical
debugging session.
</p>
<p>First, we’re going to need a good error. Let’s try to macroexpand the
expression <code class="code">(unquote foo)</code>, outside of a <code class="code">quasiquote</code> form,
and see how the macroexpander reports this error.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (macroexpand '(unquote foo))
ERROR: In procedure macroexpand:
ERROR: unquote: expression not valid outside of quasiquote in (unquote foo)
Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt;
</pre></div>

<p>The <code class="code">backtrace</code> command, which can also be invoked as <code class="code">bt</code>,
displays the call stack (aka backtrace) at the point where the debugger
was entered:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; ,bt
In ice-9/psyntax.scm:
  1130:21  3 (chi-top (unquote foo) () ((top)) e (eval) (hygiene #))
  1071:30  2 (syntax-type (unquote foo) () ((top)) #f #f (# #) #f)
  1368:28  1 (chi-macro #&lt;procedure de9360 at ice-9/psyntax.scm...&gt; ...)
In unknown file:
           0 (scm-error syntax-error macroexpand "~a: ~a in ~a" # #f)
</pre></div>

<p>A call stack consists of a sequence of stack <em class="dfn">frames</em>, with each
frame describing one procedure which is waiting to do something with the
values returned by another. Here we see that there are four frames on
the stack.
</p>
<p>Note that <code class="code">macroexpand</code> is not on the stack – it must have made a
tail call to <code class="code">chi-top</code>, as indeed we would find if we searched
<code class="code">ice-9/psyntax.scm</code> for its definition.
</p>
<p>When you enter the debugger, the innermost frame is selected, which
means that the commands for getting information about the “current”
frame, or for evaluating expressions in the context of the current
frame, will do so by default with respect to the innermost frame.  To
select a different frame, so that these operations will apply to it
instead, use the <code class="code">up</code>, <code class="code">down</code> and <code class="code">frame</code> commands like
this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; ,up
In ice-9/psyntax.scm:
  1368:28  1 (chi-macro #&lt;procedure de9360 at ice-9/psyntax.scm...&gt; ...)
scheme@(guile-user) [1]&gt; ,frame 3
In ice-9/psyntax.scm:
  1130:21  3 (chi-top (unquote foo) () ((top)) e (eval) (hygiene #))
scheme@(guile-user) [1]&gt; ,down
In ice-9/psyntax.scm:
  1071:30  2 (syntax-type (unquote foo) () ((top)) #f #f (# #) #f)
</pre></div>

<p>Perhaps we’re interested in what’s going on in frame 2, so we take a
look at its local variables:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; ,locals
  Local variables:
  $1 = e = (unquote foo)
  $2 = r = ()
  $3 = w = ((top))
  $4 = s = #f
  $5 = rib = #f
  $6 = mod = (hygiene guile-user)
  $7 = for-car? = #f
  $8 = first = unquote
  $9 = ftype = macro
  $10 = fval = #&lt;procedure de9360 at ice-9/psyntax.scm:2817:2 (x)&gt;
  $11 = fe = unquote
  $12 = fw = ((top))
  $13 = fs = #f
  $14 = fmod = (hygiene guile-user)
</pre></div>

<p>All of the values are accessible by their value-history names
(<code class="code">$<var class="var">n</var></code>):
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; $10
$15 = #&lt;procedure de9360 at ice-9/psyntax.scm:2817:2 (x)&gt;
</pre></div>

<p>We can even invoke the procedure at the REPL directly:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [1]&gt; ($10 'not-going-to-work)
ERROR: In procedure macroexpand:
ERROR: source expression failed to match any pattern in not-going-to-work
Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
</pre></div>

<p>Well at this point we’ve caused an error within an error. Let’s just
quit back to the top level:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user) [2]&gt; ,q
scheme@(guile-user) [1]&gt; ,q
scheme@(guile-user)&gt; 
</pre></div>

<p>Finally, as a word to the wise: hackers close their REPL prompts with
<kbd class="kbd">C-d</kbd>.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="Using-Guile-in-Emacs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Tools" accesskey="n" rel="next">Using Guile Tools</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively" accesskey="p" rel="prev">Using Guile Interactively</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Using-Guile-in-Emacs-1">4.5 Using Guile in Emacs</h3>

<a class="index-entry-id" id="index-Emacs"></a>
<p>Any text editor can edit Scheme, but some are better than others.  Emacs
is the best, of course, and not just because it is a fine text editor.
Emacs has good support for Scheme out of the box, with sensible
indentation rules, parenthesis-matching, syntax highlighting, and even a
set of keybindings for structural editing, allowing navigation,
cut-and-paste, and transposition operations that work on balanced
S-expressions.
</p>
<p>As good as it is, though, two things will vastly improve your experience
with Emacs and Guile.
</p>
<a class="index-entry-id" id="index-Paredit"></a>
<p>The first is Taylor Campbell’s
<a class="uref" href="http://www.emacswiki.org/emacs/ParEdit">Paredit</a>.  You should not
code in any dialect of Lisp without Paredit.  (They say that
unopinionated writing is boring—hence this tone—but it’s the
truth, regardless.)  Paredit is the bee’s knees.
</p>
<a class="index-entry-id" id="index-Geiser"></a>
<p>The second is
José
Antonio Ortega Ruiz’s
<a class="uref" href="http://www.nongnu.org/geiser/">Geiser</a>.  Geiser complements Emacs’
<code class="code">scheme-mode</code> with tight integration to running Guile processes via
a <code class="code">comint-mode</code> REPL buffer.
</p>
<p>Of course there are keybindings to switch to the REPL, and a good REPL
environment, but Geiser goes beyond that, providing:
</p>
<ul class="itemize mark-bullet">
<li>Form evaluation in the context of the current file’s module.
</li><li>Macro expansion.
</li><li>File/module loading and/or compilation.
</li><li>Namespace-aware identifier completion (including local bindings, names
visible in the current module, and module names).
</li><li>Autodoc: the echo area shows information about the signature of the
procedure/macro around point automatically.
</li><li>Jump to definition of identifier at point.
</li><li>Access to documentation (including docstrings when the implementation
provides it).
</li><li>Listings of identifiers exported by a given module.
</li><li>Listings of callers/callees of procedures.
</li><li>Rudimentary support for debugging and error navigation.
</li><li>Support for multiple, simultaneous REPLs.
</li></ul>

<p>See Geiser’s web page at <a class="uref" href="http://www.nongnu.org/geiser/">http://www.nongnu.org/geiser/</a>, for more
information.
</p>

<hr>
</div>
<div class="section-level-extent" id="Using-Guile-Tools">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages" accesskey="n" rel="next">Installing Site Packages</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-in-Emacs" accesskey="p" rel="prev">Using Guile in Emacs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Using-Guile-Tools-1">4.6 Using Guile Tools</h3>

<a class="index-entry-id" id="index-guild"></a>
<a class="index-entry-id" id="index-guile_002dtools"></a>
<a class="index-entry-id" id="index-wizards"></a>
<p>Guile also comes with a growing number of command-line utilities: a
compiler, a disassembler, some module inspectors, and in the future, a
system to install Guile packages from the internet.  These tools may be
invoked using the <code class="code">guild</code> program.
</p>
<div class="example">
<pre class="example-preformatted">$ guild compile -o foo.go foo.scm
wrote `foo.go'
</pre></div>

<p>This program used to be called <code class="code">guile-tools</code> up to
Guile version 2.0.1, and for backward
compatibility it still may be called as such.  However we changed the
name to <code class="code">guild</code>, not only because it is pleasantly shorter and
easier to read, but also because this tool will serve to bind Guile
wizards together, by allowing hackers to share code with each other
using a CPAN-like system.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for more on <code class="code">guild compile</code>.
</p>
<p>A complete list of guild scripts can be had by invoking <code class="code">guild
list</code>, or simply <code class="code">guild</code>.
</p>

<hr>
</div>
<div class="section-level-extent" id="Installing-Site-Packages">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Distributing-Guile-Code" accesskey="n" rel="next">Distributing Guile Code</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Tools" accesskey="p" rel="prev">Using Guile Tools</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Installing-Site-Packages-1">4.7 Installing Site Packages</h3>

<a class="index-entry-id" id="index-site"></a>
<a class="index-entry-id" id="index-site-path"></a>
<a class="index-entry-id" id="index-load-path"></a>
<a class="index-entry-id" id="index-_0025site_002ddir"></a>
<a class="index-entry-id" id="index-_0025site_002dccache_002ddir"></a>

<p>At some point, you will probably want to share your code with other
people.  To do so effectively, it is important to follow a set of common
conventions, to make it easy for the user to install and use your
package.
</p>
<p>The first thing to do is to install your Scheme files where Guile can
find them.  When Guile goes to find a Scheme file, it will search a
<em class="dfn">load path</em> to find the file: first in Guile’s own path, then in
paths for <em class="dfn">site packages</em>.  A site package is any Scheme code that
is installed and not part of Guile itself.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>, for more
on load paths.
</p>
<p>There are several site paths, for historical reasons, but the one that
should generally be used can be obtained by invoking the
<code class="code">%site-dir</code> procedure.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config">Configuration, Build and Installation</a>.  If Guile
3.0 is installed on your system in <code class="code">/usr/</code>,
then <code class="code">(%site-dir)</code> will be
<code class="code">/usr/share/guile/site/3.0</code>.  Scheme files
should be installed there.
</p>
<p>If you do not install compiled <code class="code">.go</code> files, Guile will compile your
modules and programs when they are first used, and cache them in the
user’s home directory.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for more on
auto-compilation.  However, it is better to compile the files before
they are installed, and to just copy the files to a place that Guile can
find them.
</p>
<p>As with Scheme files, Guile searches a path to find compiled <code class="code">.go</code>
files, the <code class="code">%load-compiled-path</code>.  By default, this path has two
entries: a path for Guile’s files, and a path for site packages.  You
should install your <code class="code">.go</code> files into the latter directory, whose
value is returned by invoking the <code class="code">%site-ccache-dir</code> procedure.  As
in the previous example, if Guile 3.0 is installed
on your system in <code class="code">/usr/</code>, then <code class="code">(%site-ccache-dir)</code> site
packages will be
<code class="code">/usr/lib/guile/3.0/site-ccache</code>.
</p>
<p>Note that a <code class="code">.go</code> file will only be loaded in preference to a
<code class="code">.scm</code> file if it is newer.  For that reason, you should install
your Scheme files first, and your compiled files second.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>, for more on the loading process.
</p>
<p>Finally, although this section is only about Scheme, sometimes you need
to install C extensions too.  Shared libraries should be installed in
the <em class="dfn">extensions dir</em>.  This value can be had from the build config
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config">Configuration, Build and Installation</a>).  Again, if Guile 3.0 is
installed on your system in <code class="code">/usr/</code>, then the extensions dir will
be <code class="code">/usr/lib/guile/3.0/extensions</code>.
</p>

<hr>
</div>
<div class="section-level-extent" id="Distributing-Guile-Code">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages" accesskey="p" rel="prev">Installing Site Packages</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="u" rel="up">Programming in Scheme</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Distributing-Guile-Code-1">4.8 Distributing Guile Code</h3>

<a class="index-entry-id" id="index-distribution_002c-of-Guile-projects"></a>
<p>There’s a tool that doesn’t come bundled with Guile and yet can be very
useful in your day to day experience with it.  This tool is
<a class="uref" href="https://gitlab.com/a-sassmannshausen/guile-hall">Hall</a>.
</p>
<p>Hall helps you create, manage, and package your Guile projects through a
simple command-line interface.  When you start a new project, Hall
creates a folder containing a scaffold of your new project.  It contains
a directory for your tests, for your libraries, for your scripts and for
your documentation.  This means you immediately know where to put the
files you are hacking on.
</p>
<a class="index-entry-id" id="index-build-system_002c-for-Guile-code"></a>
<p>In addition, the scaffold will include your basic “Autotools” setup,
so you don’t have to take care of that yourself (see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#The-GNU-Build-System">The GNU Build
System</a> in <cite class="cite">Autoconf: Creating Automatic Configuration Scripts</cite>,
for more information on the GNU “Autotools”).  Having Autotools set up
with your project means you can immediately start hacking on your
project without worrying about whether your code will work on other
people’s computers.  Hall can also generate package definitions for the
GNU&nbsp;Guix package manager, making it easy for Guix users to install
it.
</p>

<hr>
</div>
</div>
<div class="chapter-level-extent" id="Programming-in-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="n" rel="next">API Reference</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-Scheme" accesskey="p" rel="prev">Programming in Scheme</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Programming-in-C-1">5 Programming in C</h2>

<p>This part of the manual explains the general concepts that you need to
understand when interfacing to Guile from C.  You will learn about how
the latent typing of Scheme is embedded into the static typing of C, how
the garbage collection of Guile is made available to C code, and how
continuations influence the control flow in a C program.
</p>
<p>This knowledge should make it straightforward to add new functions to
Guile that can be called from Scheme.  Adding new data types is also
possible and is done by defining <em class="dfn">foreign objects</em>.
</p>
<p>The <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview">An Overview of Guile Programming</a> section of this part contains general
musings and guidelines about programming with Guile.  It explores
different ways to design a program around Guile, or how to embed Guile
into existing programs.
</p>
<p>For a pedagogical yet detailed explanation of how the data representation of
Guile is implemented, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Data-Representation">Data Representation</a>. You don’t need to know the
details given there to use Guile from C, but they are useful when you want to
modify Guile itself or when you are just curious about how it is all done.
</p>
<p>For detailed reference information on the variables, functions
etc. that make up Guile’s application programming interface (API),
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference">API Reference</a>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Installations" accesskey="1">Parallel Installations</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile" accesskey="2">Linking Programs With Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-with-Libraries" accesskey="3">Linking Guile with Libraries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="4">General concepts for using libguile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="5">Defining New Foreign Object Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Function-Snarfing" accesskey="6">Function Snarfing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="7">An Overview of Guile Programming</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support" accesskey="8">Autoconf Support</a></li>
</ul>
<hr>
<div class="section-level-extent" id="Parallel-Installations">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile" accesskey="n" rel="next">Linking Programs With Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Parallel-Installations-1">5.1 Parallel Installations</h3>

<a class="index-entry-id" id="index-pkg_002dconfig"></a>
<a class="index-entry-id" id="index-effective-version"></a>

<p>Guile provides strong API and ABI stability guarantees during stable
series, so that if a user writes a program against Guile version 2.2.3,
it will be compatible with some future version 2.2.7.  We say in this
case that 2.2 is the <em class="dfn">effective version</em>, composed of the major and
minor versions, in this case 2 and 2.
</p>
<p>Users may install multiple effective versions of Guile, with each
version’s headers, libraries, and Scheme files under their own
directories.  This provides the necessary stability guarantee for users,
while also allowing Guile developers to evolve the language and its
implementation.
</p>
<p>However, parallel installability does have a down-side, in that users
need to know which version of Guile to ask for, when they build against
Guile.  Guile solves this problem by installing a file to be read by the
<code class="code">pkg-config</code> utility, a tool to query installed packages by name.
Guile encodes the version into its pkg-config name, so that users can
ask for <code class="code">guile-2.2</code> or <code class="code">guile-3.0</code>, as appropriate.
</p>
<p>For effective version 3.0, for example, you would
invoke <code class="code">pkg-config --cflags --libs guile-3.0</code>
to get the compilation and linking flags necessary to link to version
3.0 of Guile.  You would typically run
<code class="code">pkg-config</code> during the configuration phase of your program and use
the obtained information in the Makefile.
</p>
<p>Guile’s <code class="code">pkg-config</code> file,
<samp class="file">guile-3.0.pc</samp>, defines additional useful
variables:
</p>
<dl class="table">
<dt id="index-sitedir"><span><code class="code">sitedir</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sitedir"> ¶</a></span></dt>
<dd><p>The default directory where Guile looks for Scheme source and compiled
files (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">%site-dir</a>).  Run
<code class="command">pkg-config guile-3.0 --variable=sitedir</code>
to see its value.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Macros">GUILE_SITE_DIR</a>, for more on
how to use it from Autoconf.
</p>
</dd>
<dt id="index-extensiondir"><span><code class="code">extensiondir</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-extensiondir"> ¶</a></span></dt>
<dd><p>The default directory where Guile looks for extensions—i.e., shared
libraries providing additional features (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions">Foreign Extensions</a>).
Run <code class="command">pkg-config guile-3.0
--variable=extensiondir</code> to see its value.
</p>
</dd>
<dt id="index-program-name-transformations_002c-dealing-with"><span><code class="code">guile</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program-name-transformations_002c-dealing-with"> ¶</a></span></dt>
<dt><code class="code">guild</code></dt>
<dd><p>The absolute file name of the <code class="command">guile</code> and <code class="command">guild</code>
commands<a class="footnote" id="DOCF3" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT3"><sup>3</sup></a>.  Run <code class="command">pkg-config
guile-3.0 --variable=guile</code> or
<code class="code">--variable=guild</code> to see their value.
</p>
<p>These variables allow users to deal with program name transformations
that may be specified when configuring Guile with
<code class="code">--program-transform-name</code>, <code class="code">--program-suffix</code>, or
<code class="code">--program-prefix</code> (see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Transformation-Options">Transformation Options</a> in <cite class="cite">GNU
Autoconf Manual</cite>).
</p></dd>
</dl>

<p>See the <code class="code">pkg-config</code> man page, for more information, or its web
site, <a class="url" href="http://pkg-config.freedesktop.org/">http://pkg-config.freedesktop.org/</a>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support">Autoconf Support</a>, for more on checking for Guile from within a
<code class="code">configure.ac</code> file.
</p>


<hr>
</div>
<div class="section-level-extent" id="Linking-Programs-With-Guile">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-with-Libraries" accesskey="n" rel="next">Linking Guile with Libraries</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Installations" accesskey="p" rel="prev">Parallel Installations</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Linking-Programs-With-Guile-1">5.2 Linking Programs With Guile</h3>

<p>This section covers the mechanics of linking your program with Guile
on a typical POSIX system.
</p>
<p>The header file <code class="code">&lt;libguile.h&gt;</code> provides declarations for all of
Guile’s functions and constants.  You should <code class="code">#include</code> it at the
head of any C source file that uses identifiers described in this
manual.  Once you’ve compiled your source files, you need to link them
against the Guile object code library, <code class="code">libguile</code>.
</p>
<p>As noted in the previous section, <code class="code">&lt;libguile.h&gt;</code> is not in the
default search path for headers.  The following command lines give
respectively the C compilation and link flags needed to build programs
using Guile 3.0:
</p>
<div class="example">
<pre class="example-preformatted">pkg-config guile-3.0 --cflags
pkg-config guile-3.0 --libs
</pre></div>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Initialization-Functions" accesskey="1">Guile Initialization Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#A-Sample-Guile-Main-Program" accesskey="2">A Sample Guile Main Program</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Building-the-Example-with-Make" accesskey="3">Building the Example with Make</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Building-the-Example-with-Autoconf" accesskey="4">Building the Example with Autoconf</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Guile-Initialization-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#A-Sample-Guile-Main-Program" accesskey="n" rel="next">A Sample Guile Main Program</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile" accesskey="u" rel="up">Linking Programs With Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Guile-Initialization-Functions-1">5.2.1 Guile Initialization Functions</h4>

<p>To initialize Guile, you can use one of several functions.  The first,
<code class="code">scm_with_guile</code>, is the most portable way to initialize Guile.  It
will initialize Guile when necessary and then call a function that you
can specify.  Multiple threads can call <code class="code">scm_with_guile</code>
concurrently and it can also be called more than once in a given thread.
The global state of Guile will survive from one call of
<code class="code">scm_with_guile</code> to the next.  Your function is called from within
<code class="code">scm_with_guile</code> since the garbage collector of Guile needs to know
where the stack of each thread is.
</p>
<p>A second function, <code class="code">scm_init_guile</code>, initializes Guile for the
current thread.  When it returns, you can use the Guile API in the
current thread.  This function employs some non-portable magic to learn
about stack bounds and might thus not be available on all platforms.
</p>
<p>One common way to use Guile is to write a set of C functions which
perform some useful task, make them callable from Scheme, and then link
the program with Guile.  This yields a Scheme interpreter just like
<code class="code">guile</code>, but augmented with extra functions for some specific
application — a special-purpose scripting language.
</p>
<p>In this situation, the application should probably process its
command-line arguments in the same manner as the stock Guile
interpreter.  To make that straightforward, Guile provides the
<code class="code">scm_boot_guile</code> and <code class="code">scm_shell</code> function.
</p>
<p>For more about these functions, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Initialization">Initializing Guile</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="A-Sample-Guile-Main-Program">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Initialization-Functions" accesskey="p" rel="prev">Guile Initialization Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile" accesskey="u" rel="up">Linking Programs With Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="A-Sample-Guile-Main-Program-1">5.2.2 A Sample Guile Main Program</h4>

<p>Here is <samp class="file">simple-guile.c</samp>, source code for a <code class="code">main</code> and an
<code class="code">inner_main</code> function that will produce a complete Guile
interpreter.
</p>
<div class="example">
<pre class="example-preformatted">/* simple-guile.c --- Start Guile from C.  */

#include &lt;libguile.h&gt;

static void
inner_main (void *closure, int argc, char **argv)
{
  /* preparation */
  scm_shell (argc, argv);
  /* after exit */
}

int
main (int argc, char **argv)
{
  scm_boot_guile (argc, argv, inner_main, 0);
  return 0; /* never reached, see inner_main */
}
</pre></div>

<p>The <code class="code">main</code> function calls <code class="code">scm_boot_guile</code> to initialize
Guile, passing it <code class="code">inner_main</code>.  Once <code class="code">scm_boot_guile</code> is
ready, it invokes <code class="code">inner_main</code>, which calls <code class="code">scm_shell</code> to
process the command-line arguments in the usual way.
</p>
</div>
<div class="subsection-level-extent" id="Building-the-Example-with-Make">
<h4 class="subsection">5.2.3 Building the Example with Make</h4>

<p>Here is a Makefile which you can use to compile the example program.  It
uses <code class="code">pkg-config</code> to learn about the necessary compiler and
linker flags.
</p><div class="example">
<pre class="example-preformatted"># Use GCC, if you have it installed.
CC=gcc

# Tell the C compiler where to find &lt;libguile.h&gt;
CFLAGS=`pkg-config --cflags guile-3.0`

# Tell the linker what libraries to use and where to find them.
LIBS=`pkg-config --libs guile-3.0`

simple-guile: simple-guile.o
        ${CC} simple-guile.o ${LIBS} -o simple-guile

simple-guile.o: simple-guile.c
        ${CC} -c ${CFLAGS} simple-guile.c
</pre></div>

</div>
<div class="subsection-level-extent" id="Building-the-Example-with-Autoconf">
<h4 class="subsection">5.2.4 Building the Example with Autoconf</h4>

<p>If you are using the GNU Autoconf package to make your application more
portable, Autoconf will settle many of the details in the Makefile
automatically, making it much simpler and more portable; we recommend
using Autoconf with Guile.  Here is a <samp class="file">configure.ac</samp> file for
<code class="code">simple-guile</code> that uses the standard <code class="code">PKG_CHECK_MODULES</code>
macro to check for Guile.  Autoconf will process this file into a
<code class="code">configure</code> script.  We recommend invoking Autoconf via the
<code class="code">autoreconf</code> utility.
</p>
<div class="example">
<pre class="example-preformatted">AC_INIT(simple-guile.c)

# Find a C compiler.
AC_PROG_CC

# Check for Guile
PKG_CHECK_MODULES([GUILE], [guile-3.0])

# Generate a Makefile, based on the results.
AC_OUTPUT(Makefile)
</pre></div>

<p>Run <code class="code">autoreconf -vif</code> to generate <code class="code">configure</code>.
</p>
<p>Here is a <code class="code">Makefile.in</code> template, from which the <code class="code">configure</code>
script produces a Makefile customized for the host system:
</p><div class="example">
<pre class="example-preformatted"># The configure script fills in these values.
CC=@CC@
CFLAGS=@GUILE_CFLAGS@
LIBS=@GUILE_LIBS@

simple-guile: simple-guile.o
        ${CC} simple-guile.o ${LIBS} -o simple-guile
simple-guile.o: simple-guile.c
        ${CC} -c ${CFLAGS} simple-guile.c
</pre></div>

<p>The developer should use Autoconf to generate the <samp class="file">configure</samp>
script from the <samp class="file">configure.ac</samp> template, and distribute
<samp class="file">configure</samp> with the application.  Here’s how a user might go about
building the application:
</p>
<div class="example">
<pre class="example-preformatted">$ ls
Makefile.in     configure*      configure.ac    simple-guile.c
$ ./configure
checking for gcc... ccache gcc
checking whether the C compiler works... yes
checking for C compiler default output file name... a.out
checking for suffix of executables... 
checking whether we are cross compiling... no
checking for suffix of object files... o
checking whether we are using the GNU C compiler... yes
checking whether ccache gcc accepts -g... yes
checking for ccache gcc option to accept ISO C89... none needed
checking for pkg-config... /usr/bin/pkg-config
checking pkg-config is at least version 0.9.0... yes
checking for GUILE... yes
configure: creating ./config.status
config.status: creating Makefile
$ make
[...]
$ ./simple-guile
guile&gt; (+ 1 2 3)
6
guile&gt; (getpwnam "jimb")
#("jimb" "83Z7d75W2tyJQ" 4008 10 "Jim Blandy" "/u/jimb"
  "/usr/local/bin/bash")
guile&gt; (exit)
$
</pre></div>



<hr>
</div>
</div>
<div class="section-level-extent" id="Linking-Guile-with-Libraries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="n" rel="next">General concepts for using libguile</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile" accesskey="p" rel="prev">Linking Programs With Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Linking-Guile-with-Libraries-1">5.3 Linking Guile with Libraries</h3>

<p>The previous section has briefly explained how to write programs that
make use of an embedded Guile interpreter.  But sometimes, all you
want to do is make new primitive procedures and data types available
to the Scheme programmer.  Writing a new version of <code class="code">guile</code> is
inconvenient in this case and it would in fact make the life of the
users of your new features needlessly hard.
</p>
<p>For example, suppose that there is a program <code class="code">guile-db</code> that is a
version of Guile with additional features for accessing a database.
People who want to write Scheme programs that use these features would
have to use <code class="code">guile-db</code> instead of the usual <code class="code">guile</code> program.
Now suppose that there is also a program <code class="code">guile-gtk</code> that extends
Guile with access to the popular Gtk+ toolkit for graphical user
interfaces.  People who want to write GUIs in Scheme would have to use
<code class="code">guile-gtk</code>.  Now, what happens when you want to write a Scheme
application that uses a GUI to let the user access a database?  You
would have to write a <em class="emph">third</em> program that incorporates both the
database stuff and the GUI stuff.  This might not be easy (because
<code class="code">guile-gtk</code> might be a quite obscure program, say) and taking this
example further makes it easy to see that this approach can not work in
practice.
</p>
<p>It would have been much better if both the database features and the GUI
feature had been provided as libraries that can just be linked with
<code class="code">guile</code>.  Guile makes it easy to do just this, and we encourage you
to make your extensions to Guile available as libraries whenever
possible.
</p>
<p>You write the new primitive procedures and data types in the normal
fashion, and link them into a shared library instead of into a
stand-alone program.  The shared library can then be loaded dynamically
by Guile.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#A-Sample-Guile-Extension" accesskey="1">A Sample Guile Extension</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="A-Sample-Guile-Extension">
<div class="nav-panel">
<p>
Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-with-Libraries" accesskey="u" rel="up">Linking Guile with Libraries</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="A-Sample-Guile-Extension-1">5.3.1 A Sample Guile Extension</h4>

<p>This section explains how to make the Bessel functions of the C library
available to Scheme.  First we need to write the appropriate glue code
to convert the arguments and return values of the functions from Scheme
to C and back.  Additionally, we need a function that will add them to
the set of Guile primitives.  Because this is just an example, we will
only implement this for the <code class="code">j0</code> function.
</p>
<p>Consider the following file <samp class="file">bessel.c</samp>.
</p>
<div class="example smallexample">
<pre class="example-preformatted">#include &lt;math.h&gt;
#include &lt;libguile.h&gt;

SCM
j0_wrapper (SCM x)
{
  return scm_from_double (j0 (scm_to_double (x)));
}

void
init_bessel ()
{
  scm_c_define_gsubr ("j0", 1, 0, 0, j0_wrapper);
}
</pre></div>

<p>This C source file needs to be compiled into a shared library.  Here is
how to do it on GNU/Linux:
</p>
<div class="example smallexample">
<pre class="example-preformatted">gcc `pkg-config --cflags guile-3.0` \
  -shared -o libguile-bessel.so -fPIC bessel.c
</pre></div>

<p>For creating shared libraries portably, we recommend the use of GNU
Libtool (see <a data-manual="libtool" href="http://www.gnu.org/software/libtool/manual/libtool.html#Top">Introduction</a> in <cite class="cite">GNU Libtool</cite>).
</p>
<p>A shared library can be loaded into a running Guile process with the
function <code class="code">load-extension</code>.  In addition to the name of the
library to load, this function also expects the name of a function from
that library that will be called to initialize it.  For our example,
we are going to call the function <code class="code">init_bessel</code> which will make
<code class="code">j0_wrapper</code> available to Scheme programs with the name
<code class="code">j0</code>.  Note that we do not specify a filename extension such as
<samp class="file">.so</samp> when invoking <code class="code">load-extension</code>.  The right extension for
the host platform will be provided automatically.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(load-extension "libguile-bessel" "init_bessel")
(j0 2)
⇒ 0.223890779141236
</pre></div>

<p>For this to work, <code class="code">load-extension</code> must be able to find
<samp class="file">libguile-bessel</samp>, of course.  It will look in the places that
are usual for your operating system, and it will additionally look
into the directories listed in the <code class="code">LTDL_LIBRARY_PATH</code>
environment variable.
</p>
<p>To see how these Guile extensions via shared libraries relate to the
module system, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Putting-Extensions-into-Modules">Putting Extensions into Modules</a>.
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="General-Libguile-Concepts">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="n" rel="next">Defining New Foreign Object Types</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Guile-with-Libraries" accesskey="p" rel="prev">Linking Guile with Libraries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="General-concepts-for-using-libguile">5.4 General concepts for using libguile</h3>

<p>When you want to embed the Guile Scheme interpreter into your program or
library, you need to link it against the <samp class="file">libguile</samp> library
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Linking-Programs-With-Guile">Linking Programs With Guile</a>).  Once you have done this, your C
code has access to a number of data types and functions that can be used
to invoke the interpreter, or make new functions that you have written
in C available to be called from Scheme code, among other things.
</p>
<p>Scheme is different from C in a number of significant ways, and Guile
tries to make the advantages of Scheme available to C as well.  Thus, in
addition to a Scheme interpreter, libguile also offers dynamic types,
garbage collection, continuations, arithmetic on arbitrary sized
numbers, and other things.
</p>
<p>The two fundamental concepts are dynamic types and garbage collection.
You need to understand how libguile offers them to C programs in order
to use the rest of libguile.  Also, the more general control flow of
Scheme caused by continuations needs to be dealt with.
</p>
<p>Running asynchronous signal handlers and multi-threading is known to C
code already, but there are of course a few additional rules when using
them together with libguile.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Types" accesskey="1">Dynamic Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection" accesskey="2">Garbage Collection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Flow" accesskey="3">Control Flow</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Asynchronous-Signals" accesskey="4">Asynchronous Signals</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Multi_002dThreading" accesskey="5">Multi-Threading</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Dynamic-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection" accesskey="n" rel="next">Garbage Collection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="u" rel="up">General concepts for using libguile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Dynamic-Types-1">5.4.1 Dynamic Types</h4>

<p>Scheme is a dynamically-typed language; this means that the system
cannot, in general, determine the type of a given expression at compile
time.  Types only become apparent at run time.  Variables do not have
fixed types; a variable may hold a pair at one point, an integer at the
next, and a thousand-element vector later.  Instead, values, not
variables, have fixed types.
</p>
<p>In order to implement standard Scheme functions like <code class="code">pair?</code> and
<code class="code">string?</code> and provide garbage collection, the representation of
every value must contain enough information to accurately determine its
type at run time.  Often, Scheme systems also use this information to
determine whether a program has attempted to apply an operation to an
inappropriately typed value (such as taking the <code class="code">car</code> of a string).
</p>
<p>Because variables, pairs, and vectors may hold values of any type,
Scheme implementations use a uniform representation for values — a
single type large enough to hold either a complete value or a pointer
to a complete value, along with the necessary typing information.
</p>
<p>In Guile, this uniform representation of all Scheme values is the C type
<code class="code">SCM</code>.  This is an opaque type and its size is typically equivalent
to that of a pointer to <code class="code">void</code>.  Thus, <code class="code">SCM</code> values can be
passed around efficiently and they take up reasonably little storage on
their own.
</p>
<p>The most important rule is: You never access a <code class="code">SCM</code> value
directly; you only pass it to functions or macros defined in libguile.
</p>
<p>As an obvious example, although a <code class="code">SCM</code> variable can contain
integers, you can of course not compute the sum of two <code class="code">SCM</code> values
by adding them with the C <code class="code">+</code> operator.  You must use the libguile
function <code class="code">scm_sum</code>.
</p>
<p>Less obvious and therefore more important to keep in mind is that you
also cannot directly test <code class="code">SCM</code> values for trueness.  In Scheme,
the value <code class="code">#f</code> is considered false and of course a <code class="code">SCM</code>
variable can represent that value.  But there is no guarantee that the
<code class="code">SCM</code> representation of <code class="code">#f</code> looks false to C code as well.
You need to use <code class="code">scm_is_true</code> or <code class="code">scm_is_false</code> to test a
<code class="code">SCM</code> value for trueness or falseness, respectively.
</p>
<p>You also can not directly compare two <code class="code">SCM</code> values to find out
whether they are identical (that is, whether they are <code class="code">eq?</code> in
Scheme terms).  You need to use <code class="code">scm_is_eq</code> for this.
</p>
<p>The one exception is that you can directly assign a <code class="code">SCM</code> value to
a <code class="code">SCM</code> variable by using the C <code class="code">=</code> operator.
</p>
<p>The following (contrived) example shows how to do it right.  It
implements a function of two arguments (<var class="var">a</var> and <var class="var">flag</var>) that
returns <var class="var">a</var>+1 if <var class="var">flag</var> is true, else it returns <var class="var">a</var>
unchanged.
</p>
<div class="example">
<pre class="example-preformatted">SCM
my_incrementing_function (SCM a, SCM flag)
{
  SCM result;

  if (scm_is_true (flag))
    result = scm_sum (a, scm_from_int (1));
  else
    result = a;

  return result;
}
</pre></div>

<p>Often, you need to convert between <code class="code">SCM</code> values and appropriate C
values.  For example, we needed to convert the integer <code class="code">1</code> to its
<code class="code">SCM</code> representation in order to add it to <var class="var">a</var>.  Libguile
provides many function to do these conversions, both from C to
<code class="code">SCM</code> and from <code class="code">SCM</code> to C.
</p>
<p>The conversion functions follow a common naming pattern: those that make
a <code class="code">SCM</code> value from a C value have names of the form
<code class="code">scm_from_<var class="var">type</var> (…)</code> and those that convert a <code class="code">SCM</code>
value to a C value use the form <code class="code">scm_to_<var class="var">type</var> (…)</code>.
</p>
<p>However, it is best to avoid converting values when you can.  When you
must combine C values and <code class="code">SCM</code> values in a computation, it is
often better to convert the C values to <code class="code">SCM</code> values and do the
computation by using libguile functions than to the other way around
(converting <code class="code">SCM</code> to C and doing the computation some other way).
</p>
<p>As a simple example, consider this version of
<code class="code">my_incrementing_function</code> from above:
</p>
<div class="example">
<pre class="example-preformatted">SCM
my_other_incrementing_function (SCM a, SCM flag)
{
  int result;

  if (scm_is_true (flag))
    result = scm_to_int (a) + 1;
  else
    result = scm_to_int (a);

  return scm_from_int (result);
}
</pre></div>

<p>This version is much less general than the original one: it will only
work for values <var class="var">A</var> that can fit into a <code class="code">int</code>.  The original
function will work for all values that Guile can represent and that
<code class="code">scm_sum</code> can understand, including integers bigger than <code class="code">long
long</code>, floating point numbers, complex numbers, and new numerical types
that have been added to Guile by third-party libraries.
</p>
<p>Also, computing with <code class="code">SCM</code> is not necessarily inefficient.  Small
integers will be encoded directly in the <code class="code">SCM</code> value, for example,
and do not need any additional memory on the heap.  See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Data-Representation">Data Representation</a> to find out the details.
</p>
<p>Some special <code class="code">SCM</code> values are available to C code without needing
to convert them from C values:
</p>
<table class="multitable">
<tbody><tr><td>Scheme value</td><td>C representation</td></tr>
<tr><td><code class="code">#f</code></td><td><code class="code">SCM_BOOL_F</code></td></tr>
<tr><td><code class="code">#t</code></td><td><code class="code">SCM_BOOL_T</code></td></tr>
<tr><td><code class="code">()</code></td><td><code class="code">SCM_EOL</code></td></tr>
</tbody>
</table>

<p>In addition to <code class="code">SCM</code>, Guile also defines the related type
<code class="code">scm_t_bits</code>.  This is an unsigned integral type of sufficient
size to hold all information that is directly contained in a
<code class="code">SCM</code> value.  The <code class="code">scm_t_bits</code> type is used internally by
Guile to do all the bit twiddling explained in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Data-Representation">Data Representation</a>, but
you will encounter it occasionally in low-level user code as well.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Garbage-Collection">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Flow" accesskey="n" rel="next">Control Flow</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Types" accesskey="p" rel="prev">Dynamic Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="u" rel="up">General concepts for using libguile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Garbage-Collection-1">5.4.2 Garbage Collection</h4>

<p>As explained above, the <code class="code">SCM</code> type can represent all Scheme values.
Some values fit entirely into a <code class="code">SCM</code> value (such as small
integers), but other values require additional storage in the heap (such
as strings and vectors).  This additional storage is managed
automatically by Guile.  You don’t need to explicitly deallocate it
when a <code class="code">SCM</code> value is no longer used.
</p>
<p>Two things must be guaranteed so that Guile is able to manage the
storage automatically: it must know about all blocks of memory that have
ever been allocated for Scheme values, and it must know about all Scheme
values that are still being used.  Given this knowledge, Guile can
periodically free all blocks that have been allocated but are not used
by any active Scheme values.  This activity is called <em class="dfn">garbage
collection</em>.
</p>
<p>Guile’s garbage collector will automatically discover references to
<code class="code">SCM</code> objects that originate in global variables, static data
sections, function arguments or local variables on the C and Scheme
stacks, and values in machine registers.  Other references to <code class="code">SCM</code>
objects, such as those in other random data structures in the C heap
that contain fields of type <code class="code">SCM</code>, can be made visible to the
garbage collector by calling the functions <code class="code">scm_gc_protect_object</code> or
<code class="code">scm_permanent_object</code>.  Collectively, these values form the “root
set” of garbage collection; any value on the heap that is referenced
directly or indirectly by a member of the root set is preserved, and all
other objects are eligible for reclamation.
</p>
<p>In Guile, garbage collection has two logical phases: the <em class="dfn">mark
phase</em>, in which the collector discovers the set of all live objects,
and the <em class="dfn">sweep phase</em>, in which the collector reclaims the resources
associated with dead objects.  The mark phase pauses the program and
traces all <code class="code">SCM</code> object references, starting with the root set.
The sweep phase actually runs concurrently with the main program,
incrementally reclaiming memory as needed by allocation.
</p>
<p>In the mark phase, the garbage collector traces the Scheme stack and
heap <em class="dfn">precisely</em>.  Because the Scheme stack and heap are managed by
Guile, Guile can know precisely where in those data structures it might
find references to other heap objects.  This is not the case,
unfortunately, for pointers on the C stack and static data segment.
Instead of requiring the user to inform Guile about all variables in C
that might point to heap objects, Guile traces the C stack and static
data segment <em class="dfn">conservatively</em>.  That is to say, Guile just treats
every word on the C stack and every C global variable as a potential
reference in to the Scheme heap<a class="footnote" id="DOCF4" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT4"><sup>4</sup></a>.  Any value that looks like a pointer to a GC-managed
object is treated as such, whether it actually is a reference or not.
Thus, scanning the C stack and static data segment is guaranteed to find
all actual references, but it might also find words that only
accidentally look like references.  These “false positives” might keep
<code class="code">SCM</code> objects alive that would otherwise be considered dead.  While
this might waste memory, keeping an object around longer than it
strictly needs to is harmless.  This is why this technique is called
“conservative garbage collection”.  In practice, the wasted memory
seems to be no problem, as the static C root set is almost always finite
and small, given that the Scheme stack is separate from the C stack.
</p>
<p>The stack of every thread is scanned in this way and the registers of
the CPU and all other memory locations where local variables or function
parameters might show up are included in this scan as well.
</p>
<p>The consequence of the conservative scanning is that you can just
declare local variables and function parameters of type <code class="code">SCM</code> and
be sure that the garbage collector will not free the corresponding
objects.
</p>
<p>However, a local variable or function parameter is only protected as
long as it is really on the stack (or in some register).  As an
optimization, the C compiler might reuse its location for some other
value and the <code class="code">SCM</code> object would no longer be protected.  Normally,
this leads to exactly the right behavior: the compiler will only
overwrite a reference when it is no longer needed and thus the object
becomes unprotected precisely when the reference disappears, just as
wanted.
</p>
<p>There are situations, however, where a <code class="code">SCM</code> object needs to be
around longer than its reference from a local variable or function
parameter.  This happens, for example, when you retrieve some pointer
from a foreign object and work with that pointer directly.  The
reference to the <code class="code">SCM</code> foreign object might be dead after the
pointer has been retrieved, but the pointer itself (and the memory
pointed to) is still in use and thus the foreign object must be
protected.  The compiler does not know about this connection and might
overwrite the <code class="code">SCM</code> reference too early.
</p>
<p>To get around this problem, you can use <code class="code">scm_remember_upto_here_1</code>
and its cousins.  It will keep the compiler from overwriting the
reference.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Control-Flow">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Asynchronous-Signals" accesskey="n" rel="next">Asynchronous Signals</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection" accesskey="p" rel="prev">Garbage Collection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="u" rel="up">General concepts for using libguile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Control-Flow-1">5.4.3 Control Flow</h4>

<p>Scheme has a more general view of program flow than C, both locally and
non-locally.
</p>
<p>Controlling the local flow of control involves things like gotos, loops,
calling functions and returning from them.  Non-local control flow
refers to situations where the program jumps across one or more levels
of function activations without using the normal call or return
operations.
</p>
<p>The primitive means of C for local control flow is the <code class="code">goto</code>
statement, together with <code class="code">if</code>.  Loops done with <code class="code">for</code>,
<code class="code">while</code> or <code class="code">do</code> could in principle be rewritten with just
<code class="code">goto</code> and <code class="code">if</code>.  In Scheme, the primitive means for local
control flow is the <em class="emph">function call</em> (together with <code class="code">if</code>).
Thus, the repetition of some computation in a loop is ultimately
implemented by a function that calls itself, that is, by recursion.
</p>
<p>This approach is theoretically very powerful since it is easier to
reason formally about recursion than about gotos.  In C, using
recursion exclusively would not be practical, though, since it would eat
up the stack very quickly.  In Scheme, however, it is practical:
function calls that appear in a <em class="dfn">tail position</em> do not use any
additional stack space (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Tail-Calls">Tail calls</a>).
</p>
<p>A function call is in a tail position when it is the last thing the
calling function does.  The value returned by the called function is
immediately returned from the calling function.  In the following
example, the call to <code class="code">bar-1</code> is in a tail position, while the
call to <code class="code">bar-2</code> is not.  (The call to <code class="code">1-</code> in <code class="code">foo-2</code>
is in a tail position, though.)
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (foo-1 x)
  (bar-1 (1- x)))

(define (foo-2 x)
  (1- (bar-2 x)))
</pre></div>

<p>Thus, when you take care to recurse only in tail positions, the
recursion will only use constant stack space and will be as good as a
loop constructed from gotos.
</p>
<p>Scheme offers a few syntactic abstractions (<code class="code">do</code> and <em class="dfn">named</em>
<code class="code">let</code>) that make writing loops slightly easier.
</p>
<p>But only Scheme functions can call other functions in a tail position:
C functions can not.  This matters when you have, say, two functions
that call each other recursively to form a common loop.  The following
(unrealistic) example shows how one might go about determining whether a
non-negative integer <var class="var">n</var> is even or odd.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (my-even? n)
  (cond ((zero? n) #t)
        (else (my-odd? (1- n)))))

(define (my-odd? n)
  (cond ((zero? n) #f)
        (else (my-even? (1- n)))))
</pre></div>

<p>Because the calls to <code class="code">my-even?</code> and <code class="code">my-odd?</code> are in tail
positions, these two procedures can be applied to arbitrary large
integers without overflowing the stack.  (They will still take a lot
of time, of course.)
</p>
<p>However, when one or both of the two procedures would be rewritten in
C, it could no longer call its companion in a tail position (since C
does not have this concept).  You might need to take this
consideration into account when deciding which parts of your program
to write in Scheme and which in C.
</p>
<p>In addition to calling functions and returning from them, a Scheme
program can also exit non-locally from a function so that the control
flow returns directly to an outer level.  This means that some functions
might not return at all.
</p>
<p>Even more, it is not only possible to jump to some outer level of
control, a Scheme program can also jump back into the middle of a
function that has already exited.  This might cause some functions to
return more than once.
</p>
<p>In general, these non-local jumps are done by invoking
<em class="dfn">continuations</em> that have previously been captured using
<code class="code">call-with-current-continuation</code>.  Guile also offers a slightly
restricted set of functions, <code class="code">catch</code> and <code class="code">throw</code>, that can
only be used for non-local exits.  This restriction makes them more
efficient.  Error reporting (with the function <code class="code">error</code>) is
implemented by invoking <code class="code">throw</code>, for example.  The functions
<code class="code">catch</code> and <code class="code">throw</code> belong to the topic of <em class="dfn">exceptions</em>.
</p>
<p>Since Scheme functions can call C functions and vice versa, C code can
experience the more general control flow of Scheme as well.  It is
possible that a C function will not return at all, or will return more
than once.  While C does offer <code class="code">setjmp</code> and <code class="code">longjmp</code> for
non-local exits, it is still an unusual thing for C code.  In
contrast, non-local exits are very common in Scheme, mostly to report
errors.
</p>
<p>You need to be prepared for the non-local jumps in the control flow
whenever you use a function from <code class="code">libguile</code>: it is best to assume
that any <code class="code">libguile</code> function might signal an error or run a pending
signal handler (which in turn can do arbitrary things).
</p>
<p>It is often necessary to take cleanup actions when the control leaves a
function non-locally.  Also, when the control returns non-locally, some
setup actions might be called for.  For example, the Scheme function
<code class="code">with-output-to-port</code> needs to modify the global state so that
<code class="code">current-output-port</code> returns the port passed to
<code class="code">with-output-to-port</code>.  The global output port needs to be reset to
its previous value when <code class="code">with-output-to-port</code> returns normally or
when it is exited non-locally.  Likewise, the port needs to be set again
when control enters non-locally.
</p>
<p>Scheme code can use the <code class="code">dynamic-wind</code> function to arrange for
the setting and resetting of the global state.  C code can use the
corresponding <code class="code">scm_internal_dynamic_wind</code> function, or a
<code class="code">scm_dynwind_begin</code>/<code class="code">scm_dynwind_end</code> pair together with
suitable ’dynwind actions’ (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).
</p>
<p>Instead of coping with non-local control flow, you can also prevent it
by erecting a <em class="emph">continuation barrier</em>, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Continuation-Barriers">Continuation Barriers</a>.  The function <code class="code">scm_c_with_continuation_barrier</code>, for
example, is guaranteed to return exactly once.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Asynchronous-Signals">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Multi_002dThreading" accesskey="n" rel="next">Multi-Threading</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Flow" accesskey="p" rel="prev">Control Flow</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="u" rel="up">General concepts for using libguile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Asynchronous-Signals-1">5.4.4 Asynchronous Signals</h4>

<p>You can not call libguile functions from handlers for POSIX signals, but
you can register Scheme handlers for POSIX signals such as
<code class="code">SIGINT</code>.  These handlers do not run during the actual signal
delivery.  Instead, they are run when the program (more precisely, the
thread that the handler has been registered for) reaches the next
<em class="emph">safe point</em>.
</p>
<p>The libguile functions themselves have many such safe points.
Consequently, you must be prepared for arbitrary actions anytime you
call a libguile function.  For example, even <code class="code">scm_cons</code> can contain
a safe point and when a signal handler is pending for your thread,
calling <code class="code">scm_cons</code> will run this handler and anything might happen,
including a non-local exit although <code class="code">scm_cons</code> would not ordinarily
do such a thing on its own.
</p>
<p>If you do not want to allow the running of asynchronous signal handlers,
you can block them temporarily with <code class="code">scm_dynwind_block_asyncs</code>, for
example.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>.
</p>
<p>Since signal handling in Guile relies on safe points, you need to make
sure that your functions do offer enough of them.  Normally, calling
libguile functions in the normal course of action is all that is needed.
But when a thread might spent a long time in a code section that calls
no libguile function, it is good to include explicit safe points.  This
can allow the user to interrupt your code with <kbd class="key">C-c</kbd>, for example.
</p>
<p>You can do this with the macro <code class="code">SCM_TICK</code>.  This macro is
syntactically a statement.  That is, you could use it like this:
</p>
<div class="example">
<pre class="example-preformatted">while (1)
  {
    SCM_TICK;
    do_some_work ();
  }
</pre></div>

<p>Frequent execution of a safe point is even more important in multi
threaded programs, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Multi_002dThreading">Multi-Threading</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Multi_002dThreading">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Asynchronous-Signals" accesskey="p" rel="prev">Asynchronous Signals</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="u" rel="up">General concepts for using libguile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Multi_002dThreading-1">5.4.5 Multi-Threading</h4>

<p>Guile can be used in multi-threaded programs just as well as in
single-threaded ones.
</p>
<p>Each thread that wants to use functions from libguile must put itself
into <em class="emph">guile mode</em> and must then follow a few rules.  If it doesn’t
want to honor these rules in certain situations, a thread can
temporarily leave guile mode (but can no longer use libguile functions
during that time, of course).
</p>
<p>Threads enter guile mode by calling <code class="code">scm_with_guile</code>,
<code class="code">scm_boot_guile</code>, or <code class="code">scm_init_guile</code>.  As explained in the
reference documentation for these functions, Guile will then learn about
the stack bounds of the thread and can protect the <code class="code">SCM</code> values
that are stored in local variables.  When a thread puts itself into
guile mode for the first time, it gets a Scheme representation and is
listed by <code class="code">all-threads</code>, for example.
</p>
<p>Threads in guile mode can block (e.g., do blocking I/O) without causing
any problems<a class="footnote" id="DOCF5" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT5"><sup>5</sup></a>; temporarily leaving guile mode with
<code class="code">scm_without_guile</code> before blocking slightly improves GC
performance, though.  For some common blocking operations, Guile
provides convenience functions.  For example, if you want to lock a
pthread mutex while in guile mode, you might want to use
<code class="code">scm_pthread_mutex_lock</code> which is just like
<code class="code">pthread_mutex_lock</code> except that it leaves guile mode while
blocking.
</p>

<p>All libguile functions are (intended to be) robust in the face of
multiple threads using them concurrently.  This means that there is no
risk of the internal data structures of libguile becoming corrupted in
such a way that the process crashes.
</p>
<p>A program might still produce nonsensical results, though.  Taking
hashtables as an example, Guile guarantees that you can use them from
multiple threads concurrently and a hashtable will always remain a valid
hashtable and Guile will not crash when you access it.  It does not
guarantee, however, that inserting into it concurrently from two threads
will give useful results: only one insertion might actually happen, none
might happen, or the table might in general be modified in a totally
arbitrary manner.  (It will still be a valid hashtable, but not the one
that you might have expected.)  Guile might also signal an error when it
detects a harmful race condition.
</p>
<p>Thus, you need to put in additional synchronizations when multiple
threads want to use a single hashtable, or any other mutable Scheme
object.
</p>
<p>When writing C code for use with libguile, you should try to make it
robust as well.  An example that converts a list into a vector will help
to illustrate.  Here is a correct version:
</p>
<div class="example">
<pre class="example-preformatted">SCM
my_list_to_vector (SCM list)
{
  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);
  size_t len, i;

  len = scm_c_vector_length (vector);
  i = 0;
  while (i &lt; len &amp;&amp; scm_is_pair (list))
    {
      scm_c_vector_set_x (vector, i, scm_car (list));
      list = scm_cdr (list);
      i++;
    }

  return vector;
}
</pre></div>

<p>The first thing to note is that storing into a <code class="code">SCM</code> location
concurrently from multiple threads is guaranteed to be robust: you don’t
know which value wins but it will in any case be a valid <code class="code">SCM</code>
value.
</p>
<p>But there is no guarantee that the list referenced by <var class="var">list</var> is not
modified in another thread while the loop iterates over it.  Thus, while
copying its elements into the vector, the list might get longer or
shorter.  For this reason, the loop must check both that it doesn’t
overrun the vector and that it doesn’t overrun the list.  Otherwise,
<code class="code">scm_c_vector_set_x</code> would raise an error if the index is out of
range, and <code class="code">scm_car</code> and <code class="code">scm_cdr</code> would raise an error if the
value is not a pair.
</p>
<p>It is safe to use <code class="code">scm_car</code> and <code class="code">scm_cdr</code> on the local
variable <var class="var">list</var> once it is known that the variable contains a pair.
The contents of the pair might change spontaneously, but it will always
stay a valid pair (and a local variable will of course not spontaneously
point to a different Scheme object).
</p>
<p>Likewise, a vector such as the one returned by <code class="code">scm_make_vector</code> is
guaranteed to always stay the same length so that it is safe to only use
scm_c_vector_length once and store the result.  (In the example,
<var class="var">vector</var> is safe anyway since it is a fresh object that no other
thread can possibly know about until it is returned from
<code class="code">my_list_to_vector</code>.)
</p>
<p>Of course the behavior of <code class="code">my_list_to_vector</code> is suboptimal when
<var class="var">list</var> does indeed get asynchronously lengthened or shortened in
another thread.  But it is robust: it will always return a valid vector.
That vector might be shorter than expected, or its last elements might
be unspecified, but it is a valid vector and if a program wants to rule
out these cases, it must avoid modifying the list asynchronously.
</p>
<p>Here is another version that is also correct:
</p>
<div class="example">
<pre class="example-preformatted">SCM
my_pedantic_list_to_vector (SCM list)
{
  SCM vector = scm_make_vector (scm_length (list), SCM_UNDEFINED);
  size_t len, i;

  len = scm_c_vector_length (vector);
  i = 0;
  while (i &lt; len)
    {
      scm_c_vector_set_x (vector, i, scm_car (list));
      list = scm_cdr (list);
      i++;
    }

  return vector;
}
</pre></div>

<p>This version relies on the error-checking behavior of <code class="code">scm_car</code> and
<code class="code">scm_cdr</code>.  When the list is shortened (that is, when <var class="var">list</var>
holds a non-pair), <code class="code">scm_car</code> will throw an error.  This might be
preferable to just returning a half-initialized vector.
</p>
<p>The API for accessing vectors and arrays of various kinds from C takes a
slightly different approach to thread-robustness.  In order to get at
the raw memory that stores the elements of an array, you need to
<em class="emph">reserve</em> that array as long as you need the raw memory.  During
the time an array is reserved, its elements can still spontaneously
change their values, but the memory itself and other things like the
size of the array are guaranteed to stay fixed.  Any operation that
would change these parameters of an array that is currently reserved
will signal an error.  In order to avoid these errors, a program should
of course put suitable synchronization mechanisms in place.  As you can
see, Guile itself is again only concerned about robustness, not about
correctness: without proper synchronization, your program will likely
not be correct, but the worst consequence is an error message.
</p>
<p>Real thread-safety often requires that a critical section of code is
executed in a certain restricted manner.  A common requirement is that
the code section is not entered a second time when it is already being
executed.  Locking a mutex while in that section ensures that no other
thread will start executing it, blocking asyncs ensures that no
asynchronous code enters the section again from the current thread, and
the error checking of Guile mutexes guarantees that an error is
signalled when the current thread accidentally reenters the critical
section via recursive function calls.
</p>
<p>Guile provides two mechanisms to support critical sections as outlined
above.  You can either use the macros
<code class="code">SCM_CRITICAL_SECTION_START</code> and <code class="code">SCM_CRITICAL_SECTION_END</code>
for very simple sections; or use a dynwind context together with a
call to <code class="code">scm_dynwind_critical_section</code>.
</p>
<p>The macros only work reliably for critical sections that are
guaranteed to not cause a non-local exit.  They also do not detect an
accidental reentry by the current thread.  Thus, you should probably
only use them to delimit critical sections that do not contain calls
to libguile functions or to other external functions that might do
complicated things.
</p>
<p>The function <code class="code">scm_dynwind_critical_section</code>, on the other hand,
will correctly deal with non-local exits because it requires a dynwind
context.  Also, by using a separate mutex for each critical section,
it can detect accidental reentries.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="Defining-New-Foreign-Object-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Function-Snarfing" accesskey="n" rel="next">Function Snarfing</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Libguile-Concepts" accesskey="p" rel="prev">General concepts for using libguile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Defining-New-Foreign-Object-Types-1">5.5 Defining New Foreign Object Types</h3>

<p>The <em class="dfn">foreign object type</em> facility is Guile’s mechanism for
importing object and types from C or other languages into Guile’s
system.  If you have a C <code class="code">struct foo</code> type, for example, you can
define a corresponding Guile foreign object type that allows Scheme code
to handle <code class="code">struct foo *</code> objects.
</p>
<p>To define a new foreign object type, the programmer provides Guile with
some essential information about the type — what its name is, how many
fields it has, and its finalizer (if any) — and Guile allocates a
fresh type for it.  Foreign objects can be accessed from Scheme or from
C.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Foreign-Object-Types" accesskey="1">Defining Foreign Object Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Foreign-Objects" accesskey="2">Creating Foreign Objects</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Type-Checking-of-Foreign-Objects" accesskey="3">Type Checking of Foreign Objects</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management" accesskey="4">Foreign Object Memory Management</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects-and-Scheme" accesskey="5">Foreign Objects and Scheme</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Defining-Foreign-Object-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Foreign-Objects" accesskey="n" rel="next">Creating Foreign Objects</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="u" rel="up">Defining New Foreign Object Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Defining-Foreign-Object-Types-1">5.5.1 Defining Foreign Object Types</h4>

<p>To create a new foreign object type from C, call
<code class="code">scm_make_foreign_object_type</code>.  It returns a value of type
<code class="code">SCM</code> which identifies the new type.
</p>
<p>Here is how one might declare a new type representing eight-bit
gray-scale images:
</p>
<div class="example">
<pre class="example-preformatted">#include &lt;libguile.h&gt;

struct image {
  int width, height;
  char *pixels;

  /* The name of this image */
  SCM name;

  /* A function to call when this image is
     modified, e.g., to update the screen,
     or SCM_BOOL_F if no action necessary */
  SCM update_func;
};

static SCM image_type;

void
init_image_type (void)
{
  SCM name, slots;
  scm_t_struct_finalize finalizer;

  name = scm_from_utf8_symbol ("image");
  slots = scm_list_1 (scm_from_utf8_symbol ("data"));
  finalizer = NULL;

  image_type =
    scm_make_foreign_object_type (name, slots, finalizer);
}
</pre></div>

<p>The result is an initialized <code class="code">image_type</code> value that identifies the
new foreign object type.  The next section describes how to create
foreign objects and how to access their slots.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Creating-Foreign-Objects">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Type-Checking-of-Foreign-Objects" accesskey="n" rel="next">Type Checking of Foreign Objects</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Foreign-Object-Types" accesskey="p" rel="prev">Defining Foreign Object Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="u" rel="up">Defining New Foreign Object Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Creating-Foreign-Objects-1">5.5.2 Creating Foreign Objects</h4>

<p>Foreign objects contain zero or more “slots” of data.  A slot can hold
a pointer, an integer that fits into a <code class="code">size_t</code> or <code class="code">ssize_t</code>,
or a <code class="code">SCM</code> value.
</p>
<p>All objects of a given foreign type have the same number of slots.  In
the example from the previous section, the <code class="code">image</code> type has one
slot, because the slots list passed to
<code class="code">scm_make_foreign_object_type</code> is of length one.  (The actual names
given to slots are unimportant for most users of the C interface, but
can be used on the Scheme side to introspect on the foreign object.)
</p>
<p>To construct a foreign object and initialize its first slot, call
<code class="code">scm_make_foreign_object_1 (<var class="var">type</var>, <var class="var">first_slot_value</var>)</code>.
There are similarly named constructors for initializing 0, 1, 2, or 3
slots, or initializing <var class="var">n</var> slots via an array.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a>, for full details.  Any fields that are not explicitly
initialized are set to 0.
</p>
<p>To get or set the value of a slot by index, you can use the
<code class="code">scm_foreign_object_ref</code> and <code class="code">scm_foreign_object_set_x</code>
functions.  These functions take and return values as <code class="code">void *</code>
pointers; there are corresponding convenience procedures like
<code class="code">_signed_ref</code>, <code class="code">_unsigned_set_x</code> and so on for dealing with
slots as signed or unsigned integers.
</p>
<p>Foreign objects fields that are pointers can be tricky to manage.  If
possible, it is best that all memory that is referenced by a foreign
object be managed by the garbage collector.  That way, the GC can
automatically ensure that memory is accessible when it is needed, and
freed when it becomes inaccessible.  If this is not the case for your
program – for example, if you are exposing an object to Scheme that was
allocated by some other, Guile-unaware part of your program – then you
will probably need to implement a finalizer.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>, for more.
</p>
<p>Continuing the example from the previous section, if the global variable
<code class="code">image_type</code> contains the type returned by
<code class="code">scm_make_foreign_object_type</code>, here is how we could construct a
foreign object whose “data” field contains a pointer to a freshly
allocated <code class="code">struct image</code>:
</p>
<div class="example">
<pre class="example-preformatted">SCM
make_image (SCM name, SCM s_width, SCM s_height)
{
  struct image *image;
  int width = scm_to_int (s_width);
  int height = scm_to_int (s_height);

  /* Allocate the `struct image'.  Because we
     use scm_gc_malloc, this memory block will
     be automatically reclaimed when it becomes
     inaccessible, and its members will be traced
     by the garbage collector.  */
  image = (struct image *)
    scm_gc_malloc (sizeof (struct image), "image");

  image-&gt;width = width;
  image-&gt;height = height;

  /* Allocating the pixels with
     scm_gc_malloc_pointerless means that the
     pixels data is collectable by GC, but
     that GC shouldn't spend time tracing its
     contents for nested pointers because there
     aren't any.  */
  image-&gt;pixels =
    scm_gc_malloc_pointerless (width * height, "image pixels");

  image-&gt;name = name;
  image-&gt;update_func = SCM_BOOL_F;

  /* Now wrap the struct image* in a new foreign
     object, and return that object.  */
  return scm_make_foreign_object_1 (image_type, image);
}
</pre></div>

<p>We use <code class="code">scm_gc_malloc_pointerless</code> for the pixel buffer to tell the
garbage collector not to scan it for pointers.  Calls to
<code class="code">scm_gc_malloc</code>, <code class="code">scm_make_foreign_object_1</code>, and
<code class="code">scm_gc_malloc_pointerless</code> raise an exception in out-of-memory
conditions; the garbage collector is able to reclaim previously
allocated memory if that happens.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Type-Checking-of-Foreign-Objects">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management" accesskey="n" rel="next">Foreign Object Memory Management</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Foreign-Objects" accesskey="p" rel="prev">Creating Foreign Objects</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="u" rel="up">Defining New Foreign Object Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Type-Checking-of-Foreign-Objects-1">5.5.3 Type Checking of Foreign Objects</h4>

<p>Functions that operate on foreign objects should check that the passed
<code class="code">SCM</code> value indeed is of the correct type before accessing its
data.  They can do this with <code class="code">scm_assert_foreign_object_type</code>.
</p>
<p>For example, here is a simple function that operates on an image object,
and checks the type of its argument.
</p>
<div class="example">
<pre class="example-preformatted">SCM
clear_image (SCM image_obj)
{
  int area;
  struct image *image;

  scm_assert_foreign_object_type (image_type, image_obj);

  image = scm_foreign_object_ref (image_obj, 0);
  area = image-&gt;width * image-&gt;height;
  memset (image-&gt;pixels, 0, area);

  /* Invoke the image's update function.  */
  if (scm_is_true (image-&gt;update_func))
    scm_call_0 (image-&gt;update_func);

  return SCM_UNSPECIFIED;
}
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Object-Memory-Management">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects-and-Scheme" accesskey="n" rel="next">Foreign Objects and Scheme</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Type-Checking-of-Foreign-Objects" accesskey="p" rel="prev">Type Checking of Foreign Objects</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="u" rel="up">Defining New Foreign Object Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Object-Memory-Management-1">5.5.4 Foreign Object Memory Management</h4>

<p>Once a foreign object has been released to the tender mercies of the
Scheme system, it must be prepared to survive garbage collection.  In
the example above, all the memory associated with the foreign object is
managed by the garbage collector because we used the <code class="code">scm_gc_</code>
allocation functions.  Thus, no special care must be taken: the garbage
collector automatically scans them and reclaims any unused memory.
</p>
<p>However, when data associated with a foreign object is managed in some
other way—e.g., <code class="code">malloc</code>’d memory or file descriptors—it is
possible to specify a <em class="dfn">finalizer</em> function to release those
resources when the foreign object is reclaimed.
</p>
<p>As discussed in see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection">Garbage Collection</a>, Guile’s garbage collector
will reclaim inaccessible memory as needed.  This reclamation process
runs concurrently with the main program.  When Guile analyzes the heap
and determines that an object’s memory can be reclaimed, that memory is
put on a “free list” of objects that can be reclaimed.  Usually that’s
the end of it—the object is available for immediate re-use.  However
some objects can have “finalizers” associated with them—functions
that are called on reclaimable objects to effect any external cleanup
actions.
</p>
<p>Finalizers are tricky business and it is best to avoid them.  They can
be invoked at unexpected times, or not at all—for example, they are
not invoked on process exit.  They don’t help the garbage collector do
its job; in fact, they are a hindrance.  Furthermore, they perturb the
garbage collector’s internal accounting.  The GC decides to scan the
heap when it thinks that it is necessary, after some amount of
allocation.  Finalizable objects almost always represent an amount of
allocation that is invisible to the garbage collector.  The effect can
be that the actual resource usage of a system with finalizable objects
is higher than what the GC thinks it should be.
</p>
<p>All those caveats aside, some foreign object types will need finalizers.
For example, if we had a foreign object type that wrapped file
descriptors—and we aren’t suggesting this, as Guile already has ports
—then you might define the type like this:
</p>
<div class="example">
<pre class="example-preformatted">static SCM file_type;

static void
finalize_file (SCM file)
{
  int fd = scm_foreign_object_signed_ref (file, 0);
  if (fd &gt;= 0)
    {
      scm_foreign_object_signed_set_x (file, 0, -1);
      close (fd);
    }
}

static void
init_file_type (void)
{
  SCM name, slots;
  scm_t_struct_finalize finalizer;

  name = scm_from_utf8_symbol ("file");
  slots = scm_list_1 (scm_from_utf8_symbol ("fd"));
  finalizer = finalize_file;

  image_type =
    scm_make_foreign_object_type (name, slots, finalizer);
}

static SCM
make_file (int fd)
{
  return scm_make_foreign_object_1 (file_type, (void *) fd);
}
</pre></div>

<a class="index-entry-id" id="index-finalizer"></a>
<a class="index-entry-id" id="index-finalization"></a>

<p>Note that the finalizer may be invoked in ways and at times you might
not expect.  In a Guile built without threading support, finalizers are
invoked via “asyncs”, which interleaves them with running Scheme code;
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>.  If the user’s Guile is built with support for threads,
the finalizer will probably be called by a dedicated finalization
thread, unless the user invokes <code class="code">scm_run_finalizers ()</code> explicitly.
</p>
<p>In either case, finalizers run concurrently with the main program, and
so they need to be async-safe and thread-safe.  If for some reason this
is impossible, perhaps because you are embedding Guile in some
application that is not itself thread-safe, you have a few options.  One
is to use guardians instead of finalizers, and arrange to pump the
guardians for finalizable objects.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Guardians">Guardians</a>, for more
information.  The other option is to disable automatic finalization
entirely, and arrange to call <code class="code">scm_run_finalizers ()</code> at
appropriate points.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a>, for more on these
interfaces.
</p>
<p>Finalizers are allowed to allocate memory, access GC-managed memory, and
in general can do anything any Guile user code can do.  This was not the
case in Guile 1.8, where finalizers were much more restricted.  In
particular, in Guile 2.0, finalizers can resuscitate objects.  We do not
recommend that users avail themselves of this possibility, however, as a
resuscitated object can re-expose other finalizable objects that have
been already finalized back to Scheme.  These objects will not be
finalized again, but they could cause use-after-free problems to code
that handles objects of that particular foreign object type.  To guard
against this possibility, robust finalization routines should clear
state from the foreign object, as in the above <code class="code">free_file</code> example.
</p>
<p>One final caveat.  Foreign object finalizers are associated with the
lifetime of a foreign object, not of its fields.  If you access a field
of a finalizable foreign object, and do not arrange to keep a reference
on the foreign object itself, it could be that the outer foreign object
gets finalized while you are working with its field.
</p>
<p>For example, consider a procedure to read some data from a file, from
our example above.
</p>
<div class="example">
<pre class="example-preformatted">SCM
read_bytes (SCM file, SCM n)
{
  int fd;
  SCM buf;
  size_t len, pos;

  scm_assert_foreign_object_type (file_type, file);

  fd = scm_foreign_object_signed_ref (file, 0);
  if (fd &lt; 0)
    scm_wrong_type_arg_msg ("read-bytes", SCM_ARG1,
                            file, "open file");

  len = scm_to_size_t (n);
  SCM buf = scm_c_make_bytevector (scm_to_size_t (n));

  pos = 0;
  while (pos &lt; len)
    {
      char *bytes = SCM_BYTEVECTOR_CONTENTS (buf);
      ssize_t count = read (fd, bytes + pos, len - pos);
      if (count &lt; 0)
        scm_syserror ("read-bytes");
      if (count == 0)
        break;
      pos += count;
    }

  scm_remember_upto_here_1 (file);

  return scm_values (scm_list_2 (buf, scm_from_size_t (pos)));
}
</pre></div>

<p>After the prelude, only the <code class="code">fd</code> value is used and the C compiler
has no reason to keep the <code class="code">file</code> object around.  If
<code class="code">scm_c_make_bytevector</code> results in a garbage collection,
<code class="code">file</code> might not be on the stack or anywhere else and could be
finalized, leaving <code class="code">read</code> to read a closed (or, in a multi-threaded
program, possibly re-used) file descriptor.  The use of
<code class="code">scm_remember_upto_here_1</code> prevents this, by creating a reference
to <code class="code">file</code> after all data accesses.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection-Functions">Function related to Garbage Collection</a>.
</p>
<p><code class="code">scm_remember_upto_here_1</code> is only needed on finalizable objects,
because garbage collection of other values is invisible to the program
– it happens when needed, and is not observable.  But if you can, save
yourself the headache and build your program in such a way that it
doesn’t need finalization.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Objects-and-Scheme">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management" accesskey="p" rel="prev">Foreign Object Memory Management</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="u" rel="up">Defining New Foreign Object Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Objects-and-Scheme-1">5.5.5 Foreign Objects and Scheme</h4>

<p>It is also possible to create foreign objects and object types from
Scheme, and to access fields of foreign objects from Scheme.  For
example, the file example from the last section could be equivalently
expressed as:
</p>
<div class="example">
<pre class="example-preformatted">(define-module (my-file)
  #:use-module (system foreign-object)
  #:use-module ((oop goops) #:select (make))
  #:export (make-file))

(define (finalize-file file)
  (let ((fd (struct-ref file 0)))
    (unless (&lt; fd 0)
      (struct-set! file 0 -1)
      (close-fdes fd))))

(define &lt;file&gt;
  (make-foreign-object-type '&lt;file&gt; '(fd)
                            #:finalizer finalize-file))

(define (make-file fd)
  (make &lt;file&gt; #:fd fd))
</pre></div>

<p>Here we see that the result of <code class="code">make-foreign-object-type</code>, which is
the equivalent of <code class="code">scm_make_foreign_object_type</code>, is a struct
vtable.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Vtables">Vtables</a>, for more information.  To instantiate the
foreign object, which is really a Guile struct, we use <code class="code">make</code>.  (We
could have used <code class="code">make-struct/no-tail</code>, but as an implementation
detail, finalizers are attached in the <code class="code">initialize</code> method called
by <code class="code">make</code>).  To access the fields, we use <code class="code">struct-ref</code> and
<code class="code">struct-set!</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Structure-Basics">Structure Basics</a>.
</p>
<p>There is a convenience syntax, <code class="code">define-foreign-object-type</code>, that
defines a type along with a constructor, and getters for the fields.  An
appropriate invocation of <code class="code">define-foreign-object-type</code> for the
file object type could look like this:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign-object))

(define-foreign-object-type &lt;file&gt;
  make-file
  (fd)
  #:finalizer finalize-file)
</pre></div>

<p>This defines the <code class="code">&lt;file&gt;</code> type with one field, a <code class="code">make-file</code>
constructor, and a getter for the <code class="code">fd</code> field, bound to <code class="code">fd</code>.
</p>
<p>Foreign object types are not only vtables but are actually GOOPS
classes, as hinted at above.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS">GOOPS</a>, for more on Guile’s
object-oriented programming system.  Thus one can define print and
equality methods using GOOPS:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (oop goops))

(define-method (write (file &lt;file&gt;) port)
  ;; Assuming existence of the `fd' getter
  (format port "#&lt;&lt;file&gt; ~a&gt;" (fd file)))

(define-method (equal? (a &lt;file&gt;) (b &lt;file&gt;))
  (eqv? (fd a) (fd b)))
</pre></div>

<p>One can even sub-class foreign types.
</p>
<div class="example">
<pre class="example-preformatted">(define-class &lt;named-file&gt; (&lt;file&gt;)
  (name #:init-keyword #:name #:init-value #f #:accessor name))
</pre></div>

<p>The question arises of how to construct these values, given that
<code class="code">make-file</code> returns a plain old <code class="code">&lt;file&gt;</code> object.  It turns out
that you can use the GOOPS construction interface, where every field of
the foreign object has an associated initialization keyword argument.
</p>
<div class="example">
<pre class="example-preformatted">(define* (my-open-file name #:optional (flags O_RDONLY))
  (make &lt;named-file&gt; #:fd (open-fdes name flags) #:name name))

(define-method (write (file &lt;named-file&gt;) port)
  (format port "#&lt;&lt;file&gt; ~s ~a&gt;" (name file) (fd file)))
</pre></div>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a>, for full documentation on the Scheme interface
to foreign objects.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS">GOOPS</a>, for more on GOOPS.
</p>
<p>As a final note, you might wonder how this system supports encapsulation
of sensitive values.  First, we have to recognize that some facilities
are essentially unsafe and have global scope.  For example, in C, the
integrity and confidentiality of a part of a program is at the mercy of
every other part of that program – because any part of the program can
read and write anything in its address space.  At the same time,
principled access to structured data is organized in C on lexical
boundaries; if you don’t expose accessors for your object, you trust
other parts of the program not to work around that barrier.
</p>
<p>The situation is not dissimilar in Scheme.  Although Scheme’s unsafe
constructs are fewer in number than in C, they do exist.  The
<code class="code">(system foreign)</code> module can be used to violate confidentiality
and integrity, and shouldn’t be exposed to untrusted code.  Although
<code class="code">struct-ref</code> and <code class="code">struct-set!</code> are less unsafe, they still
have a cross-cutting capability of drilling through abstractions.
Performing a <code class="code">struct-set!</code> on a foreign object slot could cause
unsafe foreign code to crash.  Ultimately, structures in Scheme are
capabilities for abstraction, and not abstractions themselves.
</p>
<p>That leaves us with the lexical capabilities, like constructors and
accessors.  Here is where encapsulation lies: the practical degree to
which the innards of your foreign objects are exposed is the degree to
which their accessors are lexically available in user code.  If you want
to allow users to reference fields of your foreign object, provide them
with a getter.  Otherwise you should assume that the only access to your
object may come from your code, which has the relevant authority, or via
code with access to cross-cutting <code class="code">struct-ref</code> and such, which also
has the cross-cutting authority.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="Function-Snarfing">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="n" rel="next">An Overview of Guile Programming</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types" accesskey="p" rel="prev">Defining New Foreign Object Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Function-Snarfing-1">5.6 Function Snarfing</h3>

<p>When writing C code for use with Guile, you typically define a set of
C functions, and then make some of them visible to the Scheme world by
calling <code class="code">scm_c_define_gsubr</code> or related functions.  If you have
many functions to publish, it can sometimes be annoying to keep the
list of calls to <code class="code">scm_c_define_gsubr</code> in sync with the list of
function definitions.
</p>
<p>Guile provides the <code class="code">guile-snarf</code> program to manage this problem.
Using this tool, you can keep all the information needed to define the
function alongside the function definition itself; <code class="code">guile-snarf</code>
will extract this information from your source code, and automatically
generate a file of calls to <code class="code">scm_c_define_gsubr</code> which you can
<code class="code">#include</code> into an initialization function.
</p>
<p>The snarfing mechanism works for many kind of initialization actions,
not just for collecting calls to <code class="code">scm_c_define_gsubr</code>.  For a
full list of what can be done, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Snarfing-Macros">Snarfing Macros</a>.
</p>
<a class="index-entry-id" id="index-guile_002dsnarf-invocation"></a>
<a class="index-entry-id" id="index-guile_002dsnarf-example"></a>

<p>The <code class="code">guile-snarf</code> program is invoked like this:
</p>
<div class="example smallexample">
<pre class="example-preformatted">guile-snarf [-o <var class="var">outfile</var>] [<var class="var">cpp-args</var> ...]
</pre></div>

<p>This command will extract initialization actions to <var class="var">outfile</var>.
When no <var class="var">outfile</var> has been specified or when <var class="var">outfile</var> is
<code class="code">-</code>, standard output will be used.  The C preprocessor is called
with <var class="var">cpp-args</var> (which usually include an input file) and the
output is filtered to extract the initialization actions.
</p>
<p>If there are errors during processing, <var class="var">outfile</var> is deleted and the
program exits with non-zero status.
</p>
<p>During snarfing, the pre-processor macro <code class="code">SCM_MAGIC_SNARFER</code> is
defined.  You could use this to avoid including snarfer output files
that don’t yet exist by writing code like this:
</p>
<div class="example smallexample">
<pre class="example-preformatted">#ifndef SCM_MAGIC_SNARFER
#include "foo.x"
#endif
</pre></div>

<p>Here is how you might define the Scheme function <code class="code">clear-image</code>,
implemented by the C function <code class="code">clear_image</code>:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">#include &lt;libguile.h&gt;

SCM_DEFINE (clear_image, "clear-image", 1, 0, 0,
            (SCM image),
            "Clear the image.")
{
  /* C code to clear the image in <code class="code">image</code>... */
}

void
init_image_type ()
{
#include "image-type.x"
}
</pre></div></div>

<p>The <code class="code">SCM_DEFINE</code> declaration says that the C function
<code class="code">clear_image</code> implements a Scheme function called
<code class="code">clear-image</code>, which takes one required argument (of type
<code class="code">SCM</code> and named <code class="code">image</code>), no optional arguments, and no rest
argument.  The string <code class="code">"Clear the image."</code> provides a short help
text for the function, it is called a <em class="dfn">docstring</em>.
</p>
<p><code class="code">SCM_DEFINE</code> macro also defines a static array of characters
initialized to the Scheme name of the function.  In this case,
<code class="code">s_clear_image</code> is set to the C string, "clear-image".  You might
want to use this symbol when generating error messages.
</p>
<p>Assuming the text above lives in a file named <samp class="file">image-type.c</samp>, you
will need to execute the following command to prepare this file for
compilation:
</p>
<div class="example">
<pre class="example-preformatted">guile-snarf -o image-type.x image-type.c
</pre></div>

<p>This scans <samp class="file">image-type.c</samp> for <code class="code">SCM_DEFINE</code>
declarations, and writes to <samp class="file">image-type.x</samp> the output:
</p>
<div class="example">
<pre class="example-preformatted">scm_c_define_gsubr ("clear-image", 1, 0, 0, (SCM (*)() ) clear_image);
</pre></div>

<p>When compiled normally, <code class="code">SCM_DEFINE</code> is a macro which expands to
the function header for <code class="code">clear_image</code>.
</p>
<p>Note that the output file name matches the <code class="code">#include</code> from the
input file.  Also, you still need to provide all the same information
you would if you were using <code class="code">scm_c_define_gsubr</code> yourself, but you
can place the information near the function definition itself, so it is
less likely to become incorrect or out-of-date.
</p>
<p>If you have many files that <code class="code">guile-snarf</code> must process, you should
consider using a fragment like the following in your Makefile:
</p>
<div class="example">
<pre class="example-preformatted">snarfcppopts = $(DEFS) $(INCLUDES) $(CPPFLAGS) $(CFLAGS)
.SUFFIXES: .x
.c.x:
	guile-snarf -o $@ $&lt; $(snarfcppopts)
</pre></div>

<p>This tells make to run <code class="code">guile-snarf</code> to produce each needed
<samp class="file">.x</samp> file from the corresponding <samp class="file">.c</samp> file.
</p>
<p>The program <code class="code">guile-snarf</code> passes its command-line arguments
directly to the C preprocessor, which it uses to extract the
information it needs from the source code. this means you can pass
normal compilation flags to <code class="code">guile-snarf</code> to define preprocessor
symbols, add header file directories, and so on.
</p>
<hr>
</div>
<div class="section-level-extent" id="Programming-Overview">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support" accesskey="n" rel="next">Autoconf Support</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Function-Snarfing" accesskey="p" rel="prev">Function Snarfing</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="An-Overview-of-Guile-Programming">5.7 An Overview of Guile Programming</h3>

<p>Guile is designed as an extension language interpreter that is
straightforward to integrate with applications written in C (and C++).
The big win here for the application developer is that Guile
integration, as the Guile web page says, “lowers your project’s
hacktivation energy.”  Lowering the hacktivation energy means that you,
as the application developer, <em class="emph">and your users</em>, reap the benefits
that flow from being able to extend the application in a high level
extension language rather than in plain old C.
</p>
<p>In abstract terms, it’s difficult to explain what this really means and
what the integration process involves, so instead let’s begin by jumping
straight into an example of how you might integrate Guile into an
existing program, and what you could expect to gain by so doing.  With
that example under our belts, we’ll then return to a more general
analysis of the arguments involved and the range of programming options
available.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="1">How One Might Extend Dia Using Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-vs-C" accesskey="2">Why Scheme is More Hackable Than C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Testbed-Example" accesskey="3">Example: Using Guile for an Application Testbed</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="4">A Choice of Programming Options</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#User-Programming" accesskey="5">How About Application Users?</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Extending-Dia">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-vs-C" accesskey="n" rel="next">Why Scheme is More Hackable Than C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="u" rel="up">An Overview of Guile Programming</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="How-One-Might-Extend-Dia-Using-Guile">5.7.1 How One Might Extend Dia Using Guile</h4>

<p>Dia is a free software program for drawing schematic diagrams like flow
charts and floor plans (<a class="uref" href="http://www.gnome.org/projects/dia/">http://www.gnome.org/projects/dia/</a>).
This section conducts the thought
experiment of adding Guile to Dia.  In so doing, it aims to illustrate
several of the steps and considerations involved in adding Guile to
applications in general.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objective" accesskey="1">Deciding Why You Want to Add Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Steps" accesskey="2">Four Steps Required to Add Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objects" accesskey="3">How to Represent Dia Data in Scheme</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Primitives" accesskey="4">Writing Guile Primitives for Dia</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Hook" accesskey="5">Providing a Hook for the Evaluation of Scheme Code</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Structure" accesskey="6">Top-level Structure of Guile-enabled Dia</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Advanced" accesskey="7">Going Further with Dia and Guile</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Dia-Objective">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Steps" accesskey="n" rel="next">Four Steps Required to Add Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Deciding-Why-You-Want-to-Add-Guile">5.7.1.1 Deciding Why You Want to Add Guile</h4>

<p>First off, you should understand why you want to add Guile to Dia at
all, and that means forming a picture of what Dia does and how it does
it.  So, what are the constituents of the Dia application?
</p>
<ul class="itemize mark-bullet">
<li>Most importantly, the <em class="dfn">application domain objects</em> — in other
words, the concepts that differentiate Dia from another application such
as a word processor or spreadsheet: shapes, templates, connectors,
pages, plus the properties of all these things.

</li><li>The code that manages the graphical face of the application, including
the layout and display of the objects above.

</li><li>The code that handles input events, which indicate that the application
user is wanting to do something.
</li></ul>

<p>(In other words, a textbook example of the <em class="dfn">model - view -
controller</em> paradigm.)
</p>
<p>Next question: how will Dia benefit once the Guile integration is
complete?  Several (positive!) answers are possible here, and the choice
is obviously up to the application developers.  Still, one answer is
that the main benefit will be the ability to manipulate Dia’s
application domain objects from Scheme.
</p>
<p>Suppose that Dia made a set of procedures available in Scheme,
representing the most basic operations on objects such as shapes,
connectors, and so on.  Using Scheme, the application user could then
write code that builds upon these basic operations to create more
complex procedures.  For example, given basic procedures to enumerate
the objects on a page, to determine whether an object is a square, and
to change the fill pattern of a single shape, the user can write a
Scheme procedure to change the fill pattern of all squares on the
current page:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (change-squares'-fill-pattern new-pattern)
  (for-each-shape current-page
    (lambda (shape)
      (if (square? shape)
          (change-fill-pattern shape new-pattern)))))
</pre></div>


<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Steps">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objects" accesskey="n" rel="next">How to Represent Dia Data in Scheme</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objective" accesskey="p" rel="prev">Deciding Why You Want to Add Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Four-Steps-Required-to-Add-Guile">5.7.1.2 Four Steps Required to Add Guile</h4>

<p>Assuming this objective, four steps are needed to achieve it.
</p>
<p>First, you need a way of representing your application-specific objects
— such as <code class="code">shape</code> in the previous example — when they are
passed into the Scheme world.  Unless your objects are so simple that
they map naturally into builtin Scheme data types like numbers and
strings, you will probably want to use Guile’s <em class="dfn">foreign object</em>
interface to create a new Scheme data type for your objects.
</p>
<p>Second, you need to write code for the basic operations like
<code class="code">for-each-shape</code> and <code class="code">square?</code> such that they access and
manipulate your existing data structures correctly, and then make these
operations available as <em class="dfn">primitives</em> on the Scheme level.
</p>
<p>Third, you need to provide some mechanism within the Dia application
that a user can hook into to cause arbitrary Scheme code to be
evaluated.
</p>
<p>Finally, you need to restructure your top-level application C code a
little so that it initializes the Guile interpreter correctly and
declares your <em class="dfn">foreign objects</em> and <em class="dfn">primitives</em> to the Scheme
world.
</p>
<p>The following subsections expand on these four points in turn.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Objects">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Primitives" accesskey="n" rel="next">Writing Guile Primitives for Dia</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Steps" accesskey="p" rel="prev">Four Steps Required to Add Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="How-to-Represent-Dia-Data-in-Scheme">5.7.1.3 How to Represent Dia Data in Scheme</h4>

<p>For all but the most trivial applications, you will probably want to
allow some representation of your domain objects to exist on the Scheme
level.  This is where foreign objects come in, and with them issues of
lifetime management and garbage collection.
</p>
<p>To get more concrete about this, let’s look again at the example we gave
earlier of how application users can use Guile to build higher-level
functions from the primitives that Dia itself provides.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (change-squares'-fill-pattern new-pattern)
  (for-each-shape current-page
    (lambda (shape)
      (if (square? shape)
          (change-fill-pattern shape new-pattern)))))
</pre></div>

<p>Consider what is stored here in the variable <code class="code">shape</code>.  For each
shape on the current page, the <code class="code">for-each-shape</code> primitive calls
<code class="code">(lambda (shape) …)</code> with an argument representing that
shape.  Question is: how is that argument represented on the Scheme
level?  The issues are as follows.
</p>
<ul class="itemize mark-bullet">
<li>Whatever the representation, it has to be decodable again by the C code
for the <code class="code">square?</code> and <code class="code">change-fill-pattern</code> primitives.  In
other words, a primitive like <code class="code">square?</code> has somehow to be able to
turn the value that it receives back into something that points to the
underlying C structure describing a shape.

</li><li>The representation must also cope with Scheme code holding on to the
value for later use.  What happens if the Scheme code stores
<code class="code">shape</code> in a global variable, but then that shape is deleted (in a
way that the Scheme code is not aware of), and later on some other
Scheme code uses that global variable again in a call to, say,
<code class="code">square?</code>?

</li><li>The lifetime and memory allocation of objects that exist <em class="emph">only</em> in
the Scheme world is managed automatically by Guile’s garbage collector
using one simple rule: when there are no remaining references to an
object, the object is considered dead and so its memory is freed.  But
for objects that exist in both C and Scheme, the picture is more
complicated; in the case of Dia, where the <code class="code">shape</code> argument passes
transiently in and out of the Scheme world, it would be quite wrong the
<strong class="strong">delete</strong> the underlying C shape just because the Scheme code has
finished evaluation.  How do we avoid this happening?
</li></ul>

<p>One resolution of these issues is for the Scheme-level representation of
a shape to be a new, Scheme-specific C structure wrapped up as a foreign
object.  The foreign object is what is passed into and out of Scheme
code, and the Scheme-specific C structure inside the foreign object
points to Dia’s underlying C structure so that the code for primitives
like <code class="code">square?</code> can get at it.
</p>
<p>To cope with an underlying shape being deleted while Scheme code is
still holding onto a Scheme shape value, the underlying C structure
should have a new field that points to the Scheme-specific foreign
object.  When a shape is deleted, the relevant code chains through to
the Scheme-specific structure and sets its pointer back to the
underlying structure to NULL.  Thus the foreign object value for the
shape continues to exist, but any primitive code that tries to use it
will detect that the underlying shape has been deleted because the
underlying structure pointer is NULL.
</p>
<p>So, to summarize the steps involved in this resolution of the problem
(and assuming that the underlying C structure for a shape is
<code class="code">struct dia_shape</code>):
</p>
<ul class="itemize mark-bullet">
<li>Define a new Scheme-specific structure that <em class="emph">points</em> to the
underlying C structure:

<div class="example lisp">
<pre class="lisp-preformatted">struct dia_guile_shape
{
  struct dia_shape * c_shape;   /* NULL =&gt; deleted */
}
</pre></div>

</li><li>Add a field to <code class="code">struct dia_shape</code> that points to its <code class="code">struct
dia_guile_shape</code> if it has one —

<div class="example lisp">
<pre class="lisp-preformatted">struct dia_shape
{
  …
  struct dia_guile_shape * guile_shape;
}
</pre></div>

<p>— so that C code can set <code class="code">guile_shape-&gt;c_shape</code> to NULL when the
underlying shape is deleted.
</p>
</li><li>Wrap <code class="code">struct dia_guile_shape</code> as a foreign object type.

</li><li>Whenever you need to represent a C shape onto the Scheme level, create a
foreign object instance for it, and pass that.

</li><li>In primitive code that receives a shape foreign object instance, check the
<code class="code">c_shape</code> field when decoding it, to find out whether the
underlying C shape is still there.
</li></ul>

<p>As far as memory management is concerned, the foreign object values and
their Scheme-specific structures are under the control of the garbage
collector, whereas the underlying C structures are explicitly managed in
exactly the same way that Dia managed them before we thought of adding
Guile.
</p>
<p>When the garbage collector decides to free a shape foreign object value,
it calls the <em class="dfn">finalizer</em> function that was specified when defining
the shape foreign object type.  To maintain the correctness of the
<code class="code">guile_shape</code> field in the underlying C structure, this function
should chain through to the underlying C structure (if it still exists)
and set its <code class="code">guile_shape</code> field to NULL.
</p>
<p>For full documentation on defining and using foreign object types, see
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types">Defining New Foreign Object Types</a>.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Primitives">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Hook" accesskey="n" rel="next">Providing a Hook for the Evaluation of Scheme Code</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Objects" accesskey="p" rel="prev">How to Represent Dia Data in Scheme</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Writing-Guile-Primitives-for-Dia">5.7.1.4 Writing Guile Primitives for Dia</h4>

<p>Once the details of object representation are decided, writing the
primitive function code that you need is usually straightforward.
</p>
<p>A primitive is simply a C function whose arguments and return value are
all of type <code class="code">SCM</code>, and whose body does whatever you want it to do.
As an example, here is a possible implementation of the <code class="code">square?</code>
primitive:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">static SCM square_p (SCM shape)
{
  struct dia_guile_shape * guile_shape;

  /* Check that arg is really a shape object. */
  scm_assert_foreign_object_type (shape_type, shape);

  /* Access Scheme-specific shape structure. */
  guile_shape = scm_foreign_object_ref (shape, 0);

  /* Find out if underlying shape exists and is a
     square; return answer as a Scheme boolean. */
  return scm_from_bool (guile_shape-&gt;c_shape &amp;&amp;
                        (guile_shape-&gt;c_shape-&gt;type == DIA_SQUARE));
}
</pre></div>

<p>Notice how easy it is to chain through from the <code class="code">SCM shape</code>
parameter that <code class="code">square_p</code> receives — which is a foreign object
— to the Scheme-specific structure inside the foreign object, and
thence to the underlying C structure for the shape.
</p>
<p>In this code, <code class="code">scm_assert_foreign_object_type</code>,
<code class="code">scm_foreign_object_ref</code>, and <code class="code">scm_from_bool</code> are from the
standard Guile API.  We assume that <code class="code">shape_type</code> was given to us
when we made the shape foreign object type, using
<code class="code">scm_make_foreign_object_type</code>.  The call to
<code class="code">scm_assert_foreign_object_type</code> ensures that <var class="var">shape</var> is indeed
a shape.  This is needed to guard against Scheme code using the
<code class="code">square?</code>  procedure incorrectly, as in <code class="code">(square? "hello")</code>;
Scheme’s latent typing means that usage errors like this must be caught
at run time.
</p>
<p>Having written the C code for your primitives, you need to make them
available as Scheme procedures by calling the <code class="code">scm_c_define_gsubr</code>
function.  <code class="code">scm_c_define_gsubr</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures">Primitive Procedures</a>)
takes arguments that specify the Scheme-level name for the primitive and
how many required, optional and rest arguments it can accept.  The
<code class="code">square?</code> primitive always requires exactly one argument, so the
call to make it available in Scheme reads like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scm_c_define_gsubr ("square?", 1, 0, 0, square_p);
</pre></div>

<p>For where to put this call, see the subsection after next on the
structure of Guile-enabled code (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Structure">Top-level Structure of Guile-enabled Dia</a>).
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Hook">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Structure" accesskey="n" rel="next">Top-level Structure of Guile-enabled Dia</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Primitives" accesskey="p" rel="prev">Writing Guile Primitives for Dia</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Providing-a-Hook-for-the-Evaluation-of-Scheme-Code">5.7.1.5 Providing a Hook for the Evaluation of Scheme Code</h4>

<p>To make the Guile integration useful, you have to design some kind of
hook into your application that application users can use to cause their
Scheme code to be evaluated.
</p>
<p>Technically, this is straightforward; you just have to decide on a
mechanism that is appropriate for your application.  Think of Emacs, for
example: when you type <kbd class="kbd"><kbd class="key">ESC</kbd> :</kbd>, you get a prompt where you can
type in any Elisp code, which Emacs will then evaluate.  Or, again like
Emacs, you could provide a mechanism (such as an init file) to allow
Scheme code to be associated with a particular key sequence, and
evaluate the code when that key sequence is entered.
</p>
<p>In either case, once you have the Scheme code that you want to evaluate,
as a null terminated string, you can tell Guile to evaluate it by
calling the <code class="code">scm_c_eval_string</code> function.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Structure">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Advanced" accesskey="n" rel="next">Going Further with Dia and Guile</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Hook" accesskey="p" rel="prev">Providing a Hook for the Evaluation of Scheme Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Top_002dlevel-Structure-of-Guile_002denabled-Dia">5.7.1.6 Top-level Structure of Guile-enabled Dia</h4>

<p>Let’s assume that the pre-Guile Dia code looks structurally like this:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">main ()</code>

<ul class="itemize mark-bullet">
<li>do lots of initialization and setup stuff
</li><li>enter Gtk main loop
</li></ul>
</li></ul>

<p>When you add Guile to a program, one (rather technical) requirement is
that Guile’s garbage collector needs to know where the bottom of the C
stack is.  The easiest way to ensure this is to use
<code class="code">scm_boot_guile</code> like this:
</p>
<ul class="itemize mark-bullet">
<li><code class="code">main ()</code>

<ul class="itemize mark-bullet">
<li>do lots of initialization and setup stuff
</li><li><code class="code">scm_boot_guile (argc, argv, inner_main, NULL)</code>
</li></ul>

</li><li><code class="code">inner_main ()</code>

<ul class="itemize mark-bullet">
<li>define all foreign object types
</li><li>export primitives to Scheme using <code class="code">scm_c_define_gsubr</code>
</li><li>enter Gtk main loop
</li></ul>
</li></ul>

<p>In other words, you move the guts of what was previously in your
<code class="code">main</code> function into a new function called <code class="code">inner_main</code>, and
then add a <code class="code">scm_boot_guile</code> call, with <code class="code">inner_main</code> as a
parameter, to the end of <code class="code">main</code>.
</p>
<p>Assuming that you are using foreign objects and have written primitive
code as described in the preceding subsections, you also need to insert
calls to declare your new foreign objects and export the primitives to
Scheme.  These declarations must happen <em class="emph">inside</em> the dynamic scope
of the <code class="code">scm_boot_guile</code> call, but also <em class="emph">before</em> any code is
run that could possibly use them — the beginning of <code class="code">inner_main</code>
is an ideal place for this.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Dia-Advanced">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dia-Structure" accesskey="p" rel="prev">Top-level Structure of Guile-enabled Dia</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="u" rel="up">How One Might Extend Dia Using Guile</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Going-Further-with-Dia-and-Guile">5.7.1.7 Going Further with Dia and Guile</h4>

<p>The steps described so far implement an initial Guile integration that
already gives a lot of additional power to Dia application users.  But
there are further steps that you could take, and it’s interesting to
consider a few of these.
</p>
<p>In general, you could progressively move more of Dia’s source code from
C into Scheme.  This might make the code more maintainable and
extensible, and it could open the door to new programming paradigms that
are tricky to effect in C but straightforward in Scheme.
</p>
<p>A specific example of this is that you could use the guile-gtk package,
which provides Scheme-level procedures for most of the Gtk+ library, to
move the code that lays out and displays Dia objects from C to Scheme.
</p>
<p>As you follow this path, it naturally becomes less useful to maintain a
distinction between Dia’s original non-Guile-related source code, and
its later code implementing foreign objects and primitives for the
Scheme world.
</p>
<p>For example, suppose that the original source code had a
<code class="code">dia_change_fill_pattern</code> function:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">void dia_change_fill_pattern (struct dia_shape * shape,
                              struct dia_pattern * pattern)
{
  /* real pattern change work */
}
</pre></div>

<p>During initial Guile integration, you add a <code class="code">change_fill_pattern</code>
primitive for Scheme purposes, which accesses the underlying structures
from its foreign object values and uses <code class="code">dia_change_fill_pattern</code>
to do the real work:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">SCM change_fill_pattern (SCM shape, SCM pattern)
{
  struct dia_shape * d_shape;
  struct dia_pattern * d_pattern;

  …

  dia_change_fill_pattern (d_shape, d_pattern);

  return SCM_UNSPECIFIED;
}
</pre></div>

<p>At this point, it makes sense to keep <code class="code">dia_change_fill_pattern</code> and
<code class="code">change_fill_pattern</code> separate, because
<code class="code">dia_change_fill_pattern</code> can also be called without going through
Scheme at all, say because the user clicks a button which causes a
C-registered Gtk+ callback to be called.
</p>
<p>But, if the code for creating buttons and registering their callbacks is
moved into Scheme (using guile-gtk), it may become true that
<code class="code">dia_change_fill_pattern</code> can no longer be called other than
through Scheme.  In which case, it makes sense to abolish it and move
its contents directly into <code class="code">change_fill_pattern</code>, like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">SCM change_fill_pattern (SCM shape, SCM pattern)
{
  struct dia_shape * d_shape;
  struct dia_pattern * d_pattern;

  …

  /* real pattern change work */

  return SCM_UNSPECIFIED;
}
</pre></div>

<p>So further Guile integration progressively <em class="emph">reduces</em> the amount of
functional C code that you have to maintain over the long term.
</p>
<p>A similar argument applies to data representation.  In the discussion of
foreign objects earlier, issues arose because of the different memory
management and lifetime models that normally apply to data structures in
C and in Scheme.  However, with further Guile integration, you can
resolve this issue in a more radical way by allowing all your data
structures to be under the control of the garbage collector, and kept
alive by references from the Scheme world.  Instead of maintaining an
array or linked list of shapes in C, you would instead maintain a list
in Scheme.
</p>
<p>Rather like the coalescing of <code class="code">dia_change_fill_pattern</code> and
<code class="code">change_fill_pattern</code>, the practical upshot of such a change is
that you would no longer have to keep the <code class="code">dia_shape</code> and
<code class="code">dia_guile_shape</code> structures separate, and so wouldn’t need to
worry about the pointers between them.  Instead, you could change the
foreign object definition to wrap the <code class="code">dia_shape</code> structure
directly, and send <code class="code">dia_guile_shape</code> off to the scrap yard.  Cut
out the middle man!
</p>
<p>Finally, we come to the holy grail of Guile’s free software / extension
language approach.  Once you have a Scheme representation for
interesting Dia data types like shapes, and a handy bunch of primitives
for manipulating them, it suddenly becomes clear that you have a bundle
of functionality that could have far-ranging use beyond Dia itself.  In
other words, the data types and primitives could now become a library,
and Dia becomes just one of the many possible applications using that
library — albeit, at this early stage, a rather important one!
</p>
<p>In this model, Guile becomes just the glue that binds everything
together.  Imagine an application that usefully combined functionality
from Dia, Gnumeric and GnuCash — it’s tricky right now, because no
such application yet exists; but it’ll happen some day …
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Scheme-vs-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Testbed-Example" accesskey="n" rel="next">Example: Using Guile for an Application Testbed</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Extending-Dia" accesskey="p" rel="prev">How One Might Extend Dia Using Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="u" rel="up">An Overview of Guile Programming</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Why-Scheme-is-More-Hackable-Than-C">5.7.2 Why Scheme is More Hackable Than C</h4>

<p>Underlying Guile’s value proposition is the assumption that programming
in a high level language, specifically Guile’s implementation of Scheme,
is necessarily better in some way than programming in C.  What do we
mean by this claim, and how can we be so sure?
</p>
<p>One class of advantages applies not only to Scheme, but more generally
to any interpretable, high level, scripting language, such as Emacs
Lisp, Python, Ruby, or TeX’s macro language.  Common features of all
such languages, when compared to C, are that:
</p>
<ul class="itemize mark-bullet">
<li>They lend themselves to rapid and experimental development cycles,
owing usually to a combination of their interpretability and the
integrated development environment in which they are used.

</li><li>They free developers from some of the low level bookkeeping tasks
associated with C programming, notably memory management.

</li><li>They provide high level features such as container objects and exception
handling that make common programming tasks easier.
</li></ul>

<p>In the case of Scheme, particular features that make programming easier
— and more fun! — are its powerful mechanisms for abstracting parts
of programs (closures — see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The Concept of Closure</a>) and for iteration
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#while-do">Iteration mechanisms</a>).
</p>
<p>The evidence in support of this argument is empirical: the huge amount
of code that has been written in extension languages for applications
that support this mechanism.  Most notable are extensions written in
Emacs Lisp for GNU Emacs, in TeX’s macro language for TeX, and in
Script-Fu for the Gimp, but there is increasingly now a significant code
eco-system for Guile-based applications as well, such as Lilypond and
GnuCash.  It is close to inconceivable that similar amounts of
functionality could have been added to these applications just by
writing new code in their base implementation languages.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Testbed-Example">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="n" rel="next">A Choice of Programming Options</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-vs-C" accesskey="p" rel="prev">Why Scheme is More Hackable Than C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="u" rel="up">An Overview of Guile Programming</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Example_003a-Using-Guile-for-an-Application-Testbed">5.7.3 Example: Using Guile for an Application Testbed</h4>

<p>As an example of what this means in practice, imagine writing a testbed
for an application that is tested by submitting various requests (via a
C interface) and validating the output received.  Suppose further that
the application keeps an idea of its current state, and that the
“correct” output for a given request may depend on the current
application state.  A complete “white box”<a class="footnote" id="DOCF6" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT6"><sup>6</sup></a> test plan for this application would aim to
submit all possible requests in each distinguishable state, and validate
the output for all request/state combinations.
</p>
<p>To write all this test code in C would be very tedious.  Suppose instead
that the testbed code adds a single new C function, to submit an
arbitrary request and return the response, and then uses Guile to export
this function as a Scheme procedure.  The rest of the testbed can then
be written in Scheme, and so benefits from all the advantages of
programming in Scheme that were described in the previous section.
</p>
<p>(In this particular example, there is an additional benefit of writing
most of the testbed in Scheme.  A common problem for white box testing
is that mistakes and mistaken assumptions in the application under test
can easily be reproduced in the testbed code.  It is more difficult to
copy mistakes like this when the testbed is written in a different
language from the application.)
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Programming-Options">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#User-Programming" accesskey="n" rel="next">How About Application Users?</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Testbed-Example" accesskey="p" rel="prev">Example: Using Guile for an Application Testbed</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="u" rel="up">An Overview of Guile Programming</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="A-Choice-of-Programming-Options">5.7.4 A Choice of Programming Options</h4>

<p>The preceding arguments and example point to a model of Guile
programming that is applicable in many cases.  According to this model,
Guile programming involves a balance between C and Scheme programming,
with the aim being to extract the greatest possible Scheme level benefit
from the least amount of C level work.
</p>
<p>The C level work required in this model usually consists of packaging
and exporting functions and application objects such that they can be
seen and manipulated on the Scheme level.  To help with this, Guile’s C
language interface includes utility features that aim to make this kind
of integration very easy for the application developer.
</p>
<p>This model, though, is really just one of a range of possible
programming options.  If all of the functionality that you need is
available from Scheme, you could choose instead to write your whole
application in Scheme (or one of the other high level languages that
Guile supports through translation), and simply use Guile as an
interpreter for Scheme.  (In the future, we hope that Guile will also be
able to compile Scheme code, so lessening the performance gap between C
and Scheme code.)  Or, at the other end of the C–Scheme scale, you
could write the majority of your application in C, and only call out to
Guile occasionally for specific actions such as reading a configuration
file or executing a user-specified extension.  The choices boil down to
two basic questions:
</p>
<ul class="itemize mark-bullet">
<li>Which parts of the application do you write in C, and which in Scheme
(or another high level translated language)?

</li><li>How do you design the interface between the C and Scheme parts of your
application?
</li></ul>

<p>These are of course design questions, and the right design for any given
application will always depend upon the particular requirements that you
are trying to meet.  In the context of Guile, however, there are some
generally applicable considerations that can help you when designing
your answers.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Available-Functionality" accesskey="1">What Functionality is Already Available?</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Basic-Constraints" accesskey="2">Functional and Performance Constraints</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Style-Choices" accesskey="3">Your Preferred Programming Style</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Program-Control" accesskey="4">What Controls Program Execution?</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Available-Functionality">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Basic-Constraints" accesskey="n" rel="next">Functional and Performance Constraints</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="u" rel="up">A Choice of Programming Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="What-Functionality-is-Already-Available_003f">5.7.4.1 What Functionality is Already Available?</h4>

<p>Suppose, for the sake of argument, that you would prefer to write your
whole application in Scheme.  Then the API available to you consists of:
</p>
<ul class="itemize mark-bullet">
<li>standard Scheme

</li><li>plus the extensions to standard Scheme provided by
Guile in its core distribution

</li><li>plus any additional functionality that you or others have packaged so
that it can be loaded as a Guile Scheme module.
</li></ul>

<p>A module in the last category can either be a pure Scheme module — in
other words a collection of utility procedures coded in Scheme — or a
module that provides a Scheme interface to an extension library coded in
C — in other words a nice package where someone else has done the work
of wrapping up some useful C code for you.  The set of available modules
is growing quickly and already includes such useful examples as
<code class="code">(gtk gtk)</code>, which makes Gtk+ drawing functions available in
Scheme, and <code class="code">(database postgres)</code>, which provides SQL access to a
Postgres database.
</p>
<p>Given the growing collection of pre-existing modules, it is quite
feasible that your application could be implemented by combining a
selection of these modules together with new application code written in
Scheme.
</p>
<p>If this approach is not enough, because the functionality that your
application needs is not already available in this form, and it is
impossible to write the new functionality in Scheme, you will need to
write some C code.  If the required function is already available in C
(e.g. in a library), all you need is a little glue to connect it to the
world of Guile.  If not, you need both to write the basic code and to
plumb it into Guile.
</p>
<p>In either case, two general considerations are important.  Firstly, what
is the interface by which the functionality is presented to the Scheme
world?  Does the interface consist only of function calls (for example,
a simple drawing interface), or does it need to include <em class="dfn">objects</em> of
some kind that can be passed between C and Scheme and manipulated by
both worlds.  Secondly, how does the lifetime and memory management of
objects in the C code relate to the garbage collection governed approach
of Scheme objects?  In the case where the basic C code is not already
written, most of the difficulties of memory management can be avoided by
using Guile’s C interface features from the start.
</p>
<p>For the full documentation on writing C code for Guile and connecting
existing C code to the Guile world, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types">Defining New Foreign Object Types</a>, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures">Primitive Procedures</a>, and <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface">Foreign Function Interface</a>.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Basic-Constraints">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Style-Choices" accesskey="n" rel="next">Your Preferred Programming Style</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Available-Functionality" accesskey="p" rel="prev">What Functionality is Already Available?</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="u" rel="up">A Choice of Programming Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Functional-and-Performance-Constraints">5.7.4.2 Functional and Performance Constraints</h4>


<hr>
</div>
<div class="subsubsection-level-extent" id="Style-Choices">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Program-Control" accesskey="n" rel="next">What Controls Program Execution?</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Basic-Constraints" accesskey="p" rel="prev">Functional and Performance Constraints</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="u" rel="up">A Choice of Programming Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Your-Preferred-Programming-Style">5.7.4.3 Your Preferred Programming Style</h4>


<hr>
</div>
<div class="subsubsection-level-extent" id="Program-Control">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Style-Choices" accesskey="p" rel="prev">Your Preferred Programming Style</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="u" rel="up">A Choice of Programming Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="What-Controls-Program-Execution_003f">5.7.4.4 What Controls Program Execution?</h4>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="User-Programming">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Options" accesskey="p" rel="prev">A Choice of Programming Options</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="u" rel="up">An Overview of Guile Programming</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="How-About-Application-Users_003f">5.7.5 How About Application Users?</h4>

<p>So far we have considered what Guile programming means for an
application developer.  But what if you are instead <em class="emph">using</em> an
existing Guile-based application, and want to know what your
options are for programming and extending this application?
</p>
<p>The answer to this question varies from one application to another,
because the options available depend inevitably on whether the
application developer has provided any hooks for you to hang your own
code on and, if there are such hooks, what they allow you to
do.<a class="footnote" id="DOCF7" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT7"><sup>7</sup></a>  For example…
</p>
<ul class="itemize mark-bullet">
<li>If the application permits you to load and execute any Guile code, the
world is your oyster.  You can extend the application in any way that
you choose.

</li><li>A more cautious application might allow you to load and execute Guile
code, but only in a <em class="dfn">safe</em> environment, where the interface
available is restricted by the application from the standard Guile API.

</li><li>Or a really fearful application might not provide a hook to really
execute user code at all, but just use Scheme syntax as a convenient way
for users to specify application data or configuration options.
</li></ul>

<p>In the last two cases, what you can do is, by definition, restricted by
the application, and you should refer to the application’s own manual to
find out your options.
</p>
<p>The most well known example of the first case is Emacs, with its
extension language Emacs Lisp: as well as being a text editor, Emacs
supports the loading and execution of arbitrary Emacs Lisp code.  The
result of such openness has been dramatic: Emacs now benefits from
user-contributed Emacs Lisp libraries that extend the basic editing
function to do everything from reading news to psychoanalysis and
playing adventure games.  The only limitation is that extensions are
restricted to the functionality provided by Emacs’s built-in set of
primitive operations.  For example, you can interact and display data by
manipulating the contents of an Emacs buffer, but you can’t pop-up and
draw a window with a layout that is totally different to the Emacs
standard.
</p>
<p>This situation with a Guile application that supports the loading of
arbitrary user code is similar, except perhaps even more so, because
Guile also supports the loading of extension libraries written in C.
This last point enables user code to add new primitive operations to
Guile, and so to bypass the limitation present in Emacs Lisp.
</p>
<p>At this point, the distinction between an application developer and an
application user becomes rather blurred.  Instead of seeing yourself as
a user extending an application, you could equally well say that you are
developing a new application of your own using some of the primitive
functionality provided by the original application.  As such, all the
discussions of the preceding sections of this chapter are relevant to
how you can proceed with developing your extension.
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="Autoconf-Support">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-Overview" accesskey="p" rel="prev">An Overview of Guile Programming</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="u" rel="up">Programming in C</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Autoconf-Support-1">5.8 Autoconf Support</h3>

<p>Autoconf, a part of the GNU build system, makes it easy for users to
build your package.  This section documents Guile’s Autoconf support.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Background" accesskey="1">Autoconf Background</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Macros" accesskey="2">Autoconf Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Autoconf-Macros" accesskey="3">Using Autoconf Macros</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Autoconf-Background">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Macros" accesskey="n" rel="next">Autoconf Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support" accesskey="u" rel="up">Autoconf Support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Autoconf-Background-1">5.8.1 Autoconf Background</h4>

<p>As explained in the <cite class="cite">GNU Autoconf Manual</cite>, any package needs
configuration at build-time (see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Top">Introduction</a> in <cite class="cite">The GNU
Autoconf Manual</cite>).  If your package uses Guile (or uses a package that
in turn uses Guile), you probably need to know what specific Guile
features are available and details about them.
</p>
<p>The way to do this is to write feature tests and arrange for their execution
by the <samp class="file">configure</samp> script, typically by adding the tests to
<samp class="file">configure.ac</samp>, and running <code class="code">autoconf</code> to create <samp class="file">configure</samp>.
Users of your package then run <samp class="file">configure</samp> in the normal way.
</p>
<p>Macros are a way to make common feature tests easy to express.
Autoconf provides a wide range of macros 
(see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Existing-Tests">Existing Tests</a> in <cite class="cite">The GNU Autoconf Manual</cite>), 
and Guile installation provides Guile-specific tests in the areas of:
program detection, compilation flags reporting, and Scheme module
checks.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Autoconf-Macros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Autoconf-Macros" accesskey="n" rel="next">Using Autoconf Macros</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Background" accesskey="p" rel="prev">Autoconf Background</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support" accesskey="u" rel="up">Autoconf Support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Autoconf-Macros-1">5.8.2 Autoconf Macros</h4>

<p>As mentioned earlier in this chapter, Guile supports parallel
installation, and uses <code class="code">pkg-config</code> to let the user choose which
version of Guile they are interested in.  <code class="code">pkg-config</code> has its own
set of Autoconf macros that are probably installed on most every
development system.  The most useful of these macros is
<code class="code">PKG_CHECK_MODULES</code>.
</p>
<a class="index-entry-id" id="index-PKG_005fCHECK_005fMODULES"></a>

<div class="example">
<pre class="example-preformatted">PKG_CHECK_MODULES([GUILE], [guile-3.0])
</pre></div>

<p>This example looks for Guile and sets the <code class="code">GUILE_CFLAGS</code> and
<code class="code">GUILE_LIBS</code> variables accordingly, or prints an error and exits if
Guile was not found.
</p>
<p>Guile comes with additional Autoconf macros providing more information,
installed as <samp class="file"><var class="var">prefix</var>/share/aclocal/guile.m4</samp>.  Their names
all begin with <code class="code">GUILE_</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fPKG"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_PKG</strong> <var class="def-var-arguments">[VERSIONS]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fPKG"> ¶</a></span></dt>
<dd>
<p>This macro runs the <code class="code">pkg-config</code> tool to find development files
for an available version of Guile.
</p>
<p>By default, this macro will search for the latest stable version of
Guile (e.g. 3.0), falling back to the previous stable version
(e.g. 2.2) if it is available.  If no guile-<var class="var">VERSION</var>.pc file is
found, an error is signalled.  The found version is stored in
<var class="var">GUILE_EFFECTIVE_VERSION</var>.
</p>
<p>If <code class="code">GUILE_PROGS</code> was already invoked, this macro ensures that the
development files have the same effective version as the Guile
program.
</p>
<p><var class="var">GUILE_EFFECTIVE_VERSION</var> is marked for substitution, as by
<code class="code">AC_SUBST</code>.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fFLAGS"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_FLAGS</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fFLAGS"> ¶</a></span></dt>
<dd>
<p>This macro runs the <code class="code">pkg-config</code> tool to find out how to compile
and link programs against Guile.  It sets four variables:
<var class="var">GUILE_CFLAGS</var>, <var class="var">GUILE_LDFLAGS</var>, <var class="var">GUILE_LIBS</var>, and
<var class="var">GUILE_LTLIBS</var>.
</p>
<p><var class="var">GUILE_CFLAGS</var>: flags to pass to a C or C++ compiler to build code that
uses Guile header files.  This is almost always just one or more <code class="code">-I</code>
flags.
</p>
<p><var class="var">GUILE_LDFLAGS</var>: flags to pass to the compiler to link a program
against Guile.  This includes <code class="code">-lguile-<var class="var">VERSION</var></code> for the
Guile library itself, and may also include one or more <code class="code">-L</code> flag
to tell the compiler where to find the libraries.  But it does not
include flags that influence the program’s runtime search path for
libraries, and will therefore lead to a program that fails to start,
unless all necessary libraries are installed in a standard location
such as <samp class="file">/usr/lib</samp>.
</p>
<p><var class="var">GUILE_LIBS</var> and <var class="var">GUILE_LTLIBS</var>: flags to pass to the compiler or to
libtool, respectively, to link a program against Guile.  It includes flags
that augment the program’s runtime search path for libraries, so that shared
libraries will be found at the location where they were during linking, even
in non-standard locations.  <var class="var">GUILE_LIBS</var> is to be used when linking the
program directly with the compiler, whereas <var class="var">GUILE_LTLIBS</var> is to be used
when linking the program is done through libtool.
</p>
<p>The variables are marked for substitution, as by <code class="code">AC_SUBST</code>.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fSITE_005fDIR"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_SITE_DIR</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fSITE_005fDIR"> ¶</a></span></dt>
<dd>
<p>This looks for Guile’s "site" directories.  The variable <var class="var">GUILE_SITE</var> will
be set to Guile’s "site" directory for Scheme source files (usually something
like PREFIX/share/guile/site).  <var class="var">GUILE_SITE_CCACHE</var> will be set to the
directory for compiled Scheme files also known as <code class="code">.go</code> files
(usually something like
PREFIX/lib/guile/<var class="var">GUILE_EFFECTIVE_VERSION</var>/site-ccache).
<var class="var">GUILE_EXTENSION</var> will be set to the directory for compiled C extensions
(usually something like
PREFIX/lib/guile/<var class="var">GUILE_EFFECTIVE_VERSION</var>/extensions). The latter two
are set to blank if the particular version of Guile does not support
them.  Note that this macro will run the macros <code class="code">GUILE_PKG</code> and
<code class="code">GUILE_PROGS</code> if they have not already been run.
</p>
<p>The variables are marked for substitution, as by <code class="code">AC_SUBST</code>.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fPROGS"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_PROGS</strong> <var class="def-var-arguments">[VERSION]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fPROGS"> ¶</a></span></dt>
<dd>
<p>This macro looks for programs <code class="code">guile</code> and <code class="code">guild</code>, setting
variables <var class="var">GUILE</var> and <var class="var">GUILD</var> to their paths, respectively.
The macro will attempt to find <code class="code">guile</code> with the suffix of
<code class="code">-X.Y</code>, followed by looking for it with the suffix <code class="code">X.Y</code>, and
then fall back to looking for <code class="code">guile</code> with no suffix. If
<code class="code">guile</code> is still not found, signal an error. The suffix, if any,
that was required to find <code class="code">guile</code> will be used for <code class="code">guild</code>
as well.
</p>
<p>By default, this macro will search for the latest stable version of
Guile (e.g. 3.0). x.y or x.y.z versions can be specified. If an older
version is found, the macro will signal an error.
</p>
<p>The effective version of the found <code class="code">guile</code> is set to
<var class="var">GUILE_EFFECTIVE_VERSION</var>.  This macro ensures that the effective
version is compatible with the result of a previous invocation of
<code class="code">GUILE_FLAGS</code>, if any.
</p>
<p>As a legacy interface, it also looks for <code class="code">guile-config</code> and
<code class="code">guile-tools</code>, setting <var class="var">GUILE_CONFIG</var> and <var class="var">GUILE_TOOLS</var>.
</p>
<p>The variables are marked for substitution, as by <code class="code">AC_SUBST</code>.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fCHECK_005fRETVAL"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_CHECK_RETVAL</strong> <var class="def-var-arguments">var check</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fCHECK_005fRETVAL"> ¶</a></span></dt>
<dd>
<p><var class="var">var</var> is a shell variable name to be set to the return value.
<var class="var">check</var> is a Guile Scheme expression, evaluated with "$GUILE -c", and
   returning either 0 or non-#f to indicate the check passed.
   Non-0 number or #f indicates failure.
   Avoid using the character "#" since that confuses autoconf.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fMODULE_005fCHECK"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_MODULE_CHECK</strong> <var class="def-var-arguments">var module featuretest description</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fMODULE_005fCHECK"> ¶</a></span></dt>
<dd>
<p><var class="var">var</var> is a shell variable name to be set to "yes" or "no".
<var class="var">module</var> is a list of symbols, like: (ice-9 common-list).
<var class="var">featuretest</var> is an expression acceptable to GUILE_CHECK, q.v.
<var class="var">description</var> is a present-tense verb phrase (passed to AC_MSG_CHECKING).
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fMODULE_005fAVAILABLE"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_MODULE_AVAILABLE</strong> <var class="def-var-arguments">var module</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fMODULE_005fAVAILABLE"> ¶</a></span></dt>
<dd>
<p><var class="var">var</var> is a shell variable name to be set to "yes" or "no".
<var class="var">module</var> is a list of symbols, like: (ice-9 common-list).
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fMODULE_005fREQUIRED"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_MODULE_REQUIRED</strong> <var class="def-var-arguments">symlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fMODULE_005fREQUIRED"> ¶</a></span></dt>
<dd>
<p><var class="var">symlist</var> is a list of symbols, WITHOUT surrounding parens,
like: ice-9 common-list.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fMODULE_005fEXPORTS"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_MODULE_EXPORTS</strong> <var class="def-var-arguments">var module modvar</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fMODULE_005fEXPORTS"> ¶</a></span></dt>
<dd>
<p><var class="var">var</var> is a shell variable to be set to "yes" or "no".
<var class="var">module</var> is a list of symbols, like: (ice-9 common-list).
<var class="var">modvar</var> is the Guile Scheme variable to check.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-GUILE_005fMODULE_005fREQUIRED_005fEXPORT"><span class="category-def">Autoconf Macro: </span><span><strong class="def-name">GUILE_MODULE_REQUIRED_EXPORT</strong> <var class="def-var-arguments">module modvar</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-GUILE_005fMODULE_005fREQUIRED_005fEXPORT"> ¶</a></span></dt>
<dd>
<p><var class="var">module</var> is a list of symbols, like: (ice-9 common-list).
<var class="var">modvar</var> is the Guile Scheme variable to check.
</p>
</dd></dl>



<hr>
</div>
<div class="subsection-level-extent" id="Using-Autoconf-Macros">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Macros" accesskey="p" rel="prev">Autoconf Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Autoconf-Support" accesskey="u" rel="up">Autoconf Support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Using-Autoconf-Macros-1">5.8.3 Using Autoconf Macros</h4>

<p>Using the autoconf macros is straightforward: Add the macro "calls" (actually
instantiations) to <samp class="file">configure.ac</samp>, run <code class="code">aclocal</code>, and finally,
run <code class="code">autoconf</code>.  If your system doesn’t have guile.m4 installed, place
the desired macro definitions (<code class="code">AC_DEFUN</code> forms) in <samp class="file">acinclude.m4</samp>,
and <code class="code">aclocal</code> will do the right thing.
</p>
<p>Some of the macros can be used inside normal shell constructs: <code class="code">if foo ;
then GUILE_BAZ ; fi</code>, but this is not guaranteed.  It’s probably a good idea
to instantiate macros at top-level.
</p>
<p>We now include two examples, one simple and one complicated.
</p>
<p>The first example is for a package that uses libguile, and thus needs to
know how to compile and link against it.  So we use
<code class="code">PKG_CHECK_MODULES</code> to set the vars <code class="code">GUILE_CFLAGS</code> and
<code class="code">GUILE_LIBS</code>, which are automatically substituted in the Makefile.
</p>
<div class="example">
<pre class="example-preformatted">In configure.ac:

  PKG_CHECK_MODULES([GUILE], [guile-3.0])

In Makefile.in:

  GUILE_CFLAGS  = @GUILE_CFLAGS@
  GUILE_LIBS = @GUILE_LIBS@

  myprog.o: myprog.c
          $(CC) -o $&nbsp;$(GUILE_CFLAGS) $&lt;
  myprog: myprog.o
          $(CC) -o $&nbsp;$&lt; $(GUILE_LIBS)
</pre></div>

<p>The second example is for a package of Guile Scheme modules that uses an
external program and other Guile Scheme modules (some might call this a "pure
scheme" package).  So we use the <code class="code">GUILE_SITE_DIR</code> macro, a regular
<code class="code">AC_PATH_PROG</code> macro, and the <code class="code">GUILE_MODULE_AVAILABLE</code> macro.
</p>
<div class="example">
<pre class="example-preformatted">In configure.ac:

  GUILE_SITE_DIR

  probably_wont_work=""

  # pgtype pgtable
  GUILE_MODULE_AVAILABLE(have_guile_pg, (database postgres))
  test $have_guile_pg = no &amp;&amp;
      probably_wont_work="(my pgtype) (my pgtable) $probably_wont_work"

  # gpgutils
  AC_PATH_PROG(GNUPG,gpg)
  test x"$GNUPG" = x &amp;&amp;
      probably_wont_work="(my gpgutils) $probably_wont_work"

  if test ! "$probably_wont_work" = "" ; then
      p="         ***"
      echo
      echo "$p"
      echo "$p NOTE:"
      echo "$p The following modules probably won't work:"
      echo "$p   $probably_wont_work"
      echo "$p They can be installed anyway, and will work if their"
      echo "$p dependencies are installed later.  Please see README."
      echo "$p"
      echo
  fi

In Makefile.in:

  instdir = @GUILE_SITE@/my

  install:
        $(INSTALL) my/*.scm $(instdir)
</pre></div>




<hr>
</div>
</div>
</div>
<div class="chapter-level-extent" id="API-Reference">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="n" rel="next">Guile Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programming-in-C" accesskey="p" rel="prev">Programming in C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="API-Reference-1">6 API Reference</h2>

<p>Guile provides an application programming interface (<em class="dfn">API</em>) to
developers in two core languages: Scheme and C.  This part of the manual
contains reference documentation for all of the functionality that is
available through both Scheme and C interfaces.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#API-Overview" accesskey="1">Overview of the Guile API</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation" accesskey="2">Deprecation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type" accesskey="3">The SCM Type</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Initialization" accesskey="4">Initializing Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Snarfing-Macros" accesskey="5">Snarfing Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="6">Data Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="7">Procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="8">Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="9">General Utility Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs">Definitions and Variable Bindings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms">Controlling the Flow of Program Execution</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output">Input and Output</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions">Regular Expressions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#LALR_00281_0029-Parsing">LALR(1) Parsing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing">PEG Parsing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile">Reading and Evaluating Scheme Code</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management">Memory Management and Garbage Collection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Modules">Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface">Foreign Function Interface</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Smobs">Smobs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling">Threads, Mutexes, Asyncs and Dynamic Roots</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config">Configuration, Features and Runtime Options</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages">Support for Other Languages</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization">Support for Internationalization</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging">Debugging Infrastructure</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Code-Coverage">Code Coverage Reports</a></li>
</ul>
<hr>
<div class="section-level-extent" id="API-Overview">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation" accesskey="n" rel="next">Deprecation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Overview-of-the-Guile-API">6.1 Overview of the Guile API</h3>

<p>Guile’s application programming interface (<em class="dfn">API</em>) makes
functionality available that an application developer can use in either
C or Scheme programming.  The interface consists of <em class="dfn">elements</em> that
may be macros, functions or variables in C, and procedures, variables,
syntax or other types of object in Scheme.
</p>
<p>Many elements are available to both Scheme and C, in a form that is
appropriate.  For example, the <code class="code">assq</code> Scheme procedure is also
available as <code class="code">scm_assq</code> to C code.  These elements are documented
only once, addressing both the Scheme and C aspects of them.
</p>
<p>The Scheme name of an element is related to its C name in a regular
way.  Also, a C function takes its parameters in a systematic way.
</p>
<p>Normally, the name of a C function can be derived given its Scheme name,
using some simple textual transformations:
</p>
<ul class="itemize mark-bullet">
<li>Replace <code class="code">-</code> (hyphen) with <code class="code">_</code> (underscore).

</li><li>Replace <code class="code">?</code> (question mark) with <code class="code">_p</code>.

</li><li>Replace <code class="code">!</code> (exclamation point) with <code class="code">_x</code>.

</li><li>Replace internal <code class="code">-&gt;</code> with <code class="code">_to_</code>.

</li><li>Replace <code class="code">&lt;=</code> (less than or equal) with <code class="code">_leq</code>.

</li><li>Replace <code class="code">&gt;=</code> (greater than or equal) with <code class="code">_geq</code>.

</li><li>Replace <code class="code">&lt;</code> (less than) with <code class="code">_less</code>.

</li><li>Replace <code class="code">&gt;</code> (greater than) with <code class="code">_gr</code>.

</li><li>Prefix with <code class="code">scm_</code>.

</li></ul>



<p>A C function always takes a fixed number of arguments of type
<code class="code">SCM</code>, even when the corresponding Scheme function takes a
variable number.
</p>
<p>For some Scheme functions, some last arguments are optional; the
corresponding C function must always be invoked with all optional
arguments specified.  To get the effect as if an argument has not been
specified, pass <code class="code">SCM_UNDEFINED</code> as its value.  You can not do
this for an argument in the middle; when one argument is
<code class="code">SCM_UNDEFINED</code> all the ones following it must be
<code class="code">SCM_UNDEFINED</code> as well.
</p>
<p>Some Scheme functions take an arbitrary number of <em class="emph">rest</em>
arguments; the corresponding C function must be invoked with a list of
all these arguments.  This list is always the last argument of the C
function.
</p>
<p>These two variants can also be combined.
</p>
<p>The type of the return value of a C function that corresponds to a
Scheme function is always <code class="code">SCM</code>.  In the descriptions below,
types are therefore often omitted but for the return value and for the
arguments.
</p>
<hr>
</div>
<div class="section-level-extent" id="Deprecation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type" accesskey="n" rel="next">The SCM Type</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Overview" accesskey="p" rel="prev">Overview of the Guile API</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Deprecation-1">6.2 Deprecation</h3>

<p>From time to time functions and other features of Guile become obsolete.
Guile’s <em class="dfn">deprecation</em> is a mechanism that can help you cope with
this.
</p>
<p>When you use a feature that is deprecated, you will likely get a warning
message at run-time. Also, if you have a new enough toolchain, using a
deprecated function from <code class="code">libguile</code> will cause a link-time warning.
</p>
<p>The primary source for information about just what interfaces are
deprecated in a given release is the file <samp class="file">NEWS</samp>.  That file also
documents what you should use instead of the obsoleted things.
</p>
<p>The file <samp class="file">README</samp> contains instructions on how to control the
inclusion or removal of the deprecated features from the public API of
Guile, and how to control the deprecation warning messages.
</p>
<p>The idea behind this mechanism is that normally all deprecated
interfaces are available, but you get feedback when compiling and
running code that uses them, so that you can migrate to the newer APIs
at your leisure.
</p>

<hr>
</div>
<div class="section-level-extent" id="The-SCM-Type">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Initialization" accesskey="n" rel="next">Initializing Guile</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation" accesskey="p" rel="prev">Deprecation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-SCM-Type-1">6.3 The SCM Type</h3>

<p>Guile represents all Scheme values with the single C type <code class="code">SCM</code>.
For an introduction to this topic, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Types">Dynamic Types</a>.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-SCM"><span class="category-def">C Type: </span><span><strong class="def-name">SCM</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM"> ¶</a></span></dt>
<dd><p><code class="code">SCM</code> is the user level abstract C type that is used to represent
all of Guile’s Scheme objects, no matter what the Scheme object type is.
No C operation except assignment is guaranteed to work with variables of
type <code class="code">SCM</code>, so you should only use macros and functions to work
with <code class="code">SCM</code> values.  Values are converted between C data types and
the <code class="code">SCM</code> type with utility functions and macros.
</p></dd></dl>
<a class="index-entry-id" id="index-SCM-data-type"></a>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fbits"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_bits</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fbits"> ¶</a></span></dt>
<dd><p><code class="code">scm_t_bits</code> is an unsigned integral data type that is guaranteed
to be large enough to hold all information that is required to
represent any Scheme object.  While this data type is mostly used to
implement Guile’s internals, the use of this type is also necessary to
write certain kinds of extensions to Guile.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fsigned_005fbits"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_signed_bits</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fsigned_005fbits"> ¶</a></span></dt>
<dd><p>This is a signed integral type of the same size as <code class="code">scm_t_bits</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fUNPACK"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_UNPACK</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fUNPACK"> ¶</a></span></dt>
<dd><p>Transforms the <code class="code">SCM</code> value <var class="var">x</var> into its representation as an
integral type.  Only after applying <code class="code">SCM_UNPACK</code> it is possible to
access the bits and contents of the <code class="code">SCM</code> value.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fPACK"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_PACK</strong> <code class="def-code-arguments">(scm_t_bits <var class="var">x</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fPACK"> ¶</a></span></dt>
<dd><p>Takes a valid integral representation of a Scheme object and transforms
it into its representation as a <code class="code">SCM</code> value.
</p></dd></dl>


<hr>
</div>
<div class="section-level-extent" id="Initialization">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Snarfing-Macros" accesskey="n" rel="next">Snarfing Macros</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type" accesskey="p" rel="prev">The SCM Type</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Initializing-Guile">6.4 Initializing Guile</h3>
<a class="index-entry-id" id="index-Initializing-Guile"></a>

<p>Each thread that wants to use functions from the Guile API needs to
put itself into guile mode with either <code class="code">scm_with_guile</code> or
<code class="code">scm_init_guile</code>.  The global state of Guile is initialized
automatically when the first thread enters guile mode.
</p>
<p>When a thread wants to block outside of a Guile API function, it
should leave guile mode temporarily with <code class="code">scm_without_guile</code>,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Blocking">Blocking in Guile Mode</a>.
</p>
<p>Threads that are created by <code class="code">call-with-new-thread</code> or
<code class="code">scm_spawn_thread</code> start out in guile mode so you don’t need to
initialize them.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fwith_005fguile"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_with_guile</strong> <code class="def-code-arguments">(void *(*func)(void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005fguile"> ¶</a></span></dt>
<dd><p>Call <var class="var">func</var>, passing it <var class="var">data</var> and return what <var class="var">func</var>
returns.  While <var class="var">func</var> is running, the current thread is in guile
mode and can thus use the Guile API.
</p>
<p>When <code class="code">scm_with_guile</code> is called from guile mode, the thread remains
in guile mode when <code class="code">scm_with_guile</code> returns.
</p>
<p>Otherwise, it puts the current thread into guile mode and, if needed,
gives it a Scheme representation that is contained in the list returned
by <code class="code">all-threads</code>, for example.  This Scheme representation is not
removed when <code class="code">scm_with_guile</code> returns so that a given thread is
always represented by the same Scheme value during its lifetime, if at
all.
</p>
<p>When this is the first thread that enters guile mode, the global state
of Guile is initialized before calling <code class="code">func</code>.
</p>
<p>The function <var class="var">func</var> is called via
<code class="code">scm_with_continuation_barrier</code>; thus, <code class="code">scm_with_guile</code>
returns exactly once.
</p>
<p>When <code class="code">scm_with_guile</code> returns, the thread is no longer in guile
mode (except when <code class="code">scm_with_guile</code> was called from guile mode, see
above).  Thus, only <code class="code">func</code> can store <code class="code">SCM</code> variables on the
stack and be sure that they are protected from the garbage collector.
See <code class="code">scm_init_guile</code> for another approach at initializing Guile
that does not have this restriction.
</p>
<p>It is OK to call <code class="code">scm_with_guile</code> while a thread has temporarily
left guile mode via <code class="code">scm_without_guile</code>.  It will then simply
temporarily enter guile mode again.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005finit_005fguile"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_init_guile</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finit_005fguile"> ¶</a></span></dt>
<dd><p>Arrange things so that all of the code in the current thread executes as
if from within a call to <code class="code">scm_with_guile</code>.  That is, all functions
called by the current thread can assume that <code class="code">SCM</code> values on their
stack frames are protected from the garbage collector (except when the
thread has explicitly left guile mode, of course).
</p>
<p>When <code class="code">scm_init_guile</code> is called from a thread that already has been
in guile mode once, nothing happens.  This behavior matters when you
call <code class="code">scm_init_guile</code> while the thread has only temporarily left
guile mode: in that case the thread will not be in guile mode after
<code class="code">scm_init_guile</code> returns.  Thus, you should not use
<code class="code">scm_init_guile</code> in such a scenario.
</p>
<p>When a uncaught throw happens in a thread that has been put into guile
mode via <code class="code">scm_init_guile</code>, a short message is printed to the
current error port and the thread is exited via <code class="code">scm_pthread_exit
(NULL)</code>.  No restrictions are placed on continuations.
</p>
<p>The function <code class="code">scm_init_guile</code> might not be available on all
platforms since it requires some stack-bounds-finding magic that might
not have been ported to all platforms that Guile runs on.  Thus, if you
can, it is better to use <code class="code">scm_with_guile</code> or its variation
<code class="code">scm_boot_guile</code> instead of this function.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fboot_005fguile"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_boot_guile</strong> <code class="def-code-arguments">(int <var class="var">argc</var>, char **<var class="var">argv</var>, void (*<var class="var">main_func</var>) (void *<var class="var">data</var>, int <var class="var">argc</var>, char **<var class="var">argv</var>), void *<var class="var">data</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fboot_005fguile"> ¶</a></span></dt>
<dd><p>Enter guile mode as with <code class="code">scm_with_guile</code> and call <var class="var">main_func</var>,
passing it <var class="var">data</var>, <var class="var">argc</var>, and <var class="var">argv</var> as indicated.  When
<var class="var">main_func</var> returns, <code class="code">scm_boot_guile</code> calls <code class="code">exit (0)</code>;
<code class="code">scm_boot_guile</code> never returns.  If you want some other exit value,
have <var class="var">main_func</var> call <code class="code">exit</code> itself.  If you don’t want to exit
at all, use <code class="code">scm_with_guile</code> instead of <code class="code">scm_boot_guile</code>.
</p>
<p>The function <code class="code">scm_boot_guile</code> arranges for the Scheme
<code class="code">command-line</code> function to return the strings given by <var class="var">argc</var>
and <var class="var">argv</var>.  If <var class="var">main_func</var> modifies <var class="var">argc</var> or <var class="var">argv</var>,
it should call <code class="code">scm_set_program_arguments</code> with the final list, so
Scheme code will know which arguments have been processed
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment">Runtime Environment</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fshell"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_shell</strong> <code class="def-code-arguments">(int <var class="var">argc</var>, char **<var class="var">argv</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fshell"> ¶</a></span></dt>
<dd><p>Process command-line arguments in the manner of the <code class="code">guile</code>
executable.  This includes loading the normal Guile initialization
files, interacting with the user or running any scripts or expressions
specified by <code class="code">-s</code> or <code class="code">-e</code> options, and then exiting.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile">Invoking Guile</a>, for more details.
</p>
<p>Since this function does not return, you must do all
application-specific initialization before calling this function.
</p></dd></dl>


<hr>
</div>
<div class="section-level-extent" id="Snarfing-Macros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="n" rel="next">Data Types</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Initialization" accesskey="p" rel="prev">Initializing Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Snarfing-Macros-1">6.5 Snarfing Macros</h3>
<a class="index-entry-id" id="index-guile_002dsnarf-recognized-macros"></a>
<a class="index-entry-id" id="index-guile_002dsnarf-deprecated-macros"></a>

<p>The following macros do two different things: when compiled normally,
they expand in one way; when processed during snarfing, they cause the
<code class="code">guile-snarf</code> program to pick up some initialization code,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Function-Snarfing">Function Snarfing</a>.
</p>
<p>The descriptions below use the term ‘normally’ to refer to the case
when the code is compiled normally, and ‘while snarfing’ when the code
is processed by <code class="code">guile-snarf</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fSNARF_005fINIT"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_SNARF_INIT</strong> <var class="def-var-arguments">(code)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSNARF_005fINIT"> ¶</a></span></dt>
<dd>
<p>Normally, <code class="code">SCM_SNARF_INIT</code> expands to nothing; while snarfing, it
causes <var class="var">code</var> to be included in the initialization action file,
followed by a semicolon.
</p>
<p>This is the fundamental macro for snarfing initialization actions.
The more specialized macros below use it internally.
</p></dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fDEFINE"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_DEFINE</strong> <var class="def-var-arguments">(c_name, scheme_name, req, opt, var, arglist, docstring)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fDEFINE"> ¶</a></span></dt>
<dd>
<p>Normally, this macro expands into
</p>
<div class="example smallexample">
<pre class="example-preformatted">static const char s_<var class="var">c_name</var>[] = <var class="var">scheme_name</var>;
SCM
<var class="var">c_name</var> <var class="var">arglist</var>
</pre></div>

<p>While snarfing, it causes
</p>
<div class="example smallexample">
<pre class="example-preformatted">scm_c_define_gsubr (s_<var class="var">c_name</var>, <var class="var">req</var>, <var class="var">opt</var>, <var class="var">var</var>,
                    <var class="var">c_name</var>);
</pre></div>

<p>to be added to the initialization actions.  Thus, you can use it to
declare a C function named <var class="var">c_name</var> that will be made available to
Scheme with the name <var class="var">scheme_name</var>.
</p>
<p>Note that the <var class="var">arglist</var> argument must have parentheses around it.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fSYMBOL"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_SYMBOL</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSYMBOL"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-SCM_005fGLOBAL_005fSYMBOL"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_GLOBAL_SYMBOL</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fGLOBAL_005fSYMBOL"> ¶</a></span></dt>
<dd><p>Normally, these macros expand into
</p>
<div class="example smallexample">
<pre class="example-preformatted">static SCM <var class="var">c_name</var>
</pre></div>

<p>or
</p>
<div class="example smallexample">
<pre class="example-preformatted">SCM <var class="var">c_name</var>
</pre></div>

<p>respectively.  While snarfing, they both expand into the
initialization code
</p>
<div class="example smallexample">
<pre class="example-preformatted"><var class="var">c_name</var> = scm_permanent_object (scm_from_locale_symbol (<var class="var">scheme_name</var>));
</pre></div>

<p>Thus, you can use them declare a static or global variable of type
<code class="code">SCM</code> that will be initialized to the symbol named
<var class="var">scheme_name</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fKEYWORD"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_KEYWORD</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fKEYWORD"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-SCM_005fGLOBAL_005fKEYWORD"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_GLOBAL_KEYWORD</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fGLOBAL_005fKEYWORD"> ¶</a></span></dt>
<dd><p>Normally, these macros expand into
</p>
<div class="example smallexample">
<pre class="example-preformatted">static SCM <var class="var">c_name</var>
</pre></div>

<p>or
</p>
<div class="example smallexample">
<pre class="example-preformatted">SCM <var class="var">c_name</var>
</pre></div>

<p>respectively.  While snarfing, they both expand into the
initialization code
</p>
<div class="example smallexample">
<pre class="example-preformatted"><var class="var">c_name</var> = scm_permanent_object (scm_c_make_keyword (<var class="var">scheme_name</var>));
</pre></div>

<p>Thus, you can use them declare a static or global variable of type
<code class="code">SCM</code> that will be initialized to the keyword named
<var class="var">scheme_name</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fVARIABLE"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_VARIABLE</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fVARIABLE"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-SCM_005fGLOBAL_005fVARIABLE"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_GLOBAL_VARIABLE</strong> <var class="def-var-arguments">(c_name, scheme_name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fGLOBAL_005fVARIABLE"> ¶</a></span></dt>
<dd><p>These macros are equivalent to <code class="code">SCM_VARIABLE_INIT</code> and
<code class="code">SCM_GLOBAL_VARIABLE_INIT</code>, respectively, with a <var class="var">value</var> of
<code class="code">SCM_BOOL_F</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-SCM_005fVARIABLE_005fINIT"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_VARIABLE_INIT</strong> <var class="def-var-arguments">(c_name, scheme_name, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fVARIABLE_005fINIT"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-SCM_005fGLOBAL_005fVARIABLE_005fINIT"><span class="category-def">C Macro: </span><span><strong class="def-name">SCM_GLOBAL_VARIABLE_INIT</strong> <var class="def-var-arguments">(c_name, scheme_name, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fGLOBAL_005fVARIABLE_005fINIT"> ¶</a></span></dt>
<dd>
<p>Normally, these macros expand into
</p>
<div class="example smallexample">
<pre class="example-preformatted">static SCM <var class="var">c_name</var>
</pre></div>

<p>or
</p>
<div class="example smallexample">
<pre class="example-preformatted">SCM <var class="var">c_name</var>
</pre></div>

<p>respectively.  While snarfing, they both expand into the
initialization code
</p>
<div class="example smallexample">
<pre class="example-preformatted"><var class="var">c_name</var> = scm_permanent_object (scm_c_define (<var class="var">scheme_name</var>, <var class="var">value</var>));
</pre></div>

<p>Thus, you can use them declare a static or global C variable of type
<code class="code">SCM</code> that will be initialized to the object representing the
Scheme variable named <var class="var">scheme_name</var> in the current module.  The
variable will be defined when it doesn’t already exist.  It is always
set to <var class="var">value</var>.
</p></dd></dl>

<hr>
</div>
<div class="section-level-extent" id="Data-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="n" rel="next">Procedures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Snarfing-Macros" accesskey="p" rel="prev">Snarfing Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Data-Types-1">6.6 Data Types</h3>

<p>Guile’s data types form a powerful built-in library of representations
and functionality that you can apply to your problem domain.  This
chapter surveys the data types built-in to Guile, from the simple to the
complex.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Booleans" accesskey="1">Booleans</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="2">Numerical data types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Characters" accesskey="3">Characters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="4">Character Sets</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="5">Strings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="6">Symbols</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="7">Keywords</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Pairs" accesskey="8">Pairs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="9">Lists</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors">Vectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bit-Vectors">Bit Vectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#VLists">VLists</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Record-Overview">Record Overview</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records">SRFI-9 Records</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Structures">Structures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dictionary-Types">Dictionary Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists">Association Lists</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#VHashes">VList-Based Hash Lists or “VHashes”</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">Hash Tables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Types">Other Types</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Booleans">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="n" rel="next">Numerical data types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Booleans-1">6.6.1 Booleans</h4>
<a class="index-entry-id" id="index-Booleans"></a>

<p>The two boolean values are <code class="code">#t</code> for true and <code class="code">#f</code> for false.
They can also be written as <code class="code">#true</code> and <code class="code">#false</code>, as per R7RS.
</p>
<p>Boolean values are returned by predicate procedures, such as the general
equality predicates <code class="code">eq?</code>, <code class="code">eqv?</code> and <code class="code">equal?</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Equality">Equality</a>) and numerical and string comparison operators like
<code class="code">string=?</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison">String Comparison</a>) and <code class="code">&lt;=</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Comparison">Comparison Predicates</a>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(&lt;= 3 8)
⇒ #t

(&lt;= 3 -3)
⇒ #f

(equal? "house" "houses")
⇒ #f

(eq? #f #f)
⇒
#t
</pre></div>

<p>In test condition contexts like <code class="code">if</code> and <code class="code">cond</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals">Simple Conditional Evaluation</a>), where a group of subexpressions will be
evaluated only if a <var class="var">condition</var> expression evaluates to “true”,
“true” means any value at all except <code class="code">#f</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(if #t "yes" "no")
⇒ "yes"

(if 0 "yes" "no")
⇒ "yes"

(if #f "yes" "no")
⇒ "no"
</pre></div>

<p>A result of this asymmetry is that typical Scheme source code more often
uses <code class="code">#f</code> explicitly than <code class="code">#t</code>: <code class="code">#f</code> is necessary to
represent an <code class="code">if</code> or <code class="code">cond</code> false value, whereas <code class="code">#t</code> is
not necessary to represent an <code class="code">if</code> or <code class="code">cond</code> true value.
</p>
<p>It is important to note that <code class="code">#f</code> is <strong class="strong">not</strong> equivalent to any
other Scheme value.  In particular, <code class="code">#f</code> is not the same as the
number 0 (like in C and C++), and not the same as the “empty list”
(like in some Lisp dialects).
</p>
<p>In C, the two Scheme boolean values are available as the two constants
<code class="code">SCM_BOOL_T</code> for <code class="code">#t</code> and <code class="code">SCM_BOOL_F</code> for <code class="code">#f</code>.
Care must be taken with the false value <code class="code">SCM_BOOL_F</code>: it is not
false when used in C conditionals.  In order to test for it, use
<code class="code">scm_is_false</code> or <code class="code">scm_is_true</code>.
</p>
<a class="index-entry-id" id="index-not-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-not"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">not</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-not"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnot"><span class="category-def">C Function: </span><span><strong class="def-name">scm_not</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnot"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is <code class="code">#f</code>, else return <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-boolean_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-boolean_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">boolean?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-boolean_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fboolean_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_boolean_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fboolean_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is either <code class="code">#t</code> or <code class="code">#f</code>, else
return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-SCM_005fBOOL_005fT"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_BOOL_T</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fBOOL_005fT"> ¶</a></span></dt>
<dd><p>The <code class="code">SCM</code> representation of the Scheme object <code class="code">#t</code>.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-SCM_005fBOOL_005fF"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_BOOL_F</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fBOOL_005fF"> ¶</a></span></dt>
<dd><p>The <code class="code">SCM</code> representation of the Scheme object <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005ftrue"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_true</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005ftrue"> ¶</a></span></dt>
<dd><p>Return <code class="code">0</code> if <var class="var">obj</var> is <code class="code">#f</code>, else return <code class="code">1</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005ffalse"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_false</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005ffalse"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> if <var class="var">obj</var> is <code class="code">#f</code>, else return <code class="code">0</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fbool"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_bool</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fbool"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> if <var class="var">obj</var> is either <code class="code">#t</code> or <code class="code">#f</code>, else
return <code class="code">0</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fbool"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_bool</strong> <code class="def-code-arguments">(int val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fbool"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">val</var> is <code class="code">0</code>, else return <code class="code">#t</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fbool"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_to_bool</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fbool"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> if <var class="var">val</var> is <code class="code">SCM_BOOL_T</code>, return <code class="code">0</code>
when <var class="var">val</var> is <code class="code">SCM_BOOL_F</code>, else signal a ‘wrong type’ error.
</p>
<p>You should probably use <code class="code">scm_is_true</code> instead of this function
when you just want to test a <code class="code">SCM</code> value for trueness.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Numbers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Characters" accesskey="n" rel="next">Characters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Booleans" accesskey="p" rel="prev">Booleans</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Numerical-data-types">6.6.2 Numerical data types</h4>
<a class="index-entry-id" id="index-Numbers"></a>

<p>Guile supports a rich “tower” of numerical types — integer,
rational, real and complex — and provides an extensive set of
mathematical and scientific functions for operating on numerical
data.  This section of the manual documents those types and functions.
</p>
<p>You may also find it illuminating to read R5RS’s presentation of numbers
in Scheme, which is particularly clear and accessible: see
<a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Numbers">Numbers</a> in <cite class="cite">R5RS</cite>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Numerical-Tower" accesskey="1">Scheme’s Numerical “Tower”</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Integers" accesskey="2">Integers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Reals-and-Rationals" accesskey="3">Real and Rational Numbers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Complex-Numbers" accesskey="4">Complex Numbers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Exactness" accesskey="5">Exact and Inexact Numbers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Syntax" accesskey="6">Read Syntax for Numerical Data</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Integer-Operations" accesskey="7">Operations on Integer Values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Comparison" accesskey="8">Comparison Predicates</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion" accesskey="9">Converting Numbers To and From Strings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Complex">Complex Number Operations</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic">Arithmetic Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scientific">Scientific Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Random">Random Number Generation</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Numerical-Tower">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Integers" accesskey="n" rel="next">Integers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Scheme_0027s-Numerical-_0060_0060Tower_0027_0027">6.6.2.1 Scheme’s Numerical “Tower”</h4>
<a class="index-entry-id" id="index-number_003f-2"></a>

<p>Scheme’s numerical “tower” consists of the following categories of
numbers:
</p>
<dl class="table">
<dt><em class="dfn">integers</em></dt>
<dd><p>Whole numbers, positive or negative; e.g. –5, 0, 18.
</p>
</dd>
<dt><em class="dfn">rationals</em></dt>
<dd><p>The set of numbers that can be expressed as <em class="math"><var class="var">p</var>/<var class="var">q</var></em>
where <var class="var">p</var> and <var class="var">q</var> are integers; e.g. <em class="math">9/16</em> works, but
pi (an irrational number) doesn’t. These include integers
(<em class="math"><var class="var">n</var>/1</em>).
</p>
</dd>
<dt><em class="dfn">real numbers</em></dt>
<dd><p>The set of numbers that describes all possible positions along a
one-dimensional line. This includes rationals as well as irrational
numbers.
</p>
</dd>
<dt><em class="dfn">complex numbers</em></dt>
<dd><p>The set of numbers that describes all possible positions in a two
dimensional space. This includes real as well as imaginary numbers
(<em class="math"><var class="var">a</var>+<var class="var">b</var>i</em>, where <var class="var">a</var> is the <em class="dfn">real part</em>,
<var class="var">b</var> is the <em class="dfn">imaginary part</em>, and <em class="math">i</em> is the square root of
−1.)
</p></dd>
</dl>

<p>It is called a tower because each category “sits on” the one that
follows it, in the sense that every integer is also a rational, every
rational is also real, and every real number is also a complex number
(but with zero imaginary part).
</p>
<p>In addition to the classification into integers, rationals, reals and
complex numbers, Scheme also distinguishes between whether a number is
represented exactly or not.  For example, the result of
<em class="math">2*sin(pi/4)</em> is exactly <em class="math">2^(1/2)</em>, but Guile
can represent neither <em class="math">pi/4</em> nor <em class="math">2^(1/2)</em> exactly.
Instead, it stores an inexact approximation, using the C type
<code class="code">double</code>.
</p>
<p>Guile can represent exact rationals of any magnitude, inexact
rationals that fit into a C <code class="code">double</code>, and inexact complex numbers
with <code class="code">double</code> real and imaginary parts.
</p>
<p>The <code class="code">number?</code> predicate may be applied to any Scheme value to
discover whether the value is any of the supported numerical types.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-number_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">number?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-number_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnumber_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_number_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnumber_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is any kind of number, else <code class="code">#f</code>.
</p></dd></dl>

<p>For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(number? 3)
⇒ #t

(number? "hello there!")
⇒ #f

(define pi 3.141592654)
(number? pi)
⇒ #t
</pre></div>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fnumber"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_number</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fnumber"> ¶</a></span></dt>
<dd><p>This is equivalent to <code class="code">scm_is_true (scm_number_p (obj))</code>.
</p></dd></dl>

<p>The next few subsections document each of Guile’s numerical data types
in detail.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Integers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reals-and-Rationals" accesskey="n" rel="next">Real and Rational Numbers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numerical-Tower" accesskey="p" rel="prev">Scheme’s Numerical “Tower”</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Integers-1">6.6.2.2 Integers</h4>

<a class="index-entry-id" id="index-Integer-numbers"></a>

<a class="index-entry-id" id="index-integer_003f-2"></a>

<p>Integers are whole numbers, that is numbers with no fractional part,
such as 2, 83, and −3789.
</p>
<p>Integers in Guile can be arbitrarily big, as shown by the following
example.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (factorial n)
  (let loop ((n n) (product 1))
    (if (= n 0)
        product
        (loop (- n 1) (* product n)))))

(factorial 3)
⇒ 6

(factorial 20)
⇒ 2432902008176640000

(- (factorial 45))
⇒ -119622220865480194561963161495657715064383733760000000000
</pre></div>

<p>Readers whose background is in programming languages where integers are
limited by the need to fit into just 4 or 8 bytes of memory may find
this surprising, or suspect that Guile’s representation of integers is
inefficient.  In fact, Guile achieves a near optimal balance of
convenience and efficiency by using the host computer’s native
representation of integers where possible, and a more general
representation where the required number does not fit in the native
form.  Conversion between these two representations is automatic and
completely invisible to the Scheme level programmer.
</p>
<p>C has a host of different integer types, and Guile offers a host of
functions to convert between them and the <code class="code">SCM</code> representation.
For example, a C <code class="code">int</code> can be handled with <code class="code">scm_to_int</code> and
<code class="code">scm_from_int</code>.  Guile also defines a few C integer types of its
own, to help with differences between systems.
</p>
<p>C integer types that are not covered can be handled with the generic
<code class="code">scm_to_signed_integer</code> and <code class="code">scm_from_signed_integer</code> for
signed types, or with <code class="code">scm_to_unsigned_integer</code> and
<code class="code">scm_from_unsigned_integer</code> for unsigned types.
</p>
<p>Scheme integers can be exact and inexact.  For example, a number
written as <code class="code">3.0</code> with an explicit decimal-point is inexact, but
it is also an integer.  The functions <code class="code">integer?</code> and
<code class="code">scm_is_integer</code> report true for such a number, but the functions
<code class="code">exact-integer?</code>, <code class="code">scm_is_exact_integer</code>,
<code class="code">scm_is_signed_integer</code>, and <code class="code">scm_is_unsigned_integer</code> only
allow exact integers and thus report false.  Likewise, the conversion
functions like <code class="code">scm_to_signed_integer</code> only accept exact
integers.
</p>
<p>The motivation for this behavior is that the inexactness of a number
should not be lost silently.  If you want to allow inexact integers,
you can explicitly insert a call to <code class="code">inexact-&gt;exact</code> or to its C
equivalent <code class="code">scm_inexact_to_exact</code>.  (Only inexact integers will
be converted by this call into exact integers; inexact non-integers
will become exact fractions.)
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-integer_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">integer?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-integer_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finteger_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_integer_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finteger_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an exact or inexact integer number, else
return <code class="code">#f</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(integer? 487)
⇒ #t

(integer? 3.0)
⇒ #t

(integer? -3.4)
⇒ #f

(integer? +inf.0)
⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_integer</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005finteger"> ¶</a></span></dt>
<dd><p>This is equivalent to <code class="code">scm_is_true (scm_integer_p (x))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exact_002dinteger_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exact-integer?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exact_002dinteger_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexact_005finteger_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_exact_integer_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexact_005finteger_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an exact integer number, else
return <code class="code">#f</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(exact-integer? 37)
⇒ #t

(exact-integer? 3.0)
⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fexact_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_exact_integer</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fexact_005finteger"> ¶</a></span></dt>
<dd><p>This is equivalent to <code class="code">scm_is_true (scm_exact_integer_p (x))</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005ft_005fint8"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_int8</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fint8"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fuint8"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_uint8</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fuint8"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fint16"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_int16</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fint16"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fuint16"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_uint16</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fuint16"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fint32"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_int32</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fint32"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fuint32"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_uint32</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fuint32"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fint64"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_int64</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fint64"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fuint64"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_uint64</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fuint64"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fintmax"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_intmax</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fintmax"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005ft_005fuintmax"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_uintmax</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fuintmax"> ¶</a></span></dt>
<dd><p>The C types are equivalent to the corresponding ISO C types but are
defined on all platforms, with the exception of <code class="code">scm_t_int64</code> and
<code class="code">scm_t_uint64</code>, which are only defined when a 64-bit type is
available.  For example, <code class="code">scm_t_int8</code> is equivalent to
<code class="code">int8_t</code>.
</p>
<p>You can regard these definitions as a stop-gap measure until all
platforms provide these types.  If you know that all the platforms
that you are interested in already provide these types, it is better
to use them directly instead of the types provided by Guile.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_signed_integer</strong> <code class="def-code-arguments">(SCM x, scm_t_intmax min, scm_t_intmax max)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fsigned_005finteger"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fis_005funsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_unsigned_integer</strong> <code class="def-code-arguments">(SCM x, scm_t_uintmax min, scm_t_uintmax max)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005funsigned_005finteger"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> when <var class="var">x</var> represents an exact integer that is
between <var class="var">min</var> and <var class="var">max</var>, inclusive.
</p>
<p>These functions can be used to check whether a <code class="code">SCM</code> value will
fit into a given range, such as the range of a given C integer type.
If you just want to convert a <code class="code">SCM</code> value to a given C integer
type, use one of the conversion functions directly.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_intmax</code> <strong class="def-name">scm_to_signed_integer</strong> <code class="def-code-arguments">(SCM x, scm_t_intmax min, scm_t_intmax max)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fsigned_005finteger"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005funsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uintmax</code> <strong class="def-name">scm_to_unsigned_integer</strong> <code class="def-code-arguments">(SCM x, scm_t_uintmax min, scm_t_uintmax max)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005funsigned_005finteger"> ¶</a></span></dt>
<dd><p>When <var class="var">x</var> represents an exact integer that is between <var class="var">min</var> and
<var class="var">max</var> inclusive, return that integer.  Else signal an error,
either a ‘wrong-type’ error when <var class="var">x</var> is not an exact integer, or
an ‘out-of-range’ error when it doesn’t fit the given range.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_signed_integer</strong> <code class="def-code-arguments">(scm_t_intmax x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fsigned_005finteger"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005funsigned_005finteger"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_unsigned_integer</strong> <code class="def-code-arguments">(scm_t_uintmax x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005funsigned_005finteger"> ¶</a></span></dt>
<dd><p>Return the <code class="code">SCM</code> value that represents the integer <var class="var">x</var>.  This
function will always succeed and will always return an exact number.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fchar"><span class="category-def">C Function: </span><span><code class="def-type">char</code> <strong class="def-name">scm_to_char</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fchar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fschar"><span class="category-def">C Function: </span><span><code class="def-type">signed char</code> <strong class="def-name">scm_to_schar</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fschar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuchar"><span class="category-def">C Function: </span><span><code class="def-type">unsigned char</code> <strong class="def-name">scm_to_uchar</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuchar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fshort"><span class="category-def">C Function: </span><span><code class="def-type">short</code> <strong class="def-name">scm_to_short</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fshort"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fushort"><span class="category-def">C Function: </span><span><code class="def-type">unsigned short</code> <strong class="def-name">scm_to_ushort</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fushort"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fint"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_to_int</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fint"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuint"><span class="category-def">C Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">scm_to_uint</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuint"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005flong"><span class="category-def">C Function: </span><span><code class="def-type">long</code> <strong class="def-name">scm_to_long</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fulong"><span class="category-def">C Function: </span><span><code class="def-type">unsigned long</code> <strong class="def-name">scm_to_ulong</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fulong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005flong_005flong"><span class="category-def">C Function: </span><span><code class="def-type">long long</code> <strong class="def-name">scm_to_long_long</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005flong_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fulong_005flong"><span class="category-def">C Function: </span><span><code class="def-type">unsigned long long</code> <strong class="def-name">scm_to_ulong_long</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fulong_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fsize_005ft"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_to_size_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fsize_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fssize_005ft"><span class="category-def">C Function: </span><span><code class="def-type">ssize_t</code> <strong class="def-name">scm_to_ssize_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fssize_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuintptr_005ft"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uintptr</code> <strong class="def-name">scm_to_uintptr_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuintptr_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fptrdiff_005ft"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_ptrdiff</code> <strong class="def-name">scm_to_ptrdiff_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fptrdiff_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fint8"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int8</code> <strong class="def-name">scm_to_int8</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fint8"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuint8"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint8</code> <strong class="def-name">scm_to_uint8</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuint8"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fint16"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int16</code> <strong class="def-name">scm_to_int16</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fint16"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuint16"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint16</code> <strong class="def-name">scm_to_uint16</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuint16"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fint32"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int32</code> <strong class="def-name">scm_to_int32</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fint32"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuint32"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint32</code> <strong class="def-name">scm_to_uint32</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuint32"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fint64"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int64</code> <strong class="def-name">scm_to_int64</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fint64"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuint64"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint64</code> <strong class="def-name">scm_to_uint64</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuint64"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fintmax"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_intmax</code> <strong class="def-name">scm_to_intmax</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fintmax"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuintmax"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uintmax</code> <strong class="def-name">scm_to_uintmax</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuintmax"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fintptr_005ft"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_intptr</code> <strong class="def-name">scm_to_intptr_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fintptr_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fuintptr_005ft-1"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uintptr</code> <strong class="def-name">scm_to_uintptr_t</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fuintptr_005ft-1"> ¶</a></span></dt>
<dd><p>When <var class="var">x</var> represents an exact integer that fits into the indicated
C type, return that integer.  Else signal an error, either a
‘wrong-type’ error when <var class="var">x</var> is not an exact integer, or an
‘out-of-range’ error when it doesn’t fit the given range.
</p>
<p>The functions <code class="code">scm_to_long_long</code>, <code class="code">scm_to_ulong_long</code>,
<code class="code">scm_to_int64</code>, and <code class="code">scm_to_uint64</code> are only available when
the corresponding types are.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fchar"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_char</strong> <code class="def-code-arguments">(char x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fchar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fschar"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_schar</strong> <code class="def-code-arguments">(signed char x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fschar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuchar"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uchar</strong> <code class="def-code-arguments">(unsigned char x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuchar"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fshort"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_short</strong> <code class="def-code-arguments">(short x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fshort"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fushort"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_ushort</strong> <code class="def-code-arguments">(unsigned short x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fushort"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fint"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_int</strong> <code class="def-code-arguments">(int  x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fint"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuint"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uint</strong> <code class="def-code-arguments">(unsigned int x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuint"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005flong"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_long</strong> <code class="def-code-arguments">(long x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fulong"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_ulong</strong> <code class="def-code-arguments">(unsigned long x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fulong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005flong_005flong"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_long_long</strong> <code class="def-code-arguments">(long long x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flong_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fulong_005flong"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_ulong_long</strong> <code class="def-code-arguments">(unsigned long long x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fulong_005flong"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fsize_005ft"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_size_t</strong> <code class="def-code-arguments">(size_t x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fsize_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fssize_005ft"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_ssize_t</strong> <code class="def-code-arguments">(ssize_t x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fssize_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuintptr_005ft"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uintptr_t</strong> <code class="def-code-arguments">(uintptr_t x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuintptr_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fptrdiff_005ft"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_ptrdiff_t</strong> <code class="def-code-arguments">(scm_t_ptrdiff x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fptrdiff_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fint8"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_int8</strong> <code class="def-code-arguments">(scm_t_int8 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fint8"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuint8"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uint8</strong> <code class="def-code-arguments">(scm_t_uint8 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuint8"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fint16"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_int16</strong> <code class="def-code-arguments">(scm_t_int16 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fint16"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuint16"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uint16</strong> <code class="def-code-arguments">(scm_t_uint16 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuint16"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fint32"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_int32</strong> <code class="def-code-arguments">(scm_t_int32 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fint32"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuint32"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uint32</strong> <code class="def-code-arguments">(scm_t_uint32 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuint32"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fint64"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_int64</strong> <code class="def-code-arguments">(scm_t_int64 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fint64"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuint64"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uint64</strong> <code class="def-code-arguments">(scm_t_uint64 x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuint64"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fintmax"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_intmax</strong> <code class="def-code-arguments">(scm_t_intmax x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fintmax"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuintmax"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uintmax</strong> <code class="def-code-arguments">(scm_t_uintmax x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuintmax"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fintptr_005ft"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_intptr_t</strong> <code class="def-code-arguments">(scm_t_intptr x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fintptr_005ft"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fuintptr_005ft-1"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_uintptr_t</strong> <code class="def-code-arguments">(scm_t_uintptr x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fuintptr_005ft-1"> ¶</a></span></dt>
<dd><p>Return the <code class="code">SCM</code> value that represents the integer <var class="var">x</var>.
These functions will always succeed and will always return an exact
number.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fmpz"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_to_mpz</strong> <code class="def-code-arguments">(SCM val, mpz_t rop)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fmpz"> ¶</a></span></dt>
<dd><p>Assign <var class="var">val</var> to the multiple precision integer <var class="var">rop</var>.
<var class="var">val</var> must be an exact integer, otherwise an error will be
signalled.  <var class="var">rop</var> must have been initialized with <code class="code">mpz_init</code>
before this function is called.  When <var class="var">rop</var> is no longer needed
the occupied space must be freed with <code class="code">mpz_clear</code>.
See <a data-manual="gmp" href="http://www.gmplib.org/manual/Initializing-Integers.html#Initializing-Integers">Initializing Integers</a> in <cite class="cite">GNU MP Manual</cite>, for details.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fmpz"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_mpz</strong> <code class="def-code-arguments">(mpz_t val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fmpz"> ¶</a></span></dt>
<dd><p>Return the <code class="code">SCM</code> value that represents <var class="var">val</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Reals-and-Rationals">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Complex-Numbers" accesskey="n" rel="next">Complex Numbers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Integers" accesskey="p" rel="prev">Integers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Real-and-Rational-Numbers">6.6.2.3 Real and Rational Numbers</h4>
<a class="index-entry-id" id="index-Real-numbers"></a>
<a class="index-entry-id" id="index-Rational-numbers"></a>

<a class="index-entry-id" id="index-real_003f-2"></a>
<a class="index-entry-id" id="index-rational_003f-2"></a>

<p>Mathematically, the real numbers are the set of numbers that describe
all possible points along a continuous, infinite, one-dimensional line.
The rational numbers are the set of all numbers that can be written as
fractions <var class="var">p</var>/<var class="var">q</var>, where <var class="var">p</var> and <var class="var">q</var> are integers.
All rational numbers are also real, but there are real numbers that
are not rational, for example <em class="math">the square root of 2</em>, and
<em class="math">pi</em>.
</p>
<p>Guile can represent both exact and inexact rational numbers, but it
cannot represent precise finite irrational numbers.  Exact rationals are
represented by storing the numerator and denominator as two exact
integers.  Inexact rationals are stored as floating point numbers using
the C type <code class="code">double</code>.
</p>
<p>Exact rationals are written as a fraction of integers.  There must be
no whitespace around the slash:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">1/2
-22/7
</pre></div>

<p>Even though the actual encoding of inexact rationals is in binary, it
may be helpful to think of it as a decimal number with a limited
number of significant figures and a decimal point somewhere, since
this corresponds to the standard notation for non-whole numbers.  For
example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">0.34
-0.00000142857931198
-5648394822220000000000.0
4.0
</pre></div>

<p>The limited precision of Guile’s encoding means that any finite “real”
number in Guile can be written in a rational form, by multiplying and
then dividing by sufficient powers of 10 (or in fact, 2).  For example,
‘<samp class="samp">-0.00000142857931198</samp>’ is the same as −142857931198 divided
by 100000000000000000.  In Guile’s current incarnation, therefore, the
<code class="code">rational?</code> and <code class="code">real?</code> predicates are equivalent for finite
numbers.
</p>

<p>Dividing by an exact zero leads to a error message, as one might expect.
However, dividing by an inexact zero does not produce an error.
Instead, the result of the division is either plus or minus infinity,
depending on the sign of the divided number and the sign of the zero
divisor (some platforms support signed zeroes ‘<samp class="samp">-0.0</samp>’ and
‘<samp class="samp">+0.0</samp>’; ‘<samp class="samp">0.0</samp>’ is the same as ‘<samp class="samp">+0.0</samp>’).
</p>
<p>Dividing zero by an inexact zero yields a <abbr class="acronym">NaN</abbr> (‘not a number’)
value, although they are actually considered numbers by Scheme.
Attempts to compare a <abbr class="acronym">NaN</abbr> value with any number (including
itself) using <code class="code">=</code>, <code class="code">&lt;</code>, <code class="code">&gt;</code>, <code class="code">&lt;=</code> or <code class="code">&gt;=</code>
always returns <code class="code">#f</code>.  Although a <abbr class="acronym">NaN</abbr> value is not
<code class="code">=</code> to itself, it is both <code class="code">eqv?</code> and <code class="code">equal?</code> to itself
and other <abbr class="acronym">NaN</abbr> values.  However, the preferred way to test for
them is by using <code class="code">nan?</code>.
</p>
<p>The real <abbr class="acronym">NaN</abbr> values and infinities are written ‘<samp class="samp">+nan.0</samp>’,
‘<samp class="samp">+inf.0</samp>’ and ‘<samp class="samp">-inf.0</samp>’.  This syntax is also recognized by
<code class="code">read</code> as an extension to the usual Scheme syntax.  These special
values are considered by Scheme to be inexact real numbers but not
rational.  Note that non-real complex numbers may also contain
infinities or <abbr class="acronym">NaN</abbr> values in their real or imaginary parts.  To
test a real number to see if it is infinite, a <abbr class="acronym">NaN</abbr> value, or
neither, use <code class="code">inf?</code>, <code class="code">nan?</code>, or <code class="code">finite?</code>, respectively.
Every real number in Scheme belongs to precisely one of those three
classes.
</p>
<p>On platforms that follow <abbr class="acronym">IEEE</abbr> 754 for their floating point
arithmetic, the ‘<samp class="samp">+inf.0</samp>’, ‘<samp class="samp">-inf.0</samp>’, and ‘<samp class="samp">+nan.0</samp>’ values
are implemented using the corresponding <abbr class="acronym">IEEE</abbr> 754 values.
They behave in arithmetic operations like <abbr class="acronym">IEEE</abbr> 754 describes
it, i.e., <code class="code">(= +nan.0 +nan.0)</code> ⇒ <code class="code">#f</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-real_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">real?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-real_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freal_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_real_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freal_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a real number, else <code class="code">#f</code>.  Note
that the sets of integer and rational values form subsets of the set
of real numbers, so the predicate will also be fulfilled if <var class="var">obj</var>
is an integer number or a rational number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-rational_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rational?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rational_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frational_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_rational_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frational_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is a rational number, <code class="code">#f</code> otherwise.
Note that the set of integer values forms a subset of the set of
rational numbers, i.e. the predicate will also be fulfilled if
<var class="var">x</var> is an integer number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-rationalize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rationalize</strong> <var class="def-var-arguments">x eps</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rationalize"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frationalize"><span class="category-def">C Function: </span><span><strong class="def-name">scm_rationalize</strong> <var class="def-var-arguments">(x, eps)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frationalize"> ¶</a></span></dt>
<dd><p>Returns the <em class="emph">simplest</em> rational number differing
from <var class="var">x</var> by no more than <var class="var">eps</var>.  
</p>
<p>As required by <abbr class="acronym">R5RS</abbr>, <code class="code">rationalize</code> only returns an
exact result when both its arguments are exact.  Thus, you might need
to use <code class="code">inexact-&gt;exact</code> on the arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(rationalize (inexact-&gt;exact 1.2) 1/100)
⇒ 6/5
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inf_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inf?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inf_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finf_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inf_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finf_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the real number <var class="var">x</var> is ‘<samp class="samp">+inf.0</samp>’ or
‘<samp class="samp">-inf.0</samp>’.  Otherwise return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-nan_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">nan?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-nan_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnan_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_nan_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnan_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the real number <var class="var">x</var> is ‘<samp class="samp">+nan.0</samp>’, or
<code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-finite_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">finite?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-finite_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffinite_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_finite_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffinite_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the real number <var class="var">x</var> is neither infinite nor a
NaN, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-nan"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">nan</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-nan"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnan"><span class="category-def">C Function: </span><span><strong class="def-name">scm_nan</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnan"> ¶</a></span></dt>
<dd><p>Return ‘<samp class="samp">+nan.0</samp>’, a <abbr class="acronym">NaN</abbr> value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inf"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inf</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inf"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finf"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inf</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finf"> ¶</a></span></dt>
<dd><p>Return ‘<samp class="samp">+inf.0</samp>’, positive infinity.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-numerator"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">numerator</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-numerator"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnumerator"><span class="category-def">C Function: </span><span><strong class="def-name">scm_numerator</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnumerator"> ¶</a></span></dt>
<dd><p>Return the numerator of the rational number <var class="var">x</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-denominator"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">denominator</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-denominator"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdenominator"><span class="category-def">C Function: </span><span><strong class="def-name">scm_denominator</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdenominator"> ¶</a></span></dt>
<dd><p>Return the denominator of the rational number <var class="var">x</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005freal"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_real</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005freal"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fis_005frational"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_rational</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005frational"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_is_true (scm_real_p (val))</code> and
<code class="code">scm_is_true (scm_rational_p (val))</code>, respectively.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fdouble"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_to_double</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fdouble"> ¶</a></span></dt>
<dd><p>Returns the number closest to <var class="var">val</var> that is representable as a
<code class="code">double</code>.  Returns infinity for a <var class="var">val</var> that is too large in
magnitude.  The argument <var class="var">val</var> must be a real number.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fdouble"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_double</strong> <code class="def-code-arguments">(double val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fdouble"> ¶</a></span></dt>
<dd><p>Return the <code class="code">SCM</code> value that represents <var class="var">val</var>.  The returned
value is inexact according to the predicate <code class="code">inexact?</code>, but it
will be exactly equal to <var class="var">val</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Complex-Numbers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exactness" accesskey="n" rel="next">Exact and Inexact Numbers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reals-and-Rationals" accesskey="p" rel="prev">Real and Rational Numbers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Complex-Numbers-1">6.6.2.4 Complex Numbers</h4>
<a class="index-entry-id" id="index-Complex-numbers"></a>

<a class="index-entry-id" id="index-complex_003f-2"></a>

<p>Complex numbers are the set of numbers that describe all possible points
in a two-dimensional space.  The two coordinates of a particular point
in this space are known as the <em class="dfn">real</em> and <em class="dfn">imaginary</em> parts of
the complex number that describes that point.
</p>
<p>In Guile, complex numbers are written in rectangular form as the sum of
their real and imaginary parts, using the symbol <code class="code">i</code> to indicate
the imaginary part.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">3+4i
⇒
3.0+4.0i

(* 3-8i 2.3+0.3i)
⇒
9.3-17.5i
</pre></div>

<a class="index-entry-id" id="index-polar-form"></a>
<p>Polar form can also be used, with an ‘<samp class="samp">@</samp>’ between magnitude and
angle,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">1@3.141592 ⇒ -1.0      (approx)
-1@1.57079 ⇒ 0.0-1.0i  (approx)
</pre></div>

<p>Guile represents a complex number as a pair of inexact reals, so the
real and imaginary parts of a complex number have the same properties of
inexactness and limited precision as single inexact real numbers.
</p>
<p>Note that each part of a complex number may contain any inexact real
value, including the special values ‘<samp class="samp">+nan.0</samp>’, ‘<samp class="samp">+inf.0</samp>’ and
‘<samp class="samp">-inf.0</samp>’, as well as either of the signed zeroes ‘<samp class="samp">0.0</samp>’ or
‘<samp class="samp">-0.0</samp>’.
</p>

<dl class="first-deffn">
<dt class="deffn" id="index-complex_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">complex?</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-complex_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcomplex_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_complex_p</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcomplex_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">z</var> is a complex number, <code class="code">#f</code>
otherwise.  Note that the sets of real, rational and integer
values form subsets of the set of complex numbers, i.e. the
predicate will also be fulfilled if <var class="var">z</var> is a real,
rational or integer number.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fcomplex"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_complex</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fcomplex"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_is_true (scm_complex_p (val))</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Exactness">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Syntax" accesskey="n" rel="next">Read Syntax for Numerical Data</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Complex-Numbers" accesskey="p" rel="prev">Complex Numbers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Exact-and-Inexact-Numbers">6.6.2.5 Exact and Inexact Numbers</h4>
<a class="index-entry-id" id="index-Exact-numbers"></a>
<a class="index-entry-id" id="index-Inexact-numbers"></a>

<a class="index-entry-id" id="index-exact_003f-2"></a>
<a class="index-entry-id" id="index-inexact_003f-2"></a>
<a class="index-entry-id" id="index-exact_002d_003einexact-2"></a>
<a class="index-entry-id" id="index-inexact_002d_003eexact-2"></a>

<p>R5RS requires that, with few exceptions, a calculation involving inexact
numbers always produces an inexact result.  To meet this requirement,
Guile distinguishes between an exact integer value such as ‘<samp class="samp">5</samp>’ and
the corresponding inexact integer value which, to the limited precision
available, has no fractional part, and is printed as ‘<samp class="samp">5.0</samp>’.  Guile
will only convert the latter value to the former when forced to do so by
an invocation of the <code class="code">inexact-&gt;exact</code> procedure.
</p>
<p>The only exception to the above requirement is when the values of the
inexact numbers do not affect the result.  For example <code class="code">(expt n 0)</code>
is ‘<samp class="samp">1</samp>’ for any value of <code class="code">n</code>, therefore <code class="code">(expt 5.0 0)</code> is
permitted to return an exact ‘<samp class="samp">1</samp>’.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-exact_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exact?</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exact_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexact_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_exact_p</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexact_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the number <var class="var">z</var> is exact, <code class="code">#f</code>
otherwise.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(exact? 2)
⇒ #t

(exact? 0.5)
⇒ #f

(exact? (/ 2))
⇒ #t
</pre></div>

</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fexact"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_exact</strong> <code class="def-code-arguments">(SCM z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fexact"> ¶</a></span></dt>
<dd><p>Return a <code class="code">1</code> if the number <var class="var">z</var> is exact, and <code class="code">0</code>
otherwise.  This is equivalent to <code class="code">scm_is_true (scm_exact_p (z))</code>.
</p>
<p>An alternate approch to testing the exactness of a number is to 
use <code class="code">scm_is_signed_integer</code> or <code class="code">scm_is_unsigned_integer</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inexact_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inexact?</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inexact_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finexact_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inexact_p</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finexact_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the number <var class="var">z</var> is inexact, <code class="code">#f</code>
else.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005finexact"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_inexact</strong> <code class="def-code-arguments">(SCM z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005finexact"> ¶</a></span></dt>
<dd><p>Return a <code class="code">1</code> if the number <var class="var">z</var> is inexact, and <code class="code">0</code>
otherwise.  This is equivalent to <code class="code">scm_is_true (scm_inexact_p (z))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inexact_002d_003eexact"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inexact-&gt;exact</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inexact_002d_003eexact"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finexact_005fto_005fexact"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inexact_to_exact</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finexact_005fto_005fexact"> ¶</a></span></dt>
<dd><p>Return an exact number that is numerically closest to <var class="var">z</var>, when
there is one.  For inexact rationals, Guile returns the exact rational
that is numerically equal to the inexact rational.  Inexact complex
numbers with a non-zero imaginary part can not be made exact.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inexact-&gt;exact 0.5)
⇒ 1/2
</pre></div>

<p>The following happens because 12/10 is not exactly representable as a
<code class="code">double</code> (on most platforms).  However, when reading a decimal
number that has been marked exact with the “#e” prefix, Guile is
able to represent it correctly.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inexact-&gt;exact 1.2)  
⇒ 5404319552844595/4503599627370496

#e1.2
⇒ 6/5
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exact_002d_003einexact"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exact-&gt;inexact</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exact_002d_003einexact"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexact_005fto_005finexact"><span class="category-def">C Function: </span><span><strong class="def-name">scm_exact_to_inexact</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexact_005fto_005finexact"> ¶</a></span></dt>
<dd><p>Convert the number <var class="var">z</var> to its inexact representation.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Number-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Integer-Operations" accesskey="n" rel="next">Operations on Integer Values</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exactness" accesskey="p" rel="prev">Exact and Inexact Numbers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Read-Syntax-for-Numerical-Data">6.6.2.6 Read Syntax for Numerical Data</h4>

<p>The read syntax for integers is a string of digits, optionally
preceded by a minus or plus character, a code indicating the
base in which the integer is encoded, and a code indicating whether
the number is exact or inexact.  The supported base codes are:
</p>
<dl class="table">
<dt><code class="code">#b</code></dt>
<dt><code class="code">#B</code></dt>
<dd><p>the integer is written in binary (base 2)
</p>
</dd>
<dt><code class="code">#o</code></dt>
<dt><code class="code">#O</code></dt>
<dd><p>the integer is written in octal (base 8)
</p>
</dd>
<dt><code class="code">#d</code></dt>
<dt><code class="code">#D</code></dt>
<dd><p>the integer is written in decimal (base 10)
</p>
</dd>
<dt><code class="code">#x</code></dt>
<dt><code class="code">#X</code></dt>
<dd><p>the integer is written in hexadecimal (base 16)
</p></dd>
</dl>

<p>If the base code is omitted, the integer is assumed to be decimal.  The
following examples show how these base codes are used.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">-13
⇒ -13

#d-13
⇒ -13

#x-13
⇒ -19

#b+1101
⇒ 13

#o377
⇒ 255
</pre></div>

<p>The codes for indicating exactness (which can, incidentally, be applied
to all numerical values) are:
</p>
<dl class="table">
<dt><code class="code">#e</code></dt>
<dt><code class="code">#E</code></dt>
<dd><p>the number is exact
</p>
</dd>
<dt><code class="code">#i</code></dt>
<dt><code class="code">#I</code></dt>
<dd><p>the number is inexact.
</p></dd>
</dl>

<p>If the exactness indicator is omitted, the number is exact unless it
contains a radix point.  Since Guile can not represent exact complex
numbers, an error is signalled when asking for them.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(exact? 1.2)
⇒ #f

(exact? #e1.2)
⇒ #t

(exact? #e+1i)
ERROR: Wrong type argument
</pre></div>

<p>Guile also understands the syntax ‘<samp class="samp">+inf.0</samp>’ and ‘<samp class="samp">-inf.0</samp>’ for
plus and minus infinity, respectively.  The value must be written
exactly as shown, that is, they always must have a sign and exactly
one zero digit after the decimal point.  It also understands
‘<samp class="samp">+nan.0</samp>’ and ‘<samp class="samp">-nan.0</samp>’ for the special ‘not-a-number’ value.
The sign is ignored for ‘not-a-number’ and the value is always printed
as ‘<samp class="samp">+nan.0</samp>’.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Integer-Operations">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Comparison" accesskey="n" rel="next">Comparison Predicates</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Syntax" accesskey="p" rel="prev">Read Syntax for Numerical Data</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Operations-on-Integer-Values">6.6.2.7 Operations on Integer Values</h4>
<a class="index-entry-id" id="index-odd_003f-2"></a>
<a class="index-entry-id" id="index-even_003f-2"></a>
<a class="index-entry-id" id="index-quotient-2"></a>
<a class="index-entry-id" id="index-remainder-2"></a>
<a class="index-entry-id" id="index-modulo-2"></a>
<a class="index-entry-id" id="index-gcd-2"></a>
<a class="index-entry-id" id="index-lcm-2"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-odd_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">odd?</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-odd_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fodd_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_odd_p</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fodd_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">n</var> is an odd number, <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-even_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">even?</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-even_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feven_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_even_p</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feven_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">n</var> is an even number, <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-quotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">quotient</strong> <var class="def-var-arguments">n d</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quotient"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-remainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">remainder</strong> <var class="def-var-arguments">n d</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-remainder"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fquotient"><span class="category-def">C Function: </span><span><strong class="def-name">scm_quotient</strong> <var class="def-var-arguments">(n, d)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fquotient"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fremainder"><span class="category-def">C Function: </span><span><strong class="def-name">scm_remainder</strong> <var class="def-var-arguments">(n, d)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fremainder"> ¶</a></span></dt>
<dd><p>Return the quotient or remainder from <var class="var">n</var> divided by <var class="var">d</var>.  The
quotient is rounded towards zero, and the remainder will have the same
sign as <var class="var">n</var>.  In all cases quotient and remainder satisfy
<em class="math"><var class="var">n</var> = <var class="var">q</var>*<var class="var">d</var> + <var class="var">r</var></em>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(remainder 13 4) ⇒ 1
(remainder -13 4) ⇒ -1
</pre></div>

<p>See also <code class="code">truncate-quotient</code>, <code class="code">truncate-remainder</code> and
related operations in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic">Arithmetic Functions</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-modulo"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">modulo</strong> <var class="def-var-arguments">n d</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modulo"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmodulo"><span class="category-def">C Function: </span><span><strong class="def-name">scm_modulo</strong> <var class="def-var-arguments">(n, d)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodulo"> ¶</a></span></dt>
<dd><p>Return the remainder from <var class="var">n</var> divided by <var class="var">d</var>, with the same
sign as <var class="var">d</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(modulo 13 4) ⇒ 1
(modulo -13 4) ⇒ 3
(modulo 13 -4) ⇒ -3
(modulo -13 -4) ⇒ -1
</pre></div>

<p>See also <code class="code">floor-quotient</code>, <code class="code">floor-remainder</code> and
related operations in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic">Arithmetic Functions</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gcd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gcd</strong> <var class="def-var-arguments">x…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gcd"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgcd"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gcd</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgcd"> ¶</a></span></dt>
<dd><p>Return the greatest common divisor of all arguments.
If called without arguments, 0 is returned.
</p>
<p>The C function <code class="code">scm_gcd</code> always takes two arguments, while the
Scheme function can take an arbitrary number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lcm"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lcm</strong> <var class="def-var-arguments">x…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lcm"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flcm"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lcm</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flcm"> ¶</a></span></dt>
<dd><p>Return the least common multiple of the arguments.
If called without arguments, 1 is returned.
</p>
<p>The C function <code class="code">scm_lcm</code> always takes two arguments, while the
Scheme function can take an arbitrary number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-modulo_002dexpt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">modulo-expt</strong> <var class="def-var-arguments">n k m</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modulo_002dexpt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmodulo_005fexpt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_modulo_expt</strong> <var class="def-var-arguments">(n, k, m)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodulo_005fexpt"> ¶</a></span></dt>
<dd><p>Return <var class="var">n</var> raised to the integer exponent
<var class="var">k</var>, modulo <var class="var">m</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(modulo-expt 2 3 5)
   ⇒ 3
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-exact_002dinteger_002dsqrt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exact-integer-sqrt</strong> <code class="def-code-arguments"><var class="var">k</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exact_002dinteger_002dsqrt"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fexact_005finteger_005fsqrt"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_exact_integer_sqrt</strong> <code class="def-code-arguments">(SCM <var class="var">k</var>, SCM *<var class="var">s</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexact_005finteger_005fsqrt"> ¶</a></span></dt>
<dd><p>Return two exact non-negative integers <var class="var">s</var> and <var class="var">r</var>
such that <em class="math"><var class="var">k</var> = <var class="var">s</var>^2 + <var class="var">r</var></em> and
<em class="math"><var class="var">s</var>^2 &lt;= <var class="var">k</var> &lt; (<var class="var">s</var> + 1)^2</em>.
An error is raised if <var class="var">k</var> is not an exact non-negative integer.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(exact-integer-sqrt 10) ⇒ 3 and 1
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Comparison">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion" accesskey="n" rel="next">Converting Numbers To and From Strings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Integer-Operations" accesskey="p" rel="prev">Operations on Integer Values</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Comparison-Predicates">6.6.2.8 Comparison Predicates</h4>
<a class="index-entry-id" id="index-zero_003f-2"></a>
<a class="index-entry-id" id="index-positive_003f-2"></a>
<a class="index-entry-id" id="index-negative_003f-2"></a>

<p>The C comparison functions below always takes two arguments, while the
Scheme functions can take an arbitrary number.  Also keep in mind that
the C functions return one of the Scheme boolean values
<code class="code">SCM_BOOL_T</code> or <code class="code">SCM_BOOL_F</code> which are both true as far as C
is concerned.  Thus, always write <code class="code">scm_is_true (scm_num_eq_p (x,
y))</code> when testing the two Scheme numbers <code class="code">x</code> and <code class="code">y</code> for
equality, for example.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">=</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnum_005feq_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_num_eq_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnum_005feq_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if all parameters are numerically equal.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_003c"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">&lt;</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003c"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fless_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_less_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fless_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the list of parameters is monotonically
increasing.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">&gt;</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgr_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gr_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgr_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the list of parameters is monotonically
decreasing.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_003c_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">&lt;=</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003c_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fleq_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_leq_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fleq_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the list of parameters is monotonically
non-decreasing.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_003e_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">&gt;=</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003e_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgeq_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_geq_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgeq_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the list of parameters is monotonically
non-increasing.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-zero_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">zero?</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-zero_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fzero_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_zero_p</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fzero_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">z</var> is an exact or inexact number equal to
zero.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-positive_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">positive?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-positive_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpositive_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_positive_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpositive_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an exact or inexact number greater than
zero.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-negative_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">negative?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-negative_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnegative_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_negative_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnegative_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an exact or inexact number less than
zero.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Conversion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Complex" accesskey="n" rel="next">Complex Number Operations</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Comparison" accesskey="p" rel="prev">Comparison Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Converting-Numbers-To-and-From-Strings">6.6.2.9 Converting Numbers To and From Strings</h4>
<a class="index-entry-id" id="index-number_002d_003estring-2"></a>
<a class="index-entry-id" id="index-string_002d_003enumber-3"></a>

<p>The following procedures read and write numbers according to their
external representation as defined by R5RS (see <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Lexical-structure">R5RS Lexical Structure</a> in <cite class="cite">The Revised^5 Report on the Algorithmic
Language Scheme</cite>).  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output">the <code class="code">(ice-9
i18n)</code> module</a>, for locale-dependent number parsing.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-number_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">number-&gt;string</strong> <var class="def-var-arguments">n [radix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-number_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnumber_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_number_to_string</strong> <var class="def-var-arguments">(n, radix)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnumber_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return a string holding the external representation of the
number <var class="var">n</var> in the given <var class="var">radix</var>.  If <var class="var">n</var> is
inexact, a radix of 10 will be used.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003enumber"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;number</strong> <var class="def-var-arguments">string [radix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003enumber"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005fnumber"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_number</strong> <var class="def-var-arguments">(string, radix)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005fnumber"> ¶</a></span></dt>
<dd><p>Return a number of the maximally precise representation
expressed by the given <var class="var">string</var>. <var class="var">radix</var> must be an
exact integer, either 2, 8, 10, or 16. If supplied, <var class="var">radix</var>
is a default radix that may be overridden by an explicit radix
prefix in <var class="var">string</var> (e.g. "#o177"). If <var class="var">radix</var> is not
supplied, then the default radix is 10. If string is not a
syntactically valid notation for a number, then
<code class="code">string-&gt;number</code> returns <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005flocale_005fstringn_005fto_005fnumber"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_locale_stringn_to_number</strong> <code class="def-code-arguments">(const char *string, size_t len, unsigned radix)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005flocale_005fstringn_005fto_005fnumber"> ¶</a></span></dt>
<dd><p>As per <code class="code">string-&gt;number</code> above, but taking a C string, as pointer
and length.  The string characters should be in the current locale
encoding (<code class="code">locale</code> in the name refers only to that, there’s no
locale-dependent parsing).
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Complex">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic" accesskey="n" rel="next">Arithmetic Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion" accesskey="p" rel="prev">Converting Numbers To and From Strings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Complex-Number-Operations">6.6.2.10 Complex Number Operations</h4>
<a class="index-entry-id" id="index-make_002drectangular-2"></a>
<a class="index-entry-id" id="index-make_002dpolar-2"></a>
<a class="index-entry-id" id="index-real_002dpart-2"></a>
<a class="index-entry-id" id="index-imag_002dpart-2"></a>
<a class="index-entry-id" id="index-magnitude-2"></a>
<a class="index-entry-id" id="index-angle-2"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002drectangular"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-rectangular</strong> <var class="def-var-arguments">real_part imaginary_part</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002drectangular"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005frectangular"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_rectangular</strong> <var class="def-var-arguments">(real_part, imaginary_part)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005frectangular"> ¶</a></span></dt>
<dd><p>Return a complex number constructed of the given <var class="var">real-part</var> and <var class="var">imaginary-part</var> parts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dpolar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-polar</strong> <var class="def-var-arguments">mag ang</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dpolar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fpolar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_polar</strong> <var class="def-var-arguments">(mag, ang)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fpolar"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-polar-form-1"></a>
<p>Return the complex number <var class="var">mag</var> * e^(i * <var class="var">ang</var>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-real_002dpart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">real-part</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-real_002dpart"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freal_005fpart"><span class="category-def">C Function: </span><span><strong class="def-name">scm_real_part</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freal_005fpart"> ¶</a></span></dt>
<dd><p>Return the real part of the number <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-imag_002dpart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">imag-part</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-imag_002dpart"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fimag_005fpart"><span class="category-def">C Function: </span><span><strong class="def-name">scm_imag_part</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fimag_005fpart"> ¶</a></span></dt>
<dd><p>Return the imaginary part of the number <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-magnitude"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">magnitude</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-magnitude"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmagnitude"><span class="category-def">C Function: </span><span><strong class="def-name">scm_magnitude</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmagnitude"> ¶</a></span></dt>
<dd><p>Return the magnitude of the number <var class="var">z</var>. This is the same as
<code class="code">abs</code> for real arguments, but also allows complex numbers.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-angle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">angle</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-angle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fangle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_angle</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fangle"> ¶</a></span></dt>
<dd><p>Return the angle of the complex number <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmake_005frectangular"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_rectangular</strong> <code class="def-code-arguments">(double re, double im)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005frectangular"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fmake_005fpolar"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_polar</strong> <code class="def-code-arguments">(double x, double y)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fpolar"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_make_rectangular</code> or <code class="code">scm_make_polar</code>,
respectively, but these functions take <code class="code">double</code>s as their
arguments.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005freal_005fpart"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_real_part</strong> <code class="def-code-arguments">(z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005freal_005fpart"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fimag_005fpart"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_imag_part</strong> <code class="def-code-arguments">(z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fimag_005fpart"> ¶</a></span></dt>
<dd><p>Returns the real or imaginary part of <var class="var">z</var> as a <code class="code">double</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmagnitude"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_magnitude</strong> <code class="def-code-arguments">(z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmagnitude"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fangle"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_angle</strong> <code class="def-code-arguments">(z)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fangle"> ¶</a></span></dt>
<dd><p>Returns the magnitude or angle of <var class="var">z</var> as a <code class="code">double</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Arithmetic">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scientific" accesskey="n" rel="next">Scientific Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Complex" accesskey="p" rel="prev">Complex Number Operations</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Arithmetic-Functions">6.6.2.11 Arithmetic Functions</h4>
<a class="index-entry-id" id="index-max-2"></a>
<a class="index-entry-id" id="index-min-2"></a>
<a class="index-entry-id" id="index-_002b-2"></a>
<a class="index-entry-id" id="index-_002a-2"></a>
<a class="index-entry-id" id="index-_002d-2"></a>
<a class="index-entry-id" id="index-_002f-2"></a>
<a class="index-entry-id" id="index-1_002b"></a>
<a class="index-entry-id" id="index-1_002d"></a>
<a class="index-entry-id" id="index-abs-2"></a>
<a class="index-entry-id" id="index-floor-2"></a>
<a class="index-entry-id" id="index-ceiling-2"></a>
<a class="index-entry-id" id="index-truncate-3"></a>
<a class="index-entry-id" id="index-round-2"></a>
<a class="index-entry-id" id="index-euclidean_002f-1"></a>
<a class="index-entry-id" id="index-euclidean_002dquotient-1"></a>
<a class="index-entry-id" id="index-euclidean_002dremainder-1"></a>
<a class="index-entry-id" id="index-floor_002f-1"></a>
<a class="index-entry-id" id="index-floor_002dquotient-1"></a>
<a class="index-entry-id" id="index-floor_002dremainder-1"></a>
<a class="index-entry-id" id="index-ceiling_002f-1"></a>
<a class="index-entry-id" id="index-ceiling_002dquotient-1"></a>
<a class="index-entry-id" id="index-ceiling_002dremainder-1"></a>
<a class="index-entry-id" id="index-truncate_002f-1"></a>
<a class="index-entry-id" id="index-truncate_002dquotient-1"></a>
<a class="index-entry-id" id="index-truncate_002dremainder-1"></a>
<a class="index-entry-id" id="index-centered_002f-1"></a>
<a class="index-entry-id" id="index-centered_002dquotient-1"></a>
<a class="index-entry-id" id="index-centered_002dremainder-1"></a>
<a class="index-entry-id" id="index-round_002f-1"></a>
<a class="index-entry-id" id="index-round_002dquotient-1"></a>
<a class="index-entry-id" id="index-round_002dremainder-1"></a>

<p>The C arithmetic functions below always takes two arguments, while the
Scheme functions can take an arbitrary number.  When you need to
invoke them with just one argument, for example to compute the
equivalent of <code class="code">(- x)</code>, pass <code class="code">SCM_UNDEFINED</code> as the second
one: <code class="code">scm_difference (x, SCM_UNDEFINED)</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_002b"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">+</strong> <var class="def-var-arguments">z1 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002b"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsum"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sum</strong> <var class="def-var-arguments">(z1, z2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsum"> ¶</a></span></dt>
<dd><p>Return the sum of all parameter values.  Return 0 if called without any
parameters.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_002d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">-</strong> <var class="def-var-arguments">z1 z2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdifference"><span class="category-def">C Function: </span><span><strong class="def-name">scm_difference</strong> <var class="def-var-arguments">(z1, z2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdifference"> ¶</a></span></dt>
<dd><p>If called with one argument <var class="var">z1</var>, -<var class="var">z1</var> is returned. Otherwise
the sum of all but the first argument are subtracted from the first
argument.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">*</strong> <var class="def-var-arguments">z1 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fproduct"><span class="category-def">C Function: </span><span><strong class="def-name">scm_product</strong> <var class="def-var-arguments">(z1, z2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fproduct"> ¶</a></span></dt>
<dd><p>Return the product of all arguments.  If called without arguments, 1 is
returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">/</strong> <var class="def-var-arguments">z1 z2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdivide"><span class="category-def">C Function: </span><span><strong class="def-name">scm_divide</strong> <var class="def-var-arguments">(z1, z2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdivide"> ¶</a></span></dt>
<dd><p>Divide the first argument by the product of the remaining arguments.  If
called with one argument <var class="var">z1</var>, 1/<var class="var">z1</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-1_002b-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">1+</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-1_002b-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005foneplus"><span class="category-def">C Function: </span><span><strong class="def-name">scm_oneplus</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005foneplus"> ¶</a></span></dt>
<dd><p>Return <em class="math"><var class="var">z</var> + 1</em>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-1_002d-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">1-</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-1_002d-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005foneminus"><span class="category-def">C function: </span><span><strong class="def-name">scm_oneminus</strong> <var class="def-var-arguments">(z)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005foneminus"> ¶</a></span></dt>
<dd><p>Return <em class="math"><var class="var">z</var> - 1</em>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-abs"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">abs</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-abs"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fabs"><span class="category-def">C Function: </span><span><strong class="def-name">scm_abs</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fabs"> ¶</a></span></dt>
<dd><p>Return the absolute value of <var class="var">x</var>.
</p>
<p><var class="var">x</var> must be a number with zero imaginary part.  To calculate the
magnitude of a complex number, use <code class="code">magnitude</code> instead.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-max"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">max</strong> <var class="def-var-arguments">x1 x2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-max"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmax"><span class="category-def">C Function: </span><span><strong class="def-name">scm_max</strong> <var class="def-var-arguments">(x1, x2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmax"> ¶</a></span></dt>
<dd><p>Return the maximum of all parameter values.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-min"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">min</strong> <var class="def-var-arguments">x1 x2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-min"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmin"><span class="category-def">C Function: </span><span><strong class="def-name">scm_min</strong> <var class="def-var-arguments">(x1, x2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmin"> ¶</a></span></dt>
<dd><p>Return the minimum of all parameter values.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-truncate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">truncate</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-truncate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftruncate_005fnumber"><span class="category-def">C Function: </span><span><strong class="def-name">scm_truncate_number</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftruncate_005fnumber"> ¶</a></span></dt>
<dd><p>Round the inexact number <var class="var">x</var> towards zero.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-round"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">round</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-round"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fround_005fnumber"><span class="category-def">C Function: </span><span><strong class="def-name">scm_round_number</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fround_005fnumber"> ¶</a></span></dt>
<dd><p>Round the inexact number <var class="var">x</var> to the nearest integer.  When exactly
halfway between two integers, round to the even one.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-floor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">floor</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-floor"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffloor"><span class="category-def">C Function: </span><span><strong class="def-name">scm_floor</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffloor"> ¶</a></span></dt>
<dd><p>Round the number <var class="var">x</var> towards minus infinity.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ceiling"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ceiling</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ceiling"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fceiling"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ceiling</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fceiling"> ¶</a></span></dt>
<dd><p>Round the number <var class="var">x</var> towards infinity.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005ftruncate"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_truncate</strong> <code class="def-code-arguments">(double x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005ftruncate"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fround"><span class="category-def">C Function: </span><span><code class="def-type">double</code> <strong class="def-name">scm_c_round</strong> <code class="def-code-arguments">(double x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fround"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_truncate_number</code> or <code class="code">scm_round_number</code>,
respectively, but these functions take and return <code class="code">double</code>
values.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-euclidean_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">euclidean/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-euclidean_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-euclidean_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">euclidean-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-euclidean_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-euclidean_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">euclidean-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-euclidean_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005feuclidean_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_euclidean_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feuclidean_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005feuclidean_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_euclidean_quotient</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feuclidean_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005feuclidean_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_euclidean_remainder</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feuclidean_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">euclidean-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">euclidean-remainder</code> returns the real number
<var class="var">r</var> such that <em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em> and
<em class="math">0 &lt;= <var class="var">r</var> &lt; |<var class="var">y</var>|</em>.  <code class="code">euclidean/</code> returns both <var class="var">q</var> and
<var class="var">r</var>, and is more efficient than computing each separately.  Note
that when <em class="math"><var class="var">y</var> &gt; 0</em>, <code class="code">euclidean-quotient</code> returns
<em class="math">floor(<var class="var">x</var>/<var class="var">y</var>)</em>, otherwise it returns
<em class="math">ceiling(<var class="var">x</var>/<var class="var">y</var>)</em>.
</p>
<p>Note that these operators are equivalent to the R6RS operators
<code class="code">div</code>, <code class="code">mod</code>, and <code class="code">div-and-mod</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(euclidean-quotient 123 10) ⇒ 12
(euclidean-remainder 123 10) ⇒ 3
(euclidean/ 123 10) ⇒ 12 and 3
(euclidean/ 123 -10) ⇒ -12 and 3
(euclidean/ -123 10) ⇒ -13 and 7
(euclidean/ -123 -10) ⇒ 13 and 7
(euclidean/ -123.2 -63.5) ⇒ 2.0 and 3.8
(euclidean/ 16/3 -10/7) ⇒ -3 and 22/21
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-floor_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">floor/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-floor_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-floor_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">floor-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-floor_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-floor_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">floor-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-floor_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffloor_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_floor_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffloor_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffloor_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_floor_quotient</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffloor_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffloor_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_floor_remainder</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffloor_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">floor-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">floor-remainder</code> returns the real number
<var class="var">r</var> such that <em class="math"><var class="var">q</var> = floor(<var class="var">x</var>/<var class="var">y</var>)</em> and
<em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em>.  <code class="code">floor/</code> returns
both <var class="var">q</var> and <var class="var">r</var>, and is more efficient than computing each
separately.  Note that <var class="var">r</var>, if non-zero, will have the same sign
as <var class="var">y</var>.
</p>
<p>When <var class="var">x</var> and <var class="var">y</var> are integers, <code class="code">floor-remainder</code> is
equivalent to the R5RS integer-only operator <code class="code">modulo</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(floor-quotient 123 10) ⇒ 12
(floor-remainder 123 10) ⇒ 3
(floor/ 123 10) ⇒ 12 and 3
(floor/ 123 -10) ⇒ -13 and -7
(floor/ -123 10) ⇒ -13 and 7
(floor/ -123 -10) ⇒ 12 and -3
(floor/ -123.2 -63.5) ⇒ 1.0 and -59.7
(floor/ 16/3 -10/7) ⇒ -4 and -8/21
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-ceiling_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ceiling/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ceiling_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ceiling_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ceiling-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ceiling_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-ceiling_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ceiling-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ceiling_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fceiling_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_ceiling_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fceiling_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fceiling_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_ceiling_quotient</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fceiling_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fceiling_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_ceiling_remainder</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fceiling_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">ceiling-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">ceiling-remainder</code> returns the real number
<var class="var">r</var> such that <em class="math"><var class="var">q</var> = ceiling(<var class="var">x</var>/<var class="var">y</var>)</em> and
<em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em>.  <code class="code">ceiling/</code> returns
both <var class="var">q</var> and <var class="var">r</var>, and is more efficient than computing each
separately.  Note that <var class="var">r</var>, if non-zero, will have the opposite sign
of <var class="var">y</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(ceiling-quotient 123 10) ⇒ 13
(ceiling-remainder 123 10) ⇒ -7
(ceiling/ 123 10) ⇒ 13 and -7
(ceiling/ 123 -10) ⇒ -12 and 3
(ceiling/ -123 10) ⇒ -12 and -3
(ceiling/ -123 -10) ⇒ 13 and 7
(ceiling/ -123.2 -63.5) ⇒ 2.0 and 3.8
(ceiling/ 16/3 -10/7) ⇒ -3 and 22/21
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-truncate_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">truncate/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-truncate_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-truncate_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">truncate-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-truncate_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-truncate_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">truncate-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-truncate_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftruncate_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_truncate_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftruncate_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftruncate_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_truncate_quotient</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftruncate_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftruncate_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_truncate_remainder</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftruncate_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">truncate-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">truncate-remainder</code> returns the real number
<var class="var">r</var> such that <var class="var">q</var> is <em class="math"><var class="var">x</var>/<var class="var">y</var></em> rounded toward zero,
and <em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em>.  <code class="code">truncate/</code> returns
both <var class="var">q</var> and <var class="var">r</var>, and is more efficient than computing each
separately.  Note that <var class="var">r</var>, if non-zero, will have the same sign
as <var class="var">x</var>.
</p>
<p>When <var class="var">x</var> and <var class="var">y</var> are integers, these operators are
equivalent to the R5RS integer-only operators <code class="code">quotient</code> and
<code class="code">remainder</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(truncate-quotient 123 10) ⇒ 12
(truncate-remainder 123 10) ⇒ 3
(truncate/ 123 10) ⇒ 12 and 3
(truncate/ 123 -10) ⇒ -12 and 3
(truncate/ -123 10) ⇒ -12 and -3
(truncate/ -123 -10) ⇒ 12 and -3
(truncate/ -123.2 -63.5) ⇒ 1.0 and -59.7
(truncate/ 16/3 -10/7) ⇒ -3 and 22/21
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-centered_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">centered/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-centered_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-centered_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">centered-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-centered_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-centered_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">centered-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-centered_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fcentered_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_centered_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcentered_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fcentered_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_centered_quotient</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcentered_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fcentered_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_centered_remainder</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcentered_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">centered-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">centered-remainder</code> returns the real number
<var class="var">r</var> such that <em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em> and
<em class="math">-|<var class="var">y</var>/2| &lt;= <var class="var">r</var> &lt; |<var class="var">y</var>/2|</em>.  <code class="code">centered/</code>
returns both <var class="var">q</var> and <var class="var">r</var>, and is more efficient than computing
each separately.
</p>
<p>Note that <code class="code">centered-quotient</code> returns <em class="math"><var class="var">x</var>/<var class="var">y</var></em>
rounded to the nearest integer.  When <em class="math"><var class="var">x</var>/<var class="var">y</var></em> lies
exactly half-way between two integers, the tie is broken according to
the sign of <var class="var">y</var>.  If <em class="math"><var class="var">y</var> &gt; 0</em>, ties are rounded toward
positive infinity, otherwise they are rounded toward negative infinity.
This is a consequence of the requirement that
<em class="math">-|<var class="var">y</var>/2| &lt;= <var class="var">r</var> &lt; |<var class="var">y</var>/2|</em>.
</p>
<p>Note that these operators are equivalent to the R6RS operators
<code class="code">div0</code>, <code class="code">mod0</code>, and <code class="code">div0-and-mod0</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(centered-quotient 123 10) ⇒ 12
(centered-remainder 123 10) ⇒ 3
(centered/ 123 10) ⇒ 12 and 3
(centered/ 123 -10) ⇒ -12 and 3
(centered/ -123 10) ⇒ -12 and -3
(centered/ -123 -10) ⇒ 12 and -3
(centered/ 125 10) ⇒ 13 and -5
(centered/ 127 10) ⇒ 13 and -3
(centered/ 135 10) ⇒ 14 and -5
(centered/ -123.2 -63.5) ⇒ 2.0 and 3.8
(centered/ 16/3 -10/7) ⇒ -4 and -8/21
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-round_002f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">round/</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-round_002f"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-round_002dquotient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">round-quotient</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-round_002dquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-round_002dremainder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">round-remainder</strong> <code class="def-code-arguments"><var class="var">x</var> <var class="var">y</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-round_002dremainder"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fround_005fdivide"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_round_divide</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>, SCM <var class="var">y</var>, SCM *<var class="var">q</var>, SCM *<var class="var">r</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fround_005fdivide"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fround_005fquotient"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_round_quotient</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fround_005fquotient"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fround_005fremainder"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_round_remainder</strong> <code class="def-code-arguments">(<var class="var">x</var>, <var class="var">y</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fround_005fremainder"> ¶</a></span></dt>
<dd><p>These procedures accept two real numbers <var class="var">x</var> and <var class="var">y</var>, where the
divisor <var class="var">y</var> must be non-zero.  <code class="code">round-quotient</code> returns the
integer <var class="var">q</var> and <code class="code">round-remainder</code> returns the real number
<var class="var">r</var> such that <em class="math"><var class="var">x</var> = <var class="var">q</var>*<var class="var">y</var> + <var class="var">r</var></em> and
<var class="var">q</var> is <em class="math"><var class="var">x</var>/<var class="var">y</var></em> rounded to the nearest integer,
with ties going to the nearest even integer.  <code class="code">round/</code>
returns both <var class="var">q</var> and <var class="var">r</var>, and is more efficient than computing
each separately.
</p>
<p>Note that <code class="code">round/</code> and <code class="code">centered/</code> are almost equivalent, but
their behavior differs when <em class="math"><var class="var">x</var>/<var class="var">y</var></em> lies exactly half-way
between two integers.  In this case, <code class="code">round/</code> chooses the nearest
even integer, whereas <code class="code">centered/</code> chooses in such a way to satisfy
the constraint <em class="math">-|<var class="var">y</var>/2| &lt;= <var class="var">r</var> &lt; |<var class="var">y</var>/2|</em>, which
is stronger than the corresponding constraint for <code class="code">round/</code>,
<em class="math">-|<var class="var">y</var>/2| &lt;= <var class="var">r</var> &lt;= |<var class="var">y</var>/2|</em>.  In particular,
when <var class="var">x</var> and <var class="var">y</var> are integers, the number of possible remainders
returned by <code class="code">centered/</code> is <em class="math">|<var class="var">y</var>|</em>, whereas the number of
possible remainders returned by <code class="code">round/</code> is <em class="math">|<var class="var">y</var>|+1</em> when
<var class="var">y</var> is even.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(round-quotient 123 10) ⇒ 12
(round-remainder 123 10) ⇒ 3
(round/ 123 10) ⇒ 12 and 3
(round/ 123 -10) ⇒ -12 and 3
(round/ -123 10) ⇒ -12 and -3
(round/ -123 -10) ⇒ 12 and -3
(round/ 125 10) ⇒ 12 and 5
(round/ 127 10) ⇒ 13 and -3
(round/ 135 10) ⇒ 14 and -5
(round/ -123.2 -63.5) ⇒ 2.0 and 3.8
(round/ 16/3 -10/7) ⇒ -4 and -8/21
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Scientific">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations" accesskey="n" rel="next">Bitwise Operations</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arithmetic" accesskey="p" rel="prev">Arithmetic Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Scientific-Functions">6.6.2.12 Scientific Functions</h4>

<p>The following procedures accept any kind of number as arguments,
including complex numbers.
</p>
<a class="index-entry-id" id="index-sqrt-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-sqrt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sqrt</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sqrt"> ¶</a></span></dt>
<dd><p>Return the square root of <var class="var">z</var>.  Of the two possible roots
(positive and negative), the one with a positive real part is
returned, or if that’s zero then a positive imaginary part.  Thus,
</p>
<div class="example">
<pre class="example-preformatted">(sqrt 9.0)       ⇒ 3.0
(sqrt -9.0)      ⇒ 0.0+3.0i
(sqrt 1.0+1.0i)  ⇒ 1.09868411346781+0.455089860562227i
(sqrt -1.0-1.0i) ⇒ 0.455089860562227-1.09868411346781i
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-expt-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-expt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">expt</strong> <var class="def-var-arguments">z1 z2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-expt"> ¶</a></span></dt>
<dd><p>Return <var class="var">z1</var> raised to the power of <var class="var">z2</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-sin-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-sin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sin</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sin"> ¶</a></span></dt>
<dd><p>Return the sine of <var class="var">z</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-cos-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-cos"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cos</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cos"> ¶</a></span></dt>
<dd><p>Return the cosine of <var class="var">z</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-tan-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-tan"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tan</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tan"> ¶</a></span></dt>
<dd><p>Return the tangent of <var class="var">z</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-asin-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-asin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">asin</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-asin"> ¶</a></span></dt>
<dd><p>Return the arcsine of <var class="var">z</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-acos-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-acos"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">acos</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-acos"> ¶</a></span></dt>
<dd><p>Return the arccosine of <var class="var">z</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-atan-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-atan"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atan</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atan"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-atan-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atan</strong> <var class="def-var-arguments">y x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atan-1"> ¶</a></span></dt>
<dd><p>Return the arctangent of <var class="var">z</var>, or of <em class="math"><var class="var">y</var>/<var class="var">x</var></em>.
</p></dd></dl>

<a class="index-entry-id" id="index-exp-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-exp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exp</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exp"> ¶</a></span></dt>
<dd><p>Return e to the power of <var class="var">z</var>, where e is the base of natural
logarithms (2.71828…).
</p></dd></dl>

<a class="index-entry-id" id="index-log-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-log"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">log</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-log"> ¶</a></span></dt>
<dd><p>Return the natural logarithm of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-log10"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">log10</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-log10"> ¶</a></span></dt>
<dd><p>Return the base 10 logarithm of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sinh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sinh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sinh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic sine of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-cosh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cosh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cosh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic cosine of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tanh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tanh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tanh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic tangent of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-asinh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">asinh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-asinh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic arcsine of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-acosh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">acosh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-acosh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic arccosine of <var class="var">z</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atanh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atanh</strong> <var class="def-var-arguments">z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atanh"> ¶</a></span></dt>
<dd><p>Return the hyperbolic arctangent of <var class="var">z</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bitwise-Operations">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Random" accesskey="n" rel="next">Random Number Generation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scientific" accesskey="p" rel="prev">Scientific Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Bitwise-Operations-1">6.6.2.13 Bitwise Operations</h4>

<p>For the following bitwise functions, negative numbers are treated as
infinite precision twos-complements.  For instance <em class="math">-6</em> is bits
<em class="math">…111010</em>, with infinitely many ones on the left.  It can
be seen that adding 6 (binary 110) to such a bit pattern gives all
zeros.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-logand"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logand</strong> <var class="def-var-arguments">n1 n2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logand"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flogand"><span class="category-def">C Function: </span><span><strong class="def-name">scm_logand</strong> <var class="def-var-arguments">(n1, n2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flogand"> ¶</a></span></dt>
<dd><p>Return the bitwise <small class="sc">AND</small> of the integer arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logand) ⇒ -1
(logand 7) ⇒ 7
(logand #b111 #b011 #b001) ⇒ 1
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-logior"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logior</strong> <var class="def-var-arguments">n1 n2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logior"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flogior"><span class="category-def">C Function: </span><span><strong class="def-name">scm_logior</strong> <var class="def-var-arguments">(n1, n2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flogior"> ¶</a></span></dt>
<dd><p>Return the bitwise <small class="sc">OR</small> of the integer arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logior) ⇒ 0
(logior 7) ⇒ 7
(logior #b000 #b001 #b011) ⇒ 3
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-logxor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logxor</strong> <var class="def-var-arguments">n1 n2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logxor"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005floxor"><span class="category-def">C Function: </span><span><strong class="def-name">scm_loxor</strong> <var class="def-var-arguments">(n1, n2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005floxor"> ¶</a></span></dt>
<dd><p>Return the bitwise <small class="sc">XOR</small> of the integer arguments.  A bit is
set in the result if it is set in an odd number of arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logxor) ⇒ 0
(logxor 7) ⇒ 7
(logxor #b000 #b001 #b011) ⇒ 2
(logxor #b000 #b001 #b011 #b011) ⇒ 1
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lognot"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lognot</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lognot"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flognot"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lognot</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flognot"> ¶</a></span></dt>
<dd><p>Return the integer which is the ones-complement of the integer
argument, ie. each 0 bit is changed to 1 and each 1 bit to 0.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(number-&gt;string (lognot #b10000000) 2)
   ⇒ "-10000001"
(number-&gt;string (lognot #b0) 2)
   ⇒ "-1"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-logtest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logtest</strong> <var class="def-var-arguments">j k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logtest"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flogtest"><span class="category-def">C Function: </span><span><strong class="def-name">scm_logtest</strong> <var class="def-var-arguments">(j, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flogtest"> ¶</a></span></dt>
<dd><p>Test whether <var class="var">j</var> and <var class="var">k</var> have any 1 bits in common.  This is
equivalent to <code class="code">(not (zero? (logand j k)))</code>, but without actually
calculating the <code class="code">logand</code>, just testing for non-zero.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logtest #b0100 #b1011) ⇒ #f
(logtest #b0100 #b0111) ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-logbit_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logbit?</strong> <var class="def-var-arguments">index j</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logbit_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flogbit_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_logbit_p</strong> <var class="def-var-arguments">(index, j)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flogbit_005fp"> ¶</a></span></dt>
<dd><p>Test whether bit number <var class="var">index</var> in <var class="var">j</var> is set.  <var class="var">index</var>
starts from 0 for the least significant bit.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logbit? 0 #b1101) ⇒ #t
(logbit? 1 #b1101) ⇒ #f
(logbit? 2 #b1101) ⇒ #t
(logbit? 3 #b1101) ⇒ #t
(logbit? 4 #b1101) ⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ash</strong> <var class="def-var-arguments">n count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ash</strong> <var class="def-var-arguments">(n, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fash"> ¶</a></span></dt>
<dd><p>Return <em class="math">floor(n * 2^{count})</em>.
<var class="var">n</var> and <var class="var">count</var> must be exact integers.
</p>
<p>With <var class="var">n</var> viewed as an infinite-precision twos-complement
integer, <code class="code">ash</code> means a left shift introducing zero bits
when <var class="var">count</var> is positive, or a right shift dropping bits
when <var class="var">count</var> is negative.  This is an “arithmetic” shift.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(number-&gt;string (ash #b1 3) 2)     ⇒ "1000"
(number-&gt;string (ash #b1010 -1) 2) ⇒ "101"

;; -23 is bits ...11101001, -6 is bits ...111010
(ash -23 -2) ⇒ -6
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-round_002dash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">round-ash</strong> <var class="def-var-arguments">n count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-round_002dash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fround_005fash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_round_ash</strong> <var class="def-var-arguments">(n, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fround_005fash"> ¶</a></span></dt>
<dd><p>Return <em class="math">round(n * 2^count)</em>.
<var class="var">n</var> and <var class="var">count</var> must be exact integers.
</p>
<p>With <var class="var">n</var> viewed as an infinite-precision twos-complement
integer, <code class="code">round-ash</code> means a left shift introducing zero
bits when <var class="var">count</var> is positive, or a right shift rounding
to the nearest integer (with ties going to the nearest even
integer) when <var class="var">count</var> is negative.  This is a rounded
“arithmetic” shift.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(number-&gt;string (round-ash #b1 3) 2)     ⇒ \"1000\"
(number-&gt;string (round-ash #b1010 -1) 2) ⇒ \"101\"
(number-&gt;string (round-ash #b1010 -2) 2) ⇒ \"10\"
(number-&gt;string (round-ash #b1011 -2) 2) ⇒ \"11\"
(number-&gt;string (round-ash #b1101 -2) 2) ⇒ \"11\"
(number-&gt;string (round-ash #b1110 -2) 2) ⇒ \"100\"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-logcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">logcount</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-logcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flogcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_logcount</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flogcount"> ¶</a></span></dt>
<dd><p>Return the number of bits in integer <var class="var">n</var>.  If <var class="var">n</var> is
positive, the 1-bits in its binary representation are counted.
If negative, the 0-bits in its two’s-complement binary
representation are counted.  If zero, 0 is returned.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(logcount #b10101010)
   ⇒ 4
(logcount 0)
   ⇒ 0
(logcount -2)
   ⇒ 1
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-integer_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">integer-length</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-integer_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finteger_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_integer_length</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finteger_005flength"> ¶</a></span></dt>
<dd><p>Return the number of bits necessary to represent <var class="var">n</var>.
</p>
<p>For positive <var class="var">n</var> this is how many bits to the most significant one
bit.  For negative <var class="var">n</var> it’s how many bits to the most significant
zero bit in twos complement form.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(integer-length #b10101010) ⇒ 8
(integer-length #b1111)     ⇒ 4
(integer-length 0)          ⇒ 0
(integer-length -1)         ⇒ 0
(integer-length -256)       ⇒ 8
(integer-length -257)       ⇒ 9
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-integer_002dexpt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">integer-expt</strong> <var class="def-var-arguments">n k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-integer_002dexpt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finteger_005fexpt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_integer_expt</strong> <var class="def-var-arguments">(n, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finteger_005fexpt"> ¶</a></span></dt>
<dd><p>Return <var class="var">n</var> raised to the power <var class="var">k</var>.  <var class="var">k</var> must be an exact
integer, <var class="var">n</var> can be any number.
</p>
<p>Negative <var class="var">k</var> is supported, and results in <em class="math">1/n^abs(k)</em>
in the usual way.  <em class="math"><var class="var">n</var>^0</em> is 1, as usual, and that includes
<em class="math">0^0</em> is 1.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(integer-expt 2 5)   ⇒ 32
(integer-expt -3 3)  ⇒ -27
(integer-expt 5 -3)  ⇒ 1/125
(integer-expt 0 0)   ⇒ 1
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bit_002dextract"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bit-extract</strong> <var class="def-var-arguments">n start end</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bit_002dextract"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbit_005fextract"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bit_extract</strong> <var class="def-var-arguments">(n, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbit_005fextract"> ¶</a></span></dt>
<dd><p>Return the integer composed of the <var class="var">start</var> (inclusive)
through <var class="var">end</var> (exclusive) bits of <var class="var">n</var>.  The
<var class="var">start</var>th bit becomes the 0-th bit in the result.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(number-&gt;string (bit-extract #b1101101010 0 4) 2)
   ⇒ "1010"
(number-&gt;string (bit-extract #b1101101010 4 9) 2)
   ⇒ "10110"
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Random">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations" accesskey="p" rel="prev">Bitwise Operations</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="u" rel="up">Numerical data types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Random-Number-Generation">6.6.2.14 Random Number Generation</h4>

<p>Pseudo-random numbers are generated from a random state object, which
can be created with <code class="code">seed-&gt;random-state</code> or
<code class="code">datum-&gt;random-state</code>.  An external representation (i.e. one
which can written with <code class="code">write</code> and read with <code class="code">read</code>) of a
random state object can be obtained via
<code class="code">random-state-&gt;datum</code>.  The <var class="var">state</var> parameter to the
various functions below is optional, it defaults to the state object
in the <code class="code">*random-state*</code> variable.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-copy_002drandom_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">copy-random-state</strong> <var class="def-var-arguments">[state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-copy_002drandom_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcopy_005frandom_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_copy_random_state</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcopy_005frandom_005fstate"> ¶</a></span></dt>
<dd><p>Return a copy of the random state <var class="var">state</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random</strong> <var class="def-var-arguments">n [state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random</strong> <var class="def-var-arguments">(n, state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom"> ¶</a></span></dt>
<dd><p>Return a number in [0, <var class="var">n</var>).
</p>
<p>Accepts a positive integer or real n and returns a
number of the same type between zero (inclusive) and
<var class="var">n</var> (exclusive). The values returned have a uniform
distribution.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003aexp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:exp</strong> <var class="def-var-arguments">[state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003aexp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fexp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_exp</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fexp"> ¶</a></span></dt>
<dd><p>Return an inexact real in an exponential distribution with mean
1.  For an exponential distribution with mean <var class="var">u</var> use <code class="code">(*
<var class="var">u</var> (random:exp))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003ahollow_002dsphere_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:hollow-sphere!</strong> <var class="def-var-arguments">vect [state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003ahollow_002dsphere_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fhollow_005fsphere_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_hollow_sphere_x</strong> <var class="def-var-arguments">(vect, state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fhollow_005fsphere_005fx"> ¶</a></span></dt>
<dd><p>Fills <var class="var">vect</var> with inexact real random numbers the sum of whose
squares is equal to 1.0.  Thinking of <var class="var">vect</var> as coordinates in
space of dimension <var class="var">n</var> <em class="math">=</em> <code class="code">(vector-length <var class="var">vect</var>)</code>,
the coordinates are uniformly distributed over the surface of the unit
n-sphere.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003anormal"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:normal</strong> <var class="def-var-arguments">[state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003anormal"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fnormal"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_normal</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fnormal"> ¶</a></span></dt>
<dd><p>Return an inexact real in a normal distribution.  The distribution
used has mean 0 and standard deviation 1.  For a normal distribution
with mean <var class="var">m</var> and standard deviation <var class="var">d</var> use <code class="code">(+ <var class="var">m</var>
(* <var class="var">d</var> (random:normal)))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003anormal_002dvector_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:normal-vector!</strong> <var class="def-var-arguments">vect [state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003anormal_002dvector_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fnormal_005fvector_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_normal_vector_x</strong> <var class="def-var-arguments">(vect, state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fnormal_005fvector_005fx"> ¶</a></span></dt>
<dd><p>Fills <var class="var">vect</var> with inexact real random numbers that are
independent and standard normally distributed
(i.e., with mean 0 and variance 1).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003asolid_002dsphere_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:solid-sphere!</strong> <var class="def-var-arguments">vect [state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003asolid_002dsphere_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fsolid_005fsphere_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_solid_sphere_x</strong> <var class="def-var-arguments">(vect, state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fsolid_005fsphere_005fx"> ¶</a></span></dt>
<dd><p>Fills <var class="var">vect</var> with inexact real random numbers the sum of whose
squares is less than 1.0.  Thinking of <var class="var">vect</var> as coordinates in
space of dimension <var class="var">n</var> <em class="math">=</em> <code class="code">(vector-length <var class="var">vect</var>)</code>,
the coordinates are uniformly distributed within the unit
<var class="var">n</var>-sphere.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_003auniform"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random:uniform</strong> <var class="def-var-arguments">[state]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_003auniform"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005funiform"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_uniform</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005funiform"> ¶</a></span></dt>
<dd><p>Return a uniformly distributed inexact real random number in
[0,1).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-seed_002d_003erandom_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">seed-&gt;random-state</strong> <var class="def-var-arguments">seed</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-seed_002d_003erandom_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fseed_005fto_005frandom_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_seed_to_random_state</strong> <var class="def-var-arguments">(seed)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fseed_005fto_005frandom_005fstate"> ¶</a></span></dt>
<dd><p>Return a new random state using <var class="var">seed</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-datum_002d_003erandom_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">datum-&gt;random-state</strong> <var class="def-var-arguments">datum</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-datum_002d_003erandom_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdatum_005fto_005frandom_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_datum_to_random_state</strong> <var class="def-var-arguments">(datum)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdatum_005fto_005frandom_005fstate"> ¶</a></span></dt>
<dd><p>Return a new random state from <var class="var">datum</var>, which should have been
obtained by <code class="code">random-state-&gt;datum</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_002dstate_002d_003edatum"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random-state-&gt;datum</strong> <var class="def-var-arguments">state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dstate_002d_003edatum"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fstate_005fto_005fdatum"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_state_to_datum</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fstate_005fto_005fdatum"> ¶</a></span></dt>
<dd><p>Return a datum representation of <var class="var">state</var> that may be written out and
read back with the Scheme reader.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-random_002dstate_002dfrom_002dplatform"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">random-state-from-platform</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dstate_002dfrom_002dplatform"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frandom_005fstate_005ffrom_005fplatform"><span class="category-def">C Function: </span><span><strong class="def-name">scm_random_state_from_platform</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frandom_005fstate_005ffrom_005fplatform"> ¶</a></span></dt>
<dd><p>Construct a new random state seeded from a platform-specific source of
entropy, appropriate for use in non-security-critical applications.
Currently <samp class="file">/dev/urandom</samp> is tried first, or else the seed is based
on the time, date, process ID, an address from a freshly allocated heap
cell, an address from the local stack frame, and a high-resolution timer
if available.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_002arandom_002dstate_002a"><span class="category-def">Variable: </span><span><strong class="def-name">*random-state*</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002arandom_002dstate_002a"> ¶</a></span></dt>
<dd><p>The global random state used by the above functions when the
<var class="var">state</var> parameter is not given.
</p></dd></dl>

<p>Note that the initial value of <code class="code">*random-state*</code> is the same every
time Guile starts up.  Therefore, if you don’t pass a <var class="var">state</var>
parameter to the above procedures, and you don’t set
<code class="code">*random-state*</code> to <code class="code">(seed-&gt;random-state your-seed)</code>, where
<code class="code">your-seed</code> is something that <em class="emph">isn’t</em> the same every time,
you’ll get the same sequence of “random” numbers on every run.
</p>
<p>For example, unless the relevant source code has changed, <code class="code">(map
random (cdr (iota 30)))</code>, if the first use of random numbers since
Guile started up, will always give:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(map random (cdr (iota 19)))
⇒
(0 1 1 2 2 2 1 2 6 7 10 0 5 3 12 5 5 12)
</pre></div>

<p>To seed the random state in a sensible way for non-security-critical
applications, do this during initialization of your program:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! *random-state* (random-state-from-platform))
</pre></div>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Characters">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="n" rel="next">Character Sets</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Numbers" accesskey="p" rel="prev">Numerical data types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Characters-1">6.6.3 Characters</h4>
<a class="index-entry-id" id="index-Characters"></a>

<p>In Scheme, there is a data type to describe a single character.  
</p>
<p>Defining what exactly a character <em class="emph">is</em> can be more complicated
than it seems.  Guile follows the advice of R6RS and uses The Unicode
Standard to help define what a character is.  So, for Guile, a
character is anything in the Unicode Character Database.
</p>
<a class="index-entry-id" id="index-code-point"></a>
<a class="index-entry-id" id="index-Unicode-code-point"></a>

<p>The Unicode Character Database is basically a table of characters
indexed using integers called ’code points’.  Valid code points are in
the ranges 0 to <code class="code">#xD7FF</code> inclusive or <code class="code">#xE000</code> to
<code class="code">#x10FFFF</code> inclusive, which is about 1.1 million code points.
</p>
<a class="index-entry-id" id="index-designated-code-point"></a>
<a class="index-entry-id" id="index-code-point_002c-designated"></a>

<p>Any code point that has been assigned to a character or that has
otherwise been given a meaning by Unicode is called a ’designated code
point’.  Most of the designated code points, about 200,000 of them,
indicate characters, accents or other combining marks that modify
other characters, symbols, whitespace, and control characters.  Some
are not characters but indicators that suggest how to format or
display neighboring characters.
</p>
<a class="index-entry-id" id="index-reserved-code-point"></a>
<a class="index-entry-id" id="index-code-point_002c-reserved"></a>

<p>If a code point is not a designated code point – if it has not been
assigned to a character by The Unicode Standard – it is a ’reserved
code point’, meaning that they are reserved for future use.  Most of
the code points, about 800,000, are ’reserved code points’.
</p>
<p>By convention, a Unicode code point is written as
“U+XXXX” where “XXXX” is a hexadecimal number.  Please note that
this convenient notation is not valid code.  Guile does not interpret
“U+XXXX” as a character.
</p>
<p>In Scheme, a character literal is written as <code class="code">#\<var class="var">name</var></code> where
<var class="var">name</var> is the name of the character that you want.  Printable
characters have their usual single character name; for example,
<code class="code">#\a</code> is a lower case <code class="code">a</code>.  
</p>
<p>Some of the code points are ’combining characters’ that are not meant
to be printed by themselves but are instead meant to modify the
appearance of the previous character.  For combining characters, an
alternate form of the character literal is <code class="code">#\</code> followed by
U+25CC (a small, dotted circle), followed by the combining character.
This allows the combining character to be drawn on the circle, not on
the backslash of <code class="code">#\</code>.
</p>
<p>Many of the non-printing characters, such as whitespace characters and
control characters, also have names.
</p>
<p>The most commonly used non-printing characters have long character
names, described in the table below.
</p>
<table class="multitable">
<tbody><tr><td>Character Name</td><td>Codepoint</td></tr>
<tr><td><code class="code">#\nul</code></td><td>U+0000</td></tr>
<tr><td><code class="code">#\alarm</code></td><td>U+0007</td></tr>
<tr><td><code class="code">#\backspace</code></td><td>U+0008</td></tr>
<tr><td><code class="code">#\tab</code></td><td>U+0009</td></tr>
<tr><td><code class="code">#\linefeed</code></td><td>U+000A</td></tr>
<tr><td><code class="code">#\newline</code></td><td>U+000A</td></tr>
<tr><td><code class="code">#\vtab</code></td><td>U+000B</td></tr>
<tr><td><code class="code">#\page</code></td><td>U+000C</td></tr>
<tr><td><code class="code">#\return</code></td><td>U+000D</td></tr>
<tr><td><code class="code">#\esc</code></td><td>U+001B</td></tr>
<tr><td><code class="code">#\space</code></td><td>U+0020</td></tr>
<tr><td><code class="code">#\delete</code></td><td>U+007F</td></tr>
</tbody>
</table>

<p>There are also short names for all of the “C0 control characters”
(those with code points below 32).  The following table lists the short
name for each character.
</p>
<table class="multitable">
<tbody><tr><td width="25%">0 = <code class="code">#\nul</code></td><td width="25%">1 = <code class="code">#\soh</code></td><td width="25%">2 = <code class="code">#\stx</code></td><td width="25%">3 = <code class="code">#\etx</code></td></tr>
<tr><td width="25%">4 = <code class="code">#\eot</code></td><td width="25%">5 = <code class="code">#\enq</code></td><td width="25%">6 = <code class="code">#\ack</code></td><td width="25%">7 = <code class="code">#\bel</code></td></tr>
<tr><td width="25%">8 = <code class="code">#\bs</code></td><td width="25%">9 = <code class="code">#\ht</code></td><td width="25%">10 = <code class="code">#\lf</code></td><td width="25%">11 = <code class="code">#\vt</code></td></tr>
<tr><td width="25%">12 = <code class="code">#\ff</code></td><td width="25%">13 = <code class="code">#\cr</code></td><td width="25%">14 = <code class="code">#\so</code></td><td width="25%">15 = <code class="code">#\si</code></td></tr>
<tr><td width="25%">16 = <code class="code">#\dle</code></td><td width="25%">17 = <code class="code">#\dc1</code></td><td width="25%">18 = <code class="code">#\dc2</code></td><td width="25%">19 = <code class="code">#\dc3</code></td></tr>
<tr><td width="25%">20 = <code class="code">#\dc4</code></td><td width="25%">21 = <code class="code">#\nak</code></td><td width="25%">22 = <code class="code">#\syn</code></td><td width="25%">23 = <code class="code">#\etb</code></td></tr>
<tr><td width="25%">24 = <code class="code">#\can</code></td><td width="25%">25 = <code class="code">#\em</code></td><td width="25%">26 = <code class="code">#\sub</code></td><td width="25%">27 = <code class="code">#\esc</code></td></tr>
<tr><td width="25%">28 = <code class="code">#\fs</code></td><td width="25%">29 = <code class="code">#\gs</code></td><td width="25%">30 = <code class="code">#\rs</code></td><td width="25%">31 = <code class="code">#\us</code></td></tr>
<tr><td width="25%">32 = <code class="code">#\sp</code></td></tr>
</tbody>
</table>

<p>The short name for the “delete” character (code point U+007F) is
<code class="code">#\del</code>.
</p>
<p>The R7RS name for the “escape” character (code point U+001B) is
<code class="code">#\escape</code>.
</p>
<p>There are also a few alternative names left over for compatibility with
previous versions of Guile.
</p>
<table class="multitable">
<tbody><tr><td>Alternate</td><td>Standard</td></tr>
<tr><td><code class="code">#\nl</code></td><td><code class="code">#\newline</code></td></tr>
<tr><td><code class="code">#\np</code></td><td><code class="code">#\page</code></td></tr>
<tr><td><code class="code">#\null</code></td><td><code class="code">#\nul</code></td></tr>
</tbody>
</table>

<p>Characters may also be written using their code point values.  They can
be written with as an octal number, such as <code class="code">#\10</code> for
<code class="code">#\bs</code> or <code class="code">#\177</code> for <code class="code">#\del</code>.
</p>
<p>If one prefers hex to octal, there is an additional syntax for character
escapes: <code class="code">#\xHHHH</code> – the letter ’x’ followed by a hexadecimal
number of one to eight digits.
</p>
<a class="index-entry-id" id="index-char_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is a character, else <code class="code">#f</code>.
</p></dd></dl>

<p>Fundamentally, the character comparison operations below are
numeric comparisons of the character’s code points.
</p>
<a class="index-entry-id" id="index-char_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if code point of <var class="var">x</var> is equal to the code point
of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_003c_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char&lt;?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003c_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the code point of <var class="var">x</var> is less than the code
point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_003c_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003c_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char&lt;=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003c_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the code point of <var class="var">x</var> is less than or equal
to the code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_003e_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char&gt;?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003e_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the code point of <var class="var">x</var> is greater than the
code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_003e_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_003e_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char&gt;=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_003e_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the code point of <var class="var">x</var> is greater than or
equal to the code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-case-folding"></a>

<p>Case-insensitive character comparisons use <em class="emph">Unicode case
folding</em>.  In case folding comparisons, if a character is lowercase
and has an uppercase form that can be expressed as a single character,
it is converted to uppercase before comparison.  All other characters
undergo no conversion before the comparison occurs.  This includes the
German sharp S (Eszett) which is not uppercased before conversion
because its uppercase form has two characters.  Unicode case folding
is language independent: it uses rules that are generally true, but,
it cannot cover all cases for all languages.
</p>
<a class="index-entry-id" id="index-char_002dci_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dci_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ci=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dci_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the case-folded code point of <var class="var">x</var> is the same
as the case-folded code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dci_003c_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dci_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ci&lt;?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dci_003c_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the case-folded code point of <var class="var">x</var> is less
than the case-folded code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dci_003c_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dci_003c_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ci&lt;=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dci_003c_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the case-folded code point of <var class="var">x</var> is less
than or equal to the case-folded code point of <var class="var">y</var>, else
<code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dci_003e_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dci_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ci&gt;?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dci_003e_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the case-folded code point of <var class="var">x</var> is greater
than the case-folded code point of <var class="var">y</var>, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dci_003e_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dci_003e_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ci&gt;=?</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dci_003e_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the case-folded code point of <var class="var">x</var> is greater
than or equal to the case-folded code point of <var class="var">y</var>, else
<code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dalphabetic_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dalphabetic_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-alphabetic?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dalphabetic_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005falphabetic_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_alphabetic_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005falphabetic_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is alphabetic, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dnumeric_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dnumeric_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-numeric?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dnumeric_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fnumeric_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_numeric_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fnumeric_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is numeric, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dwhitespace_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dwhitespace_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-whitespace?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dwhitespace_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fwhitespace_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_whitespace_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fwhitespace_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is whitespace, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dupper_002dcase_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dupper_002dcase_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-upper-case?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dupper_002dcase_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fupper_005fcase_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_upper_case_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fupper_005fcase_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is uppercase, else <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dlower_002dcase_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlower_002dcase_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-lower-case?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlower_002dcase_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flower_005fcase_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_lower_case_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flower_005fcase_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is lowercase, else <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dis_002dboth_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-is-both?</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dis_002dboth_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fis_005fboth_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_is_both_p</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fis_005fboth_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">chr</var> is either uppercase or lowercase, else
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dgeneral_002dcategory"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-general-category</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dgeneral_002dcategory"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fgeneral_005fcategory"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_general_category</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fgeneral_005fcategory"> ¶</a></span></dt>
<dd><p>Return a symbol giving the two-letter name of the Unicode general 
category assigned to <var class="var">chr</var> or <code class="code">#f</code> if no named category is 
assigned.  The following table provides a list of category names along
with their meanings.
</p>
<table class="multitable">
<tbody><tr><td width="10%">Lu</td><td width="40%">Uppercase letter</td><td width="10%">Pf</td><td width="40%">Final quote punctuation</td></tr>
<tr><td width="10%">Ll</td><td width="40%">Lowercase letter</td><td width="10%">Po</td><td width="40%">Other punctuation</td></tr>
<tr><td width="10%">Lt</td><td width="40%">Titlecase letter</td><td width="10%">Sm</td><td width="40%">Math symbol</td></tr>
<tr><td width="10%">Lm</td><td width="40%">Modifier letter</td><td width="10%">Sc</td><td width="40%">Currency symbol</td></tr>
<tr><td width="10%">Lo</td><td width="40%">Other letter</td><td width="10%">Sk</td><td width="40%">Modifier symbol</td></tr>
<tr><td width="10%">Mn</td><td width="40%">Non-spacing mark</td><td width="10%">So</td><td width="40%">Other symbol</td></tr>
<tr><td width="10%">Mc</td><td width="40%">Combining spacing mark</td><td width="10%">Zs</td><td width="40%">Space separator</td></tr>
<tr><td width="10%">Me</td><td width="40%">Enclosing mark</td><td width="10%">Zl</td><td width="40%">Line separator</td></tr>
<tr><td width="10%">Nd</td><td width="40%">Decimal digit number</td><td width="10%">Zp</td><td width="40%">Paragraph separator</td></tr>
<tr><td width="10%">Nl</td><td width="40%">Letter number</td><td width="10%">Cc</td><td width="40%">Control</td></tr>
<tr><td width="10%">No</td><td width="40%">Other number</td><td width="10%">Cf</td><td width="40%">Format</td></tr>
<tr><td width="10%">Pc</td><td width="40%">Connector punctuation</td><td width="10%">Cs</td><td width="40%">Surrogate</td></tr>
<tr><td width="10%">Pd</td><td width="40%">Dash punctuation</td><td width="10%">Co</td><td width="40%">Private use</td></tr>
<tr><td width="10%">Ps</td><td width="40%">Open punctuation</td><td width="10%">Cn</td><td width="40%">Unassigned</td></tr>
<tr><td width="10%">Pe</td><td width="40%">Close punctuation</td><td width="10%"></td><td width="40%"></td></tr>
<tr><td width="10%">Pi</td><td width="40%">Initial quote punctuation</td><td width="10%"></td><td width="40%"></td></tr>
</tbody>
</table>
</dd></dl>

<a class="index-entry-id" id="index-char_002d_003einteger-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002d_003einteger"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-&gt;integer</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002d_003einteger"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fto_005finteger"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_to_integer</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fto_005finteger"> ¶</a></span></dt>
<dd><p>Return the code point of <var class="var">chr</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-integer_002d_003echar-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-integer_002d_003echar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">integer-&gt;char</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-integer_002d_003echar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finteger_005fto_005fchar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_integer_to_char</strong> <var class="def-var-arguments">(n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finteger_005fto_005fchar"> ¶</a></span></dt>
<dd><p>Return the character that has code point <var class="var">n</var>.  The integer <var class="var">n</var>
must be a valid code point.  Valid code points are in the ranges 0 to
<code class="code">#xD7FF</code> inclusive or <code class="code">#xE000</code> to <code class="code">#x10FFFF</code> inclusive.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dupcase-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dupcase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-upcase</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dupcase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fupcase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_upcase</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fupcase"> ¶</a></span></dt>
<dd><p>Return the uppercase character version of <var class="var">chr</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002ddowncase-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002ddowncase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-downcase</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002ddowncase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fdowncase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_downcase</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fdowncase"> ¶</a></span></dt>
<dd><p>Return the lowercase character version of <var class="var">chr</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-char_002dtitlecase-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dtitlecase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-titlecase</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dtitlecase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005ftitlecase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_titlecase</strong> <var class="def-var-arguments">(chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005ftitlecase"> ¶</a></span></dt>
<dd><p>Return the titlecase character version of <var class="var">chr</var> if one exists;
otherwise return the uppercase version.  
</p>
<p>For most characters these will be the same, but the Unicode Standard 
includes certain digraph compatibility characters, such as <code class="code">U+01F3</code>
“dz”, for which the uppercase and titlecase characters are different 
(<code class="code">U+01F1</code> “DZ” and <code class="code">U+01F2</code> “Dz” in this case, 
respectively).
</p></dd></dl>

<a class="index-entry-id" id="index-scm_005ft_005fwchar"></a>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fupcase"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_wchar</code> <strong class="def-name">scm_c_upcase</strong> <code class="def-code-arguments">(scm_t_wchar <var class="var">c</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fupcase"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fdowncase"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_wchar</code> <strong class="def-name">scm_c_downcase</strong> <code class="def-code-arguments">(scm_t_wchar <var class="var">c</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fdowncase"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005ftitlecase"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_wchar</code> <strong class="def-name">scm_c_titlecase</strong> <code class="def-code-arguments">(scm_t_wchar <var class="var">c</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005ftitlecase"> ¶</a></span></dt>
<dd>
<p>These C functions take an integer representation of a Unicode
codepoint and return the codepoint corresponding to its uppercase,
lowercase, and titlecase forms respectively.  The type
<code class="code">scm_t_wchar</code> is a signed, 32-bit integer.
</p></dd></dl>

<p>Characters also have “formal names”, which are defined by Unicode.
These names can be accessed in Guile from the <code class="code">(ice-9 unicode)</code>
module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 unicode))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002d_003eformal_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-&gt;formal-name</strong> <var class="def-var-arguments">chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002d_003eformal_002dname"> ¶</a></span></dt>
<dd><p>Return the formal all-upper-case Unicode name of <var class="var">ch</var>,
as a string, or <code class="code">#f</code> if the character has no name.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-formal_002dname_002d_003echar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">formal-name-&gt;char</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-formal_002dname_002d_003echar"> ¶</a></span></dt>
<dd><p>Return the character whose formal all-upper-case Unicode name is
<var class="var">name</var>, or <code class="code">#f</code> if no such character is known.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Character-Sets">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="n" rel="next">Strings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Characters" accesskey="p" rel="prev">Characters</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Character-Sets-1">6.6.4 Character Sets</h4>

<p>The features described in this section correspond directly to SRFI-14.
</p>
<p>The data type <em class="dfn">charset</em> implements sets of characters
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Characters">Characters</a>).  Because the internal representation of
character sets is not visible to the user, a lot of procedures for
handling them are provided.
</p>
<p>Character sets can be created, extended, tested for the membership of a
characters and be compared to other character sets.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Set-Predicates_002fComparison" accesskey="1">Character Set Predicates/Comparison</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Iterating-Over-Character-Sets" accesskey="2">Iterating Over Character Sets</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Character-Sets" accesskey="3">Creating Character Sets</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Querying-Character-Sets" accesskey="4">Querying Character Sets</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Character_002dSet-Algebra" accesskey="5">Character-Set Algebra</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Character-Sets" accesskey="6">Standard Character Sets</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Character-Set-Predicates_002fComparison">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Iterating-Over-Character-Sets" accesskey="n" rel="next">Iterating Over Character Sets</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Character-Set-Predicates_002fComparison-1">6.6.4.1 Character Set Predicates/Comparison</h4>

<p>Use these procedures for testing whether an object is a character set,
or whether several character sets are equal or subsets of each other.
<code class="code">char-set-hash</code> can be used for calculating a hash value, maybe for
usage in fast lookup procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a character set, <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set=</strong> <var class="def-var-arguments">char_set …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005feq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_eq</strong> <var class="def-var-arguments">(char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005feq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if all given character sets are equal.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_003c_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set&lt;=</strong> <var class="def-var-arguments">char_set …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003c_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fleq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_leq</strong> <var class="def-var-arguments">(char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fleq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if every character set <var class="var">char_set</var>i is a subset
of character set <var class="var">char_set</var>i+1.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dhash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-hash</strong> <var class="def-var-arguments">cs [bound]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dhash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fhash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_hash</strong> <var class="def-var-arguments">(cs, bound)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fhash"> ¶</a></span></dt>
<dd><p>Compute a hash value for the character set <var class="var">cs</var>.  If
<var class="var">bound</var> is given and non-zero, it restricts the
returned value to the range 0 … <var class="var">bound</var> - 1.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Iterating-Over-Character-Sets">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Character-Sets" accesskey="n" rel="next">Creating Character Sets</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Set-Predicates_002fComparison" accesskey="p" rel="prev">Character Set Predicates/Comparison</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Iterating-Over-Character-Sets-1">6.6.4.2 Iterating Over Character Sets</h4>

<p>Character set cursors are a means for iterating over the members of a
character sets.  After creating a character set cursor with
<code class="code">char-set-cursor</code>, a cursor can be dereferenced with
<code class="code">char-set-ref</code>, advanced to the next member with
<code class="code">char-set-cursor-next</code>.  Whether a cursor has passed past the last
element of the set can be checked with <code class="code">end-of-char-set?</code>.
</p>
<p>Additionally, mapping and (un-)folding procedures for character sets are
provided.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcursor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-cursor</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcursor"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcursor"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_cursor</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcursor"> ¶</a></span></dt>
<dd><p>Return a cursor into the character set <var class="var">cs</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-ref</strong> <var class="def-var-arguments">cs cursor</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_ref</strong> <var class="def-var-arguments">(cs, cursor)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fref"> ¶</a></span></dt>
<dd><p>Return the character at the current cursor position
<var class="var">cursor</var> in the character set <var class="var">cs</var>.  It is an error to
pass a cursor for which <code class="code">end-of-char-set?</code> returns true.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcursor_002dnext"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-cursor-next</strong> <var class="def-var-arguments">cs cursor</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcursor_002dnext"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcursor_005fnext"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_cursor_next</strong> <var class="def-var-arguments">(cs, cursor)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcursor_005fnext"> ¶</a></span></dt>
<dd><p>Advance the character set cursor <var class="var">cursor</var> to the next
character in the character set <var class="var">cs</var>.  It is an error if the
cursor given satisfies <code class="code">end-of-char-set?</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-end_002dof_002dchar_002dset_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">end-of-char-set?</strong> <var class="def-var-arguments">cursor</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-end_002dof_002dchar_002dset_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fend_005fof_005fchar_005fset_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_end_of_char_set_p</strong> <var class="def-var-arguments">(cursor)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fend_005fof_005fchar_005fset_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">cursor</var> has reached the end of a
character set, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-fold</strong> <var class="def-var-arguments">kons knil cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005ffold"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_fold</strong> <var class="def-var-arguments">(kons, knil, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ffold"> ¶</a></span></dt>
<dd><p>Fold the procedure <var class="var">kons</var> over the character set <var class="var">cs</var>,
initializing it with <var class="var">knil</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dunfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-unfold</strong> <var class="def-var-arguments">p f g seed [base_cs]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dunfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005funfold"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_unfold</strong> <var class="def-var-arguments">(p, f, g, seed, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005funfold"> ¶</a></span></dt>
<dd><p>This is a fundamental constructor for character sets.
</p><ul class="itemize mark-bullet">
<li><var class="var">g</var> is used to generate a series of “seed” values
from the initial seed: <var class="var">seed</var>, (<var class="var">g</var> <var class="var">seed</var>),
(<var class="var">g</var>^2 <var class="var">seed</var>), (<var class="var">g</var>^3 <var class="var">seed</var>), …
</li><li><var class="var">p</var> tells us when to stop – when it returns true
when applied to one of the seed values.
</li><li><var class="var">f</var> maps each seed value to a character. These
characters are added to the base character set <var class="var">base_cs</var> to
form the result; <var class="var">base_cs</var> defaults to the empty set.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dunfold_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-unfold!</strong> <var class="def-var-arguments">p f g seed base_cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dunfold_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005funfold_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_unfold_x</strong> <var class="def-var-arguments">(p, f, g, seed, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005funfold_005fx"> ¶</a></span></dt>
<dd><p>This is a fundamental constructor for character sets.
</p><ul class="itemize mark-bullet">
<li><var class="var">g</var> is used to generate a series of “seed” values
from the initial seed: <var class="var">seed</var>, (<var class="var">g</var> <var class="var">seed</var>),
(<var class="var">g</var>^2 <var class="var">seed</var>), (<var class="var">g</var>^3 <var class="var">seed</var>), …
</li><li><var class="var">p</var> tells us when to stop – when it returns true
when applied to one of the seed values.
</li><li><var class="var">f</var> maps each seed value to a character. These
characters are added to the base character set <var class="var">base_cs</var> to
form the result; <var class="var">base_cs</var> defaults to the empty set.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-for-each</strong> <var class="def-var-arguments">proc cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_for_each</strong> <var class="def-var-arguments">(proc, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ffor_005feach"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to every character in the character set
<var class="var">cs</var>.  The return value is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-map</strong> <var class="def-var-arguments">proc cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dmap"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fmap"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_map</strong> <var class="def-var-arguments">(proc, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fmap"> ¶</a></span></dt>
<dd><p>Map the procedure <var class="var">proc</var> over every character in <var class="var">cs</var>.
<var class="var">proc</var> must be a character -&gt; character procedure.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Creating-Character-Sets">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Querying-Character-Sets" accesskey="n" rel="next">Querying Character Sets</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Iterating-Over-Character-Sets" accesskey="p" rel="prev">Iterating Over Character Sets</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Creating-Character-Sets-1">6.6.4.3 Creating Character Sets</h4>

<p>New character sets are produced with these procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-copy</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_copy</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcopy"> ¶</a></span></dt>
<dd><p>Return a newly allocated character set containing all
characters in <var class="var">cs</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set</strong> <var class="def-var-arguments">chr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set</strong> <var class="def-var-arguments">(chrs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset"> ¶</a></span></dt>
<dd><p>Return a character set containing all given characters.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003echar_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;char-set</strong> <var class="def-var-arguments">list [base_cs]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003echar_002dset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fchar_005fset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_char_set</strong> <var class="def-var-arguments">(list, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fchar_005fset"> ¶</a></span></dt>
<dd><p>Convert the character list <var class="var">list</var> to a character set.  If
the character set <var class="var">base_cs</var> is given, the character in this
set are also included in the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003echar_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;char-set!</strong> <var class="def-var-arguments">list base_cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003echar_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fchar_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_char_set_x</strong> <var class="def-var-arguments">(list, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fchar_005fset_005fx"> ¶</a></span></dt>
<dd><p>Convert the character list <var class="var">list</var> to a character set.  The
characters are added to <var class="var">base_cs</var> and <var class="var">base_cs</var> is
returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003echar_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;char-set</strong> <var class="def-var-arguments">str [base_cs]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003echar_002dset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005fchar_005fset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_char_set</strong> <var class="def-var-arguments">(str, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005fchar_005fset"> ¶</a></span></dt>
<dd><p>Convert the string <var class="var">str</var> to a character set.  If the
character set <var class="var">base_cs</var> is given, the characters in this
set are also included in the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003echar_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;char-set!</strong> <var class="def-var-arguments">str base_cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003echar_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005fchar_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_char_set_x</strong> <var class="def-var-arguments">(str, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005fchar_005fset_005fx"> ¶</a></span></dt>
<dd><p>Convert the string <var class="var">str</var> to a character set.  The
characters from the string are added to <var class="var">base_cs</var>, and
<var class="var">base_cs</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dfilter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-filter</strong> <var class="def-var-arguments">pred cs [base_cs]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dfilter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005ffilter"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_filter</strong> <var class="def-var-arguments">(pred, cs, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ffilter"> ¶</a></span></dt>
<dd><p>Return a character set containing every character from <var class="var">cs</var>
so that it satisfies <var class="var">pred</var>.  If provided, the characters
from <var class="var">base_cs</var> are added to the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dfilter_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-filter!</strong> <var class="def-var-arguments">pred cs base_cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dfilter_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005ffilter_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_filter_x</strong> <var class="def-var-arguments">(pred, cs, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ffilter_005fx"> ¶</a></span></dt>
<dd><p>Return a character set containing every character from <var class="var">cs</var>
so that it satisfies <var class="var">pred</var>.  The characters are added to
<var class="var">base_cs</var> and <var class="var">base_cs</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ucs_002drange_002d_003echar_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ucs-range-&gt;char-set</strong> <var class="def-var-arguments">lower upper [error [base_cs]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ucs_002drange_002d_003echar_002dset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fucs_005frange_005fto_005fchar_005fset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ucs_range_to_char_set</strong> <var class="def-var-arguments">(lower, upper, error, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fucs_005frange_005fto_005fchar_005fset"> ¶</a></span></dt>
<dd><p>Return a character set containing all characters whose
character codes lie in the half-open range
[<var class="var">lower</var>,<var class="var">upper</var>).
</p>
<p>If <var class="var">error</var> is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If <var class="var">error</var> is <code class="code">#f</code>,
these characters are silently left out of the resulting
character set.
</p>
<p>The characters in <var class="var">base_cs</var> are added to the result, if
given.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ucs_002drange_002d_003echar_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ucs-range-&gt;char-set!</strong> <var class="def-var-arguments">lower upper error base_cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ucs_002drange_002d_003echar_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fucs_005frange_005fto_005fchar_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ucs_range_to_char_set_x</strong> <var class="def-var-arguments">(lower, upper, error, base_cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fucs_005frange_005fto_005fchar_005fset_005fx"> ¶</a></span></dt>
<dd><p>Return a character set containing all characters whose
character codes lie in the half-open range
[<var class="var">lower</var>,<var class="var">upper</var>).
</p>
<p>If <var class="var">error</var> is a true value, an error is signalled if the
specified range contains characters which are not contained in
the implemented character range.  If <var class="var">error</var> is <code class="code">#f</code>,
these characters are silently left out of the resulting
character set.
</p>
<p>The characters are added to <var class="var">base_cs</var> and <var class="var">base_cs</var> is
returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_002d_003echar_002dset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">-&gt;char-set</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002d_003echar_002dset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fto_005fchar_005fset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_to_char_set</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fchar_005fset"> ¶</a></span></dt>
<dd><p>Coerces x into a char-set. <var class="var">x</var> may be a string, character or
char-set. A string is converted to the set of its constituent
characters; a character is converted to a singleton set; a char-set is
returned as-is.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Querying-Character-Sets">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character_002dSet-Algebra" accesskey="n" rel="next">Character-Set Algebra</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Character-Sets" accesskey="p" rel="prev">Creating Character Sets</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Querying-Character-Sets-1">6.6.4.4 Querying Character Sets</h4>

<p>Access the elements and other information of a character set with these
procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_0025char_002dset_002ddump"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%char-set-dump</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025char_002dset_002ddump"> ¶</a></span></dt>
<dd><p>Returns an association list containing debugging information
for <var class="var">cs</var>. The association list has the following entries.
</p><dl class="table">
<dt><code class="code">char-set</code></dt>
<dd><p>The char-set itself
</p></dd>
<dt><code class="code">len</code></dt>
<dd><p>The number of groups of contiguous code points the char-set
contains
</p></dd>
<dt><code class="code">ranges</code></dt>
<dd><p>A list of lists where each sublist is a range of code points
and their associated characters
</p></dd>
</dl>
<p>The return value of this function cannot be relied upon to be
consistent between versions of Guile and should not be used in code.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dsize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-size</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dsize"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fsize"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_size</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fsize"> ¶</a></span></dt>
<dd><p>Return the number of elements in character set <var class="var">cs</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-count</strong> <var class="def-var-arguments">pred cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_count</strong> <var class="def-var-arguments">(pred, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcount"> ¶</a></span></dt>
<dd><p>Return the number of the elements int the character set
<var class="var">cs</var> which satisfy the predicate <var class="var">pred</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-&gt;list</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_to_list</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fto_005flist"> ¶</a></span></dt>
<dd><p>Return a list containing the elements of the character set
<var class="var">cs</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-&gt;string</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_to_string</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return a string containing the elements of the character set
<var class="var">cs</var>.  The order in which the characters are placed in the
string is not defined.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcontains_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-contains?</strong> <var class="def-var-arguments">cs ch</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcontains_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcontains_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_contains_p</strong> <var class="def-var-arguments">(cs, ch)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcontains_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the character <var class="var">ch</var> is contained in the
character set <var class="var">cs</var>, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002devery"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-every</strong> <var class="def-var-arguments">pred cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002devery"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fevery"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_every</strong> <var class="def-var-arguments">(pred, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fevery"> ¶</a></span></dt>
<dd><p>Return a true value if every character in the character set
<var class="var">cs</var> satisfies the predicate <var class="var">pred</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dany"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-any</strong> <var class="def-var-arguments">pred cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dany"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fany"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_any</strong> <var class="def-var-arguments">(pred, cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fany"> ¶</a></span></dt>
<dd><p>Return a true value if any character in the character set
<var class="var">cs</var> satisfies the predicate <var class="var">pred</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Character_002dSet-Algebra">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Character-Sets" accesskey="n" rel="next">Standard Character Sets</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Querying-Character-Sets" accesskey="p" rel="prev">Querying Character Sets</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Character_002dSet-Algebra-1">6.6.4.5 Character-Set Algebra</h4>

<p>Character sets can be manipulated with the common set algebra operation,
such as union, complement, intersection etc.  All of these procedures
provide side-effecting variants, which modify their character set
argument(s).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dadjoin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-adjoin</strong> <var class="def-var-arguments">cs chr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dadjoin"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fadjoin"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_adjoin</strong> <var class="def-var-arguments">(cs, chrs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fadjoin"> ¶</a></span></dt>
<dd><p>Add all character arguments to the first argument, which must
be a character set.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-delete</strong> <var class="def-var-arguments">cs chr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddelete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdelete"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_delete</strong> <var class="def-var-arguments">(cs, chrs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdelete"> ¶</a></span></dt>
<dd><p>Delete all character arguments from the first argument, which
must be a character set.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dadjoin_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-adjoin!</strong> <var class="def-var-arguments">cs chr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dadjoin_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fadjoin_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_adjoin_x</strong> <var class="def-var-arguments">(cs, chrs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fadjoin_005fx"> ¶</a></span></dt>
<dd><p>Add all character arguments to the first argument, which must
be a character set.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddelete_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-delete!</strong> <var class="def-var-arguments">cs chr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddelete_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdelete_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_delete_x</strong> <var class="def-var-arguments">(cs, chrs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdelete_005fx"> ¶</a></span></dt>
<dd><p>Delete all character arguments from the first argument, which
must be a character set.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcomplement"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-complement</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcomplement"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcomplement"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_complement</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcomplement"> ¶</a></span></dt>
<dd><p>Return the complement of the character set <var class="var">cs</var>.
</p></dd></dl>

<p>Note that the complement of a character set is likely to contain many
reserved code points (code points that are not associated with
characters).  It may be helpful to modify the output of
<code class="code">char-set-complement</code> by computing its intersection with the set
of designated code points, <code class="code">char-set:designated</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dunion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-union</strong> <var class="def-var-arguments">cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dunion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005funion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_union</strong> <var class="def-var-arguments">(char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005funion"> ¶</a></span></dt>
<dd><p>Return the union of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dintersection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-intersection</strong> <var class="def-var-arguments">cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dintersection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fintersection"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_intersection</strong> <var class="def-var-arguments">(char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fintersection"> ¶</a></span></dt>
<dd><p>Return the intersection of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddifference"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-difference</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddifference"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdifference"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_difference</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdifference"> ¶</a></span></dt>
<dd><p>Return the difference of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dxor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-xor</strong> <var class="def-var-arguments">cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dxor"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fxor"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_xor</strong> <var class="def-var-arguments">(char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fxor"> ¶</a></span></dt>
<dd><p>Return the exclusive-or of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddiff_002bintersection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-diff+intersection</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddiff_002bintersection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdiff_005fplus_005fintersection"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_diff_plus_intersection</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdiff_005fplus_005fintersection"> ¶</a></span></dt>
<dd><p>Return the difference and the intersection of all argument
character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dcomplement_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-complement!</strong> <var class="def-var-arguments">cs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dcomplement_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fcomplement_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_complement_x</strong> <var class="def-var-arguments">(cs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fcomplement_005fx"> ¶</a></span></dt>
<dd><p>Return the complement of the character set <var class="var">cs</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dunion_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-union!</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dunion_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005funion_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_union_x</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005funion_005fx"> ¶</a></span></dt>
<dd><p>Return the union of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dintersection_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-intersection!</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dintersection_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fintersection_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_intersection_x</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fintersection_005fx"> ¶</a></span></dt>
<dd><p>Return the intersection of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddifference_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-difference!</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddifference_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdifference_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_difference_x</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdifference_005fx"> ¶</a></span></dt>
<dd><p>Return the difference of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002dxor_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-xor!</strong> <var class="def-var-arguments">cs1 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dxor_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fxor_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_xor_x</strong> <var class="def-var-arguments">(cs1, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fxor_005fx"> ¶</a></span></dt>
<dd><p>Return the exclusive-or of all argument character sets.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dset_002ddiff_002bintersection_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-set-diff+intersection!</strong> <var class="def-var-arguments">cs1 cs2 cs …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002ddiff_002bintersection_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005fset_005fdiff_005fplus_005fintersection_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_set_diff_plus_intersection_x</strong> <var class="def-var-arguments">(cs1, cs2, char_sets)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdiff_005fplus_005fintersection_005fx"> ¶</a></span></dt>
<dd><p>Return the difference and the intersection of all argument
character sets.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Standard-Character-Sets">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character_002dSet-Algebra" accesskey="p" rel="prev">Character-Set Algebra</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="u" rel="up">Character Sets</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Standard-Character-Sets-1">6.6.4.6 Standard Character Sets</h4>

<p>In order to make the use of the character set data type and procedures
useful, several predefined character set variables exist.
</p>
<a class="index-entry-id" id="index-codeset"></a>
<a class="index-entry-id" id="index-charset"></a>
<a class="index-entry-id" id="index-locale"></a>

<p>These character sets are locale independent and are not recomputed
upon a <code class="code">setlocale</code> call.  They contain characters from the whole
range of Unicode code points. For instance, <code class="code">char-set:letter</code>
contains about 100,000 characters.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003alower_002dcase"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:lower-case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003alower_002dcase"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005flower_005fcase"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_lower_case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005flower_005fcase"> ¶</a></span></dt>
<dd><p>All lower-case characters.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aupper_002dcase"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:upper-case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aupper_002dcase"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fupper_005fcase"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_upper_case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fupper_005fcase"> ¶</a></span></dt>
<dd><p>All upper-case characters.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003atitle_002dcase"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:title-case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003atitle_002dcase"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005ftitle_005fcase"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_title_case</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ftitle_005fcase"> ¶</a></span></dt>
<dd><p>All single characters that function as if they were an upper-case
letter followed by a lower-case letter.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aletter"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:letter</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aletter"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fletter"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_letter</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fletter"> ¶</a></span></dt>
<dd><p>All letters.  This includes <code class="code">char-set:lower-case</code>,
<code class="code">char-set:upper-case</code>, <code class="code">char-set:title-case</code>, and many
letters that have no case at all.  For example, Chinese and Japanese
characters typically have no concept of case.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003adigit"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003adigit"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fdigit"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdigit"> ¶</a></span></dt>
<dd><p>All digits.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aletter_002bdigit"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:letter+digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aletter_002bdigit"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fletter_005fand_005fdigit"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_letter_and_digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fletter_005fand_005fdigit"> ¶</a></span></dt>
<dd><p>The union of <code class="code">char-set:letter</code> and <code class="code">char-set:digit</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003agraphic"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:graphic</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003agraphic"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fgraphic"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_graphic</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fgraphic"> ¶</a></span></dt>
<dd><p>All characters which would put ink on the paper.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aprinting"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:printing</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aprinting"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fprinting"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_printing</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fprinting"> ¶</a></span></dt>
<dd><p>The union of <code class="code">char-set:graphic</code> and <code class="code">char-set:whitespace</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003awhitespace"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:whitespace</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003awhitespace"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fwhitespace"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_whitespace</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fwhitespace"> ¶</a></span></dt>
<dd><p>All whitespace characters.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003ablank"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:blank</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003ablank"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fblank"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_blank</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fblank"> ¶</a></span></dt>
<dd><p>All horizontal whitespace characters, which notably includes
<code class="code">#\space</code> and <code class="code">#\tab</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aiso_002dcontrol"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:iso-control</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aiso_002dcontrol"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fiso_005fcontrol"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_iso_control</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fiso_005fcontrol"> ¶</a></span></dt>
<dd><p>The ISO control characters are the C0 control characters (U+0000 to
U+001F), delete (U+007F), and the C1 control characters (U+0080 to
U+009F).
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003apunctuation"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:punctuation</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003apunctuation"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fpunctuation"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_punctuation</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fpunctuation"> ¶</a></span></dt>
<dd><p>All punctuation characters, such as the characters
<code class="code">!"#%&amp;'()*,-./:;?@[\\]_{}</code>
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003asymbol"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:symbol</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003asymbol"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fsymbol"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_symbol</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fsymbol"> ¶</a></span></dt>
<dd><p>All symbol characters, such as the characters <code class="code">$+&lt;=&gt;^`|~</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003ahex_002ddigit"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:hex-digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003ahex_002ddigit"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fhex_005fdigit"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_hex_digit</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fhex_005fdigit"> ¶</a></span></dt>
<dd><p>The hexadecimal digits <code class="code">0123456789abcdefABCDEF</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aascii"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:ascii</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aascii"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fascii"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_ascii</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fascii"> ¶</a></span></dt>
<dd><p>All ASCII characters.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003aempty"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:empty</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003aempty"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fempty"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_empty</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fempty"> ¶</a></span></dt>
<dd><p>The empty character set.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003adesignated"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:designated</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003adesignated"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005fdesignated"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_designated</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005fdesignated"> ¶</a></span></dt>
<dd><p>This character set contains all designated code points.  This includes
all the code points to which Unicode has assigned a character or other
meaning.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-char_002dset_003afull"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set:full</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_003afull"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fchar_005fset_005ffull"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_char_set_full</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005fset_005ffull"> ¶</a></span></dt>
<dd><p>This character set contains all possible code points.  This includes
both designated and reserved code points.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Strings">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="n" rel="next">Symbols</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets" accesskey="p" rel="prev">Character Sets</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Strings-1">6.6.5 Strings</h4>
<a class="index-entry-id" id="index-Strings"></a>

<p>Strings are fixed-length sequences of characters.  They can be created
by calling constructor procedures, but they can also literally get
entered at the <abbr class="acronym">REPL</abbr> or in Scheme source files.
</p>

<p>Strings always carry the information about how many characters they are
composed of with them, so there is no special end-of-string character,
like in C.  That means that Scheme strings can contain any character,
even the ‘<samp class="samp">#\nul</samp>’ character ‘<samp class="samp">\0</samp>’.
</p>
<p>To use strings efficiently, you need to know a bit about how Guile
implements them.  In Guile, a string consists of two parts, a head and
the actual memory where the characters are stored.  When a string (or
a substring of it) is copied, only a new head gets created, the memory
is usually not copied.  The two heads start out pointing to the same
memory.
</p>
<p>When one of these two strings is modified, as with <code class="code">string-set!</code>,
their common memory does get copied so that each string has its own
memory and modifying one does not accidentally modify the other as well.
Thus, Guile’s strings are ‘copy on write’; the actual copying of their
memory is delayed until one string is written to.
</p>
<p>This implementation makes functions like <code class="code">substring</code> very
efficient in the common case that no modifications are done to the
involved strings.
</p>
<p>If you do know that your strings are getting modified right away, you
can use <code class="code">substring/copy</code> instead of <code class="code">substring</code>.  This
function performs the copy immediately at the time of creation.  This
is more efficient, especially in a multi-threaded program.  Also,
<code class="code">substring/copy</code> can avoid the problem that a short substring
holds on to the memory of a very large original string that could
otherwise be recycled.
</p>
<p>If you want to avoid the copy altogether, so that modifications of one
string show up in the other, you can use <code class="code">substring/shared</code>.  The
strings created by this procedure are called <em class="dfn">mutation sharing
substrings</em> since the substring and the original string share
modifications to each other.
</p>
<p>If you want to prevent modifications, use <code class="code">substring/read-only</code>.
</p>
<p>Guile provides all procedures of SRFI-13 and a few more.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Syntax" accesskey="1">String Read Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Predicates" accesskey="2">String Predicates</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Constructors" accesskey="3">String Constructors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List_002fString-Conversion" accesskey="4">List/String conversion</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Selection" accesskey="5">String Selection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Modification" accesskey="6">String Modification</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison" accesskey="7">String Comparison</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Searching" accesskey="8">String Searching</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Alphabetic-Case-Mapping" accesskey="9">Alphabetic Case Mapping</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Reversing-and-Appending-Strings">Reversing and Appending Strings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Mapping-Folding-and-Unfolding">Mapping, Folding, and Unfolding</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Miscellaneous-String-Operations">Miscellaneous String Operations</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes">Representing Strings as Bytes</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion-to_002ffrom-C">Conversion to/from C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Internals">String Internals</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="String-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Predicates" accesskey="n" rel="next">String Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Read-Syntax">6.6.5.1 String Read Syntax</h4>


<p>The read syntax for strings is an arbitrarily long sequence of
characters enclosed in double quotes (<code class="code">"</code>).
</p>
<p>Backslash is an escape character and can be used to insert the following
special characters.  <code class="code">\"</code> and <code class="code">\\</code> are R5RS standard,
<code class="code">\|</code> is R7RS standard, the next seven are R6RS standard —
notice they follow C syntax — and the remaining four are Guile
extensions.
</p>
<dl class="table">
<dt><code class="code">\\</code></dt>
<dd><p>Backslash character.
</p>
</dd>
<dt><code class="code">\"</code></dt>
<dd><p>Double quote character (an unescaped <code class="code">"</code> is otherwise the end
of the string).
</p>
</dd>
<dt><code class="code">\|</code></dt>
<dd><p>Vertical bar character.
</p>
</dd>
<dt><code class="code">\a</code></dt>
<dd><p>Bell character (ASCII 7).
</p>
</dd>
<dt><code class="code">\f</code></dt>
<dd><p>Formfeed character (ASCII 12).
</p>
</dd>
<dt><code class="code">\n</code></dt>
<dd><p>Newline character (ASCII 10).
</p>
</dd>
<dt><code class="code">\r</code></dt>
<dd><p>Carriage return character (ASCII 13).
</p>
</dd>
<dt><code class="code">\t</code></dt>
<dd><p>Tab character (ASCII 9).
</p>
</dd>
<dt><code class="code">\v</code></dt>
<dd><p>Vertical tab character (ASCII 11).
</p>
</dd>
<dt><code class="code">\b</code></dt>
<dd><p>Backspace character (ASCII 8).
</p>
</dd>
<dt><code class="code">\0</code></dt>
<dd><p>NUL character (ASCII 0).
</p>
</dd>
<dt><code class="code">\(</code></dt>
<dd><p>Open parenthesis.  This is intended for use at the beginning of lines in
multiline strings to avoid confusing Emacs lisp modes.
</p>
</dd>
<dt><code class="code">\</code> followed by newline (ASCII 10)</dt>
<dd><p>Nothing.  This way if <code class="code">\</code> is the last character in a line, the
string will continue with the first character from the next line,
without a line break.
</p>
<p>If the <code class="code">hungry-eol-escapes</code> reader option is enabled, which is not
the case by default, leading whitespace on the next line is discarded.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">"foo\
  bar"
⇒ "foo  bar"
(read-enable 'hungry-eol-escapes)
"foo\
  bar"
⇒ "foobar"
</pre></div>
</dd>
<dt><code class="code">\xHH</code></dt>
<dd><p>Character code given by two hexadecimal digits.  For example
<code class="code">\x7f</code> for an ASCII DEL (127).
</p>
</dd>
<dt><code class="code">\uHHHH</code></dt>
<dd><p>Character code given by four hexadecimal digits.  For example
<code class="code">\u0100</code> for a capital A with macron (U+0100).
</p>
</dd>
<dt><code class="code">\UHHHHHH</code></dt>
<dd><p>Character code given by six hexadecimal digits.  For example
<code class="code">\U010402</code>.
</p></dd>
</dl>

<p>The following are examples of string literals:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">"foo"
"bar plonk"
"Hello World"
"\"Hi\", he said."
</pre></div>

<p>The three escape sequences <code class="code">\xHH</code>, <code class="code">\uHHHH</code> and <code class="code">\UHHHHHH</code> were
chosen to not break compatibility with code written for previous versions of
Guile.  The R6RS specification suggests a different, incompatible syntax for hex
escapes: <code class="code">\xHHHH;</code> – a character code followed by one to eight hexadecimal
digits terminated with a semicolon.  If this escape format is desired instead,
it can be enabled with the reader option <code class="code">r6rs-hex-escapes</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(read-enable 'r6rs-hex-escapes)
</pre></div>

<p>For more on reader options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="String-Predicates">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Constructors" accesskey="n" rel="next">String Constructors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Syntax" accesskey="p" rel="prev">String Read Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Predicates-1">6.6.5.2 String Predicates</h4>

<p>The following procedures can be used to check whether a given string
fulfills some specified property.
</p>
<a class="index-entry-id" id="index-string_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a string, else <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_string</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fstring"> ¶</a></span></dt>
<dd><p>Returns <code class="code">1</code> if <var class="var">obj</var> is a string, <code class="code">0</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dnull_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-null?</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dnull_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fnull_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_null_p</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fnull_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">str</var>’s length is zero, and
<code class="code">#f</code> otherwise.
</p><div class="example lisp">
<pre class="lisp-preformatted">(string-null? "")  ⇒ #t
y                    ⇒ "foo"
(string-null? y)     ⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dany"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-any</strong> <var class="def-var-arguments">char_pred s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dany"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fany"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_any</strong> <var class="def-var-arguments">(char_pred, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fany"> ¶</a></span></dt>
<dd><p>Check if <var class="var">char_pred</var> is true for any character in string <var class="var">s</var>.
</p>
<p><var class="var">char_pred</var> can be a character to check for any equal to that, or
a character set (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets">Character Sets</a>) to check for any in that set,
or a predicate procedure to call.
</p>
<p>For a procedure, calls <code class="code">(<var class="var">char_pred</var> c)</code> are made
successively on the characters from <var class="var">start</var> to <var class="var">end</var>.  If
<var class="var">char_pred</var> returns true (ie. non-<code class="code">#f</code>), <code class="code">string-any</code>
stops and that return value is the return from <code class="code">string-any</code>.  The
call on the last character (ie. at <em class="math"><var class="var">end</var>-1</em>), if that
point is reached, is a tail call.
</p>
<p>If there are no characters in <var class="var">s</var> (ie. <var class="var">start</var> equals
<var class="var">end</var>) then the return is <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002devery"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-every</strong> <var class="def-var-arguments">char_pred s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002devery"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fevery"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_every</strong> <var class="def-var-arguments">(char_pred, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fevery"> ¶</a></span></dt>
<dd><p>Check if <var class="var">char_pred</var> is true for every character in string
<var class="var">s</var>.
</p>
<p><var class="var">char_pred</var> can be a character to check for every character equal
to that, or a character set (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets">Character Sets</a>) to check for
every character being in that set, or a predicate procedure to call.
</p>
<p>For a procedure, calls <code class="code">(<var class="var">char_pred</var> c)</code> are made
successively on the characters from <var class="var">start</var> to <var class="var">end</var>.  If
<var class="var">char_pred</var> returns <code class="code">#f</code>, <code class="code">string-every</code> stops and
returns <code class="code">#f</code>.  The call on the last character (ie. at
<em class="math"><var class="var">end</var>-1</em>), if that point is reached, is a tail call and the
return from that call is the return from <code class="code">string-every</code>.
</p>
<p>If there are no characters in <var class="var">s</var> (ie. <var class="var">start</var> equals
<var class="var">end</var>) then the return is <code class="code">#t</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="String-Constructors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List_002fString-Conversion" accesskey="n" rel="next">List/String conversion</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Predicates" accesskey="p" rel="prev">String Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Constructors-1">6.6.5.3 String Constructors</h4>

<p>The string constructor procedures create new string objects, possibly
initializing them with some specified character data.  See also
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#String-Selection">String Selection</a>, for ways to create strings from existing
strings.
</p>

<dl class="first-deffn">
<dt class="deffn" id="index-string"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string</strong> <var class="def-var-arguments">char…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-string-2"></a>
<p>Return a newly allocated string made from the given character
arguments.
</p>
<div class="example">
<pre class="example-preformatted">(string #\x #\y #\z) ⇒ "xyz"
(string)             ⇒ ""
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;string</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-list_002d_003estring-2"></a>
<p>Return a newly allocated string made from a list of characters.
</p>
<div class="example">
<pre class="example-preformatted">(list-&gt;string '(#\a #\b #\c)) ⇒ "abc"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-reverse_002dlist_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reverse-list-&gt;string</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reverse_002dlist_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freverse_005flist_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_reverse_list_to_string</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freverse_005flist_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return a newly allocated string made from a list of characters, in
reverse order.
</p>
<div class="example">
<pre class="example-preformatted">(reverse-list-&gt;string '(#\a #\B #\c)) ⇒ "cBa"
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-make_002dstring-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-string</strong> <var class="def-var-arguments">k [chr]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_string</strong> <var class="def-var-arguments">(k, chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fstring"> ¶</a></span></dt>
<dd><p>Return a newly allocated string of
length <var class="var">k</var>.  If <var class="var">chr</var> is given, then all elements of
the string are initialized to <var class="var">chr</var>, otherwise the contents
of the string are unspecified.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmake_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_string</strong> <code class="def-code-arguments">(size_t len, SCM chr)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fstring"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_make_string</code>, but expects the length as a
<code class="code">size_t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtabulate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-tabulate</strong> <var class="def-var-arguments">proc len</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtabulate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftabulate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_tabulate</strong> <var class="def-var-arguments">(proc, len)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftabulate"> ¶</a></span></dt>
<dd><p><var class="var">proc</var> is an integer-&gt;char procedure.  Construct a string
of size <var class="var">len</var> by applying <var class="var">proc</var> to each index to
produce the corresponding string element.  The order in which
<var class="var">proc</var> is applied to the indices is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002djoin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-join</strong> <var class="def-var-arguments">ls [delimiter [grammar]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002djoin"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fjoin"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_join</strong> <var class="def-var-arguments">(ls, delimiter, grammar)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fjoin"> ¶</a></span></dt>
<dd><p>Append the string in the string list <var class="var">ls</var>, using the string
<var class="var">delimiter</var> as a delimiter between the elements of <var class="var">ls</var>.
<var class="var">delimiter</var> defaults to ‘<samp class="samp">&nbsp;</samp>’<!-- /@w -->, that is, strings in <var class="var">ls</var>
are appended with the space character in between them.  <var class="var">grammar</var> is
a symbol which specifies how the delimiter is placed between the
strings, and defaults to the symbol <code class="code">infix</code>.
</p>
<dl class="table">
<dt><code class="code">infix</code></dt>
<dd><p>Insert the separator between list elements.  An empty string
will produce an empty list.
</p></dd>
<dt><code class="code">strict-infix</code></dt>
<dd><p>Like <code class="code">infix</code>, but will raise an error if given the empty
list.
</p></dd>
<dt><code class="code">suffix</code></dt>
<dd><p>Insert the separator after every list element.
</p></dd>
<dt><code class="code">prefix</code></dt>
<dd><p>Insert the separator before each list element.
</p></dd>
</dl>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="List_002fString-Conversion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Selection" accesskey="n" rel="next">String Selection</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Constructors" accesskey="p" rel="prev">String Constructors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List_002fString-conversion">6.6.5.4 List/String conversion</h4>

<p>When processing strings, it is often convenient to first convert them
into a list representation by using the procedure <code class="code">string-&gt;list</code>,
work with the resulting list, and then convert it back into a string.
These procedures are useful for similar tasks.
</p>
<a class="index-entry-id" id="index-string_002d_003elist-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;list</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_to_list</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_list</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005flist"> ¶</a></span></dt>
<dd><p>Convert the string <var class="var">str</var> into a list of characters.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dsplit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-split</strong> <var class="def-var-arguments">str char_pred</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dsplit"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fsplit"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_split</strong> <var class="def-var-arguments">(str, char_pred)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fsplit"> ¶</a></span></dt>
<dd><p>Split the string <var class="var">str</var> into a list of substrings delimited
by appearances of characters that
</p>
<ul class="itemize mark-bullet">
<li>equal <var class="var">char_pred</var>, if it is a character,

</li><li>satisfy the predicate <var class="var">char_pred</var>, if it is a procedure,

</li><li>are in the set <var class="var">char_pred</var>, if it is a character set.
</li></ul>

<p>Note that an empty substring between separator characters will result in
an empty string in the result list.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-split "root:x:0:0:root:/root:/bin/bash" #\:)
⇒
("root" "x" "0" "0" "root" "/root" "/bin/bash")

(string-split "::" #\:)
⇒
("" "" "")

(string-split "" #\:)
⇒
("")
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="String-Selection">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Modification" accesskey="n" rel="next">String Modification</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List_002fString-Conversion" accesskey="p" rel="prev">List/String conversion</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Selection-1">6.6.5.5 String Selection</h4>

<p>Portions of strings can be extracted by these procedures.
<code class="code">string-ref</code> delivers individual characters whereas
<code class="code">substring</code> can be used to extract substrings from longer strings.
</p>
<a class="index-entry-id" id="index-string_002dlength-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-length</strong> <var class="def-var-arguments">string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_length</strong> <var class="def-var-arguments">(string)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flength"> ¶</a></span></dt>
<dd><p>Return the number of characters in <var class="var">string</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fstring_005flength"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_string_length</strong> <code class="def-code-arguments">(SCM str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fstring_005flength"> ¶</a></span></dt>
<dd><p>Return the number of characters in <var class="var">str</var> as a <code class="code">size_t</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dref-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ref</strong> <var class="def-var-arguments">str k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ref</strong> <var class="def-var-arguments">(str, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fref"> ¶</a></span></dt>
<dd><p>Return character <var class="var">k</var> of <var class="var">str</var> using zero-origin
indexing. <var class="var">k</var> must be a valid index of <var class="var">str</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fstring_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_string_ref</strong> <code class="def-code-arguments">(SCM str, size_t k)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fstring_005fref"> ¶</a></span></dt>
<dd><p>Return character <var class="var">k</var> of <var class="var">str</var> using zero-origin
indexing. <var class="var">k</var> must be a valid index of <var class="var">str</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dcopy-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-copy</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_copy</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_copy</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcopy"> ¶</a></span></dt>
<dd><p>Return a copy of the given string <var class="var">str</var>.
</p>
<p>The returned string shares storage with <var class="var">str</var> initially, but it is
copied as soon as one of the two strings is modified.
</p></dd></dl>

<a class="index-entry-id" id="index-substring-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-substring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring</strong> <var class="def-var-arguments">str start [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring"> ¶</a></span></dt>
<dd><p>Return a new string formed from the characters
of <var class="var">str</var> beginning with index <var class="var">start</var> (inclusive) and
ending with index <var class="var">end</var> (exclusive).
<var class="var">str</var> must be a string, <var class="var">start</var> and <var class="var">end</var> must be
exact integers satisfying:
</p>
<p>0 &lt;= <var class="var">start</var> &lt;= <var class="var">end</var> &lt;= <code class="code">(string-length <var class="var">str</var>)</code>.
</p>
<p>The returned string shares storage with <var class="var">str</var> initially, but it is
copied as soon as one of the two strings is modified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-substring_002fshared"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring/shared</strong> <var class="def-var-arguments">str start [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring_002fshared"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fshared"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_shared</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fshared"> ¶</a></span></dt>
<dd><p>Like <code class="code">substring</code>, but the strings continue to share their storage
even if they are modified.  Thus, modifications to <var class="var">str</var> show up
in the new string, and vice versa.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-substring_002fcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring/copy</strong> <var class="def-var-arguments">str start [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring_002fcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fcopy-1"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_copy</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fcopy-1"> ¶</a></span></dt>
<dd><p>Like <code class="code">substring</code>, but the storage for the new string is copied
immediately.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-substring_002fread_002donly"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring/read-only</strong> <var class="def-var-arguments">str start [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring_002fread_002donly"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fread_005fonly"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_read_only</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fread_005fonly"> ¶</a></span></dt>
<dd><p>Like <code class="code">substring</code>, but the resulting string can not be modified.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fsubstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_substring</strong> <code class="def-code-arguments">(SCM str, size_t start, size_t end)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fsubstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fsubstring_005fshared"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_substring_shared</strong> <code class="def-code-arguments">(SCM str, size_t start, size_t end)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fsubstring_005fshared"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fsubstring_005fcopy"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_substring_copy</strong> <code class="def-code-arguments">(SCM str, size_t start, size_t end)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fsubstring_005fcopy"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fsubstring_005fread_005fonly"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_substring_read_only</strong> <code class="def-code-arguments">(SCM str, size_t start, size_t end)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fsubstring_005fread_005fonly"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_substring</code>, etc. but the bounds are given as a <code class="code">size_t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtake"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-take</strong> <var class="def-var-arguments">s n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtake"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftake"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_take</strong> <var class="def-var-arguments">(s, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftake"> ¶</a></span></dt>
<dd><p>Return the <var class="var">n</var> first characters of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002ddrop"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-drop</strong> <var class="def-var-arguments">s n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002ddrop"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fdrop"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_drop</strong> <var class="def-var-arguments">(s, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fdrop"> ¶</a></span></dt>
<dd><p>Return all but the first <var class="var">n</var> characters of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtake_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-take-right</strong> <var class="def-var-arguments">s n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtake_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftake_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_take_right</strong> <var class="def-var-arguments">(s, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftake_005fright"> ¶</a></span></dt>
<dd><p>Return the <var class="var">n</var> last characters of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002ddrop_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-drop-right</strong> <var class="def-var-arguments">s n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002ddrop_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fdrop_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_drop_right</strong> <var class="def-var-arguments">(s, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fdrop_005fright"> ¶</a></span></dt>
<dd><p>Return all but the last <var class="var">n</var> characters of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dpad"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-pad</strong> <var class="def-var-arguments">s len [chr [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dpad"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dpad_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-pad-right</strong> <var class="def-var-arguments">s len [chr [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dpad_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fpad"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_pad</strong> <var class="def-var-arguments">(s, len, chr, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fpad"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fpad_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_pad_right</strong> <var class="def-var-arguments">(s, len, chr, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fpad_005fright"> ¶</a></span></dt>
<dd><p>Take characters <var class="var">start</var> to <var class="var">end</var> from the string <var class="var">s</var> and
either pad with <var class="var">chr</var> or truncate them to give <var class="var">len</var>
characters.
</p>
<p><code class="code">string-pad</code> pads or truncates on the left, so for example
</p>
<div class="example">
<pre class="example-preformatted">(string-pad "x" 3)     ⇒ "  x"
(string-pad "abcde" 3) ⇒ "cde"
</pre></div>

<p><code class="code">string-pad-right</code> pads or truncates on the right, so for example
</p>
<div class="example">
<pre class="example-preformatted">(string-pad-right "x" 3)     ⇒ "x  "
(string-pad-right "abcde" 3) ⇒ "abc"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtrim"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-trim</strong> <var class="def-var-arguments">s [char_pred [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtrim"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dtrim_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-trim-right</strong> <var class="def-var-arguments">s [char_pred [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtrim_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dtrim_002dboth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-trim-both</strong> <var class="def-var-arguments">s [char_pred [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtrim_002dboth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftrim"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_trim</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftrim"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftrim_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_trim_right</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftrim_005fright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftrim_005fboth"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_trim_both</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftrim_005fboth"> ¶</a></span></dt>
<dd><p>Trim occurrences of <var class="var">char_pred</var> from the ends of <var class="var">s</var>.
</p>
<p><code class="code">string-trim</code> trims <var class="var">char_pred</var> characters from the left
(start) of the string, <code class="code">string-trim-right</code> trims them from the
right (end) of the string, <code class="code">string-trim-both</code> trims from both
ends.
</p>
<p><var class="var">char_pred</var> can be a character, a character set, or a predicate
procedure to call on each character.  If <var class="var">char_pred</var> is not given
the default is whitespace as per <code class="code">char-set:whitespace</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Character-Sets">Standard Character Sets</a>).
</p>
<div class="example">
<pre class="example-preformatted">(string-trim " x ")              ⇒ "x "
(string-trim-right "banana" #\a) ⇒ "banan"
(string-trim-both ".,xy:;" char-set:punctuation)
                  ⇒ "xy"
(string-trim-both "xyzzy" (lambda (c)
                             (or (eqv? c #\x)
                                 (eqv? c #\y))))
                  ⇒ "zz"
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="String-Modification">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison" accesskey="n" rel="next">String Comparison</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Selection" accesskey="p" rel="prev">String Selection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Modification-1">6.6.5.6 String Modification</h4>

<p>These procedures are for modifying strings in-place.  This means that the
result of the operation is not a new string; instead, the original string’s
memory representation is modified.
</p>
<a class="index-entry-id" id="index-string_002dset_0021-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-set!</strong> <var class="def-var-arguments">str k chr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_set_x</strong> <var class="def-var-arguments">(str, k, chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">chr</var> in element <var class="var">k</var> of <var class="var">str</var> and return
an unspecified value. <var class="var">k</var> must be a valid index of
<var class="var">str</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fstring_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_string_set_x</strong> <code class="def-code-arguments">(SCM str, size_t k, SCM chr)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fstring_005fset_005fx"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_string_set_x</code>, but the index is given as a <code class="code">size_t</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dfill_0021-1"></a>
<a class="anchor" id="x_002dstring_002dfill_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-string_002dfill_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-fill!</strong> <var class="def-var-arguments">str chr [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfill_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005ffill_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_fill_x</strong> <var class="def-var-arguments">(str, chr, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005ffill_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffill_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_fill_x</strong> <var class="def-var-arguments">(str, chr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffill_005fx"> ¶</a></span></dt>
<dd><p>Stores <var class="var">chr</var> in every element of the given <var class="var">str</var> and
returns an unspecified value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-substring_002dfill_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring-fill!</strong> <var class="def-var-arguments">str start end fill</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring_002dfill_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005ffill_005fx-1"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_fill_x</strong> <var class="def-var-arguments">(str, start, end, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005ffill_005fx-1"> ¶</a></span></dt>
<dd><p>Change every character in <var class="var">str</var> between <var class="var">start</var> and
<var class="var">end</var> to <var class="var">fill</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define y (string-copy "abcdefg"))
(substring-fill! y 1 3 #\r)
y
⇒ "arrdefg"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-substring_002dmove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">substring-move!</strong> <var class="def-var-arguments">str1 start1 end1 str2 start2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-substring_002dmove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fmove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_move_x</strong> <var class="def-var-arguments">(str1, start1, end1, str2, start2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fmove_005fx"> ¶</a></span></dt>
<dd><p>Copy the substring of <var class="var">str1</var> bounded by <var class="var">start1</var> and <var class="var">end1</var>
into <var class="var">str2</var> beginning at position <var class="var">start2</var>.
<var class="var">str1</var> and <var class="var">str2</var> can be the same string.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-copy!</strong> <var class="def-var-arguments">target tstart s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcopy_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_copy_x</strong> <var class="def-var-arguments">(target, tstart, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcopy_005fx"> ¶</a></span></dt>
<dd><p>Copy the sequence of characters from index range [<var class="var">start</var>,
<var class="var">end</var>) in string <var class="var">s</var> to string <var class="var">target</var>, beginning
at index <var class="var">tstart</var>.  The characters are copied left-to-right
or right-to-left as needed – the copy is guaranteed to work,
even if <var class="var">target</var> and <var class="var">s</var> are the same string.  It is an
error if the copy operation runs off the end of the target
string.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="String-Comparison">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Searching" accesskey="n" rel="next">String Searching</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Modification" accesskey="p" rel="prev">String Modification</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Comparison-1">6.6.5.7 String Comparison</h4>

<p>The procedures in this section are similar to the character ordering
predicates (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Characters">Characters</a>), but are defined on character sequences.
</p>
<p>The first set is specified in R5RS and has names that end in <code class="code">?</code>.
The second set is specified in SRFI-13 and the names have not ending
<code class="code">?</code>.
</p>
<p>The predicates ending in <code class="code">-ci</code> ignore the character case
when comparing strings.  For now, case-insensitive comparison is done
using the R5RS rules, where every lower-case character that has a
single character upper-case form is converted to uppercase before
comparison.  See See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Text-Collation">the <code class="code">(ice-9
i18n)</code> module</a>, for locale-dependent string comparison.
</p>
<a class="index-entry-id" id="index-string_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003d_003f"> ¶</a></span></dt>
<dd><p>Lexicographic equality predicate; return <code class="code">#t</code> if all strings are
the same length and contain the same characters in the same positions,
otherwise return <code class="code">#f</code>.
</p>
<p>The procedure <code class="code">string-ci=?</code> treats upper and lower case
letters as though they were the same character, but
<code class="code">string=?</code> treats upper and lower case as distinct
characters.
</p></dd></dl>

<a class="index-entry-id" id="index-string_003c_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&lt;?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003c_003f"> ¶</a></span></dt>
<dd><p>Lexicographic ordering predicate; return <code class="code">#t</code> if, for every pair of
consecutive string arguments <var class="var">str_i</var> and <var class="var">str_i+1</var>, <var class="var">str_i</var> is
lexicographically less than <var class="var">str_i+1</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_003c_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003c_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&lt;=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003c_003d_003f"> ¶</a></span></dt>
<dd><p>Lexicographic ordering predicate; return <code class="code">#t</code> if, for every pair of
consecutive string arguments <var class="var">str_i</var> and <var class="var">str_i+1</var>, <var class="var">str_i</var> is
lexicographically less than or equal to <var class="var">str_i+1</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_003e_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&gt;?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003e_003f"> ¶</a></span></dt>
<dd><p>Lexicographic ordering predicate; return <code class="code">#t</code> if, for every pair of
consecutive string arguments <var class="var">str_i</var> and <var class="var">str_i+1</var>, <var class="var">str_i</var> is
lexicographically greater than <var class="var">str_i+1</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_003e_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_003e_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&gt;=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003e_003d_003f"> ¶</a></span></dt>
<dd><p>Lexicographic ordering predicate; return <code class="code">#t</code> if, for every pair of
consecutive string arguments <var class="var">str_i</var> and <var class="var">str_i+1</var>, <var class="var">str_i</var> is
lexicographically greater than or equal to <var class="var">str_i+1</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dci_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003d_003f"> ¶</a></span></dt>
<dd><p>Case-insensitive string equality predicate; return <code class="code">#t</code> if
all strings are the same length and their component
characters match (ignoring case) at each position; otherwise
return <code class="code">#f</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dci_003c_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&lt;?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003c_003f"> ¶</a></span></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code class="code">#t</code> if,
for every pair of consecutive string arguments <var class="var">str_i</var> and
<var class="var">str_i+1</var>, <var class="var">str_i</var> is lexicographically less than <var class="var">str_i+1</var>
regardless of case.
</p></dd></dl>

<a class="index-entry-id" id="index-string_003c_003d_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003c_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&lt;=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003c_003d_003f"> ¶</a></span></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code class="code">#t</code> if,
for every pair of consecutive string arguments <var class="var">str_i</var> and
<var class="var">str_i+1</var>, <var class="var">str_i</var> is lexicographically less than or equal to
<var class="var">str_i+1</var> regardless of case.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dci_003e_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&gt;?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003e_003f"> ¶</a></span></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code class="code">#t</code> if,
for every pair of consecutive string arguments <var class="var">str_i</var> and
<var class="var">str_i+1</var>, <var class="var">str_i</var> is lexicographically greater than
<var class="var">str_i+1</var> regardless of case.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dci_003e_003d_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003e_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&gt;=?</strong> <var class="def-var-arguments">s1 s2 s3 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003e_003d_003f"> ¶</a></span></dt>
<dd><p>Case insensitive lexicographic ordering predicate; return <code class="code">#t</code> if,
for every pair of consecutive string arguments <var class="var">str_i</var> and
<var class="var">str_i+1</var>, <var class="var">str_i</var> is lexicographically greater than or equal to
<var class="var">str_i+1</var> regardless of case.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcompare"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-compare</strong> <var class="def-var-arguments">s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcompare"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcompare"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_compare</strong> <var class="def-var-arguments">(s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcompare"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc_lt</var>, <var class="var">proc_eq</var>, <var class="var">proc_gt</var> to the
mismatch index, depending upon whether <var class="var">s1</var> is less than,
equal to, or greater than <var class="var">s2</var>.  The mismatch index is the
largest index <var class="var">i</var> such that for every 0 &lt;= <var class="var">j</var> &lt;
<var class="var">i</var>, <var class="var">s1</var>[<var class="var">j</var>] = <var class="var">s2</var>[<var class="var">j</var>] – that is,
<var class="var">i</var> is the first position that does not match.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcompare_002dci"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-compare-ci</strong> <var class="def-var-arguments">s1 s2 proc_lt proc_eq proc_gt [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcompare_002dci"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcompare_005fci"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_compare_ci</strong> <var class="def-var-arguments">(s1, s2, proc_lt, proc_eq, proc_gt, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcompare_005fci"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc_lt</var>, <var class="var">proc_eq</var>, <var class="var">proc_gt</var> to the
mismatch index, depending upon whether <var class="var">s1</var> is less than,
equal to, or greater than <var class="var">s2</var>.  The mismatch index is the
largest index <var class="var">i</var> such that for every 0 &lt;= <var class="var">j</var> &lt;
<var class="var">i</var>, <var class="var">s1</var>[<var class="var">j</var>] = <var class="var">s2</var>[<var class="var">j</var>] – that is,
<var class="var">i</var> is the first position where the lowercased letters 
do not match.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005feq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_eq</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005feq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> and <var class="var">s2</var> are not equal, a true
value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003c_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&lt;&gt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003c_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fneq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_neq</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fneq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> and <var class="var">s2</var> are equal, a true
value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003c"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&lt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003c"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_lt</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flt"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is greater or equal to <var class="var">s2</var>, a
true value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&gt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_gt</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fgt"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is less or equal to <var class="var">s2</var>, a
true value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003c_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&lt;=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003c_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_le</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fle"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is greater to <var class="var">s2</var>, a true
value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_003e_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string&gt;=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_003e_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fge"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ge</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fge"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is less to <var class="var">s2</var>, a true value
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005feq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_eq</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005feq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> and <var class="var">s2</var> are not equal, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003c_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&lt;&gt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003c_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005fneq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_neq</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005fneq"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> and <var class="var">s2</var> are equal, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003c"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&lt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003c"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_lt</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005flt"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is greater or equal to <var class="var">s2</var>, a
true value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&gt;</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_gt</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005fgt"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is less or equal to <var class="var">s2</var>, a
true value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003c_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&lt;=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003c_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005fle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_le</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005fle"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is greater to <var class="var">s2</var>, a true
value otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_003e_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci&gt;=</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_003e_003d"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005fge"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_ge</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005fge"> ¶</a></span></dt>
<dd><p>Return <code class="code">#f</code> if <var class="var">s1</var> is less to <var class="var">s2</var>, a true value
otherwise.  The character comparison is done
case-insensitively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dhash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-hash</strong> <var class="def-var-arguments">s [bound [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dhash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fhash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_hash</strong> <var class="def-var-arguments">(s, bound, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fhash"> ¶</a></span></dt>
<dd><p>Compute a hash value for <var class="var">s</var>.  The optional argument <var class="var">bound</var> is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dhash_002dci"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-hash-ci</strong> <var class="def-var-arguments">s [bound [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dhash_002dci"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fhash_005fci"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_hash_ci</strong> <var class="def-var-arguments">(s, bound, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fhash_005fci"> ¶</a></span></dt>
<dd><p>Compute a hash value for <var class="var">s</var>.  The optional argument <var class="var">bound</var> is a non-negative exact integer specifying the range of the hash function. A positive value restricts the return value to the range [0,bound).
</p></dd></dl>

<p>Because the same visual appearance of an abstract Unicode character can 
be obtained via multiple sequences of Unicode characters, even the 
case-insensitive string comparison functions described above may return
<code class="code">#f</code> when presented with strings containing different 
representations of the same character.  For example, the Unicode 
character “LATIN SMALL LETTER S WITH DOT BELOW AND DOT ABOVE” can be 
represented with a single character (U+1E69) or by the character “LATIN
SMALL LETTER S” (U+0073) followed by the combining marks “COMBINING 
DOT BELOW” (U+0323) and “COMBINING DOT ABOVE” (U+0307).
</p>
<p>For this reason, it is often desirable to ensure that the strings
to be compared are using a mutually consistent representation for every 
character.  The Unicode standard defines two methods of normalizing the
contents of strings: Decomposition, which breaks composite characters 
into a set of constituent characters with an ordering defined by the
Unicode Standard; and composition, which performs the converse.
</p>
<p>There are two decomposition operations.  “Canonical decomposition” 
produces character sequences that share the same visual appearance as
the original characters, while “compatibility decomposition” produces
ones whose visual appearances may differ from the originals but which
represent the same abstract character.
</p>
<p>These operations are encapsulated in the following set of normalization
forms:
</p>
<dl class="table">
<dt><em class="dfn">NFD</em></dt>
<dd><p>Characters are decomposed to their canonical forms.
</p>
</dd>
<dt><em class="dfn">NFKD</em></dt>
<dd><p>Characters are decomposed to their compatibility forms.
</p>
</dd>
<dt><em class="dfn">NFC</em></dt>
<dd><p>Characters are decomposed to their canonical forms, then composed.
</p>
</dd>
<dt><em class="dfn">NFKC</em></dt>
<dd><p>Characters are decomposed to their compatibility forms, then composed.
</p>
</dd>
</dl>

<p>The functions below put their arguments into one of the forms described
above.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dnormalize_002dnfd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-normalize-nfd</strong> <var class="def-var-arguments">s</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dnormalize_002dnfd"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fnormalize_005fnfd"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_normalize_nfd</strong> <var class="def-var-arguments">(s)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fnormalize_005fnfd"> ¶</a></span></dt>
<dd><p>Return the <code class="code">NFD</code> normalized form of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dnormalize_002dnfkd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-normalize-nfkd</strong> <var class="def-var-arguments">s</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dnormalize_002dnfkd"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fnormalize_005fnfkd"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_normalize_nfkd</strong> <var class="def-var-arguments">(s)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fnormalize_005fnfkd"> ¶</a></span></dt>
<dd><p>Return the <code class="code">NFKD</code> normalized form of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dnormalize_002dnfc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-normalize-nfc</strong> <var class="def-var-arguments">s</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dnormalize_002dnfc"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fnormalize_005fnfc"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_normalize_nfc</strong> <var class="def-var-arguments">(s)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fnormalize_005fnfc"> ¶</a></span></dt>
<dd><p>Return the <code class="code">NFC</code> normalized form of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dnormalize_002dnfkc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-normalize-nfkc</strong> <var class="def-var-arguments">s</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dnormalize_002dnfkc"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fnormalize_005fnfkc"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_normalize_nfkc</strong> <var class="def-var-arguments">(s)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fnormalize_005fnfkc"> ¶</a></span></dt>
<dd><p>Return the <code class="code">NFKC</code> normalized form of <var class="var">s</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="String-Searching">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Alphabetic-Case-Mapping" accesskey="n" rel="next">Alphabetic Case Mapping</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison" accesskey="p" rel="prev">String Comparison</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Searching-1">6.6.5.8 String Searching</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-index</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dindex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005findex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_index</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005findex"> ¶</a></span></dt>
<dd><p>Search through the string <var class="var">s</var> from left to right, returning
the index of the first occurrence of a character which
</p>
<ul class="itemize mark-bullet">
<li>equals <var class="var">char_pred</var>, if it is character,

</li><li>satisfies the predicate <var class="var">char_pred</var>, if it is a procedure,

</li><li>is in the set <var class="var">char_pred</var>, if it is a character set.
</li></ul>

<p>Return <code class="code">#f</code> if no match is found.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002drindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-rindex</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002drindex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005frindex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_rindex</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005frindex"> ¶</a></span></dt>
<dd><p>Search through the string <var class="var">s</var> from right to left, returning
the index of the last occurrence of a character which
</p>
<ul class="itemize mark-bullet">
<li>equals <var class="var">char_pred</var>, if it is character,

</li><li>satisfies the predicate <var class="var">char_pred</var>, if it is a procedure,

</li><li>is in the set if <var class="var">char_pred</var> is a character set.
</li></ul>

<p>Return <code class="code">#f</code> if no match is found.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dprefix_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-prefix-length</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dprefix_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fprefix_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_prefix_length</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fprefix_005flength"> ¶</a></span></dt>
<dd><p>Return the length of the longest common prefix of the two
strings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dprefix_002dlength_002dci"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-prefix-length-ci</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dprefix_002dlength_002dci"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fprefix_005flength_005fci"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_prefix_length_ci</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fprefix_005flength_005fci"> ¶</a></span></dt>
<dd><p>Return the length of the longest common prefix of the two
strings, ignoring character case.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dsuffix_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-suffix-length</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dsuffix_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fsuffix_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_suffix_length</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fsuffix_005flength"> ¶</a></span></dt>
<dd><p>Return the length of the longest common suffix of the two
strings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dsuffix_002dlength_002dci"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-suffix-length-ci</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dsuffix_002dlength_002dci"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fsuffix_005flength_005fci"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_suffix_length_ci</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fsuffix_005flength_005fci"> ¶</a></span></dt>
<dd><p>Return the length of the longest common suffix of the two
strings, ignoring character case.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dprefix_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-prefix?</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dprefix_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fprefix_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_prefix_p</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fprefix_005fp"> ¶</a></span></dt>
<dd><p>Is <var class="var">s1</var> a prefix of <var class="var">s2</var>?
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dprefix_002dci_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-prefix-ci?</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dprefix_002dci_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fprefix_005fci_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_prefix_ci_p</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fprefix_005fci_005fp"> ¶</a></span></dt>
<dd><p>Is <var class="var">s1</var> a prefix of <var class="var">s2</var>, ignoring character case?
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dsuffix_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-suffix?</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dsuffix_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fsuffix_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_suffix_p</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fsuffix_005fp"> ¶</a></span></dt>
<dd><p>Is <var class="var">s1</var> a suffix of <var class="var">s2</var>?
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dsuffix_002dci_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-suffix-ci?</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dsuffix_002dci_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fsuffix_005fci_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_suffix_ci_p</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fsuffix_005fci_005fp"> ¶</a></span></dt>
<dd><p>Is <var class="var">s1</var> a suffix of <var class="var">s2</var>, ignoring character case?
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dindex_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-index-right</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dindex_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005findex_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_index_right</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005findex_005fright"> ¶</a></span></dt>
<dd><p>Search through the string <var class="var">s</var> from right to left, returning
the index of the last occurrence of a character which
</p>
<ul class="itemize mark-bullet">
<li>equals <var class="var">char_pred</var>, if it is character,

</li><li>satisfies the predicate <var class="var">char_pred</var>, if it is a procedure,

</li><li>is in the set if <var class="var">char_pred</var> is a character set.
</li></ul>

<p>Return <code class="code">#f</code> if no match is found.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dskip"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-skip</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dskip"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fskip"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_skip</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fskip"> ¶</a></span></dt>
<dd><p>Search through the string <var class="var">s</var> from left to right, returning
the index of the first occurrence of a character which
</p>
<ul class="itemize mark-bullet">
<li>does not equal <var class="var">char_pred</var>, if it is character,

</li><li>does not satisfy the predicate <var class="var">char_pred</var>, if it is a
procedure,

</li><li>is not in the set if <var class="var">char_pred</var> is a character set.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dskip_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-skip-right</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dskip_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fskip_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_skip_right</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fskip_005fright"> ¶</a></span></dt>
<dd><p>Search through the string <var class="var">s</var> from right to left, returning
the index of the last occurrence of a character which
</p>
<ul class="itemize mark-bullet">
<li>does not equal <var class="var">char_pred</var>, if it is character,

</li><li>does not satisfy the predicate <var class="var">char_pred</var>, if it is a
procedure,

</li><li>is not in the set if <var class="var">char_pred</var> is a character set.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-count</strong> <var class="def-var-arguments">s char_pred [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_count</strong> <var class="def-var-arguments">(s, char_pred, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcount"> ¶</a></span></dt>
<dd><p>Return the count of the number of characters in the string
<var class="var">s</var> which
</p>
<ul class="itemize mark-bullet">
<li>equals <var class="var">char_pred</var>, if it is character,

</li><li>satisfies the predicate <var class="var">char_pred</var>, if it is a procedure.

</li><li>is in the set <var class="var">char_pred</var>, if it is a character set.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcontains"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-contains</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcontains"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcontains"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_contains</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcontains"> ¶</a></span></dt>
<dd><p>Does string <var class="var">s1</var> contain string <var class="var">s2</var>?  Return the index
in <var class="var">s1</var> where <var class="var">s2</var> occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcontains_002dci"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-contains-ci</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcontains_002dci"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcontains_005fci"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_contains_ci</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcontains_005fci"> ¶</a></span></dt>
<dd><p>Does string <var class="var">s1</var> contain string <var class="var">s2</var>?  Return the index
in <var class="var">s1</var> where <var class="var">s2</var> occurs as a substring, or false.
The optional start/end indices restrict the operation to the
indicated substrings.  Character comparison is done
case-insensitively.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Alphabetic-Case-Mapping">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reversing-and-Appending-Strings" accesskey="n" rel="next">Reversing and Appending Strings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Searching" accesskey="p" rel="prev">String Searching</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Alphabetic-Case-Mapping-1">6.6.5.9 Alphabetic Case Mapping</h4>

<p>These are procedures for mapping strings to their upper- or lower-case
equivalents, respectively, or for capitalizing strings.
</p>
<p>They use the basic case mapping rules for Unicode characters.  No
special language or context rules are considered.  The resulting strings
are guaranteed to be the same length as the input strings.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Case-Mapping">the <code class="code">(ice-9
i18n)</code> module</a>, for locale-dependent case conversions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dupcase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-upcase</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dupcase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fupcase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_upcase</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fupcase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fupcase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_upcase</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fupcase"> ¶</a></span></dt>
<dd><p>Upcase every character in <code class="code">str</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dupcase_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-upcase!</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dupcase_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fupcase_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_upcase_x</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fupcase_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fupcase_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_upcase_x</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fupcase_005fx"> ¶</a></span></dt>
<dd><p>Destructively upcase every character in <code class="code">str</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-upcase! y)
⇒ "ARRDEFG"
y
⇒ "ARRDEFG"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002ddowncase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-downcase</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002ddowncase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fdowncase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_downcase</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fdowncase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fdowncase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_downcase</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fdowncase"> ¶</a></span></dt>
<dd><p>Downcase every character in <var class="var">str</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002ddowncase_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-downcase!</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002ddowncase_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsubstring_005fdowncase_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_substring_downcase_x</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsubstring_005fdowncase_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fdowncase_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_downcase_x</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fdowncase_005fx"> ¶</a></span></dt>
<dd><p>Destructively downcase every character in <var class="var">str</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">y
⇒ "ARRDEFG"
(string-downcase! y)
⇒ "arrdefg"
y
⇒ "arrdefg"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcapitalize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-capitalize</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcapitalize"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcapitalize"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_capitalize</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcapitalize"> ¶</a></span></dt>
<dd><p>Return a freshly allocated string with the characters in
<var class="var">str</var>, where the first character of every word is
capitalized.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dcapitalize_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-capitalize!</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dcapitalize_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fcapitalize_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_capitalize_x</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fcapitalize_005fx"> ¶</a></span></dt>
<dd><p>Upcase the first character of every word in <var class="var">str</var>
destructively and return <var class="var">str</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">y                      ⇒ "hello world"
(string-capitalize! y) ⇒ "Hello World"
y                      ⇒ "Hello World"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtitlecase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-titlecase</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtitlecase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftitlecase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_titlecase</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftitlecase"> ¶</a></span></dt>
<dd><p>Titlecase every first character in a word in <var class="var">str</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtitlecase_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-titlecase!</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtitlecase_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftitlecase_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_titlecase_x</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftitlecase_005fx"> ¶</a></span></dt>
<dd><p>Destructively titlecase every first character in a word in
<var class="var">str</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Reversing-and-Appending-Strings">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Mapping-Folding-and-Unfolding" accesskey="n" rel="next">Mapping, Folding, and Unfolding</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Alphabetic-Case-Mapping" accesskey="p" rel="prev">Alphabetic Case Mapping</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Reversing-and-Appending-Strings-1">6.6.5.10 Reversing and Appending Strings</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dreverse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-reverse</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dreverse"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005freverse"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_reverse</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005freverse"> ¶</a></span></dt>
<dd><p>Reverse the string <var class="var">str</var>.  The optional arguments
<var class="var">start</var> and <var class="var">end</var> delimit the region of <var class="var">str</var> to
operate on.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dreverse_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-reverse!</strong> <var class="def-var-arguments">str [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dreverse_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005freverse_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_reverse_x</strong> <var class="def-var-arguments">(str, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005freverse_005fx"> ¶</a></span></dt>
<dd><p>Reverse the string <var class="var">str</var> in-place.  The optional arguments
<var class="var">start</var> and <var class="var">end</var> delimit the region of <var class="var">str</var> to
operate on.  The return value is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-string_002dappend-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dappend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-append</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dappend"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fappend"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_append</strong> <var class="def-var-arguments">(args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fappend"> ¶</a></span></dt>
<dd><p>Return a newly allocated string whose characters form the
concatenation of the given strings, <var class="var">arg</var> <small class="enddots">...</small>.
</p>
<div class="example">
<pre class="example-preformatted">(let ((h "hello "))
  (string-append h "world"))
⇒ "hello world"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dappend_002fshared"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-append/shared</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dappend_002fshared"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fappend_005fshared"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_append_shared</strong> <var class="def-var-arguments">(args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fappend_005fshared"> ¶</a></span></dt>
<dd><p>Like <code class="code">string-append</code>, but the result may share memory
with the argument strings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dconcatenate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-concatenate</strong> <var class="def-var-arguments">ls</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dconcatenate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fconcatenate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_concatenate</strong> <var class="def-var-arguments">(ls)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fconcatenate"> ¶</a></span></dt>
<dd><p>Append the elements (which must be strings) of <var class="var">ls</var> together into a
single string.  Guaranteed to return a freshly allocated string.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dconcatenate_002dreverse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-concatenate-reverse</strong> <var class="def-var-arguments">ls [final_string [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dconcatenate_002dreverse"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fconcatenate_005freverse"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_concatenate_reverse</strong> <var class="def-var-arguments">(ls, final_string, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fconcatenate_005freverse"> ¶</a></span></dt>
<dd><p>Without optional arguments, this procedure is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-concatenate (reverse ls))
</pre></div>

<p>If the optional argument <var class="var">final_string</var> is specified, it is
consed onto the beginning to <var class="var">ls</var> before performing the
list-reverse and string-concatenate operations.  If <var class="var">end</var>
is given, only the characters of <var class="var">final_string</var> up to index
<var class="var">end</var> are used.
</p>
<p>Guaranteed to return a freshly allocated string.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dconcatenate_002fshared"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-concatenate/shared</strong> <var class="def-var-arguments">ls</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dconcatenate_002fshared"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fconcatenate_005fshared"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_concatenate_shared</strong> <var class="def-var-arguments">(ls)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fconcatenate_005fshared"> ¶</a></span></dt>
<dd><p>Like <code class="code">string-concatenate</code>, but the result may share memory
with the strings in the list <var class="var">ls</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dconcatenate_002dreverse_002fshared"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-concatenate-reverse/shared</strong> <var class="def-var-arguments">ls [final_string [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dconcatenate_002dreverse_002fshared"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fconcatenate_005freverse_005fshared"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_concatenate_reverse_shared</strong> <var class="def-var-arguments">(ls, final_string, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fconcatenate_005freverse_005fshared"> ¶</a></span></dt>
<dd><p>Like <code class="code">string-concatenate-reverse</code>, but the result may
share memory with the strings in the <var class="var">ls</var> arguments.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Mapping-Folding-and-Unfolding">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Miscellaneous-String-Operations" accesskey="n" rel="next">Miscellaneous String Operations</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reversing-and-Appending-Strings" accesskey="p" rel="prev">Reversing and Appending Strings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Mapping_002c-Folding_002c-and-Unfolding">6.6.5.11 Mapping, Folding, and Unfolding</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-map</strong> <var class="def-var-arguments">proc s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dmap"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fmap"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_map</strong> <var class="def-var-arguments">(proc, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fmap"> ¶</a></span></dt>
<dd><p><var class="var">proc</var> is a char-&gt;char procedure, it is mapped over
<var class="var">s</var>.  The order in which the procedure is applied to the
string elements is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dmap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-map!</strong> <var class="def-var-arguments">proc s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dmap_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fmap_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_map_x</strong> <var class="def-var-arguments">(proc, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fmap_005fx"> ¶</a></span></dt>
<dd><p><var class="var">proc</var> is a char-&gt;char procedure, it is mapped over
<var class="var">s</var>.  The order in which the procedure is applied to the
string elements is not specified.  The string <var class="var">s</var> is
modified in-place, the return value is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-for-each</strong> <var class="def-var-arguments">proc s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_for_each</strong> <var class="def-var-arguments">(proc, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffor_005feach"> ¶</a></span></dt>
<dd><p><var class="var">proc</var> is mapped over <var class="var">s</var> in left-to-right order.  The
return value is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dfor_002deach_002dindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-for-each-index</strong> <var class="def-var-arguments">proc s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfor_002deach_002dindex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffor_005feach_005findex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_for_each_index</strong> <var class="def-var-arguments">(proc, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffor_005feach_005findex"> ¶</a></span></dt>
<dd><p>Call <code class="code">(<var class="var">proc</var> i)</code> for each index i in <var class="var">s</var>, from left to
right.
</p>
<p>For example, to change characters to alternately upper and lower case,
</p>
<div class="example">
<pre class="example-preformatted">(define str (string-copy "studly"))
(string-for-each-index
    (lambda (i)
      (string-set! str i
        ((if (even? i) char-upcase char-downcase)
         (string-ref str i))))
    str)
str ⇒ "StUdLy"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-fold</strong> <var class="def-var-arguments">kons knil s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffold"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_fold</strong> <var class="def-var-arguments">(kons, knil, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffold"> ¶</a></span></dt>
<dd><p>Fold <var class="var">kons</var> over the characters of <var class="var">s</var>, with <var class="var">knil</var>
as the terminating element, from left to right.  <var class="var">kons</var>
must expect two arguments: The actual character and the last
result of <var class="var">kons</var>’ application.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-fold-right</strong> <var class="def-var-arguments">kons knil s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfold_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffold_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_fold_right</strong> <var class="def-var-arguments">(kons, knil, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffold_005fright"> ¶</a></span></dt>
<dd><p>Fold <var class="var">kons</var> over the characters of <var class="var">s</var>, with <var class="var">knil</var>
as the terminating element, from right to left.  <var class="var">kons</var>
must expect two arguments: The actual character and the last
result of <var class="var">kons</var>’ application.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dunfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-unfold</strong> <var class="def-var-arguments">p f g seed [base [make_final]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dunfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005funfold"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_unfold</strong> <var class="def-var-arguments">(p, f, g, seed, base, make_final)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005funfold"> ¶</a></span></dt>
<dd><ul class="itemize mark-bullet">
<li><var class="var">g</var> is used to generate a series of <em class="emph">seed</em>
values from the initial <var class="var">seed</var>: <var class="var">seed</var>, (<var class="var">g</var>
<var class="var">seed</var>), (<var class="var">g</var>^2 <var class="var">seed</var>), (<var class="var">g</var>^3 <var class="var">seed</var>),
…
</li><li><var class="var">p</var> tells us when to stop – when it returns true
when applied to one of these seed values.
</li><li><var class="var">f</var> maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a left-to-right order.
</li><li><var class="var">base</var> is the optional initial/leftmost portion
of the constructed string; it default to the empty
string.
</li><li><var class="var">make_final</var> is applied to the terminal seed
value (on which <var class="var">p</var> returns true) to produce
the final/rightmost portion of the constructed string.
The default is nothing extra.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dunfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-unfold-right</strong> <var class="def-var-arguments">p f g seed [base [make_final]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dunfold_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005funfold_005fright"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_unfold_right</strong> <var class="def-var-arguments">(p, f, g, seed, base, make_final)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005funfold_005fright"> ¶</a></span></dt>
<dd><ul class="itemize mark-bullet">
<li><var class="var">g</var> is used to generate a series of <em class="emph">seed</em>
values from the initial <var class="var">seed</var>: <var class="var">seed</var>, (<var class="var">g</var>
<var class="var">seed</var>), (<var class="var">g</var>^2 <var class="var">seed</var>), (<var class="var">g</var>^3 <var class="var">seed</var>),
…
</li><li><var class="var">p</var> tells us when to stop – when it returns true
when applied to one of these seed values.
</li><li><var class="var">f</var> maps each seed value to the corresponding
character in the result string.  These chars are assembled
into the string in a right-to-left order.
</li><li><var class="var">base</var> is the optional initial/rightmost portion
of the constructed string; it default to the empty
string.
</li><li><var class="var">make_final</var> is applied to the terminal seed
value (on which <var class="var">p</var> returns true) to produce
the final/leftmost portion of the constructed string.
It defaults to <code class="code">(lambda (x) )</code>.
</li></ul>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Miscellaneous-String-Operations">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes" accesskey="n" rel="next">Representing Strings as Bytes</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Mapping-Folding-and-Unfolding" accesskey="p" rel="prev">Mapping, Folding, and Unfolding</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Miscellaneous-String-Operations-1">6.6.5.12 Miscellaneous String Operations</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-xsubstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">xsubstring</strong> <var class="def-var-arguments">s from [to [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-xsubstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fxsubstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_xsubstring</strong> <var class="def-var-arguments">(s, from, to, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fxsubstring"> ¶</a></span></dt>
<dd><p>This is the <em class="emph">extended substring</em> procedure that implements
replicated copying of a substring of some string.
</p>
<p><var class="var">s</var> is a string, <var class="var">start</var> and <var class="var">end</var> are optional
arguments that demarcate a substring of <var class="var">s</var>, defaulting to
0 and the length of <var class="var">s</var>.  Replicate this substring up and
down index space, in both the positive and negative directions.
<code class="code">xsubstring</code> returns the substring of this string
beginning at index <var class="var">from</var>, and ending at <var class="var">to</var>, which
defaults to <var class="var">from</var> + (<var class="var">end</var> - <var class="var">start</var>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dxcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-xcopy!</strong> <var class="def-var-arguments">target tstart s sfrom [sto [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dxcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fxcopy_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_xcopy_x</strong> <var class="def-var-arguments">(target, tstart, s, sfrom, sto, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fxcopy_005fx"> ¶</a></span></dt>
<dd><p>Exactly the same as <code class="code">xsubstring</code>, but the extracted text
is written into the string <var class="var">target</var> starting at index
<var class="var">tstart</var>.  The operation is not defined if <code class="code">(eq?
<var class="var">target</var> <var class="var">s</var>)</code> or these arguments share storage – you
cannot copy a string on top of itself.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dreplace"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-replace</strong> <var class="def-var-arguments">s1 s2 [start1 [end1 [start2 [end2]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dreplace"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005freplace"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_replace</strong> <var class="def-var-arguments">(s1, s2, start1, end1, start2, end2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005freplace"> ¶</a></span></dt>
<dd><p>Return the string <var class="var">s1</var>, but with the characters
<var class="var">start1</var> … <var class="var">end1</var> replaced by the characters
<var class="var">start2</var> … <var class="var">end2</var> from <var class="var">s2</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dtokenize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-tokenize</strong> <var class="def-var-arguments">s [token_set [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dtokenize"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ftokenize"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_tokenize</strong> <var class="def-var-arguments">(s, token_set, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ftokenize"> ¶</a></span></dt>
<dd><p>Split the string <var class="var">s</var> into a list of substrings, where each
substring is a maximal non-empty contiguous sequence of
characters from the character set <var class="var">token_set</var>, which
defaults to <code class="code">char-set:graphic</code>.
If <var class="var">start</var> or <var class="var">end</var> indices are provided, they restrict
<code class="code">string-tokenize</code> to operating on the indicated substring
of <var class="var">s</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dfilter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-filter</strong> <var class="def-var-arguments">char_pred s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dfilter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005ffilter"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_filter</strong> <var class="def-var-arguments">(char_pred, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005ffilter"> ¶</a></span></dt>
<dd><p>Filter the string <var class="var">s</var>, retaining only those characters which
satisfy <var class="var">char_pred</var>.
</p>
<p>If <var class="var">char_pred</var> is a procedure, it is applied to each character as
a predicate, if it is a character, it is tested for equality and if it
is a character set, it is tested for membership.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-delete</strong> <var class="def-var-arguments">char_pred s [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002ddelete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fdelete"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_delete</strong> <var class="def-var-arguments">(char_pred, s, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fdelete"> ¶</a></span></dt>
<dd><p>Delete characters satisfying <var class="var">char_pred</var> from <var class="var">s</var>.
</p>
<p>If <var class="var">char_pred</var> is a procedure, it is applied to each character as
a predicate, if it is a character, it is tested for equality and if it
is a character set, it is tested for membership.
</p></dd></dl>

<p>The following additional functions are available in the module <code class="code">(ice-9 string-fun)</code>. They can be used with:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 string-fun))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dreplace_002dsubstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-replace-substring</strong> <var class="def-var-arguments">str substring replacement</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dreplace_002dsubstring"> ¶</a></span></dt>
<dd><p>Return a new string where every instance of <var class="var">substring</var> in string
<var class="var">str</var> has been replaced by <var class="var">replacement</var>. For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(string-replace-substring "a ring of strings" "ring" "rut")
⇒ "a rut of struts"
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Representing-Strings-as-Bytes">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion-to_002ffrom-C" accesskey="n" rel="next">Conversion to/from C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Miscellaneous-String-Operations" accesskey="p" rel="prev">Miscellaneous String Operations</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Representing-Strings-as-Bytes-1">6.6.5.13 Representing Strings as Bytes</h4>

<p>Out in the cold world outside of Guile, not all strings are treated in
the same way.  Out there there are only bytes, and there are many ways
of representing a strings (sequences of characters) as binary data
(sequences of bytes).
</p>
<p>As a user, usually you don’t have to think about this very much.  When
you type on your keyboard, your system encodes your keystrokes as bytes
according to the locale that you have configured on your computer.
Guile uses the locale to decode those bytes back into characters –
hopefully the same characters that you typed in.
</p>
<p>All is not so clear when dealing with a system with multiple users, such
as a web server.  Your web server might get a request from one user for
data encoded in the ISO-8859-1 character set, and then another request
from a different user for UTF-8 data.
</p>
<a class="index-entry-id" id="index-iconv"></a>
<a class="index-entry-id" id="index-character-encoding"></a>
<p>Guile provides an <em class="dfn">iconv</em> module for converting between strings and
sequences of bytes.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>, for more on how Guile
represents raw byte sequences.  This module gets its name from the
common <small class="sc">UNIX</small> command of the same name.
</p>
<p>Note that often it is sufficient to just read and write strings from
ports instead of using these functions.  To do this, specify the port
encoding using <code class="code">set-port-encoding!</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more on
ports and character encodings.
</p>
<p>Unlike the rest of the procedures in this section, you have to load the
<code class="code">iconv</code> module before having access to these procedures:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 iconv))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003ebytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;bytevector</strong> <var class="def-var-arguments">string encoding [conversion-strategy]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003ebytevector"> ¶</a></span></dt>
<dd><p>Encode <var class="var">string</var> as a sequence of bytes.
</p>
<p>The string will be encoded in the character set specified by the
<var class="var">encoding</var> string.  If the string has characters that cannot be
represented in the encoding, by default this procedure raises an
<code class="code">encoding-error</code>.  Pass a <var class="var">conversion-strategy</var> argument to
specify other behaviors.
</p>
<p>The return value is a bytevector.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>, for more on
bytevectors.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more on character encodings and
conversion strategies.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-&gt;string</strong> <var class="def-var-arguments">bytevector encoding [conversion-strategy]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002d_003estring"> ¶</a></span></dt>
<dd><p>Decode <var class="var">bytevector</var> into a string.
</p>
<p>The bytes will be decoded from the character set by the <var class="var">encoding</var>
string.  If the bytes do not form a valid encoding, by default this
procedure raises an <code class="code">decoding-error</code>.  As with
<code class="code">string-&gt;bytevector</code>, pass the optional <var class="var">conversion-strategy</var>
argument to modify this behavior.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more on character
encodings and conversion strategies.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002doutput_002dencoded_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-output-encoded-string</strong> <var class="def-var-arguments">encoding proc [conversion-strategy]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002doutput_002dencoded_002dstring"> ¶</a></span></dt>
<dd><p>Like <code class="code">call-with-output-string</code>, but instead of returning a string,
returns a encoding of the string according to <var class="var">encoding</var>, as a
bytevector.  This procedure can be more efficient than collecting a
string and then converting it via <code class="code">string-&gt;bytevector</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Conversion-to_002ffrom-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Internals" accesskey="n" rel="next">String Internals</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes" accesskey="p" rel="prev">Representing Strings as Bytes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Conversion-to_002ffrom-C-1">6.6.5.14 Conversion to/from C</h4>

<p>When creating a Scheme string from a C string or when converting a
Scheme string to a C string, the concept of character encoding becomes
important.
</p>
<p>In C, a string is just a sequence of bytes, and the character encoding
describes the relation between these bytes and the actual characters
that make up the string.  For Scheme strings, character encoding is not
an issue (most of the time), since in Scheme you usually treat strings
as character sequences, not byte sequences.
</p>
<p>Converting to C and converting from C each have their own challenges.
</p>
<p>When converting from C to Scheme, it is important that the sequence of
bytes in the C string be valid with respect to its encoding.  ASCII
strings, for example, can’t have any bytes greater than 127.  An ASCII
byte greater than 127 is considered <em class="emph">ill-formed</em> and cannot be
converted into a Scheme character.
</p>
<p>Problems can occur in the reverse operation as well.  Not all character
encodings can hold all possible Scheme characters.  Some encodings, like
ASCII for example, can only describe a small subset of all possible
characters.  So, when converting to C, one must first decide what to do
with Scheme characters that can’t be represented in the C string.
</p>
<p>Converting a Scheme string to a C string will often allocate fresh
memory to hold the result.  You must take care that this memory is
properly freed eventually.  In many cases, this can be achieved by
using <code class="code">scm_dynwind_free</code> inside an appropriate dynwind context,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flocale_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_string</strong> <code class="def-code-arguments">(const char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005flocale_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_stringn</strong> <code class="def-code-arguments">(const char *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fstringn"> ¶</a></span></dt>
<dd><p>Creates a new Scheme string that has the same contents as <var class="var">str</var> when
interpreted in the character encoding of the current locale.
</p>
<p>For <code class="code">scm_from_locale_string</code>, <var class="var">str</var> must be null-terminated.
</p>
<p>For <code class="code">scm_from_locale_stringn</code>, <var class="var">len</var> specifies the length of
<var class="var">str</var> in bytes, and <var class="var">str</var> does not need to be null-terminated.
If <var class="var">len</var> is <code class="code">(size_t)-1</code>, then <var class="var">str</var> does need to be
null-terminated and the real length will be found with <code class="code">strlen</code>.
</p>
<p>If the C string is ill-formed, an error will be raised.
</p>
<p>Note that these functions should <em class="emph">not</em> be used to convert C string
constants, because there is no guarantee that the current locale will
match that of the execution character set, used for string and character
constants.  Most modern C compilers use UTF-8 by default, so to convert
C string constants we recommend <code class="code">scm_from_utf8_string</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ftake_005flocale_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_locale_string</strong> <code class="def-code-arguments">(char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005flocale_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005flocale_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_locale_stringn</strong> <code class="def-code-arguments">(char *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005flocale_005fstringn"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_from_locale_string</code> and <code class="code">scm_from_locale_stringn</code>,
respectively, but also frees <var class="var">str</var> with <code class="code">free</code> eventually.
Thus, you can use this function when you would free <var class="var">str</var> anyway
immediately after creating the Scheme string.  In certain cases, Guile
can then use <var class="var">str</var> directly as its internal representation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005flocale_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">char *</code> <strong class="def-name">scm_to_locale_string</strong> <code class="def-code-arguments">(SCM str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005flocale_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005flocale_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">char *</code> <strong class="def-name">scm_to_locale_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005flocale_005fstringn"> ¶</a></span></dt>
<dd><p>Returns a C string with the same contents as <var class="var">str</var> in the character
encoding of the current locale.  The C string must be freed with
<code class="code">free</code> eventually, maybe by using <code class="code">scm_dynwind_free</code>,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>.
</p>
<p>For <code class="code">scm_to_locale_string</code>, the returned string is
null-terminated and an error is signalled when <var class="var">str</var> contains
<code class="code">#\nul</code> characters.
</p>
<p>For <code class="code">scm_to_locale_stringn</code> and <var class="var">lenp</var> not <code class="code">NULL</code>,
<var class="var">str</var> might contain <code class="code">#\nul</code> characters and the length of the
returned string in bytes is stored in <code class="code">*<var class="var">lenp</var></code>.  The
returned string will not be null-terminated in this case.  If
<var class="var">lenp</var> is <code class="code">NULL</code>, <code class="code">scm_to_locale_stringn</code> behaves like
<code class="code">scm_to_locale_string</code>.
</p>
<p>If a character in <var class="var">str</var> cannot be represented in the character
encoding of the current locale, the default port conversion strategy is
used.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more on conversion strategies.
</p>
<p>If the conversion strategy is <code class="code">error</code>, an error will be raised.  If
it is <code class="code">substitute</code>, a replacement character, such as a question
mark, will be inserted in its place.  If it is <code class="code">escape</code>, a hex
escape will be inserted in its place.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005flocale_005fstringbuf"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_to_locale_stringbuf</strong> <code class="def-code-arguments">(SCM str, char *buf, size_t max_len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005flocale_005fstringbuf"> ¶</a></span></dt>
<dd><p>Puts <var class="var">str</var> as a C string in the current locale encoding into the
memory pointed to by <var class="var">buf</var>.  The buffer at <var class="var">buf</var> has room for
<var class="var">max_len</var> bytes and <code class="code">scm_to_local_stringbuf</code> will never store
more than that.  No terminating <code class="code">'\0'</code> will be stored.
</p>
<p>The return value of <code class="code">scm_to_locale_stringbuf</code> is the number of
bytes that are needed for all of <var class="var">str</var>, regardless of whether
<var class="var">buf</var> was large enough to hold them.  Thus, when the return value
is larger than <var class="var">max_len</var>, only <var class="var">max_len</var> bytes have been
stored and you probably need to try again with a larger buffer.
</p></dd></dl>

<p>For most situations, string conversion should occur using the current
locale, such as with the functions above.  But there may be cases where
one wants to convert strings from a character encoding other than the
locale’s character encoding.  For these cases, the lower-level functions
<code class="code">scm_to_stringn</code> and <code class="code">scm_from_stringn</code> are provided.  These
functions should seldom be necessary if one is properly using locales.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fstring_005ffailed_005fconversion_005fhandler"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_string_failed_conversion_handler</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fstring_005ffailed_005fconversion_005fhandler"> ¶</a></span></dt>
<dd><p>This is an enumerated type that can take one of three values:
<code class="code">SCM_FAILED_CONVERSION_ERROR</code>,
<code class="code">SCM_FAILED_CONVERSION_QUESTION_MARK</code>, and
<code class="code">SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE</code>.  They are used to indicate
a strategy for handling characters that cannot be converted to or from a
given character encoding.  <code class="code">SCM_FAILED_CONVERSION_ERROR</code> indicates
that a conversion should throw an error if some characters cannot be
converted.  <code class="code">SCM_FAILED_CONVERSION_QUESTION_MARK</code> indicates that a
conversion should replace unconvertable characters with the question
mark character.  And, <code class="code">SCM_FAILED_CONVERSION_ESCAPE_SEQUENCE</code>
requests that a conversion should replace an unconvertable character
with an escape sequence.
</p>
<p>While all three strategies apply when converting Scheme strings to C,
only <code class="code">SCM_FAILED_CONVERSION_ERROR</code> and
<code class="code">SCM_FAILED_CONVERSION_QUESTION_MARK</code> can be used when converting C
strings to Scheme.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-_002ascm_005fto_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">char</code> <strong class="def-name">*scm_to_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp, const char *encoding, scm_t_string_failed_conversion_handler handler)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002ascm_005fto_005fstringn"> ¶</a></span></dt>
<dd><p>This function returns a newly allocated C string from the Guile string
<var class="var">str</var>.  The length of the returned string in bytes will be returned in
<var class="var">lenp</var>.  The character encoding of the C string is passed as the ASCII,
null-terminated C string <var class="var">encoding</var>.  The <var class="var">handler</var> parameter
gives a strategy for dealing with characters that cannot be converted
into <var class="var">encoding</var>.
</p>
<p>If <var class="var">lenp</var> is <code class="code">NULL</code>, this function will return a null-terminated C
string.  It will throw an error if the string contains a null
character.
</p>
<p>The Scheme interface to this function is <code class="code">string-&gt;bytevector</code>, from the
<code class="code">ice-9 iconv</code> module.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes">Representing Strings as Bytes</a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_stringn</strong> <code class="def-code-arguments">(const char *str, size_t len, const char *encoding, scm_t_string_failed_conversion_handler handler)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fstringn"> ¶</a></span></dt>
<dd><p>This function returns a scheme string from the C string <var class="var">str</var>.  The
length in bytes of the C string is input as <var class="var">len</var>.  The encoding of the C
string is passed as the ASCII, null-terminated C string <code class="code">encoding</code>.
The <var class="var">handler</var> parameters suggests a strategy for dealing with
unconvertable characters.
</p>
<p>The Scheme interface to this function is <code class="code">bytevector-&gt;string</code>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes">Representing Strings as Bytes</a>.
</p></dd></dl>

<p>The following conversion functions are provided as a convenience for the
most commonly used encodings.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flatin1_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_latin1_string</strong> <code class="def-code-arguments">(const char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flatin1_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf8_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf8_string</strong> <code class="def-code-arguments">(const char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf8_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf32_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf32_string</strong> <code class="def-code-arguments">(const scm_t_wchar *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf32_005fstring"> ¶</a></span></dt>
<dd><p>Return a scheme string from the null-terminated C string <var class="var">str</var>,
which is ISO-8859-1-, UTF-8-, or UTF-32-encoded.  These functions should
be used to convert hard-coded C string constants into Scheme strings.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flatin1_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_latin1_stringn</strong> <code class="def-code-arguments">(const char *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flatin1_005fstringn"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf8_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf8_stringn</strong> <code class="def-code-arguments">(const char *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf8_005fstringn"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf32_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf32_stringn</strong> <code class="def-code-arguments">(const scm_t_wchar *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf32_005fstringn"> ¶</a></span></dt>
<dd><p>Return a scheme string from C string <var class="var">str</var>, which is ISO-8859-1-,
UTF-8-, or UTF-32-encoded, of length <var class="var">len</var>.  <var class="var">len</var> is the number
of bytes pointed to by <var class="var">str</var> for <code class="code">scm_from_latin1_stringn</code> and
<code class="code">scm_from_utf8_stringn</code>; it is the number of elements (code points)
in <var class="var">str</var> in the case of <code class="code">scm_from_utf32_stringn</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-_002ascm_005fto_005flatin1_005fstringn"><span class="category-def">C function: </span><span><code class="def-type">char</code> <strong class="def-name">*scm_to_latin1_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002ascm_005fto_005flatin1_005fstringn"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-_002ascm_005fto_005futf8_005fstringn"><span class="category-def">C function: </span><span><code class="def-type">char</code> <strong class="def-name">*scm_to_utf8_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002ascm_005fto_005futf8_005fstringn"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-_002ascm_005fto_005futf32_005fstringn"><span class="category-def">C function: </span><span><code class="def-type">scm_t_wchar</code> <strong class="def-name">*scm_to_utf32_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002ascm_005fto_005futf32_005fstringn"> ¶</a></span></dt>
<dd><p>Return a newly allocated, ISO-8859-1-, UTF-8-, or UTF-32-encoded C string
from Scheme string <var class="var">str</var>.  An error is thrown when <var class="var">str</var>
cannot be converted to the specified encoding.  If <var class="var">lenp</var> is
<code class="code">NULL</code>, the returned C string will be null terminated, and an error
will be thrown if the C string would otherwise contain null
characters.  If <var class="var">lenp</var> is not <code class="code">NULL</code>, the string is not null terminated,
and the length of the returned string is returned in <var class="var">lenp</var>.  The length
returned is the number of bytes for <code class="code">scm_to_latin1_stringn</code> and
<code class="code">scm_to_utf8_stringn</code>; it is the number of elements (code points)
for <code class="code">scm_to_utf32_stringn</code>.
</p></dd></dl>

<p>It is not often the case, but sometimes when you are dealing with the
implementation details of a port, you need to encode and decode strings
according to the encoding and conversion strategy of the port.  There
are some convenience functions for that purpose as well.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fport_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_port_string</strong> <code class="def-code-arguments">(const char *str, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fport_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005fport_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_port_stringn</strong> <code class="def-code-arguments">(const char *str, size_t len, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fport_005fstringn"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fport_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">char*</code> <strong class="def-name">scm_to_port_string</strong> <code class="def-code-arguments">(SCM str, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fport_005fstring"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fto_005fport_005fstringn"><span class="category-def">C Function: </span><span><code class="def-type">char*</code> <strong class="def-name">scm_to_port_stringn</strong> <code class="def-code-arguments">(SCM str, size_t *lenp, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fport_005fstringn"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_from_stringn</code> and friends, except they take their
encoding and conversion strategy from a given port object.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="String-Internals">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conversion-to_002ffrom-C" accesskey="p" rel="prev">Conversion to/from C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="u" rel="up">Strings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Internals-1">6.6.5.15 String Internals</h4>

<p>Guile stores each string in memory as a contiguous array of Unicode code
points along with an associated set of attributes.  If all of the code
points of a string have an integer range between 0 and 255 inclusive,
the code point array is stored as one byte per code point: it is stored
as an ISO-8859-1 (aka Latin-1) string.  If any of the code points of the
string has an integer value greater that 255, the code point array is
stored as four bytes per code point: it is stored as a UTF-32 string.
</p>
<p>Conversion between the one-byte-per-code-point and
four-bytes-per-code-point representations happens automatically as
necessary.
</p>
<p>No API is provided to set the internal representation of strings;
however, there are pair of procedures available to query it.  These are
debugging procedures.  Using them in production code is discouraged,
since the details of Guile’s internal representation of strings may
change from release to release.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dbytes_002dper_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-bytes-per-char</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dbytes_002dper_002dchar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fbytes_005fper_005fchar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_bytes_per_char</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fbytes_005fper_005fchar"> ¶</a></span></dt>
<dd><p>Return the number of bytes used to encode a Unicode code point in string
<var class="var">str</var>.  The result is one or four.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025string_002ddump"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%string-dump</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025string_002ddump"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fstring_005fdump"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_string_dump</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fstring_005fdump"> ¶</a></span></dt>
<dd><p>Returns an association list containing debugging information for
<var class="var">str</var>. The association list has the following entries.
</p><dl class="table">
<dt><code class="code">string</code></dt>
<dd><p>The string itself.
</p>
</dd>
<dt><code class="code">start</code></dt>
<dd><p>The start index of the string into its stringbuf
</p>
</dd>
<dt><code class="code">length</code></dt>
<dd><p>The length of the string
</p>
</dd>
<dt><code class="code">shared</code></dt>
<dd><p>If this string is a substring, it returns its
parent string.  Otherwise, it returns <code class="code">#f</code>
</p>
</dd>
<dt><code class="code">read-only</code></dt>
<dd><p><code class="code">#t</code> if the string is read-only
</p>
</dd>
<dt><code class="code">stringbuf-chars</code></dt>
<dd><p>A new string containing this string’s stringbuf’s characters
</p>
</dd>
<dt><code class="code">stringbuf-length</code></dt>
<dd><p>The number of characters in this stringbuf
</p>
</dd>
<dt><code class="code">stringbuf-shared</code></dt>
<dd><p><code class="code">#t</code> if this stringbuf is shared
</p>
</dd>
<dt><code class="code">stringbuf-wide</code></dt>
<dd><p><code class="code">#t</code> if this stringbuf’s characters are stored in a 32-bit buffer,
or <code class="code">#f</code> if they are stored in an 8-bit buffer
</p></dd>
</dl>
</dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Symbols">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="n" rel="next">Keywords</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Strings" accesskey="p" rel="prev">Strings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Symbols-1">6.6.6 Symbols</h4>
<a class="index-entry-id" id="index-Symbols"></a>

<p>Symbols in Scheme are widely used in three ways: as items of discrete
data, as lookup keys for alists and hash tables, and to denote variable
references.
</p>
<p>A <em class="dfn">symbol</em> is similar to a string in that it is defined by a
sequence of characters.  The sequence of characters is known as the
symbol’s <em class="dfn">name</em>.  In the usual case — that is, where the symbol’s
name doesn’t include any characters that could be confused with other
elements of Scheme syntax — a symbol is written in a Scheme program by
writing the sequence of characters that make up the name, <em class="emph">without</em>
any quotation marks or other special syntax.  For example, the symbol
whose name is “multiply-by-2” is written, simply:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">multiply-by-2
</pre></div>

<p>Notice how this differs from a <em class="emph">string</em> with contents
“multiply-by-2”, which is written with double quotation marks, like
this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">"multiply-by-2"
</pre></div>

<p>Looking beyond how they are written, symbols are different from strings
in two important respects.
</p>
<p>The first important difference is uniqueness.  If the same-looking
string is read twice from two different places in a program, the result
is two <em class="emph">different</em> string objects whose contents just happen to be
the same.  If, on the other hand, the same-looking symbol is read twice
from two different places in a program, the result is the <em class="emph">same</em>
symbol object both times.
</p>
<p>Given two read symbols, you can use <code class="code">eq?</code> to test whether they are
the same (that is, have the same name).  <code class="code">eq?</code> is the most
efficient comparison operator in Scheme, and comparing two symbols like
this is as fast as comparing, for example, two numbers.  Given two
strings, on the other hand, you must use <code class="code">equal?</code> or
<code class="code">string=?</code>, which are much slower comparison operators, to
determine whether the strings have the same contents.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define sym1 (quote hello))
(define sym2 (quote hello))
(eq? sym1 sym2) ⇒ #t

(define str1 "hello")
(define str2 "hello")
(eq? str1 str2) ⇒ #f
(equal? str1 str2) ⇒ #t
</pre></div>

<p>The second important difference is that symbols, unlike strings, are not
self-evaluating.  This is why we need the <code class="code">(quote …)</code>s in the
example above: <code class="code">(quote hello)</code> evaluates to the symbol named
"hello" itself, whereas an unquoted <code class="code">hello</code> is <em class="emph">read</em> as the
symbol named "hello" and evaluated as a variable reference … about
which more below (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Variables">Symbols as Denoting Variables</a>).
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Data" accesskey="1">Symbols as Discrete Data</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Keys" accesskey="2">Symbols as Lookup Keys</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Variables" accesskey="3">Symbols as Denoting Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Primitives" accesskey="4">Operations Related to Symbols</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax" accesskey="5">Extended Read Syntax for Symbols</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Uninterned" accesskey="6">Uninterned Symbols</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Symbol-Data">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Keys" accesskey="n" rel="next">Symbols as Lookup Keys</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Symbols-as-Discrete-Data">6.6.6.1 Symbols as Discrete Data</h4>

<p>Numbers and symbols are similar to the extent that they both lend
themselves to <code class="code">eq?</code> comparison.  But symbols are more descriptive
than numbers, because a symbol’s name can be used directly to describe
the concept for which that symbol stands.
</p>
<p>For example, imagine that you need to represent some colours in a
computer program.  Using numbers, you would have to choose arbitrarily
some mapping between numbers and colours, and then take care to use that
mapping consistently:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">;; 1=red, 2=green, 3=purple

(if (eq? (colour-of vehicle) 1)
    ...)
</pre></div>

<p>You can make the mapping more explicit and the code more readable by
defining constants:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define red 1)
(define green 2)
(define purple 3)

(if (eq? (colour-of vehicle) red)
    ...)
</pre></div>

<p>But the simplest and clearest approach is not to use numbers at all, but
symbols whose names specify the colours that they refer to:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(if (eq? (colour-of vehicle) 'red)
    ...)
</pre></div>

<p>The descriptive advantages of symbols over numbers increase as the set
of concepts that you want to describe grows.  Suppose that a car object
can have other properties as well, such as whether it has or uses:
</p>
<ul class="itemize mark-bullet">
<li>automatic or manual transmission
</li><li>leaded or unleaded fuel
</li><li>power steering (or not).
</li></ul>

<p>Then a car’s combined property set could be naturally represented and
manipulated as a list of symbols:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(properties-of vehicle1)
⇒
(red manual unleaded power-steering)

(if (memq 'power-steering (properties-of vehicle1))
    (display "Unfit people can drive this vehicle.\n")
    (display "You'll need strong arms to drive this vehicle!\n"))
-|
Unfit people can drive this vehicle.
</pre></div>

<p>Remember, the fundamental property of symbols that we are relying on
here is that an occurrence of <code class="code">'red</code> in one part of a program is an
<em class="emph">indistinguishable</em> symbol from an occurrence of <code class="code">'red</code> in
another part of a program; this means that symbols can usefully be
compared using <code class="code">eq?</code>.  At the same time, symbols have naturally
descriptive names.  This combination of efficiency and descriptive power
makes them ideal for use as discrete data.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Symbol-Keys">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Variables" accesskey="n" rel="next">Symbols as Denoting Variables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Data" accesskey="p" rel="prev">Symbols as Discrete Data</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Symbols-as-Lookup-Keys">6.6.6.2 Symbols as Lookup Keys</h4>

<p>Given their efficiency and descriptive power, it is natural to use
symbols as the keys in an association list or hash table.
</p>
<p>To illustrate this, consider a more structured representation of the car
properties example from the preceding subsection.  Rather than
mixing all the properties up together in a flat list, we could use an
association list like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define car1-properties '((colour . red)
                          (transmission . manual)
                          (fuel . unleaded)
                          (steering . power-assisted)))
</pre></div>

<p>Notice how this structure is more explicit and extensible than the flat
list.  For example it makes clear that <code class="code">manual</code> refers to the
transmission rather than, say, the windows or the locking of the car.
It also allows further properties to use the same symbols among their
possible values without becoming ambiguous:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define car1-properties '((colour . red)
                          (transmission . manual)
                          (fuel . unleaded)
                          (steering . power-assisted)
                          (seat-colour . red)
                          (locking . manual)))
</pre></div>

<p>With a representation like this, it is easy to use the efficient
<code class="code">assq-XXX</code> family of procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists">Association Lists</a>) to
extract or change individual pieces of information:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(assq-ref car1-properties 'fuel) ⇒ unleaded
(assq-ref car1-properties 'transmission) ⇒ manual

(assq-set! car1-properties 'seat-colour 'black)
⇒
((colour . red)
 (transmission . manual)
 (fuel . unleaded)
 (steering . power-assisted)
 (seat-colour . black)
 (locking . manual)))
</pre></div>

<p>Hash tables also have keys, and exactly the same arguments apply to the
use of symbols in hash tables as in association lists.  The hash value
that Guile uses to decide where to add a symbol-keyed entry to a hash
table can be obtained by calling the <code class="code">symbol-hash</code> procedure:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002dhash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-hash</strong> <var class="def-var-arguments">symbol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002dhash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymbol_005fhash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symbol_hash</strong> <var class="def-var-arguments">(symbol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymbol_005fhash"> ¶</a></span></dt>
<dd><p>Return a hash value for <var class="var">symbol</var>.
</p></dd></dl>

<p>See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">Hash Tables</a> for information about hash tables in general, and
for why you might choose to use a hash table rather than an association
list.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Symbol-Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Primitives" accesskey="n" rel="next">Operations Related to Symbols</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Keys" accesskey="p" rel="prev">Symbols as Lookup Keys</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Symbols-as-Denoting-Variables">6.6.6.3 Symbols as Denoting Variables</h4>

<p>When an unquoted symbol in a Scheme program is evaluated, it is
interpreted as a variable reference, and the result of the evaluation is
the appropriate variable’s value.
</p>
<p>For example, when the expression <code class="code">(string-length "abcd")</code> is read
and evaluated, the sequence of characters <code class="code">string-length</code> is read
as the symbol whose name is "string-length".  This symbol is associated
with a variable whose value is the procedure that implements string
length calculation.  Therefore evaluation of the <code class="code">string-length</code>
symbol results in that procedure.
</p>
<p>The details of the connection between an unquoted symbol and the
variable to which it refers are explained elsewhere.  See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs">Definitions and Variable Bindings</a>, for how associations between symbols and variables are
created, and <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Modules">Modules</a>, for how those associations are affected by
Guile’s module system.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Symbol-Primitives">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax" accesskey="n" rel="next">Extended Read Syntax for Symbols</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Variables" accesskey="p" rel="prev">Symbols as Denoting Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Operations-Related-to-Symbols">6.6.6.4 Operations Related to Symbols</h4>

<p>Given any Scheme value, you can determine whether it is a symbol using
the <code class="code">symbol?</code> primitive:
</p>
<a class="index-entry-id" id="index-symbol_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymbol_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symbol_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymbol_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a symbol, otherwise return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fsymbol"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_symbol</strong> <code class="def-code-arguments">(SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fsymbol"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_is_true (scm_symbol_p (val))</code>.
</p></dd></dl>

<p>Once you know that you have a symbol, you can obtain its name as a
string by calling <code class="code">symbol-&gt;string</code>.  Note that Guile differs by
default from R5RS on the details of <code class="code">symbol-&gt;string</code> as regards
case-sensitivity:
</p>
<a class="index-entry-id" id="index-symbol_002d_003estring-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-&gt;string</strong> <var class="def-var-arguments">s</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymbol_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symbol_to_string</strong> <var class="def-var-arguments">(s)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymbol_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return the name of symbol <var class="var">s</var> as a string.  By default, Guile reads
symbols case-sensitively, so the string returned will have the same case
variation as the sequence of characters that caused <var class="var">s</var> to be
created.
</p>
<p>If Guile is set to read symbols case-insensitively (as specified by
R5RS), and <var class="var">s</var> comes into being as part of a literal expression
(see <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Literal-expressions">Literal expressions</a> in <cite class="cite">The Revised^5 Report on Scheme</cite>) or
by a call to the <code class="code">read</code> or <code class="code">string-ci-&gt;symbol</code> procedures,
Guile converts any alphabetic characters in the symbol’s name to
lower case before creating the symbol object, so the string returned
here will be in lower case.
</p>
<p>If <var class="var">s</var> was created by <code class="code">string-&gt;symbol</code>, the case of characters
in the string returned will be the same as that in the string that was
passed to <code class="code">string-&gt;symbol</code>, regardless of Guile’s case-sensitivity
setting at the time <var class="var">s</var> was created.
</p>
<p>It is an error to apply mutation procedures like <code class="code">string-set!</code> to
strings returned by this procedure.
</p></dd></dl>

<p>Most symbols are created by writing them literally in code.  However it
is also possible to create symbols programmatically using the following
procedures:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol</strong> <var class="def-var-arguments">char…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-symbol-1"></a>
<p>Return a newly allocated symbol made from the given character arguments.
</p>
<div class="example">
<pre class="example-preformatted">(symbol #\x #\y #\z) ⇒ xyz
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003esymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;symbol</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003esymbol"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-list_002d_003esymbol-1"></a>
<p>Return a newly allocated symbol made from a list of characters.
</p>
<div class="example">
<pre class="example-preformatted">(list-&gt;symbol '(#\a #\b #\c)) ⇒ abc
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-symbol_002dappend-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002dappend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-append</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002dappend"> ¶</a></span></dt>
<dd><p>Return a newly allocated symbol whose characters form the
concatenation of the given symbols, <var class="var">arg</var> <small class="enddots">...</small>.
</p>
<div class="example">
<pre class="example-preformatted">(let ((h 'hello))
  (symbol-append h 'world))
⇒ helloworld
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-string_002d_003esymbol-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003esymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;symbol</strong> <var class="def-var-arguments">string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003esymbol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005fsymbol"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_symbol</strong> <var class="def-var-arguments">(string)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005fsymbol"> ¶</a></span></dt>
<dd><p>Return the symbol whose name is <var class="var">string</var>.  This procedure can create
symbols with names containing special characters or letters in the
non-standard case, but it is usually a bad idea to create such symbols
because in some implementations of Scheme they cannot be read as
themselves.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dci_002d_003esymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-ci-&gt;symbol</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dci_002d_003esymbol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fci_005fto_005fsymbol"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_ci_to_symbol</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fci_005fto_005fsymbol"> ¶</a></span></dt>
<dd><p>Return the symbol whose name is <var class="var">str</var>.  If Guile is currently
reading symbols case-insensitively, <var class="var">str</var> is converted to lowercase
before the returned symbol is looked up or created.
</p></dd></dl>

<p>The following examples illustrate Guile’s detailed behaviour as regards
the case-sensitivity of symbols:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(read-enable 'case-insensitive)   ; R5RS compliant behaviour

(symbol-&gt;string 'flying-fish)    ⇒ "flying-fish"
(symbol-&gt;string 'Martin)         ⇒ "martin"
(symbol-&gt;string
   (string-&gt;symbol "Malvina"))   ⇒ "Malvina"

(eq? 'mISSISSIppi 'mississippi)  ⇒ #t
(string-&gt;symbol "mISSISSIppi")   ⇒ mISSISSIppi
(eq? 'bitBlt (string-&gt;symbol "bitBlt")) ⇒ #f
(eq? 'LolliPop
  (string-&gt;symbol (symbol-&gt;string 'LolliPop))) ⇒ #t
(string=? "K. Harper, M.D."
  (symbol-&gt;string
    (string-&gt;symbol "K. Harper, M.D."))) ⇒ #t

(read-disable 'case-insensitive)   ; Guile default behaviour

(symbol-&gt;string 'flying-fish)    ⇒ "flying-fish"
(symbol-&gt;string 'Martin)         ⇒ "Martin"
(symbol-&gt;string
   (string-&gt;symbol "Malvina"))   ⇒ "Malvina"

(eq? 'mISSISSIppi 'mississippi)  ⇒ #f
(string-&gt;symbol "mISSISSIppi")   ⇒ mISSISSIppi
(eq? 'bitBlt (string-&gt;symbol "bitBlt")) ⇒ #t
(eq? 'LolliPop
  (string-&gt;symbol (symbol-&gt;string 'LolliPop))) ⇒ #t
(string=? "K. Harper, M.D."
  (symbol-&gt;string
    (string-&gt;symbol "K. Harper, M.D."))) ⇒ #t
</pre></div>

<p>From C, there are lower level functions that construct a Scheme symbol
from a C string in the current locale encoding.
</p>
<p>When you want to do more from C, you should convert between symbols
and strings using <code class="code">scm_symbol_to_string</code> and
<code class="code">scm_string_to_symbol</code> and work with the strings.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flatin1_005fsymbol"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_latin1_symbol</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flatin1_005fsymbol"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf8_005fsymbol"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf8_symbol</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf8_005fsymbol"> ¶</a></span></dt>
<dd><p>Construct and return a Scheme symbol whose name is specified by the
null-terminated C string <var class="var">name</var>.  These are appropriate when
the C string is hard-coded in the source code.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flocale_005fsymbol"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_symbol</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fsymbol"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005flocale_005fsymboln"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_symboln</strong> <code class="def-code-arguments">(const char *name, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fsymboln"> ¶</a></span></dt>
<dd><p>Construct and return a Scheme symbol whose name is specified by
<var class="var">name</var>.  For <code class="code">scm_from_locale_symbol</code>, <var class="var">name</var> must be null
terminated; for <code class="code">scm_from_locale_symboln</code> the length of <var class="var">name</var> is
specified explicitly by <var class="var">len</var>.
</p>
<p>Note that these functions should <em class="emph">not</em> be used when <var class="var">name</var> is a
C string constant, because there is no guarantee that the current locale
will match that of the execution character set, used for string and
character constants.  Most modern C compilers use UTF-8 by default, so
in such cases we recommend <code class="code">scm_from_utf8_symbol</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ftake_005flocale_005fsymbol"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_locale_symbol</strong> <code class="def-code-arguments">(char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005flocale_005fsymbol"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005flocale_005fsymboln"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_locale_symboln</strong> <code class="def-code-arguments">(char *str, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005flocale_005fsymboln"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_from_locale_symbol</code> and <code class="code">scm_from_locale_symboln</code>,
respectively, but also frees <var class="var">str</var> with <code class="code">free</code> eventually.
Thus, you can use this function when you would free <var class="var">str</var> anyway
immediately after creating the Scheme string.  In certain cases, Guile
can then use <var class="var">str</var> directly as its internal representation.
</p></dd></dl>

<p>The size of a symbol can also be obtained from C:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fsymbol_005flength"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_symbol_length</strong> <code class="def-code-arguments">(SCM sym)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fsymbol_005flength"> ¶</a></span></dt>
<dd><p>Return the number of characters in <var class="var">sym</var>.
</p></dd></dl>

<p>Finally, some applications, especially those that generate new Scheme
code dynamically, need to generate symbols for use in the generated
code.  The <code class="code">gensym</code> primitive meets this need:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-gensym"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gensym</strong> <var class="def-var-arguments">[prefix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gensym"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgensym"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gensym</strong> <var class="def-var-arguments">(prefix)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgensym"> ¶</a></span></dt>
<dd><p>Create a new symbol with a name constructed from a prefix and a counter
value.  The string <var class="var">prefix</var> can be specified as an optional
argument.  Default prefix is ‘<samp class="samp">&nbsp;g<!-- /@w --></samp>’.  The counter is increased by 1
at each call.  There is no provision for resetting the counter.
</p></dd></dl>

<p>The symbols generated by <code class="code">gensym</code> are <em class="emph">likely</em> to be unique,
since their names begin with a space and it is only otherwise possible
to generate such symbols if a programmer goes out of their way to do
so.  Uniqueness can be guaranteed by instead using uninterned symbols
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Uninterned">Uninterned Symbols</a>), though they can’t be usefully written out
and read back in.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Symbol-Read-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Uninterned" accesskey="n" rel="next">Uninterned Symbols</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Primitives" accesskey="p" rel="prev">Operations Related to Symbols</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Extended-Read-Syntax-for-Symbols">6.6.6.5 Extended Read Syntax for Symbols</h4>

<a class="index-entry-id" id="index-r7rs_002dsymbols"></a>

<p>The read syntax for a symbol is a sequence of letters, digits, and
<em class="dfn">extended alphabetic characters</em>, beginning with a character that
cannot begin a number.  In addition, the special cases of <code class="code">+</code>,
<code class="code">-</code>, and <code class="code">...</code> are read as symbols even though numbers can
begin with <code class="code">+</code>, <code class="code">-</code> or <code class="code">.</code>.
</p>
<p>Extended alphabetic characters may be used within identifiers as if
they were letters.  The set of extended alphabetic characters is:
</p>
<div class="example">
<pre class="example-preformatted">! $ % &amp; * + - . / : &lt; = &gt; ? @ ^ _ ~
</pre></div>

<p>In addition to the standard read syntax defined above (which is taken
from R5RS (see <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Formal-syntax">Formal syntax</a> in <cite class="cite">The Revised^5 Report on
Scheme</cite>)), Guile provides an extended symbol read syntax that allows the
inclusion of unusual characters such as space characters, newlines and
parentheses.  If (for whatever reason) you need to write a symbol
containing characters not mentioned above, you can do so as follows.
</p>
<ul class="itemize mark-bullet">
<li>Begin the symbol with the characters <code class="code">#{</code>,

</li><li>write the characters of the symbol and

</li><li>finish the symbol with the characters <code class="code">}#</code>.
</li></ul>

<p>Here are a few examples of this form of read syntax.  The first symbol
needs to use extended syntax because it contains a space character, the
second because it contains a line break, and the last because it looks
like a number.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#{foo bar}#

#{what
ever}#

#{4242}#
</pre></div>

<p>Although Guile provides this extended read syntax for symbols,
widespread usage of it is discouraged because it is not portable and not
very readable.
</p>
<p>Alternatively, if you enable the <code class="code">r7rs-symbols</code> read option (see
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>), you can write arbitrary symbols using the same
notation used for strings, except delimited by vertical bars instead of
double quotes.
</p>
<div class="example">
<pre class="example-preformatted">|foo bar|
|\x3BB; is a greek lambda|
|\| is a vertical bar|
</pre></div>

<p>Note that there’s also an <code class="code">r7rs-symbols</code> print option
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write">Writing Scheme Values</a>).  To enable the use of this notation, evaluate
one or both of the following expressions:
</p>
<div class="example">
<pre class="example-preformatted">(read-enable  'r7rs-symbols)
(print-enable 'r7rs-symbols)
</pre></div>


<hr>
</div>
<div class="subsubsection-level-extent" id="Symbol-Uninterned">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax" accesskey="p" rel="prev">Extended Read Syntax for Symbols</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="u" rel="up">Symbols</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Uninterned-Symbols">6.6.6.6 Uninterned Symbols</h4>

<p>What makes symbols useful is that they are automatically kept unique.
There are no two symbols that are distinct objects but have the same
name.  But of course, there is no rule without exception.  In addition
to the normal symbols that have been discussed up to now, you can also
create special <em class="dfn">uninterned</em> symbols that behave slightly
differently.
</p>
<p>To understand what is different about them and why they might be useful,
we look at how normal symbols are actually kept unique.
</p>
<p>Whenever Guile wants to find the symbol with a specific name, for
example during <code class="code">read</code> or when executing <code class="code">string-&gt;symbol</code>, it
first looks into a table of all existing symbols to find out whether a
symbol with the given name already exists.  When this is the case, Guile
just returns that symbol.  When not, a new symbol with the name is
created and entered into the table so that it can be found later.
</p>
<p>Sometimes you might want to create a symbol that is guaranteed ‘fresh’,
i.e. a symbol that did not exist previously.  You might also want to
somehow guarantee that no one else will ever unintentionally stumble
across your symbol in the future.  These properties of a symbol are
often needed when generating code during macro expansion.  When
introducing new temporary variables, you want to guarantee that they
don’t conflict with variables in other people’s code.
</p>
<p>The simplest way to arrange for this is to create a new symbol but
not enter it into the global table of all symbols.  That way, no one
will ever get access to your symbol by chance.  Symbols that are not in
the table are called <em class="dfn">uninterned</em>.  Of course, symbols that
<em class="emph">are</em> in the table are called <em class="dfn">interned</em>.
</p>
<p>You create new uninterned symbols with the function <code class="code">make-symbol</code>.
You can test whether a symbol is interned or not with
<code class="code">symbol-interned?</code>.
</p>
<p>Uninterned symbols break the rule that the name of a symbol uniquely
identifies the symbol object.  Because of this, they can not be written
out and read back in like interned symbols.  Currently, Guile has no
support for reading uninterned symbols.  Note that the function
<code class="code">gensym</code> does not return uninterned symbols for this reason.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-symbol</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsymbol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fsymbol"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_symbol</strong> <var class="def-var-arguments">(name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fsymbol"> ¶</a></span></dt>
<dd><p>Return a new uninterned symbol with the name <var class="var">name</var>.  The returned
symbol is guaranteed to be unique and future calls to
<code class="code">string-&gt;symbol</code> will not return it.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002dinterned_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-interned?</strong> <var class="def-var-arguments">symbol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002dinterned_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymbol_005finterned_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symbol_interned_p</strong> <var class="def-var-arguments">(symbol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymbol_005finterned_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">symbol</var> is interned, otherwise return
<code class="code">#f</code>.
</p></dd></dl>

<p>For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define foo-1 (string-&gt;symbol "foo"))
(define foo-2 (string-&gt;symbol "foo"))
(define foo-3 (make-symbol "foo"))
(define foo-4 (make-symbol "foo"))

(eq? foo-1 foo-2)
⇒ #t
; Two interned symbols with the same name are the same object,

(eq? foo-1 foo-3)
⇒ #f
; but a call to make-symbol with the same name returns a
; distinct object.

(eq? foo-3 foo-4)
⇒ #f
; A call to make-symbol always returns a new object, even for
; the same name.

foo-3
⇒ #&lt;uninterned-symbol foo 8085290&gt;
; Uninterned symbols print differently from interned symbols,

(symbol? foo-3)
⇒ #t
; but they are still symbols,

(symbol-interned? foo-3)
⇒ #f
; just not interned.
</pre></div>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Keywords">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pairs" accesskey="n" rel="next">Pairs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Symbols" accesskey="p" rel="prev">Symbols</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Keywords-1">6.6.7 Keywords</h4>
<a class="index-entry-id" id="index-Keywords"></a>

<p>Keywords are self-evaluating objects with a convenient read syntax that
makes them easy to type.
</p>
<p>Guile’s keyword support conforms to R5RS, and adds a (switchable) read
syntax extension to permit keywords to begin with <code class="code">:</code> as well as
<code class="code">#:</code>, or to end with <code class="code">:</code>.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Why-Use-Keywords_003f" accesskey="1">Why Use Keywords?</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Coding-With-Keywords" accesskey="2">Coding With Keywords</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Read-Syntax" accesskey="3">Keyword Read Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Procedures" accesskey="4">Keyword Procedures</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Why-Use-Keywords_003f">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Coding-With-Keywords" accesskey="n" rel="next">Coding With Keywords</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="u" rel="up">Keywords</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Why-Use-Keywords_003f-1">6.6.7.1 Why Use Keywords?</h4>

<p>Keywords are useful in contexts where a program or procedure wants to be
able to accept a large number of optional arguments without making its
interface unmanageable.
</p>
<p>To illustrate this, consider a hypothetical <code class="code">make-window</code>
procedure, which creates a new window on the screen for drawing into
using some graphical toolkit.  There are many parameters that the caller
might like to specify, but which could also be sensibly defaulted, for
example:
</p>
<ul class="itemize mark-bullet">
<li>color depth – Default: the color depth for the screen

</li><li>background color – Default: white

</li><li>width – Default: 600

</li><li>height – Default: 400
</li></ul>

<p>If <code class="code">make-window</code> did not use keywords, the caller would have to
pass in a value for each possible argument, remembering the correct
argument order and using a special value to indicate the default value
for that argument:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-window 'default              ;; Color depth
             'default              ;; Background color
             800                   ;; Width
             100                   ;; Height
             …)                  ;; More make-window arguments
</pre></div>

<p>With keywords, on the other hand, defaulted arguments are omitted, and
non-default arguments are clearly tagged by the appropriate keyword.  As
a result, the invocation becomes much clearer:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-window #:width 800 #:height 100)
</pre></div>

<p>On the other hand, for a simpler procedure with few arguments, the use
of keywords would be a hindrance rather than a help.  The primitive
procedure <code class="code">cons</code>, for example, would not be improved if it had to
be invoked as
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(cons #:car x #:cdr y)
</pre></div>

<p>So the decision whether to use keywords or not is purely pragmatic: use
them if they will clarify the procedure invocation at point of call.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Coding-With-Keywords">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Read-Syntax" accesskey="n" rel="next">Keyword Read Syntax</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Why-Use-Keywords_003f" accesskey="p" rel="prev">Why Use Keywords?</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="u" rel="up">Keywords</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Coding-With-Keywords-1">6.6.7.2 Coding With Keywords</h4>

<p>If a procedure wants to support keywords, it should take a rest argument
and then use whatever means is convenient to extract keywords and their
corresponding arguments from the contents of that rest argument.
</p>
<p>The following example illustrates the principle: the code for
<code class="code">make-window</code> uses a helper procedure called
<code class="code">get-keyword-value</code> to extract individual keyword arguments from
the rest argument.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (get-keyword-value args keyword default)
  (let ((kv (memq keyword args)))
    (if (and kv (&gt;= (length kv) 2))
        (cadr kv)
        default)))

(define (make-window . args)
  (let ((depth  (get-keyword-value args #:depth  screen-depth))
        (bg     (get-keyword-value args #:bg     "white"))
        (width  (get-keyword-value args #:width  800))
        (height (get-keyword-value args #:height 100))
        …)
    …))
</pre></div>

<p>But you don’t need to write <code class="code">get-keyword-value</code>.  The <code class="code">(ice-9
optargs)</code> module provides a set of powerful macros that you can use to
implement keyword-supporting procedures like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 optargs))

(define (make-window . args)
  (let-keywords args #f ((depth  screen-depth)
                         (bg     "white")
                         (width  800)
                         (height 100))
    ...))
</pre></div>

<p>Or, even more economically, like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 optargs))

(define* (make-window #:key (depth  screen-depth)
                            (bg     "white")
                            (width  800)
                            (height 100))
  ...)
</pre></div>

<p>For further details on <code class="code">let-keywords</code>, <code class="code">define*</code> and other
facilities provided by the <code class="code">(ice-9 optargs)</code> module, see
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments">Optional Arguments</a>.
</p>
<p>To handle keyword arguments from procedures implemented in C,
use <code class="code">scm_c_bind_keyword_arguments</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Procedures">Keyword Procedures</a>).
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Keyword-Read-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Procedures" accesskey="n" rel="next">Keyword Procedures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Coding-With-Keywords" accesskey="p" rel="prev">Coding With Keywords</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="u" rel="up">Keywords</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Keyword-Read-Syntax-1">6.6.7.3 Keyword Read Syntax</h4>

<p>Guile, by default, only recognizes a keyword syntax that is compatible
with R5RS.  A token of the form <code class="code">#:NAME</code>, where <code class="code">NAME</code> has the
same syntax as a Scheme symbol (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax">Extended Read Syntax for Symbols</a>), is the
external representation of the keyword named <code class="code">NAME</code>.  Keyword
objects print using this syntax as well, so values containing keyword
objects can be read back into Guile.  When used in an expression,
keywords are self-quoting objects.
</p>
<p>If the <code class="code">keywords</code> read option is set to <code class="code">'prefix</code>, Guile also
recognizes the alternative read syntax <code class="code">:NAME</code>.  Otherwise, tokens
of the form <code class="code">:NAME</code> are read as symbols, as required by R5RS.
</p>
<a class="index-entry-id" id="index-SRFI_002d88-keyword-syntax"></a>

<p>If the <code class="code">keywords</code> read option is set to <code class="code">'postfix</code>, Guile
recognizes the SRFI-88 read syntax <code class="code">NAME:</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d88">SRFI-88 Keyword Objects</a>).
Otherwise, tokens of this form are read as symbols.
</p>
<p>To enable and disable the alternative non-R5RS keyword syntax, you use
the <code class="code">read-set!</code> procedure documented <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>.  Note that
the <code class="code">prefix</code> and <code class="code">postfix</code> syntax are mutually exclusive.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(read-set! keywords 'prefix)

#:type
⇒
#:type

:type
⇒
#:type

(read-set! keywords 'postfix)

type:
⇒
#:type

:type
⇒
:type

(read-set! keywords #f)

#:type
⇒
#:type

:type
-|
ERROR: In expression :type:
ERROR: Unbound variable: :type
ABORT: (unbound-variable)
</pre></div>

<hr>
</div>
<div class="subsubsection-level-extent" id="Keyword-Procedures">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Read-Syntax" accesskey="p" rel="prev">Keyword Read Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="u" rel="up">Keywords</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Keyword-Procedures-1">6.6.7.4 Keyword Procedures</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-keyword_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">keyword?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-keyword_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fkeyword_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_keyword_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fkeyword_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the argument <var class="var">obj</var> is a keyword, else
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-keyword_002d_003esymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">keyword-&gt;symbol</strong> <var class="def-var-arguments">keyword</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-keyword_002d_003esymbol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fkeyword_005fto_005fsymbol"><span class="category-def">C Function: </span><span><strong class="def-name">scm_keyword_to_symbol</strong> <var class="def-var-arguments">(keyword)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fkeyword_005fto_005fsymbol"> ¶</a></span></dt>
<dd><p>Return the symbol with the same name as <var class="var">keyword</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002d_003ekeyword"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-&gt;keyword</strong> <var class="def-var-arguments">symbol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002d_003ekeyword"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymbol_005fto_005fkeyword"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symbol_to_keyword</strong> <var class="def-var-arguments">(symbol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymbol_005fto_005fkeyword"> ¶</a></span></dt>
<dd><p>Return the keyword with the same name as <var class="var">symbol</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fkeyword"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_keyword</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fkeyword"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_is_true (scm_keyword_p (<var class="var">obj</var>))</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flocale_005fkeyword"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_keyword</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fkeyword"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005flocale_005fkeywordn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_locale_keywordn</strong> <code class="def-code-arguments">(const char *name, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flocale_005fkeywordn"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_symbol_to_keyword (scm_from_locale_symbol
(<var class="var">name</var>))</code> and <code class="code">scm_symbol_to_keyword (scm_from_locale_symboln
(<var class="var">name</var>, <var class="var">len</var>))</code>, respectively.
</p>
<p>Note that these functions should <em class="emph">not</em> be used when <var class="var">name</var> is a
C string constant, because there is no guarantee that the current locale
will match that of the execution character set, used for string and
character constants.  Most modern C compilers use UTF-8 by default, so
in such cases we recommend <code class="code">scm_from_utf8_keyword</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005flatin1_005fkeyword"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_latin1_keyword</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005flatin1_005fkeyword"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ffrom_005futf8_005fkeyword"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_utf8_keyword</strong> <code class="def-code-arguments">(const char *name)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005futf8_005fkeyword"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_symbol_to_keyword (scm_from_latin1_symbol
(<var class="var">name</var>))</code> and <code class="code">scm_symbol_to_keyword (scm_from_utf8_symbol
(<var class="var">name</var>))</code>, respectively.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fbind_005fkeyword_005farguments"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bind_keyword_arguments</strong> <code class="def-code-arguments">(const char *subr,                              SCM rest, scm_t_keyword_arguments_flags flags,                              SCM keyword1, SCM *argp1,                              …,                              SCM keywordN, SCM *argpN,                              <code class="code">SCM_UNDEFINED</code>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbind_005fkeyword_005farguments"> ¶</a></span></dt>
<dd>
<p>Extract the specified keyword arguments from <var class="var">rest</var>, which is not
modified.  If the keyword argument <var class="var">keyword1</var> is present in
<var class="var">rest</var> with an associated value, that value is stored in the
variable pointed to by <var class="var">argp1</var>, otherwise the variable is left
unchanged.  Similarly for the other keywords and argument pointers up to
<var class="var">keywordN</var> and <var class="var">argpN</var>.  The argument list to
<code class="code">scm_c_bind_keyword_arguments</code> must be terminated by
<code class="code">SCM_UNDEFINED</code>.
</p>
<p>Note that since the variables pointed to by <var class="var">argp1</var> through
<var class="var">argpN</var> are left unchanged if the associated keyword argument is not
present, they should be initialized to their default values before
calling <code class="code">scm_c_bind_keyword_arguments</code>.  Alternatively, you can
initialize them to <code class="code">SCM_UNDEFINED</code> before the call, and then use
<code class="code">SCM_UNBNDP</code> after the call to see which ones were provided.
</p>
<p>If an unrecognized keyword argument is present in <var class="var">rest</var> and
<var class="var">flags</var> does not contain <code class="code">SCM_ALLOW_OTHER_KEYS</code>, or if
non-keyword arguments are present and <var class="var">flags</var> does not contain
<code class="code">SCM_ALLOW_NON_KEYWORD_ARGUMENTS</code>, an exception is raised.
<var class="var">subr</var> should be the name of the procedure receiving the keyword
arguments, for purposes of error reporting.
</p>
<p>For example:
</p>
<div class="example">
<pre class="example-preformatted">SCM k_delimiter;
SCM k_grammar;
SCM sym_infix;

SCM my_string_join (SCM strings, SCM rest)
{
  SCM delimiter = SCM_UNDEFINED;
  SCM grammar   = sym_infix;

  scm_c_bind_keyword_arguments ("my-string-join", rest, 0,
                                k_delimiter, &amp;delimiter,
                                k_grammar, &amp;grammar,
                                SCM_UNDEFINED);

  if (SCM_UNBNDP (delimiter))
    delimiter = scm_from_utf8_string (" ");

  return scm_string_join (strings, delimiter, grammar);
}

void my_init ()
{
  k_delimiter = scm_from_utf8_keyword ("delimiter");
  k_grammar   = scm_from_utf8_keyword ("grammar");
  sym_infix   = scm_from_utf8_symbol  ("infix");
  scm_c_define_gsubr ("my-string-join", 1, 0, 1, my_string_join);
}
</pre></div>
</dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Pairs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="n" rel="next">Lists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keywords" accesskey="p" rel="prev">Keywords</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Pairs-1">6.6.8 Pairs</h4>
<a class="index-entry-id" id="index-Pairs"></a>

<p>Pairs are used to combine two Scheme objects into one compound object.
Hence the name: A pair stores a pair of objects.
</p>
<p>The data type <em class="dfn">pair</em> is extremely important in Scheme, just like in
any other Lisp dialect.  The reason is that pairs are not only used to
make two values available as one object, but that pairs are used for
constructing lists of values.  Because lists are so important in Scheme,
they are described in a section of their own (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lists">Lists</a>).
</p>
<p>Pairs can literally get entered in source code or at the REPL, in the
so-called <em class="dfn">dotted list</em> syntax.  This syntax consists of an opening
parentheses, the first element of the pair, a dot, the second element
and a closing parentheses.  The following example shows how a pair
consisting of the two numbers 1 and 2, and a pair containing the symbols
<code class="code">foo</code> and <code class="code">bar</code> can be entered.  It is very important to write
the whitespace before and after the dot, because otherwise the Scheme
parser would not be able to figure out where to split the tokens.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(1 . 2)
(foo . bar)
</pre></div>

<p>But beware, if you want to try out these examples, you have to
<em class="dfn">quote</em> the expressions.  More information about quotation is
available in the section <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Expression-Syntax">Expression Syntax</a>.  The correct way
to try these examples is as follows.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">'(1 . 2)
⇒
(1 . 2)
'(foo . bar)
⇒
(foo . bar)
</pre></div>

<p>A new pair is made by calling the procedure <code class="code">cons</code> with two
arguments.  Then the argument values are stored into a newly allocated
pair, and the pair is returned.  The name <code class="code">cons</code> stands for
"construct".  Use the procedure <code class="code">pair?</code> to test whether a
given Scheme object is a pair or not.
</p>
<a class="index-entry-id" id="index-cons-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-cons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cons</strong> <var class="def-var-arguments">x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cons"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcons"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cons</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcons"> ¶</a></span></dt>
<dd><p>Return a newly allocated pair whose car is <var class="var">x</var> and whose
cdr is <var class="var">y</var>.  The pair is guaranteed to be different (in the
sense of <code class="code">eq?</code>) from every previously existing object.
</p></dd></dl>

<a class="index-entry-id" id="index-pair_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-pair_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pair?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pair_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpair_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pair_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpair_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is a pair; otherwise return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fpair"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_pair</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fpair"> ¶</a></span></dt>
<dd><p>Return 1 when <var class="var">x</var> is a pair; otherwise return 0.
</p></dd></dl>

<p>The two parts of a pair are traditionally called <em class="dfn">car</em> and
<em class="dfn">cdr</em>.  They can be retrieved with procedures of the same name
(<code class="code">car</code> and <code class="code">cdr</code>), and can be modified with the procedures
<code class="code">set-car!</code> and <code class="code">set-cdr!</code>.
</p>
<p>Since a very common operation in Scheme programs is to access the car of
a car of a pair, or the car of the cdr of a pair, etc., the procedures
called <code class="code">caar</code>, <code class="code">cadr</code> and so on are also predefined.  However,
using these procedures is often detrimental to readability, and
error-prone.  Thus, accessing the contents of a list is usually better
achieved using pattern matching techniques (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Pattern-Matching">Pattern Matching</a>).
</p>
<a class="index-entry-id" id="index-car-2"></a>
<a class="index-entry-id" id="index-cdr-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-car"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">car</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-car"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_car</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdr"> ¶</a></span></dt>
<dd><p>Return the car or the cdr of <var class="var">pair</var>, respectively.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fCAR"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_CAR</strong> <code class="def-code-arguments">(SCM pair)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fCAR"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fCDR"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_CDR</strong> <code class="def-code-arguments">(SCM pair)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fCDR"> ¶</a></span></dt>
<dd><p>These two macros are the fastest way to access the car or cdr of a
pair; they can be thought of as compiling into a single memory
reference.
</p>
<p>These macros do no checking at all.  The argument <var class="var">pair</var> must be a
valid pair.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-cddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cddar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cddar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cadar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cadar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cddddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cddddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cddddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdddar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdddar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cddadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cddadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cddadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cddaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cddaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cddaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdaddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdadar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdadar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdaadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdaadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdaadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cdaaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cdaaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cdaaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cadddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cadddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cadddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caddar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caddar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cadadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cadadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cadadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cadaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cadaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cadaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caaddr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caadar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caadar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caaadr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caaadr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caaadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-caaaar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">caaaar</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-caaaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcddar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cddar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcadar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cadar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcddddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cddddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcddddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdddar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdddar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcddadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cddadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcddadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcddaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cddaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcddaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdaddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdaddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdadar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdadar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdaadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdaadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdaadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcdaaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cdaaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcdaaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcadddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cadddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcadddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaddar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caddar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaddar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcadadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cadadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcadadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcadaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cadaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcadaar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaaddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caaddr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaadar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caadar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaadar"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaaadr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caaadr</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaaadr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcaaaar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_caaaar</strong> <var class="def-var-arguments">(pair)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcaaaar"> ¶</a></span></dt>
<dd><p>These procedures are compositions of <code class="code">car</code> and <code class="code">cdr</code>, where
for example <code class="code">caddr</code> could be defined by
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define caddr (lambda (x) (car (cdr (cdr x)))))
</pre></div>

<p><code class="code">cadr</code>, <code class="code">caddr</code> and <code class="code">cadddr</code> pick out the second, third
or fourth elements of a list, respectively.  SRFI-1 provides the same
under the names <code class="code">second</code>, <code class="code">third</code> and <code class="code">fourth</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors">Selectors</a>).
</p></dd></dl>

<a class="index-entry-id" id="index-set_002dcar_0021-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002dcar_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-car!</strong> <var class="def-var-arguments">pair value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcar_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcar_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_car_x</strong> <var class="def-var-arguments">(pair, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcar_005fx"> ¶</a></span></dt>
<dd><p>Stores <var class="var">value</var> in the car field of <var class="var">pair</var>.  The value returned
by <code class="code">set-car!</code> is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-set_002dcdr_0021-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002dcdr_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-cdr!</strong> <var class="def-var-arguments">pair value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcdr_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcdr_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_cdr_x</strong> <var class="def-var-arguments">(pair, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcdr_005fx"> ¶</a></span></dt>
<dd><p>Stores <var class="var">value</var> in the cdr field of <var class="var">pair</var>.  The value returned
by <code class="code">set-cdr!</code> is unspecified.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Lists">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="n" rel="next">Vectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pairs" accesskey="p" rel="prev">Pairs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Lists-1">6.6.9 Lists</h4>
<a class="index-entry-id" id="index-Lists"></a>

<p>A very important data type in Scheme—as well as in all other Lisp
dialects—is the data type <em class="dfn">list</em>.<a class="footnote" id="DOCF8" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT8"><sup>8</sup></a>
</p>
<p>This is the short definition of what a list is:
</p>
<ul class="itemize mark-bullet">
<li>Either the empty list <code class="code">()</code>,

</li><li>or a pair which has a list in its cdr.
</li></ul>





<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Syntax" accesskey="1">List Read Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Predicates" accesskey="2">List Predicates</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Constructors" accesskey="3">List Constructors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Selection" accesskey="4">List Selection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Append_002fReverse" accesskey="5">Append and Reverse</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification" accesskey="6">List Modification</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching" accesskey="7">List Searching</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#List-Mapping" accesskey="8">List Mapping</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="List-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Predicates" accesskey="n" rel="next">List Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Read-Syntax">6.6.9.1 List Read Syntax</h4>

<p>The syntax for lists is an opening parentheses, then all the elements of
the list (separated by whitespace) and finally a closing
parentheses.<a class="footnote" id="DOCF9" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT9"><sup>9</sup></a>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(1 2 3)            ; <span class="r">a list of the numbers 1, 2 and 3</span>
("foo" bar 3.1415) ; <span class="r">a string, a symbol and a real number</span>
()                 ; <span class="r">the empty list</span>
</pre></div>

<p>The last example needs a bit more explanation.  A list with no elements,
called the <em class="dfn">empty list</em>, is special in some ways.  It is used for
terminating lists by storing it into the cdr of the last pair that makes
up a list.  An example will clear that up:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(car '(1))
⇒
1
(cdr '(1))
⇒
()
</pre></div>

<p>This example also shows that lists have to be quoted when written
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Expression-Syntax">Expression Syntax</a>), because they would otherwise be
mistakingly taken as procedure applications (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Invocation">Simple Procedure Invocation</a>).
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="List-Predicates">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Constructors" accesskey="n" rel="next">List Constructors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Syntax" accesskey="p" rel="prev">List Read Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Predicates-1">6.6.9.2 List Predicates</h4>

<p>Often it is useful to test whether a given Scheme object is a list or
not.  List-processing procedures could use this information to test
whether their input is valid, or they could do different things
depending on the datatype of their arguments.
</p>
<a class="index-entry-id" id="index-list_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-list_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is a proper list, else <code class="code">#f</code>.
</p></dd></dl>

<p>The predicate <code class="code">null?</code> is often used in list-processing code to
tell whether a given list has run out of elements.  That is, a loop
somehow deals with the elements of a list until the list satisfies
<code class="code">null?</code>.  Then, the algorithm terminates.
</p>
<a class="index-entry-id" id="index-null_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-null_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">null?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-null_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnull_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_null_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnull_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is the empty list, else <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fnull"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_null</strong> <code class="def-code-arguments">(SCM x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fnull"> ¶</a></span></dt>
<dd><p>Return 1 when <var class="var">x</var> is the empty list; otherwise return 0.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="List-Constructors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Selection" accesskey="n" rel="next">List Selection</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Predicates" accesskey="p" rel="prev">List Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Constructors-1">6.6.9.3 List Constructors</h4>

<p>This section describes the procedures for constructing new lists.
<code class="code">list</code> simply returns a list where the elements are the arguments,
<code class="code">cons*</code> is similar, but the last argument is stored in the cdr of
the last pair of the list.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-list-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list</strong> <var class="def-var-arguments">elem …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005f1"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_1</strong> <var class="def-var-arguments">(elem1)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005f1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005f2"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_2</strong> <var class="def-var-arguments">(elem1, elem2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005f2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005f3"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_3</strong> <var class="def-var-arguments">(elem1, elem2, elem3)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005f3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005f4"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_4</strong> <var class="def-var-arguments">(elem1, elem2, elem3, elem4)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005f4"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005f5"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_5</strong> <var class="def-var-arguments">(elem1, elem2, elem3, elem4, elem5)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005f5"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fn"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_n</strong> <var class="def-var-arguments">(elem1, …, elemN, <code class="code">SCM_UNDEFINED</code>)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fn"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-list-3"></a>
<p>Return a new list containing elements <var class="var">elem</var> <small class="enddots">...</small>.
</p>
<p><code class="code">scm_list_n</code> takes a variable number of arguments, terminated by
the special <code class="code">SCM_UNDEFINED</code>.  That final <code class="code">SCM_UNDEFINED</code> is
not included in the list.  None of <var class="var">elem</var> … can
themselves be <code class="code">SCM_UNDEFINED</code>, or <code class="code">scm_list_n</code> will
terminate at that point.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-cons_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cons*</strong> <var class="def-var-arguments">arg1 arg2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cons_002a"> ¶</a></span></dt>
<dd><p>Like <code class="code">list</code>, but the last arg provides the tail of the
constructed list, returning <code class="code">(cons <var class="var">arg1</var> (cons
<var class="var">arg2</var> (cons … <var class="var">argn</var>)))</code>.  Requires at least one
argument.  If given one argument, that argument is returned as
result.  This function is called <code class="code">list*</code> in some other
Schemes and in Common LISP.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-copy</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_copy</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fcopy"> ¶</a></span></dt>
<dd><p>Return a (newly-created) copy of <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-list</strong> <var class="def-var-arguments">n [init]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dlist"> ¶</a></span></dt>
<dd><p>Create a list containing of <var class="var">n</var> elements, where each element is
initialized to <var class="var">init</var>.  <var class="var">init</var> defaults to the empty list
<code class="code">()</code> if not given.
</p></dd></dl>

<p>Note that <code class="code">list-copy</code> only makes a copy of the pairs which make up
the spine of the lists.  The list elements are not copied, which means
that modifying the elements of the new list also modifies the elements
of the old list.  On the other hand, applying procedures like
<code class="code">set-cdr!</code> or <code class="code">delv!</code> to the new list will not alter the old
list.  If you also need to copy the list elements (making a deep copy),
use the procedure <code class="code">copy-tree</code> from <code class="code">(ice-9 copy-tree)</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Copying">Copying Deep Structures</a>).
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="List-Selection">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Append_002fReverse" accesskey="n" rel="next">Append and Reverse</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Constructors" accesskey="p" rel="prev">List Constructors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Selection-1">6.6.9.4 List Selection</h4>

<p>These procedures are used to get some information about a list, or to
retrieve one or more elements of a list.
</p>
<a class="index-entry-id" id="index-length-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-length"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">length</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-length"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_length</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flength"> ¶</a></span></dt>
<dd><p>Return the number of elements in list <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-last_002dpair"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">last-pair</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-last_002dpair"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flast_005fpair"><span class="category-def">C Function: </span><span><strong class="def-name">scm_last_pair</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flast_005fpair"> ¶</a></span></dt>
<dd><p>Return the last pair in <var class="var">lst</var>, signalling an error if
<var class="var">lst</var> is circular.
</p></dd></dl>

<a class="index-entry-id" id="index-list_002dref-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-list_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-ref</strong> <var class="def-var-arguments">list k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_ref</strong> <var class="def-var-arguments">(list, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fref"> ¶</a></span></dt>
<dd><p>Return the <var class="var">k</var>th element from <var class="var">list</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-list_002dtail-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-list_002dtail"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-tail</strong> <var class="def-var-arguments">lst k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dtail"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002dcdr_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-cdr-ref</strong> <var class="def-var-arguments">lst k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dcdr_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005ftail"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_tail</strong> <var class="def-var-arguments">(lst, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005ftail"> ¶</a></span></dt>
<dd><p>Return the "tail" of <var class="var">lst</var> beginning with its <var class="var">k</var>th element.
The first element of the list is considered to be element 0.
</p>
<p><code class="code">list-tail</code> and <code class="code">list-cdr-ref</code> are identical.  It may help to
think of <code class="code">list-cdr-ref</code> as accessing the <var class="var">k</var>th cdr of the list,
or returning the results of cdring <var class="var">k</var> times down <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dhead"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-head</strong> <var class="def-var-arguments">lst k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dhead"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fhead"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_head</strong> <var class="def-var-arguments">(lst, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fhead"> ¶</a></span></dt>
<dd><p>Copy the first <var class="var">k</var> elements from <var class="var">lst</var> into a new list, and
return it.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Append_002fReverse">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification" accesskey="n" rel="next">List Modification</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Selection" accesskey="p" rel="prev">List Selection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Append-and-Reverse">6.6.9.5 Append and Reverse</h4>

<p><code class="code">append</code> and <code class="code">append!</code> are used to concatenate two or more
lists in order to form a new list.  <code class="code">reverse</code> and <code class="code">reverse!</code>
return lists with the same elements as their arguments, but in reverse
order.  The procedure variants with an <code class="code">!</code> directly modify the
pairs which form the list, whereas the other procedures create new
pairs.  This is why you should be careful when using the side-effecting
variants.
</p>
<a class="index-entry-id" id="index-append-4"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-append"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append</strong> <var class="def-var-arguments">lst … obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-append-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-append_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append!</strong> <var class="def-var-arguments">lst … obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-append_0021-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_0021-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fappend"><span class="category-def">C Function: </span><span><strong class="def-name">scm_append</strong> <var class="def-var-arguments">(lstlst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fappend"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fappend_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_append_x</strong> <var class="def-var-arguments">(lstlst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fappend_005fx"> ¶</a></span></dt>
<dd><p>Return a list comprising all the elements of lists <var class="var">lst</var> …
<var class="var">obj</var>.  If called with no arguments, return the empty list.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(append '(x) '(y))          ⇒  (x y)
(append '(a) '(b c d))      ⇒  (a b c d)
(append '(a (b)) '((c)))    ⇒  (a (b) (c))
</pre></div>

<p>The last argument <var class="var">obj</var> may actually be any object; an improper
list results if the last argument is not a proper list.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(append '(a b) '(c . d))    ⇒  (a b c . d)
(append '() 'a)             ⇒  a
</pre></div>

<p><code class="code">append</code> doesn’t modify the given lists, but the return may share
structure with the final <var class="var">obj</var>.  <code class="code">append!</code> is permitted, but
not required, to modify the given lists to form its return.
</p>
<p>For <code class="code">scm_append</code> and <code class="code">scm_append_x</code>, <var class="var">lstlst</var> is a list
of the list operands <var class="var">lst</var> … <var class="var">obj</var>.  That <var class="var">lstlst</var>
itself is not modified or used in the return.
</p></dd></dl>

<a class="index-entry-id" id="index-reverse-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-reverse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reverse</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reverse"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-reverse_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reverse!</strong> <var class="def-var-arguments">lst [newtail]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reverse_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freverse"><span class="category-def">C Function: </span><span><strong class="def-name">scm_reverse</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freverse"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freverse_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_reverse_x</strong> <var class="def-var-arguments">(lst, newtail)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freverse_005fx"> ¶</a></span></dt>
<dd><p>Return a list comprising the elements of <var class="var">lst</var>, in reverse order.
</p>
<p><code class="code">reverse</code> constructs a new list.  <code class="code">reverse!</code> is permitted, but
not required, to modify <var class="var">lst</var> in constructing its return.
</p>
<p>For <code class="code">reverse!</code>, the optional <var class="var">newtail</var> is appended to the
result.  <var class="var">newtail</var> isn’t reversed, it simply becomes the list
tail.  For <code class="code">scm_reverse_x</code>, the <var class="var">newtail</var> parameter is
mandatory, but can be <code class="code">SCM_EOL</code> if no further tail is required.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="List-Modification">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching" accesskey="n" rel="next">List Searching</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Append_002fReverse" accesskey="p" rel="prev">Append and Reverse</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Modification-1">6.6.9.6 List Modification</h4>

<p>The following procedures modify an existing list, either by changing
elements of the list, or by changing the list structure itself.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-list_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-set!</strong> <var class="def-var-arguments">list k val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_set_x</strong> <var class="def-var-arguments">(list, k, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the <var class="var">k</var>th element of <var class="var">list</var> to <var class="var">val</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dcdr_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-cdr-set!</strong> <var class="def-var-arguments">list k val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dcdr_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fcdr_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_cdr_set_x</strong> <var class="def-var-arguments">(list, k, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fcdr_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the <var class="var">k</var>th cdr of <var class="var">list</var> to <var class="var">val</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delq</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delq</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelq"> ¶</a></span></dt>
<dd><p>Return a newly-created copy of <var class="var">lst</var> with elements
<code class="code">eq?</code> to <var class="var">item</var> removed.  This procedure mirrors
<code class="code">memq</code>: <code class="code">delq</code> compares elements of <var class="var">lst</var> against
<var class="var">item</var> with <code class="code">eq?</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delv</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delv</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelv"> ¶</a></span></dt>
<dd><p>Return a newly-created copy of <var class="var">lst</var> with elements
<code class="code">eqv?</code> to <var class="var">item</var> removed.  This procedure mirrors
<code class="code">memv</code>: <code class="code">delv</code> compares elements of <var class="var">lst</var> against
<var class="var">item</var> with <code class="code">eqv?</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelete"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delete</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelete"> ¶</a></span></dt>
<dd><p>Return a newly-created copy of <var class="var">lst</var> with elements
<code class="code">equal?</code> to <var class="var">item</var> removed.  This procedure mirrors
<code class="code">member</code>: <code class="code">delete</code> compares elements of <var class="var">lst</var>
against <var class="var">item</var> with <code class="code">equal?</code>.
</p>
<p>See also SRFI-1 which has an extended <code class="code">delete</code> (<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Deleting">Deleting</a>), and also an <code class="code">lset-difference</code> which can delete
multiple <var class="var">item</var>s in one call (<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Set-Operations">Set Operations on Lists</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delq_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delq!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delq_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-delv_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delv!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delv_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-delete_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelq_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delq_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelq_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelv_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delv_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelv_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelete_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delete_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelete_005fx"> ¶</a></span></dt>
<dd><p>These procedures are destructive versions of <code class="code">delq</code>, <code class="code">delv</code>
and <code class="code">delete</code>: they modify the pointers in the existing <var class="var">lst</var>
rather than creating a new list.  Caveat evaluator: Like other
destructive list functions, these functions cannot modify the binding of
<var class="var">lst</var>, and so cannot be used to delete the first element of
<var class="var">lst</var> destructively.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delq1_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delq1!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delq1_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelq1_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delq1_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelq1_005fx"> ¶</a></span></dt>
<dd><p>Like <code class="code">delq!</code>, but only deletes the first occurrence of
<var class="var">item</var> from <var class="var">lst</var>.  Tests for equality using
<code class="code">eq?</code>.  See also <code class="code">delv1!</code> and <code class="code">delete1!</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delv1_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delv1!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delv1_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelv1_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delv1_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelv1_005fx"> ¶</a></span></dt>
<dd><p>Like <code class="code">delv!</code>, but only deletes the first occurrence of
<var class="var">item</var> from <var class="var">lst</var>.  Tests for equality using
<code class="code">eqv?</code>.  See also <code class="code">delq1!</code> and <code class="code">delete1!</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delete1_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete1!</strong> <var class="def-var-arguments">item lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete1_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelete1_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delete1_x</strong> <var class="def-var-arguments">(item, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelete1_005fx"> ¶</a></span></dt>
<dd><p>Like <code class="code">delete!</code>, but only deletes the first occurrence of
<var class="var">item</var> from <var class="var">lst</var>.  Tests for equality using
<code class="code">equal?</code>.  See also <code class="code">delq1!</code> and <code class="code">delv1!</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-filter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">filter</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-filter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-filter_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">filter!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-filter_0021"> ¶</a></span></dt>
<dd><p>Return a list containing all elements from <var class="var">lst</var> which satisfy the
predicate <var class="var">pred</var>.  The elements in the result list have the same
order as in <var class="var">lst</var>.  The order in which <var class="var">pred</var> is applied to
the list elements is not specified.
</p>
<p><code class="code">filter</code> does not change <var class="var">lst</var>, but the result may share a
tail with it.  <code class="code">filter!</code> may modify <var class="var">lst</var> to construct its
return.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="List-Searching">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Mapping" accesskey="n" rel="next">List Mapping</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification" accesskey="p" rel="prev">List Modification</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Searching-1">6.6.9.7 List Searching</h4>

<p>The following procedures search lists for particular elements.  They use
different comparison predicates for comparing list elements with the
object to be searched.  When they fail, they return <code class="code">#f</code>, otherwise
they return the sublist whose car is equal to the search object, where
equality depends on the equality predicate used.
</p>
<a class="index-entry-id" id="index-memq-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-memq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">memq</strong> <var class="def-var-arguments">x lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-memq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmemq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_memq</strong> <var class="def-var-arguments">(x, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmemq"> ¶</a></span></dt>
<dd><p>Return the first sublist of <var class="var">lst</var> whose car is <code class="code">eq?</code>
to <var class="var">x</var> where the sublists of <var class="var">lst</var> are the non-empty
lists returned by <code class="code">(list-tail <var class="var">lst</var> <var class="var">k</var>)</code> for
<var class="var">k</var> less than the length of <var class="var">lst</var>.  If <var class="var">x</var> does not
occur in <var class="var">lst</var>, then <code class="code">#f</code> (not the empty list) is
returned.
</p></dd></dl>

<a class="index-entry-id" id="index-memv-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-memv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">memv</strong> <var class="def-var-arguments">x lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-memv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmemv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_memv</strong> <var class="def-var-arguments">(x, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmemv"> ¶</a></span></dt>
<dd><p>Return the first sublist of <var class="var">lst</var> whose car is <code class="code">eqv?</code>
to <var class="var">x</var> where the sublists of <var class="var">lst</var> are the non-empty
lists returned by <code class="code">(list-tail <var class="var">lst</var> <var class="var">k</var>)</code> for
<var class="var">k</var> less than the length of <var class="var">lst</var>.  If <var class="var">x</var> does not
occur in <var class="var">lst</var>, then <code class="code">#f</code> (not the empty list) is
returned.
</p></dd></dl>

<a class="index-entry-id" id="index-member-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-member"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">member</strong> <var class="def-var-arguments">x lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-member"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmember"><span class="category-def">C Function: </span><span><strong class="def-name">scm_member</strong> <var class="def-var-arguments">(x, lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmember"> ¶</a></span></dt>
<dd><p>Return the first sublist of <var class="var">lst</var> whose car is
<code class="code">equal?</code> to <var class="var">x</var> where the sublists of <var class="var">lst</var> are
the non-empty lists returned by <code class="code">(list-tail <var class="var">lst</var>
<var class="var">k</var>)</code> for <var class="var">k</var> less than the length of <var class="var">lst</var>.  If
<var class="var">x</var> does not occur in <var class="var">lst</var>, then <code class="code">#f</code> (not the
empty list) is returned.
</p>
<p>See also SRFI-1 which has an extended <code class="code">member</code> function
(<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching">Searching</a>).
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="List-Mapping">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching" accesskey="p" rel="prev">List Searching</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="u" rel="up">Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="List-Mapping-1">6.6.9.8 List Mapping</h4>

<p>List processing is very convenient in Scheme because the process of
iterating over the elements of a list can be highly abstracted.  The
procedures in this section are the most basic iterating procedures for
lists.  They take a procedure and one or more lists as arguments, and
apply the procedure to each element of the list.  They differ in their
return value.
</p>
<a class="index-entry-id" id="index-map-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-map"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">map</strong> <var class="def-var-arguments">proc arg1 arg2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-map"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-map_002din_002dorder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">map-in-order</strong> <var class="def-var-arguments">proc arg1 arg2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-map_002din_002dorder"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmap"><span class="category-def">C Function: </span><span><strong class="def-name">scm_map</strong> <var class="def-var-arguments">(proc, arg1, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmap"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to each element of the list <var class="var">arg1</var> (if only two
arguments are given), or to the corresponding elements of the argument
lists (if more than two arguments are given).  The result(s) of the
procedure applications are saved and returned in a list.  For
<code class="code">map</code>, the order of procedure applications is not specified,
<code class="code">map-in-order</code> applies the procedure from left to right to the list
elements.
</p></dd></dl>

<a class="index-entry-id" id="index-for_002deach-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-for_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">for-each</strong> <var class="def-var-arguments">proc arg1 arg2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-for_002deach"> ¶</a></span></dt>
<dd><p>Like <code class="code">map</code>, but the procedure is always applied from left to right,
and the result(s) of the procedure applications are thrown away.  The
return value is not specified.
</p></dd></dl>

<p>See also SRFI-1 which extends these functions to take lists of unequal
lengths (<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Fold-and-Map">Fold, Unfold &amp; Map</a>).
</p>
<hr>
</div>
</div>
<div class="subsection-level-extent" id="Vectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bit-Vectors" accesskey="n" rel="next">Bit Vectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lists" accesskey="p" rel="prev">Lists</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Vectors-1">6.6.10 Vectors</h4>
<a class="index-entry-id" id="index-Vectors"></a>

<p>Vectors are sequences of Scheme objects.  Unlike lists, the length of a
vector, once the vector is created, cannot be changed.  The advantage of
vectors over lists is that the time required to access one element of a vector
given its <em class="dfn">position</em> (synonymous with <em class="dfn">index</em>), a zero-origin number,
is constant, whereas lists have an access time linear to the position of the
accessed element in the list.
</p>
<p>Vectors can contain any kind of Scheme object; it is even possible to
have different types of objects in the same vector.  For vectors
containing vectors, you may wish to use <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a> instead.
Note, too, that vectors are a special case of one dimensional
non-uniform arrays and that array procedures operate happily on vectors.
</p>
<p>Also see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43">SRFI-43 - Vector Library</a>, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support">R6RS Support</a>, or <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">R7RS Support</a>, for
more comprehensive vector libraries.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Syntax" accesskey="1">Read Syntax for Vectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Creation" accesskey="2">Dynamic Vector Creation and Validation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessors" accesskey="3">Accessing and Modifying Vector Contents</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C" accesskey="4">Vector Accessing from C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Uniform-Numeric-Vectors" accesskey="5">Uniform Numeric Vectors</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Vector-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Creation" accesskey="n" rel="next">Dynamic Vector Creation and Validation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="u" rel="up">Vectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Read-Syntax-for-Vectors">6.6.10.1 Read Syntax for Vectors</h4>

<p>Vectors can literally be entered in source code, just like strings,
characters or some of the other data types.  The read syntax for vectors
is as follows: A sharp sign (<code class="code">#</code>), followed by an opening
parentheses, all elements of the vector in their respective read syntax,
and finally a closing parentheses.  Like strings, vectors do not have to
be quoted.
</p>
<p>The following are examples of the read syntax for vectors; where the
first vector only contains numbers and the second three different object
types: a string, a symbol and a number in hexadecimal notation.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#(1 2 3)
#("Hello" foo #xdeadbeef)
</pre></div>

<hr>
</div>
<div class="subsubsection-level-extent" id="Vector-Creation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessors" accesskey="n" rel="next">Accessing and Modifying Vector Contents</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Syntax" accesskey="p" rel="prev">Read Syntax for Vectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="u" rel="up">Vectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Dynamic-Vector-Creation-and-Validation">6.6.10.2 Dynamic Vector Creation and Validation</h4>

<p>Instead of creating a vector implicitly by using the read syntax just
described, you can create a vector dynamically by calling one of the
<code class="code">vector</code> and <code class="code">list-&gt;vector</code> primitives with the list of Scheme
values that you want to place into a vector.  The size of the vector
thus created is determined implicitly by the number of arguments given.
</p>
<a class="index-entry-id" id="index-vector-3"></a>
<a class="index-entry-id" id="index-list_002d_003evector-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003evector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;vector</strong> <var class="def-var-arguments">l</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003evector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector</strong> <var class="def-var-arguments">(l)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector"> ¶</a></span></dt>
<dd><p>Return a newly allocated vector composed of the
given arguments.  Analogous to <code class="code">list</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(vector 'a 'b 'c) ⇒ #(a b c)
</pre></div>
</dd></dl>

<p>The inverse operation is <code class="code">vector-&gt;list</code>:
</p>
<a class="index-entry-id" id="index-vector_002d_003elist-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-&gt;list</strong> <var class="def-var-arguments">v</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_to_list</strong> <var class="def-var-arguments">(v)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fto_005flist"> ¶</a></span></dt>
<dd><p>Return a newly allocated list composed of the elements of <var class="var">v</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(vector-&gt;list #(dah dah didah)) ⇒  (dah dah didah)
(list-&gt;vector '(dididit dah)) ⇒  #(dididit dah)
</pre></div>
</dd></dl>

<p>To allocate a vector with an explicitly specified size, use
<code class="code">make-vector</code>.  With this primitive you can also specify an initial
value for the vector elements (the same value for all elements, that
is):
</p>
<a class="index-entry-id" id="index-make_002dvector-4"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-vector</strong> <var class="def-var-arguments">len [fill]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dvector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fvector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_vector</strong> <var class="def-var-arguments">(len, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fvector"> ¶</a></span></dt>
<dd><p>Return a newly allocated vector of <var class="var">len</var> elements.  If a
second argument is given, then each position is initialized to
<var class="var">fill</var>.  Otherwise the initial contents of each position is
unspecified.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmake_005fvector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_vector</strong> <code class="def-code-arguments">(size_t k, SCM fill)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fvector"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_make_vector</code>, but the length is given as a <code class="code">size_t</code>.
</p></dd></dl>

<p>To check whether an arbitrary Scheme value <em class="emph">is</em> a vector, use the
<code class="code">vector?</code> primitive:
</p>
<a class="index-entry-id" id="index-vector_003f-4"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a vector, otherwise return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fvector"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_vector</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fvector"> ¶</a></span></dt>
<dd><p>Return non-zero when <var class="var">obj</var> is a vector, otherwise return
<code class="code">zero</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Vector-Accessors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C" accesskey="n" rel="next">Vector Accessing from C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Creation" accesskey="p" rel="prev">Dynamic Vector Creation and Validation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="u" rel="up">Vectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Accessing-and-Modifying-Vector-Contents">6.6.10.3 Accessing and Modifying Vector Contents</h4>

<p><code class="code">vector-length</code> and <code class="code">vector-ref</code> return information about a
given vector, respectively its size and the elements that are contained
in the vector.
</p>
<a class="index-entry-id" id="index-vector_002dlength-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-length</strong> <var class="def-var-arguments">vector</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_length</strong> <var class="def-var-arguments">(vector)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005flength"> ¶</a></span></dt>
<dd><p>Return the number of elements in <var class="var">vector</var> as an exact integer.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fvector_005flength"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_vector_length</strong> <code class="def-code-arguments">(SCM vec)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fvector_005flength"> ¶</a></span></dt>
<dd><p>Return the number of elements in <var class="var">vec</var> as a <code class="code">size_t</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-vector_002dref-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-ref</strong> <var class="def-var-arguments">vec k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_ref</strong> <var class="def-var-arguments">(vec, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fref"> ¶</a></span></dt>
<dd><p>Return the contents of position <var class="var">k</var> of <var class="var">vec</var>.
<var class="var">k</var> must be a valid index of <var class="var">vec</var>.
</p><div class="example lisp">
<pre class="lisp-preformatted">(vector-ref #(1 1 2 3 5 8 13 21) 5) ⇒ 8
(vector-ref #(1 1 2 3 5 8 13 21)
    (let ((i (round (* 2 (acos -1)))))
      (if (inexact? i)
        (inexact-&gt;exact i)
           i))) ⇒ 13
</pre></div>
</dd></dl>

<a class="anchor" id="x_002dscm_005fc_005fvector_005fref"></a><dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fvector_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_vector_ref</strong> <code class="def-code-arguments">(SCM vec, size_t k)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fvector_005fref"> ¶</a></span></dt>
<dd><p>Return the contents of position <var class="var">k</var> (a <code class="code">size_t</code>) of
<var class="var">vec</var>.
</p></dd></dl>

<p>A vector created by one of the dynamic vector constructor procedures
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Creation">Dynamic Vector Creation and Validation</a>) can be modified using the following
procedures.
</p>
<p><em class="emph">NOTE:</em> According to R5RS, it is an error to use any of these
procedures on a literally read vector, because such vectors should be
considered as constants.  Currently, however, Guile does not detect this
error.
</p>
<a class="index-entry-id" id="index-vector_002dset_0021-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-set!</strong> <var class="def-var-arguments">vec k obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_set_x</strong> <var class="def-var-arguments">(vec, k, obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">obj</var> in position <var class="var">k</var> of <var class="var">vec</var>.
<var class="var">k</var> must be a valid index of <var class="var">vec</var>.
The value returned by ‘<samp class="samp">vector-set!</samp>’ is unspecified.
</p><div class="example lisp">
<pre class="lisp-preformatted">(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec) ⇒  #(0 ("Sue" "Sue") "Anna")
</pre></div>
</dd></dl>

<a class="anchor" id="x_002dscm_005fc_005fvector_005fset_005fx"></a><dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fvector_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_vector_set_x</strong> <code class="def-code-arguments">(SCM vec, size_t k, SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fvector_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">obj</var> in position <var class="var">k</var> (a <code class="code">size_t</code>) of <var class="var">vec</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-vector_002dfill_0021-3"></a>
<a class="anchor" id="x_002dvector_002dfill_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-vector_002dfill_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-fill!</strong> <var class="def-var-arguments">vec fill [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dfill_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005ffill_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_fill_x</strong> <var class="def-var-arguments">(vec, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005ffill_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">fill</var> in every position of <var class="var">vec</var> in the range
[<var class="var">start</var> ... <var class="var">end</var>). <var class="var">start</var> defaults to 0 and <var class="var">end</var>
defaults to the length of <var class="var">vec</var>.
</p>
<p>The value returned by <code class="code">vector-fill!</code> is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-vector_002dcopy-2"></a>
<a class="anchor" id="x_002dvector_002dcopy"></a><dl class="first-deffn">
<dt class="deffn" id="index-vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-copy</strong> <var class="def-var-arguments">vec [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_copy</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fcopy"> ¶</a></span></dt>
<dd><p>Returns a freshly allocated vector containing the elements of <var class="var">vec</var>
in the range [<var class="var">start</var> ... <var class="var">end</var>). <var class="var">start</var> defaults to 0 and
<var class="var">end</var> defaults to the length of <var class="var">vec</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-vector_002dcopy_0021-2"></a>
<a class="anchor" id="x_002dvector_002dcopy_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dcopy_0021"> ¶</a></span></dt>
<dd><p>Copy the block of elements from vector <var class="var">src</var> in the range
[<var class="var">start</var> ... <var class="var">end</var>) into vector <var class="var">dst</var>, starting at position
<var class="var">at</var>. <var class="var">at</var> and <var class="var">start</var> default to 0 and <var class="var">end</var> defaults
to the length of <var class="var">src</var>.
</p>
<p>It is an error for <var class="var">dst</var> to have a length less than <var class="var">at</var> +
(<var class="var">end</var> - <var class="var">start</var>).  
</p>
<p>The order in which elements are copied is unspecified, except that if the
source and destination overlap, copying takes place as if the source is
first copied into a temporary vector and then into the destination.
</p>
<p>The value returned by <code class="code">vector-copy!</code> is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vector_002dmove_002dleft_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-move-left!</strong> <var class="def-var-arguments">vec1 start1 end1 vec2 start2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dmove_002dleft_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fmove_005fleft_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_move_left_x</strong> <var class="def-var-arguments">(vec1, start1, end1, vec2, start2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fmove_005fleft_005fx"> ¶</a></span></dt>
<dd><p>Copy elements from <var class="var">vec1</var>, positions <var class="var">start1</var> to <var class="var">end1</var>,
to <var class="var">vec2</var> starting at position <var class="var">start2</var>.  <var class="var">start1</var> and
<var class="var">start2</var> are inclusive indices; <var class="var">end1</var> is exclusive.
</p>
<p><code class="code">vector-move-left!</code> copies elements in leftmost order.
Therefore, in the case where <var class="var">vec1</var> and <var class="var">vec2</var> refer to the
same vector, <code class="code">vector-move-left!</code> is usually appropriate when
<var class="var">start1</var> is greater than <var class="var">start2</var>.
</p>
<p>The value returned by <code class="code">vector-move-left!</code> is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vector_002dmove_002dright_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vector-move-right!</strong> <var class="def-var-arguments">vec1 start1 end1 vec2 start2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dmove_002dright_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvector_005fmove_005fright_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_vector_move_right_x</strong> <var class="def-var-arguments">(vec1, start1, end1, vec2, start2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fmove_005fright_005fx"> ¶</a></span></dt>
<dd><p>Copy elements from <var class="var">vec1</var>, positions <var class="var">start1</var> to <var class="var">end1</var>,
to <var class="var">vec2</var> starting at position <var class="var">start2</var>.  <var class="var">start1</var> and
<var class="var">start2</var> are inclusive indices; <var class="var">end1</var> is exclusive.
</p>
<p><code class="code">vector-move-right!</code> copies elements in rightmost order.
Therefore, in the case where <var class="var">vec1</var> and <var class="var">vec2</var> refer to the
same vector, <code class="code">vector-move-right!</code> is usually appropriate when
<var class="var">start1</var> is less than <var class="var">start2</var>.
</p>
<p>The value returned by <code class="code">vector-move-right!</code> is unspecified.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Vector-Accessing-from-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Uniform-Numeric-Vectors" accesskey="n" rel="next">Uniform Numeric Vectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessors" accesskey="p" rel="prev">Accessing and Modifying Vector Contents</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="u" rel="up">Vectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Vector-Accessing-from-C-1">6.6.10.4 Vector Accessing from C</h4>

<p>A vector can be read and modified from C with the functions
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dscm_005fc_005fvector_005fref"><code class="code">scm_c_vector_ref</code></a> and
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dscm_005fc_005fvector_005fset_005fx"><code class="code">scm_c_vector_set_x</code></a>.  In addition to
these functions, there are two other ways to access vectors from C that
might be more efficient in certain situations: you can use the unsafe
<em class="emph">vector macros</em>; or you can use the general framework for accessing
all kinds of arrays (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Arrays-from-C">Accessing Arrays from C</a>), which is more
verbose, but can deal efficiently with all kinds of vectors (and
arrays).  For arrays of rank 1 whose backing store is a vector, you can
use the <code class="code">scm_vector_elements</code> and
<code class="code">scm_vector_writable_elements</code> functions as shortcuts.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSIMPLE_005fVECTOR_005fLENGTH"><span class="category-def">C Macro: </span><span><code class="def-type">size_t</code> <strong class="def-name">SCM_SIMPLE_VECTOR_LENGTH</strong> <code class="def-code-arguments">(SCM vec)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSIMPLE_005fVECTOR_005fLENGTH"> ¶</a></span></dt>
<dd><p>Evaluates to the length of the vector <var class="var">vec</var>.  No type
checking is done.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSIMPLE_005fVECTOR_005fREF"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_SIMPLE_VECTOR_REF</strong> <code class="def-code-arguments">(SCM vec, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSIMPLE_005fVECTOR_005fREF"> ¶</a></span></dt>
<dd><p>Evaluates to the element at position <var class="var">idx</var> in the vector <var class="var">vec</var>.
No type or range checking is done.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSIMPLE_005fVECTOR_005fSET"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SIMPLE_VECTOR_SET</strong> <code class="def-code-arguments">(SCM vec, size_t idx, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSIMPLE_005fVECTOR_005fSET"> ¶</a></span></dt>
<dd><p>Sets the element at position <var class="var">idx</var> in the vector <var class="var">vec</var> to
<var class="var">val</var>.  No type or range checking is done.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fvector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const SCM *</code> <strong class="def-name">scm_vector_elements</strong> <code class="def-code-arguments">(SCM array, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005felements"> ¶</a></span></dt>
<dd><p>Acquire a <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Arrays-from-C">handle</a> for <var class="var">array</var> and
return a read-only pointer to its elements.  <var class="var">array</var> must be either
a vector, or an array of rank 1 whose backing store is a vector;
otherwise an error is signaled.  The handle must eventually be released
with <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dscm_005farray_005fhandle_005frelease"><code class="code">scm_array_handle_release</code></a>.
</p>
<p>The variables pointed to by <var class="var">lenp</var> and <var class="var">incp</var> are filled with
the number of elements of the array and the increment (number of
elements) between successive elements, respectively.  Successive
elements of <var class="var">array</var> need not be contiguous in their underlying
“root vector” returned here; hence the increment is not necessarily
equal to 1 and may well be negative too (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Arrays">Shared Arrays</a>).
</p>
<p>The following example shows the typical way to use this function.  It
creates a list of all elements of <var class="var">array</var> (in reverse order).
</p>
<div class="example">
<pre class="example-preformatted">scm_t_array_handle handle;
size_t i, len;
ssize_t inc;
const SCM *elt;
SCM list;

elt = scm_vector_elements (array, &amp;handle, &amp;len, &amp;inc);
list = SCM_EOL;
for (i = 0; i &lt; len; i++, elt += inc)
  list = scm_cons (*elt, list);
scm_array_handle_release (&amp;handle);
</pre></div>

</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fvector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">SCM *</code> <strong class="def-name">scm_vector_writable_elements</strong> <code class="def-code-arguments">(SCM array, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvector_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_vector_elements</code> but the pointer can be used to modify
the array.
</p>
<p>The following example shows the typical way to use this function.  It
fills an array with <code class="code">#t</code>.
</p>
<div class="example">
<pre class="example-preformatted">scm_t_array_handle handle;
size_t i, len;
ssize_t inc;
SCM *elt;

elt = scm_vector_writable_elements (array, &amp;handle, &amp;len, &amp;inc);
for (i = 0; i &lt; len; i++, elt += inc)
  *elt = SCM_BOOL_T;
scm_array_handle_release (&amp;handle);
</pre></div>

</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Uniform-Numeric-Vectors">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C" accesskey="p" rel="prev">Vector Accessing from C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="u" rel="up">Vectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Uniform-Numeric-Vectors-1">6.6.10.5 Uniform Numeric Vectors</h4>

<p>A uniform numeric vector is a vector whose elements are all of a single
numeric type.  Guile offers uniform numeric vectors for signed and
unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes of
floating point values, and complex floating-point numbers of these two
sizes. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4">SRFI-4 - Homogeneous numeric vector datatypes</a>, for more information.
</p>
<p>For many purposes, bytevectors work just as well as uniform vectors, and have
the advantage that they integrate well with binary input and output.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>, for more information on bytevectors.
</p>
<hr>
</div>
</div>
<div class="subsection-level-extent" id="Bit-Vectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="n" rel="next">Bytevectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vectors" accesskey="p" rel="prev">Vectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Bit-Vectors-1">6.6.11 Bit Vectors</h4>

<p>Bit vectors are zero-origin, one-dimensional arrays of booleans.  They
are displayed as a sequence of <code class="code">0</code>s and <code class="code">1</code>s prefixed by
<code class="code">#*</code>, e.g.,
</p>
<div class="example">
<pre class="example-preformatted">(make-bitvector 8 #f) ⇒
#*00000000
</pre></div>

<p>Bit vectors are the special case of one dimensional bit arrays, and can
thus be used with the array procedures, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> when <var class="var">obj</var> is a bitvector, else
return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dbitvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-bitvector</strong> <var class="def-var-arguments">len [fill]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dbitvector"> ¶</a></span></dt>
<dd><p>Create a new bitvector of length <var class="var">len</var> and
optionally initialize all elements to <var class="var">fill</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector</strong> <var class="def-var-arguments">bit …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector"> ¶</a></span></dt>
<dd><p>Create a new bitvector with the arguments as elements.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dlength"> ¶</a></span></dt>
<dd><p>Return the length of the bitvector <var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dbit_002dset_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-bit-set?</strong> <var class="def-var-arguments">vec idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dbit_002dset_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bitvector_002dbit_002dclear_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-bit-clear?</strong> <var class="def-var-arguments">vec idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dbit_002dclear_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the bit at index <var class="var">idx</var> of the bitvector
<var class="var">vec</var> is set (for <code class="code">bitvector-bit-set?</code>) or clear (for
<code class="code">bitvector-bit-clear?</code>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dset_002dbit_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-set-bit!</strong> <var class="def-var-arguments">vec idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dset_002dbit_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bitvector_002dclear_002dbit_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-clear-bit!</strong> <var class="def-var-arguments">vec idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dclear_002dbit_0021"> ¶</a></span></dt>
<dd><p>Set (for <code class="code">bitvector-set-bit!</code>) or clear (for
<code class="code">bitvector-clear-bit!</code>) the bit at index <var class="var">idx</var> of the bitvector
<var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dset_002dall_002dbits_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-set-all-bits!</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dset_002dall_002dbits_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bitvector_002dclear_002dall_002dbits_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-clear-all-bits!</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dclear_002dall_002dbits_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bitvector_002dflip_002dall_002dbits_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-flip-all-bits!</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dflip_002dall_002dbits_0021"> ¶</a></span></dt>
<dd><p>Set, clear, or flip all bits of <var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003ebitvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;bitvector</strong> <var class="def-var-arguments">list</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003ebitvector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fbitvector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_bitvector</strong> <var class="def-var-arguments">(list)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fbitvector"> ¶</a></span></dt>
<dd><p>Return a new bitvector initialized with the elements
of <var class="var">list</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbitvector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bitvector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fto_005flist"> ¶</a></span></dt>
<dd><p>Return a new list initialized with the elements
of the bitvector <var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-copy</strong> <var class="def-var-arguments">bitvector [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbitvector_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bitvector_copy</strong> <var class="def-var-arguments">(bitvector, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fcopy"> ¶</a></span></dt>
<dd><p>Returns a freshly allocated bitvector containing the elements of <var class="var">bitvector</var>
in the range [<var class="var">start</var> ... <var class="var">end</var>). <var class="var">start</var> defaults to 0 and
<var class="var">end</var> defaults to the length of <var class="var">bitvector</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-count</strong> <var class="def-var-arguments">bitvector</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dcount"> ¶</a></span></dt>
<dd><p>Return a count of how many entries in <var class="var">bitvector</var> are set.
</p>
<div class="example">
<pre class="example-preformatted">(bitvector-count #*000111000)  ⇒ 3
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dcount_002dbits"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-count-bits</strong> <var class="def-var-arguments">bitvector bits</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dcount_002dbits"> ¶</a></span></dt>
<dd><p>Return a count of how many entries in <var class="var">bitvector</var> are set, with the
bitvector <var class="var">bits</var> selecting the entries to consider.  <var class="var">bitvector</var>
must be at least as long as <var class="var">bits</var>.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example-preformatted">(bitvector-count-bits #*01110111 #*11001101) ⇒ 3
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dposition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-position</strong> <var class="def-var-arguments">bitvector bool start</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dposition"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbitvector_005fposition"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bitvector_position</strong> <var class="def-var-arguments">(bitvector, bool, start)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fposition"> ¶</a></span></dt>
<dd><p>Return the index of the first occurrence of <var class="var">bool</var> in
<var class="var">bitvector</var>, starting from <var class="var">start</var>.  If there is no <var class="var">bool</var>
entry between <var class="var">start</var> and the end of <var class="var">bitvector</var>, then return
<code class="code">#f</code>.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(bitvector-position #*000101 #t 0)  ⇒ 3
(bitvector-position #*0001111 #f 3) ⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dset_002dbits_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-set-bits!</strong> <var class="def-var-arguments">bitvector bits</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dset_002dbits_0021"> ¶</a></span></dt>
<dd><p>Set entries of <var class="var">bitvector</var> to <code class="code">#t</code>, with <var class="var">bits</var> selecting
the bits to set.  The return value is unspecified.  <var class="var">bitvector</var> must
be at least as long as <var class="var">bits</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define bv (bitvector-copy #*11000010))
(bitvector-set-bits! bv #*10010001)
bv
⇒ #*11010011
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bitvector_002dclear_002dbits_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bitvector-clear-bits!</strong> <var class="def-var-arguments">bitvector bits</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dclear_002dbits_0021"> ¶</a></span></dt>
<dd><p>Set entries of <var class="var">bitvector</var> to <code class="code">#f</code>, with <var class="var">bits</var> selecting
the bits to clear.  The return value is unspecified.  <var class="var">bitvector</var>
must be at least as long as <var class="var">bits</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define bv (bitvector-copy #*11000010))
(bitvector-clear-bits! bv #*10010001)
bv
⇒ #*01000010
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fbitvector"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_bitvector</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fbitvector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fmake_005fbitvector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_bitvector</strong> <code class="def-code-arguments">(size_t len, SCM fill)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fbitvector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fbitvector_005fbit_005fis_005fset"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_bitvector_bit_is_set</strong> <code class="def-code-arguments">(SCM vec, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fbit_005fis_005fset"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fbitvector_005fbit_005fis_005fclear"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_bitvector_bit_is_clear</strong> <code class="def-code-arguments">(SCM vec, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fbit_005fis_005fclear"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fset_005fbit_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_set_bit_x</strong> <code class="def-code-arguments">(SCM vec, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fset_005fbit_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fclear_005fbit_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_clear_bit_x</strong> <code class="def-code-arguments">(SCM vec, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fclear_005fbit_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fset_005fbits_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_set_bits_x</strong> <code class="def-code-arguments">(SCM vec, SCM bits)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fset_005fbits_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fclear_005fbits_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_clear_bits_x</strong> <code class="def-code-arguments">(SCM vec, SCM bits)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fclear_005fbits_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fset_005fall_005fbits_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_set_all_bits_x</strong> <code class="def-code-arguments">(SCM vec)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fset_005fall_005fbits_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fclear_005fall_005fbits_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_clear_all_bits_x</strong> <code class="def-code-arguments">(SCM vec)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fclear_005fall_005fbits_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fflip_005fall_005fbits_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bitvector_flip_all_bits_x</strong> <code class="def-code-arguments">(SCM vec)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fflip_005fall_005fbits_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005flength"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_bitvector_length</strong> <code class="def-code-arguments">(SCM bitvector)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005flength"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fcount"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_bitvector_count</strong> <code class="def-code-arguments">(SCM bitvector)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fcount"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fbitvector_005fcount_005fbits"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_bitvector_count_bits</strong> <code class="def-code-arguments">(SCM bitvector, SCM bits)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbitvector_005fcount_005fbits"> ¶</a></span></dt>
<dd><p>C API for the corresponding Scheme bitvector interfaces.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fbitvector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint32 *</code> <strong class="def-name">scm_bitvector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_vector_elements</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C">Vector Accessing from C</a>), but
for bitvectors.  The variable pointed to by <var class="var">offp</var> is set to the
value returned by <code class="code">scm_array_handle_bit_elements_offset</code>.  See
<code class="code">scm_array_handle_bit_elements</code> for how to use the returned
pointer and the offset.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fbitvector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint32 *</code> <strong class="def-name">scm_bitvector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *offp, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbitvector_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_bitvector_elements</code>, but the pointer is good for reading
and writing.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Bytevectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="n" rel="next">Arrays</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bit-Vectors" accesskey="p" rel="prev">Bit Vectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Bytevectors-1">6.6.12 Bytevectors</h4>

<a class="index-entry-id" id="index-bytevector"></a>
<a class="index-entry-id" id="index-R6RS"></a>

<p>A <em class="dfn">bytevector</em> is a raw byte string.  The <code class="code">(rnrs bytevectors)</code>
module provides the programming interface specified by the
<a class="uref" href="http://www.r6rs.org/">Revised^6 Report on the Algorithmic Language
Scheme (R6RS)</a>.  It contains procedures to manipulate bytevectors and
interpret their contents in a number of ways: as signed or unsigned
integer of various sizes and endianness, as IEEE-754 floating point
numbers, or as strings.  It is a useful tool to encode and decode binary
data.  The <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">R7RS</a> offers its own set of bytevector
procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Procedures-in-R7RS">Bytevector Procedures in R7RS</a>).
</p>
<p>The R6RS (Section 4.3.4) specifies an external representation for
bytevectors, whereby the octets (integers in the range 0–255) contained
in the bytevector are represented as a list prefixed by <code class="code">#vu8</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#vu8(1 53 204)
</pre></div>

<p>denotes a 3-byte bytevector containing the octets 1, 53, and 204.  Like
string literals, booleans, etc., bytevectors are “self-quoting”, i.e.,
they do not need to be quoted:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#vu8(1 53 204)
⇒ #vu8(1 53 204)
</pre></div>

<p>Bytevectors can be used with the binary input/output primitives
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO">Binary I/O</a>).
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Endianness" accesskey="1">Endianness</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Manipulation" accesskey="2">Manipulating Bytevectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Integers" accesskey="3">Interpreting Bytevector Contents as Integers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-and-Integer-Lists" accesskey="4">Converting Bytevectors to/from Integer Lists</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Floats" accesskey="5">Interpreting Bytevector Contents as Floating Point Numbers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Strings" accesskey="6">Interpreting Bytevector Contents as Unicode Strings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Arrays" accesskey="7">Accessing Bytevectors with the Array API</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Uniform-Vectors" accesskey="8">Accessing Bytevectors with the SRFI-4 API</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Procedures-in-R7RS" accesskey="9">Bytevector Procedures in R7RS</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Slices">Bytevector Slices</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Bytevector-Endianness">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Manipulation" accesskey="n" rel="next">Manipulating Bytevectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Endianness">6.6.12.1 Endianness</h4>

<a class="index-entry-id" id="index-endianness"></a>
<a class="index-entry-id" id="index-byte-order"></a>
<a class="index-entry-id" id="index-word-order"></a>

<p>Some of the following procedures take an <var class="var">endianness</var> parameter.
The <em class="dfn">endianness</em> is defined as the order of bytes in multi-byte
numbers: numbers encoded in <em class="dfn">big endian</em> have their most
significant bytes written first, whereas numbers encoded in
<em class="dfn">little endian</em> have their least significant bytes
first<a class="footnote" id="DOCF10" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT10"><sup>10</sup></a>.
</p>
<p>Little-endian is the native endianness of the IA32 architecture and
its derivatives, while big-endian is native to SPARC and PowerPC,
among others. The <code class="code">native-endianness</code> procedure returns the
native endianness of the machine it runs on.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-native_002dendianness"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">native-endianness</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-native_002dendianness"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnative_005fendianness"><span class="category-def">C Function: </span><span><strong class="def-name">scm_native_endianness</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnative_005fendianness"> ¶</a></span></dt>
<dd><p>Return a value denoting the native endianness of the host machine.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endianness-1"><span class="category-def">Scheme Macro: </span><span><strong class="def-name">endianness</strong> <var class="def-var-arguments">symbol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endianness-1"> ¶</a></span></dt>
<dd><p>Return an object denoting the endianness specified by <var class="var">symbol</var>.  If
<var class="var">symbol</var> is neither <code class="code">big</code> nor <code class="code">little</code> then an error is
raised at expand-time.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fendianness_005fbig"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_endianness_big</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fendianness_005fbig"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fendianness_005flittle"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_endianness_little</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fendianness_005flittle"> ¶</a></span></dt>
<dd><p>The objects denoting big- and little-endianness, respectively.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevector-Manipulation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Integers" accesskey="n" rel="next">Interpreting Bytevector Contents as Integers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Endianness" accesskey="p" rel="prev">Endianness</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Manipulating-Bytevectors">6.6.12.2 Manipulating Bytevectors</h4>

<p>Bytevectors can be created, copied, and analyzed with the following
procedures and C functions.
</p>
<a class="anchor" id="x_002dmake_002dbytevector"></a><dl class="first-deffn">
<dt class="deffn" id="index-make_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-bytevector</strong> <var class="def-var-arguments">len [fill]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dbytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_bytevector</strong> <var class="def-var-arguments">(len, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fbytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc_005fmake_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c_make_bytevector</strong> <var class="def-var-arguments">(size_t len)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fbytevector"> ¶</a></span></dt>
<dd><p>Return a new bytevector of <var class="var">len</var> bytes.  Optionally, if <var class="var">fill</var>
is given, fill it with <var class="var">fill</var>; <var class="var">fill</var> must be in the range
[-128,255].
</p></dd></dl>

<a class="anchor" id="x_002dbytevector_003f"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fp"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a bytevector.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fbytevector"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_bytevector</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fbytevector"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_is_true (scm_bytevector_p (obj))</code>.
</p></dd></dl>

<a class="anchor" id="x_002dbytevector_002dlength"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-length</strong> <var class="def-var-arguments">bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_length</strong> <var class="def-var-arguments">(bv)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005flength"> ¶</a></span></dt>
<dd><p>Return the length in bytes of bytevector <var class="var">bv</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fbytevector_005flength"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_bytevector_length</strong> <code class="def-code-arguments">(SCM bv)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbytevector_005flength"> ¶</a></span></dt>
<dd><p>Likewise, return the length in bytes of bytevector <var class="var">bv</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector=?</strong> <var class="def-var-arguments">bv1 bv2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_003d_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005feq_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_eq_p</strong> <var class="def-var-arguments">(bv1, bv2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005feq_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">bv1</var> equals <var class="var">bv2</var>—i.e., if they have the same
length and contents.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dfill_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-fill!</strong> <var class="def-var-arguments">bv fill [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dfill_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005ffill_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_fill_x</strong> <var class="def-var-arguments">(bv, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005ffill_005fx"> ¶</a></span></dt>
<dd><p>Fill positions [<var class="var">start</var> ... <var class="var">end</var>) of bytevector <var class="var">bv</var> with
byte <var class="var">fill</var>.  <var class="var">start</var> defaults to 0 and <var class="var">end</var> defaults to the
length of <var class="var">bv</var>.<a class="footnote" id="DOCF11" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT11"><sup>11</sup></a>
</p></dd></dl>

<a class="anchor" id="x_002dr6_003abytevector_002dcopy_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-copy!</strong> <var class="def-var-arguments">source source-start target target-start len</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fcopy_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_copy_x</strong> <var class="def-var-arguments">(source, source_start, target, target_start, len)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fcopy_005fx"> ¶</a></span></dt>
<dd><p>Copy <var class="var">len</var> bytes from <var class="var">source</var> into <var class="var">target</var>, starting
reading from <var class="var">source-start</var> (an index index within <var class="var">source</var>)
and writing at <var class="var">target-start</var>.
</p>
<p>It is permitted for the <var class="var">source</var> and <var class="var">target</var> regions to
overlap.  In that case, copying takes place as if the source is first
copied into a temporary bytevector and then into the destination.
</p></dd></dl>

<a class="anchor" id="x_002dr6_003abytevector_002dcopy"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-copy</strong> <var class="def-var-arguments">bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fcopy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_copy</strong> <var class="def-var-arguments">(bv)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fcopy"> ¶</a></span></dt>
<dd><p>Return a newly allocated copy of <var class="var">bv</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fbytevector_005fref"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint8</code> <strong class="def-name">scm_c_bytevector_ref</strong> <code class="def-code-arguments">(SCM bv, size_t index)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbytevector_005fref"> ¶</a></span></dt>
<dd><p>Return the byte at <var class="var">index</var> in bytevector <var class="var">bv</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fbytevector_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_bytevector_set_x</strong> <code class="def-code-arguments">(SCM bv, size_t index, scm_t_uint8 value)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fbytevector_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the byte at <var class="var">index</var> in <var class="var">bv</var> to <var class="var">value</var>.
</p></dd></dl>

<p>Low-level C macros are available.  They do not perform any
type-checking; as such they should be used with care.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fBYTEVECTOR_005fLENGTH"><span class="category-def">C Macro: </span><span><code class="def-type">size_t</code> <strong class="def-name">SCM_BYTEVECTOR_LENGTH</strong> <code class="def-code-arguments">(bv)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fBYTEVECTOR_005fLENGTH"> ¶</a></span></dt>
<dd><p>Return the length in bytes of bytevector <var class="var">bv</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fBYTEVECTOR_005fCONTENTS"><span class="category-def">C Macro: </span><span><code class="def-type">signed char *</code> <strong class="def-name">SCM_BYTEVECTOR_CONTENTS</strong> <code class="def-code-arguments">(bv)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fBYTEVECTOR_005fCONTENTS"> ¶</a></span></dt>
<dd><p>Return a pointer to the contents of bytevector <var class="var">bv</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-as-Integers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-and-Integer-Lists" accesskey="n" rel="next">Converting Bytevectors to/from Integer Lists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Manipulation" accesskey="p" rel="prev">Manipulating Bytevectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Interpreting-Bytevector-Contents-as-Integers">6.6.12.3 Interpreting Bytevector Contents as Integers</h4>

<p>The contents of a bytevector can be interpreted as a sequence of
integers of any given size, sign, and endianness.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((bv (make-bytevector 4)))
  (bytevector-u8-set! bv 0 #x12)
  (bytevector-u8-set! bv 1 #x34)
  (bytevector-u8-set! bv 2 #x56)
  (bytevector-u8-set! bv 3 #x78)

  (map (lambda (number)
         (number-&gt;string number 16))
       (list (bytevector-u8-ref bv 0)
             (bytevector-u16-ref bv 0 (endianness big))
             (bytevector-u32-ref bv 0 (endianness little)))))

⇒ ("12" "1234" "78563412")
</pre></div>

<p>The most generic procedures to interpret bytevector contents as integers
are described below.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002duint_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-uint-ref</strong> <var class="def-var-arguments">bv index endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002duint_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fuint_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_uint_ref</strong> <var class="def-var-arguments">(bv, index, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fuint_005fref"> ¶</a></span></dt>
<dd><p>Return the <var class="var">size</var>-byte long unsigned integer at index <var class="var">index</var> in
<var class="var">bv</var>, decoded according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dsint_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-sint-ref</strong> <var class="def-var-arguments">bv index endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dsint_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fsint_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_sint_ref</strong> <var class="def-var-arguments">(bv, index, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fsint_005fref"> ¶</a></span></dt>
<dd><p>Return the <var class="var">size</var>-byte long signed integer at index <var class="var">index</var> in
<var class="var">bv</var>, decoded according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002duint_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-uint-set!</strong> <var class="def-var-arguments">bv index value endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002duint_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fuint_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_uint_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fuint_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the <var class="var">size</var>-byte long unsigned integer at <var class="var">index</var> to
<var class="var">value</var>, encoded according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dsint_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-sint-set!</strong> <var class="def-var-arguments">bv index value endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dsint_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fsint_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_sint_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fsint_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the <var class="var">size</var>-byte long signed integer at <var class="var">index</var> to
<var class="var">value</var>, encoded according to <var class="var">endianness</var>.
</p></dd></dl>

<p>The following procedures are similar to the ones above, but specialized
to a given integer size:
</p>
<a class="anchor" id="x_002dbytevector_002du8_002dref"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002du8_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u8-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du8_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds8_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s8-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds8_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du16_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u16-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du16_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds16_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s16-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds16_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du32_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u32-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du32_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds32_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s32-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds32_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du64_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u64-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du64_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds64_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s64-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds64_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu8_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u8_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu8_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs8_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s8_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs8_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu16_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u16_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu16_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs16_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s16_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs16_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu32_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u32_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu32_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs32_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s32_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs32_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu64_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u64_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu64_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs64_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s64_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs64_005fref"> ¶</a></span></dt>
<dd><p>Return the unsigned <var class="var">n</var>-bit (signed) integer (where <var class="var">n</var> is 8,
16, 32 or 64) from <var class="var">bv</var> at <var class="var">index</var>, decoded according to
<var class="var">endianness</var>.
</p></dd></dl>

<a class="anchor" id="x_002dbytevector_002du8_002dset_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002du8_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u8-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du8_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds8_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s8-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds8_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du16_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u16-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du16_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds16_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s16-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds16_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du32_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u32-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du32_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds32_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s32-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds32_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du64_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u64-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du64_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds64_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s64-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds64_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu8_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u8_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu8_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs8_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s8_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs8_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu16_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u16_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu16_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs16_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s16_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs16_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu32_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u32_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu32_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs32_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s32_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs32_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu64_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u64_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu64_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs64_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s64_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs64_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">value</var> as an <var class="var">n</var>-bit (signed) integer (where <var class="var">n</var> is
8, 16, 32 or 64) in <var class="var">bv</var> at <var class="var">index</var>, encoded according to
<var class="var">endianness</var>.
</p></dd></dl>

<p>Finally, a variant specialized for the host’s endianness is available
for each of these functions (with the exception of the <code class="code">u8</code> and
<code class="code">s8</code> accessors, as endianness is about byte order and there is only
1 byte):
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002du16_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u16-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du16_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds16_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s16-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds16_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du32_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u32-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du32_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds32_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s32-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds32_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du64_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u64-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du64_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds64_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s64-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds64_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu16_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u16_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu16_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs16_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s16_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs16_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu32_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u32_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu32_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs32_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s32_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs32_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu64_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u64_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu64_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs64_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s64_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs64_005fnative_005fref"> ¶</a></span></dt>
<dd><p>Return the unsigned <var class="var">n</var>-bit (signed) integer (where <var class="var">n</var> is 8,
16, 32 or 64) from <var class="var">bv</var> at <var class="var">index</var>, decoded according to the
host’s native endianness.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002du16_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u16-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du16_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds16_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s16-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds16_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du32_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u32-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du32_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds32_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s32-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds32_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002du64_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-u64-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002du64_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002ds64_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-s64-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002ds64_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu16_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u16_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu16_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs16_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s16_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs16_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu32_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u32_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu32_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs32_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s32_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs32_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fu64_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_u64_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fu64_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fs64_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_s64_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fs64_005fnative_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">value</var> as an <var class="var">n</var>-bit (signed) integer (where <var class="var">n</var> is
8, 16, 32 or 64) in <var class="var">bv</var> at <var class="var">index</var>, encoded according to the
host’s native endianness.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-and-Integer-Lists">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Floats" accesskey="n" rel="next">Interpreting Bytevector Contents as Floating Point Numbers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Integers" accesskey="p" rel="prev">Interpreting Bytevector Contents as Integers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Converting-Bytevectors-to_002ffrom-Integer-Lists">6.6.12.4 Converting Bytevectors to/from Integer Lists</h4>

<p>Bytevector contents can readily be converted to/from lists of signed or
unsigned integers:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(bytevector-&gt;sint-list (u8-list-&gt;bytevector (make-list 4 255))
                       (endianness little) 2)
⇒ (-1 -1)
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002d_003eu8_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-&gt;u8-list</strong> <var class="def-var-arguments">bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002d_003eu8_002dlist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fto_005fu8_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_to_u8_list</strong> <var class="def-var-arguments">(bv)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fto_005fu8_005flist"> ¶</a></span></dt>
<dd><p>Return a newly allocated list of unsigned 8-bit integers from the
contents of <var class="var">bv</var>.
</p></dd></dl>

<a class="anchor" id="x_002du8_002dlist_002d_003ebytevector"></a><dl class="first-deffn">
<dt class="deffn" id="index-u8_002dlist_002d_003ebytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8-list-&gt;bytevector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8_002dlist_002d_003ebytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8_005flist_005fto_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8_list_to_bytevector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8_005flist_005fto_005fbytevector"> ¶</a></span></dt>
<dd><p>Return a newly allocated bytevector consisting of the unsigned 8-bit
integers listed in <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002d_003euint_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-&gt;uint-list</strong> <var class="def-var-arguments">bv endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002d_003euint_002dlist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fto_005fuint_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_to_uint_list</strong> <var class="def-var-arguments">(bv, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fto_005fuint_005flist"> ¶</a></span></dt>
<dd><p>Return a list of unsigned integers of <var class="var">size</var> bytes representing the
contents of <var class="var">bv</var>, decoded according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002d_003esint_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-&gt;sint-list</strong> <var class="def-var-arguments">bv endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002d_003esint_002dlist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fto_005fsint_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_to_sint_list</strong> <var class="def-var-arguments">(bv, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fto_005fsint_005flist"> ¶</a></span></dt>
<dd><p>Return a list of signed integers of <var class="var">size</var> bytes representing the
contents of <var class="var">bv</var>, decoded according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-uint_002dlist_002d_003ebytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uint-list-&gt;bytevector</strong> <var class="def-var-arguments">lst endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uint_002dlist_002d_003ebytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fuint_005flist_005fto_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_uint_list_to_bytevector</strong> <var class="def-var-arguments">(lst, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fuint_005flist_005fto_005fbytevector"> ¶</a></span></dt>
<dd><p>Return a new bytevector containing the unsigned integers listed in
<var class="var">lst</var> and encoded on <var class="var">size</var> bytes according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sint_002dlist_002d_003ebytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sint-list-&gt;bytevector</strong> <var class="def-var-arguments">lst endianness size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sint_002dlist_002d_003ebytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsint_005flist_005fto_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sint_list_to_bytevector</strong> <var class="def-var-arguments">(lst, endianness, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsint_005flist_005fto_005fbytevector"> ¶</a></span></dt>
<dd><p>Return a new bytevector containing the signed integers listed in
<var class="var">lst</var> and encoded on <var class="var">size</var> bytes according to <var class="var">endianness</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-as-Floats">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Strings" accesskey="n" rel="next">Interpreting Bytevector Contents as Unicode Strings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-and-Integer-Lists" accesskey="p" rel="prev">Converting Bytevectors to/from Integer Lists</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Interpreting-Bytevector-Contents-as-Floating-Point-Numbers">6.6.12.5 Interpreting Bytevector Contents as Floating Point Numbers</h4>

<a class="index-entry-id" id="index-IEEE_002d754-floating-point-numbers"></a>

<p>Bytevector contents can also be accessed as IEEE-754 single- or
double-precision floating point numbers (respectively 32 and 64-bit
long) using the procedures described here.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dieee_002dsingle_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-single-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002dsingle_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002dieee_002ddouble_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-double-ref</strong> <var class="def-var-arguments">bv index endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002ddouble_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fsingle_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_single_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fsingle_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fdouble_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_double_ref</strong> <var class="def-var-arguments">(bv, index, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fdouble_005fref"> ¶</a></span></dt>
<dd><p>Return the IEEE-754 single-precision floating point number from <var class="var">bv</var>
at <var class="var">index</var> according to <var class="var">endianness</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dieee_002dsingle_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-single-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002dsingle_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002dieee_002ddouble_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-double-set!</strong> <var class="def-var-arguments">bv index value endianness</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002ddouble_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fsingle_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_single_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fsingle_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fdouble_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_double_set_x</strong> <var class="def-var-arguments">(bv, index, value, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fdouble_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store real number <var class="var">value</var> in <var class="var">bv</var> at <var class="var">index</var> according to
<var class="var">endianness</var>.
</p></dd></dl>

<p>Specialized procedures are also available:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dieee_002dsingle_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-single-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002dsingle_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002dieee_002ddouble_002dnative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-double-native-ref</strong> <var class="def-var-arguments">bv index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002ddouble_002dnative_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fsingle_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_single_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fsingle_005fnative_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fdouble_005fnative_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_double_native_ref</strong> <var class="def-var-arguments">(bv, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fdouble_005fnative_005fref"> ¶</a></span></dt>
<dd><p>Return the IEEE-754 single-precision floating point number from <var class="var">bv</var>
at <var class="var">index</var> according to the host’s native endianness.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dieee_002dsingle_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-single-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002dsingle_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bytevector_002dieee_002ddouble_002dnative_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-ieee-double-native-set!</strong> <var class="def-var-arguments">bv index value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dieee_002ddouble_002dnative_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fsingle_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_single_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fsingle_005fnative_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fieee_005fdouble_005fnative_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_ieee_double_native_set_x</strong> <var class="def-var-arguments">(bv, index, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fieee_005fdouble_005fnative_005fset_005fx"> ¶</a></span></dt>
<dd><p>Store real number <var class="var">value</var> in <var class="var">bv</var> at <var class="var">index</var> according to
the host’s native endianness.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-as-Strings">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Arrays" accesskey="n" rel="next">Accessing Bytevectors with the Array API</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Floats" accesskey="p" rel="prev">Interpreting Bytevector Contents as Floating Point Numbers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Interpreting-Bytevector-Contents-as-Unicode-Strings">6.6.12.6 Interpreting Bytevector Contents as Unicode Strings</h4>

<a class="index-entry-id" id="index-Unicode-string-encoding"></a>

<p>Bytevector contents can also be interpreted as Unicode strings encoded
in one of the most commonly available encoding formats.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Representing-Strings-as-Bytes">Representing Strings as Bytes</a>, for a more generic interface.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(utf8-&gt;string (u8-list-&gt;bytevector '(99 97 102 101)))
⇒ "cafe"

(string-&gt;utf8 "café") ;; SMALL LATIN LETTER E WITH ACUTE ACCENT
⇒ #vu8(99 97 102 195 169)
</pre></div>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-string_002dutf8_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-utf8-length</strong> <code class="def-code-arguments">str</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dutf8_002dlength"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fstring_005futf8_005flength"><span class="category-def">C function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_string_utf8_length</strong> <code class="def-code-arguments">(str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005futf8_005flength"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fstring_005futf8_005flength"><span class="category-def">C function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_string_utf8_length</strong> <code class="def-code-arguments">(str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fstring_005futf8_005flength"> ¶</a></span></dt>
<dd><p>Return the number of bytes in the UTF-8 representation of <var class="var">str</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003eutf8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;utf8</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003eutf8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002d_003eutf16"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;utf16</strong> <var class="def-var-arguments">str [endianness]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003eutf16"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002d_003eutf32"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;utf32</strong> <var class="def-var-arguments">str [endianness]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003eutf32"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005futf8"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_utf8</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005futf8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005futf16"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_utf16</strong> <var class="def-var-arguments">(str, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005futf16"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005fto_005futf32"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_to_utf32</strong> <var class="def-var-arguments">(str, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005fto_005futf32"> ¶</a></span></dt>
<dd><p>Return a newly allocated bytevector that contains the UTF-8, UTF-16, or
UTF-32 (aka. UCS-4) encoding of <var class="var">str</var>.  For UTF-16 and UTF-32,
<var class="var">endianness</var> should be the symbol <code class="code">big</code> or <code class="code">little</code>; when omitted,
it defaults to big endian.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-utf8_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utf8-&gt;string</strong> <var class="def-var-arguments">utf</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utf8_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-utf16_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utf16-&gt;string</strong> <var class="def-var-arguments">utf [endianness]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utf16_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-utf32_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utf32-&gt;string</strong> <var class="def-var-arguments">utf [endianness]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utf32_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005futf8_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_utf8_to_string</strong> <var class="def-var-arguments">(utf)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005futf8_005fto_005fstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005futf16_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_utf16_to_string</strong> <var class="def-var-arguments">(utf, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005futf16_005fto_005fstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005futf32_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_utf32_to_string</strong> <var class="def-var-arguments">(utf, endianness)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005futf32_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return a newly allocated string that contains from the UTF-8-, UTF-16-,
or UTF-32-decoded contents of bytevector <var class="var">utf</var>.  For UTF-16 and UTF-32,
<var class="var">endianness</var> should be the symbol <code class="code">big</code> or <code class="code">little</code>; when omitted,
it defaults to big endian.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-as-Arrays">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Uniform-Vectors" accesskey="n" rel="next">Accessing Bytevectors with the SRFI-4 API</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Strings" accesskey="p" rel="prev">Interpreting Bytevector Contents as Unicode Strings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Accessing-Bytevectors-with-the-Array-API">6.6.12.7 Accessing Bytevectors with the Array API</h4>

<p>As an extension to the R6RS, Guile allows bytevectors to be manipulated
with the <em class="dfn">array</em> procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a>).  When using these
APIs, bytes are accessed one at a time as 8-bit unsigned integers:
</p>
<div class="example">
<pre class="example-preformatted">(define bv #vu8(0 1 2 3))

(array? bv)
⇒ #t

(array-rank bv)
⇒ 1

(array-ref bv 2)
⇒ 2

;; Note the different argument order on array-set!.
(array-set! bv 77 2)
(array-ref bv 2)
⇒ 77

(array-type bv)
⇒ vu8
</pre></div>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevectors-as-Uniform-Vectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Procedures-in-R7RS" accesskey="n" rel="next">Bytevector Procedures in R7RS</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Arrays" accesskey="p" rel="prev">Accessing Bytevectors with the Array API</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Accessing-Bytevectors-with-the-SRFI_002d4-API">6.6.12.8 Accessing Bytevectors with the SRFI-4 API</h4>

<p>Bytevectors may also be accessed with the SRFI-4 API. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-and-Bytevectors">SRFI-4 - Relation to bytevectors</a>, for more information.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevector-Procedures-in-R7RS">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Slices" accesskey="n" rel="next">Bytevector Slices</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors-as-Uniform-Vectors" accesskey="p" rel="prev">Accessing Bytevectors with the SRFI-4 API</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Bytevector-Procedures-in-R7RS-1">6.6.12.9 Bytevector Procedures in R7RS</h4>

<p>The <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">R7RS</a> (Section 6.9) defines a set of
bytevector manipulation procedures, accessible with
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (scheme base))
</pre></div>

<p>Of these, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dmake_002dbytevector"><code class="code">make-bytevector</code></a>,
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dbytevector_003f"><code class="code">bytevector?</code></a>,
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dbytevector_002dlength"><code class="code">bytevector-length</code></a>,
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dbytevector_002du8_002dref"><code class="code">bytevector-u8-ref</code></a> and
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dbytevector_002du8_002dset_0021"><code class="code">bytevector-u8-set!</code></a> have the same
definition as in R6RS.  The procedures listed below either have a
different definition in R7RS and R6RS, or are not defined in R6RS.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector-1"> ¶</a></span></dt>
<dd><p>Return a newly allocated bytevector composed of the given arguments.
Analogous to <code class="code">list</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(bytevector 2 3 4) ⇒ #vu8(2 3 4)
</pre></div>

<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002du8_002dlist_002d_003ebytevector"><code class="code">u8-list-&gt;bytevector</code></a>.
</p></dd></dl>

<a class="anchor" id="x_002dr7_003abytevector_002dcopy"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dcopy-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-copy</strong> <var class="def-var-arguments">bv [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dcopy-1"> ¶</a></span></dt>
<dd><p>Returns a newly allocated bytevector containing the elements of <var class="var">bv</var>
in the range [<var class="var">start</var> ... <var class="var">end</var>).  <var class="var">start</var> defaults to 0 and
<var class="var">end</var> defaults to the length of <var class="var">bv</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define bv #vu8(0 1 2 3 4 5))
(bytevector-copy bv) ⇒ #vu8(0 1 2 3 4 5)
(bytevector-copy bv 2) ⇒ #vu8(2 3 4 5)
(bytevector-copy bv 2 4) ⇒ #vu8(2 3)
</pre></div>

<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dr6_003abytevector_002dcopy">the R6RS version</a>.
</p></dd></dl>

<a class="anchor" id="x_002dr7_003abytevector_002dcopy_0021"></a><dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dcopy_0021-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dcopy_0021-1"> ¶</a></span></dt>
<dd><p>Copy the block of elements from bytevector <var class="var">src</var> in the range
[<var class="var">start</var> ... <var class="var">end</var>) into bytevector <var class="var">dst</var>, starting at
position <var class="var">at</var>.  <var class="var">start</var> defaults to 0 and <var class="var">end</var> defaults to
the length of <var class="var">src</var>.  It is an error for <var class="var">dst</var>
to have a length less than <var class="var">at</var> + (<var class="var">end</var> - <var class="var">start</var>).
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dr6_003abytevector_002dcopy_0021">the R6RS version</a>.  With
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules ((rnrs bytevectors) #:prefix r6:)
             ((scheme base) #:prefix r7:))
</pre></div>

<p>the following calls are equivalent:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(r6:bytevector-copy! source source-start target target-start len)
(r7:bytevector-copy! target target-start source source-start (+ source-start len))
</pre></div>

</dd></dl>

<a class="index-entry-id" id="index-bytevector_002dappend-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dappend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-append</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dappend"> ¶</a></span></dt>
<dd><p>Return a newly allocated bytevector whose characters form the
concatenation of the given bytevectors <var class="var">arg</var> <small class="enddots">...</small>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(bytevector-append #vu8(0 1 2) #vu8(3 4 5))
⇒ #vu8(0 1 2 3 4 5)
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevector-Slices">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Procedures-in-R7RS" accesskey="p" rel="prev">Bytevector Procedures in R7RS</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="u" rel="up">Bytevectors</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Bytevector-Slices-1">6.6.12.10 Bytevector Slices</h4>

<a class="index-entry-id" id="index-subset_002c-of-a-bytevector"></a>
<a class="index-entry-id" id="index-slice_002c-of-a-bytevector"></a>
<a class="index-entry-id" id="index-slice_002c-of-a-uniform-vector"></a>
<p>As an extension to the R6RS specification, the <code class="code">(rnrs bytevectors
gnu)</code> module provides the <code class="code">bytevector-slice</code> procedure, which
returns a bytevector aliasing part of an existing bytevector.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002dslice"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-slice</strong> <var class="def-var-arguments"><var class="var">bv</var> <var class="var">offset</var> [<var class="var">size</var>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002dslice"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fslice"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_slice</strong> <var class="def-var-arguments">(<var class="var">bv</var>, <var class="var">offset</var>, <var class="var">size</var>)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fslice"> ¶</a></span></dt>
<dd><p>Return the slice of <var class="var">bv</var> starting at <var class="var">offset</var> and counting
<var class="var">size</var> bytes.  When <var class="var">size</var> is omitted, the slice covers all
of <var class="var">bv</var> starting from <var class="var">offset</var>.  The returned slice shares
storage with <var class="var">bv</var>: changes to the slice are visible in <var class="var">bv</var>
and vice-versa.
</p>
<p>When <var class="var">bv</var> is actually a SRFI-4 uniform vector, its element
type is preserved unless <var class="var">offset</var> and <var class="var">size</var> are not aligned
on its element type size.
</p></dd></dl>

<p>Here is an example showing how to use it:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (rnrs bytevectors)
             (rnrs bytevectors gnu))

(define bv (u8-list-&gt;bytevector (iota 10)))
(define slice (bytevector-slice bv 2 3))

slice
⇒ #vu8(2 3 4)

(bytevector-u8-set! slice 0 77)
slice
⇒ #vu8(77 3 4)

bv
⇒ #vu8(0 1 77 3 4 5 6 7 8 9)
</pre></div>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Arrays">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#VLists" accesskey="n" rel="next">VLists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors" accesskey="p" rel="prev">Bytevectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Arrays-1">6.6.13 Arrays</h4>
<a class="index-entry-id" id="index-Arrays"></a>

<p><em class="dfn">Arrays</em> are a collection of cells organized into an arbitrary
number of dimensions.  Each cell can be accessed in constant time by
supplying an index for each dimension.
</p>
<p>In the current implementation, an array uses a vector of some kind for
the actual storage of its elements.  Any kind of vector will do, so you
can have arrays of uniform numeric values, arrays of characters, arrays
of bits, and of course, arrays of arbitrary Scheme values.  For example,
arrays with an underlying <code class="code">c64vector</code> might be nice for digital
signal processing, while arrays made from a <code class="code">u8vector</code> might be
used to hold gray-scale images.
</p>
<p>The number of dimensions of an array is called its <em class="dfn">rank</em>.  Thus,
a matrix is an array of rank 2, while a vector has rank 1.  When
accessing an array element, you have to specify one exact integer for
each dimension.  These integers are called the <em class="dfn">indices</em> of the
element.  An array specifies the allowed range of indices for each
dimension via an inclusive lower and upper bound.  These bounds can
well be negative, but the upper bound must be greater than or equal to
the lower bound minus one.  When all lower bounds of an array are
zero, it is called a <em class="dfn">zero-origin</em> array.
</p>
<p>Arrays can be of rank 0, which could be interpreted as a scalar.
Thus, a zero-rank array can store exactly one object and the list of
indices of this element is the empty list.
</p>
<p>Arrays contain zero elements when one of their dimensions has a zero
length.  These empty arrays maintain information about their shape: a
matrix with zero columns and 3 rows is different from a matrix with 3
columns and zero rows, which again is different from a vector of
length zero.
</p>
<p>The array procedures are all polymorphic, treating strings, uniform
numeric vectors, bytevectors, bit vectors and ordinary vectors as one
dimensional arrays.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Array-Syntax" accesskey="1">Array Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Array-Procedures" accesskey="2">Array Procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Arrays" accesskey="3">Shared Arrays</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays-as-arrays-of-arrays" accesskey="4">Arrays as arrays of arrays</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Arrays-from-C" accesskey="5">Accessing Arrays from C</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Array-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Array-Procedures" accesskey="n" rel="next">Array Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="u" rel="up">Arrays</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Array-Syntax-1">6.6.13.1 Array Syntax</h4>

<p>An array is displayed as <code class="code">#</code> followed by its rank, followed by a
tag that describes the underlying vector, optionally followed by
information about its shape, and finally followed by the cells,
organized into dimensions using parentheses.
</p>
<p>In more words, the array tag is of the form
</p>
<div class="example">
<pre class="example-preformatted">  #&lt;rank&gt;&lt;vectag&gt;&lt;@lower&gt;&lt;:len&gt;&lt;@lower&gt;&lt;:len&gt;...
</pre></div>

<p>where <code class="code">&lt;rank&gt;</code> is a positive integer in decimal giving the rank of
the array.  It is omitted when the rank is 1 and the array is non-shared
and has zero-origin (see below).  For shared arrays and for a non-zero
origin, the rank is always printed even when it is 1 to distinguish
them from ordinary vectors.
</p>
<p>The <code class="code">&lt;vectag&gt;</code> part is the tag for a uniform numeric vector, like
<code class="code">u8</code>, <code class="code">s16</code>, etc, <code class="code">b</code> for bitvectors, or <code class="code">a</code> for
strings.  It is empty for ordinary vectors.
</p>
<p>The <code class="code">&lt;@lower&gt;</code> part is a ‘<samp class="samp">@</samp>’ character followed by a signed
integer in decimal giving the lower bound of a dimension.  There is one
<code class="code">&lt;@lower&gt;</code> for each dimension.  When all lower bounds are zero,
all <code class="code">&lt;@lower&gt;</code> parts are omitted.
</p>
<p>The <code class="code">&lt;:len&gt;</code> part is a ‘<samp class="samp">:</samp>’ character followed by an unsigned
integer in decimal giving the length of a dimension.  Like for the lower
bounds, there is one <code class="code">&lt;:len&gt;</code> for each dimension, and the
<code class="code">&lt;:len&gt;</code> part always follows the <code class="code">&lt;@lower&gt;</code> part for a
dimension.  Lengths are only then printed when they can’t be deduced
from the nested lists of elements of the array literal, which can happen
when at least one length is zero.
</p>
<p>As a special case, an array of rank 0 is printed as
<code class="code">#0&lt;vectag&gt;(&lt;scalar&gt;)</code>, where <code class="code">&lt;scalar&gt;</code> is the result of
printing the single element of the array.
</p>
<p>Thus, 
</p>
<dl class="table">
<dt><code class="code">#(1 2 3)</code></dt>
<dd><p>is an ordinary array of rank 1 with lower bound 0 in dimension 0.
(I.e., a regular vector.)
</p>
</dd>
<dt><code class="code">#@2(1 2 3)</code></dt>
<dd><p>is an ordinary array of rank 1 with lower bound 2 in dimension 0.
</p>
</dd>
<dt><code class="code">#2((1 2 3) (4 5 6))</code></dt>
<dd><p>is a non-uniform array of rank 2; a 2x3 matrix with index ranges 0..1
and 0..2.
</p>
</dd>
<dt><code class="code">#u8(0 1 2)</code></dt>
<dd><p>is a uniform u8 array of rank 1.
</p>
</dd>
<dt><code class="code">#2u32@2@3((1 2) (2 3))</code></dt>
<dd><p>is a uniform u32 array of rank 2 with index ranges 2..3 and 3..4.
</p>
</dd>
<dt><code class="code">#2()</code></dt>
<dd><p>is a two-dimensional array with index ranges 0..-1 and 0..-1, i.e.
both dimensions have length zero.
</p>
</dd>
<dt><code class="code">#2:0:2()</code></dt>
<dd><p>is a two-dimensional array with index ranges 0..-1 and 0..1, i.e. the
first dimension has length zero, but the second has length 2.
</p>
</dd>
<dt><code class="code">#0(12)</code></dt>
<dd><p>is a rank-zero array with contents 12.
</p>
</dd>
</dl>

<p>In addition, bytevectors are also arrays, but use a different syntax
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>):
</p>
<dl class="table">
<dt><code class="code">#vu8(1 2 3)</code></dt>
<dd><p>is a 3-byte long bytevector, with contents 1, 2, 3.
</p>
</dd>
</dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Array-Procedures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Arrays" accesskey="n" rel="next">Shared Arrays</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Array-Syntax" accesskey="p" rel="prev">Array Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="u" rel="up">Arrays</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Array-Procedures-1">6.6.13.2 Array Procedures</h4>

<p>When an array is created, the range of each dimension must be
specified, e.g., to create a 2x3 array with a zero-based index:
</p>
<div class="example">
<pre class="example-preformatted">(make-array 'ho 2 3) ⇒ #2((ho ho ho) (ho ho ho))
</pre></div>

<p>The range of each dimension can also be given explicitly, e.g., another
way to create the same array:
</p>
<div class="example">
<pre class="example-preformatted">(make-array 'ho '(0 1) '(0 2)) ⇒ #2((ho ho ho) (ho ho ho))
</pre></div>

<p>The following procedures can be used with arrays (or vectors).  An
argument shown as <var class="var">idx</var>… means one parameter for each
dimension in the array.  A <var class="var">idxlist</var> argument means a list of such
values, one for each dimension.
</p>

<dl class="first-deffn">
<dt class="deffn" id="index-array_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_p</strong> <var class="def-var-arguments">(obj, unused)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the <var class="var">obj</var> is an array, and <code class="code">#f</code> if
not.
</p>
<p>The second argument to scm_array_p is there for historical reasons,
but it is not used.  You should always pass <code class="code">SCM_UNDEFINED</code> as
its value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-typed_002darray_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">typed-array?</strong> <var class="def-var-arguments">obj type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-typed_002darray_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftyped_005farray_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_typed_array_p</strong> <var class="def-var-arguments">(obj, type)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftyped_005farray_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the <var class="var">obj</var> is an array of type <var class="var">type</var>, and
<code class="code">#f</code> if not.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005farray"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_array</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005farray"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> if the <var class="var">obj</var> is an array and <code class="code">0</code> if not.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005ftyped_005farray"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_typed_array</strong> <code class="def-code-arguments">(SCM obj, SCM type)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005ftyped_005farray"> ¶</a></span></dt>
<dd><p>Return <code class="code">0</code> if the <var class="var">obj</var> is an array of type <var class="var">type</var>, and
<code class="code">1</code> if not.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002darray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-array</strong> <var class="def-var-arguments">fill bound …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002darray"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005farray"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_array</strong> <var class="def-var-arguments">(fill, bounds)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005farray"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">(make-typed-array #t <var class="var">fill</var> <var class="var">bound</var> ...)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dtyped_002darray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-typed-array</strong> <var class="def-var-arguments">type fill bound …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dtyped_002darray"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005ftyped_005farray"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_typed_array</strong> <var class="def-var-arguments">(type, fill, bounds)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005ftyped_005farray"> ¶</a></span></dt>
<dd><p>Create and return an array that has as many dimensions as there are
<var class="var">bound</var>s and (maybe) fill it with <var class="var">fill</var>.
</p>
<p>The underlying storage vector is created according to <var class="var">type</var>,
which must be a symbol whose name is the ‘vectag’ of the array as
explained above, or <code class="code">#t</code> for ordinary, non-specialized arrays.
</p>
<p>For example, using the symbol <code class="code">f64</code> for <var class="var">type</var> will create an
array that uses a <code class="code">f64vector</code> for storing its elements, and
<code class="code">a</code> will use a string.
</p>
<p>When <var class="var">fill</var> is not the special <em class="emph">unspecified</em> value, the new
array is filled with <var class="var">fill</var>.  Otherwise, the initial contents of
the array is unspecified.  The special <em class="emph">unspecified</em> value is
stored in the variable <code class="code">*unspecified*</code> so that for example
<code class="code">(make-typed-array 'u32 *unspecified* 4)</code> creates a uninitialized
<code class="code">u32</code> vector of length 4.
</p>
<p>Each <var class="var">bound</var> may be a positive non-zero integer <var class="var">n</var>, in which
case the index for that dimension can range from 0 through <var class="var">n</var>-1; or
an explicit index range specifier in the form <code class="code">(LOWER UPPER)</code>,
where both <var class="var">lower</var> and <var class="var">upper</var> are integers, possibly less than
zero, and possibly the same number (however, <var class="var">lower</var> cannot be
greater than <var class="var">upper</var>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003earray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;array</strong> <var class="def-var-arguments">dimspec list</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003earray"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">(list-&gt;typed-array #t <var class="var">dimspec</var>
<var class="var">list</var>)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003etyped_002darray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;typed-array</strong> <var class="def-var-arguments">type dimspec list</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003etyped_002darray"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005ftyped_005farray"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_typed_array</strong> <var class="def-var-arguments">(type, dimspec, list)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005ftyped_005farray"> ¶</a></span></dt>
<dd><p>Return an array of the type indicated by <var class="var">type</var> with elements the
same as those of <var class="var">list</var>.
</p>
<p>The argument <var class="var">dimspec</var> determines the number of dimensions of the
array and their lower bounds.  When <var class="var">dimspec</var> is an exact integer,
it gives the number of dimensions directly and all lower bounds are
zero.  When it is a list of exact integers, then each element is the
lower index bound of a dimension, and there will be as many dimensions
as elements in the list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-type</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dtype"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005ftype"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_type</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005ftype"> ¶</a></span></dt>
<dd><p>Return the type of <var class="var">array</var>.  This is the ‘vectag’ used for
printing <var class="var">array</var> (or <code class="code">#t</code> for ordinary arrays) and can be
used with <code class="code">make-typed-array</code> to create an array of the same kind
as <var class="var">array</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-ref</strong> <var class="def-var-arguments">array idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_ref</strong> <var class="def-var-arguments">(array, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fref"> ¶</a></span></dt>
<dd><p>Return the element at <code class="code">(idx …)</code> in <var class="var">array</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define a (make-array 999 '(1 2) '(3 4)))
(array-ref a 2 4) ⇒ 999
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002din_002dbounds_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-in-bounds?</strong> <var class="def-var-arguments">array idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002din_002dbounds_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fin_005fbounds_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_in_bounds_p</strong> <var class="def-var-arguments">(array, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fin_005fbounds_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the given indices would be acceptable to
<code class="code">array-ref</code>.
</p>
<div class="example">
<pre class="example-preformatted">(define a (make-array #f '(1 2) '(3 4)))
(array-in-bounds? a 2 3) ⇒ #t
(array-in-bounds? a 0 0) ⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-set!</strong> <var class="def-var-arguments">array obj idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_set_x</strong> <var class="def-var-arguments">(array, obj, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the element at <code class="code">(idx …)</code> in <var class="var">array</var> to <var class="var">obj</var>.
The return value is unspecified.
</p>
<div class="example">
<pre class="example-preformatted">(define a (make-array #f '(0 1) '(0 1)))
(array-set! a #t 1 1)
a ⇒ #2((#f #f) (#f #t))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dshape"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-shape</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dshape"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-array_002ddimensions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-dimensions</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002ddimensions"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fdimensions"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_dimensions</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fdimensions"> ¶</a></span></dt>
<dd><p>Return a list of the bounds for each dimension of <var class="var">array</var>.
</p>
<p><code class="code">array-shape</code> gives <code class="code">(<var class="var">lower</var> <var class="var">upper</var>)</code> for each
dimension.  <code class="code">array-dimensions</code> instead returns just
<em class="math"><var class="var">upper</var>+1</em> for dimensions with a 0 lower bound.  Both are
suitable as input to <code class="code">make-array</code>.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example-preformatted">(define a (make-array 'foo '(-1 3) 5))
(array-shape a)      ⇒ ((-1 3) (0 4))
(array-dimensions a) ⇒ ((-1 3) 5)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-length</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_length</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-size_005ft"><span class="category-def">C Function: </span><span><strong class="def-name">size_t</strong> <var class="def-var-arguments">scm_c_array_length (array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-size_005ft"> ¶</a></span></dt>
<dd><p>Return the length of an array: its first dimension. It is an error to
ask for the length of an array of rank 0.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002drank"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-rank</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002drank"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005frank"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_rank</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005frank"> ¶</a></span></dt>
<dd><p>Return the rank of <var class="var">array</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005farray_005frank"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_array_rank</strong> <code class="def-code-arguments">(SCM array)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005farray_005frank"> ¶</a></span></dt>
<dd><p>Return the rank of <var class="var">array</var> as a <code class="code">size_t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-&gt;list</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_to_list</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fto_005flist"> ¶</a></span></dt>
<dd><p>Return a list consisting of all the elements, in order, of
<var class="var">array</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-copy!</strong> <var class="def-var-arguments">src dst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-array_002dcopy_002din_002dorder_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-copy-in-order!</strong> <var class="def-var-arguments">src dst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcopy_002din_002dorder_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fcopy_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_copy_x</strong> <var class="def-var-arguments">(src, dst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fcopy_005fx"> ¶</a></span></dt>
<dd><p>Copy every element from vector or array <var class="var">src</var> to the corresponding
element of <var class="var">dst</var>.  <var class="var">dst</var> must have the same rank as <var class="var">src</var>,
and be at least as large in each dimension.  The return value is
unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dfill_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-fill!</strong> <var class="def-var-arguments">array fill</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dfill_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005ffill_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_fill_x</strong> <var class="def-var-arguments">(array, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005ffill_005fx"> ¶</a></span></dt>
<dd><p>Store <var class="var">fill</var> in every element of <var class="var">array</var>.  The value returned
is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dequal_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-equal?</strong> <var class="def-var-arguments">array …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dequal_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if all arguments are arrays with the same shape, the
same type, and have corresponding elements which are either
<code class="code">equal?</code> or <code class="code">array-equal?</code>.  This function differs from
<code class="code">equal?</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Equality">Equality</a>) in that all arguments must be arrays.
</p></dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-array_002dmap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-map!</strong> <var class="def-var-arguments">dst proc src …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dmap_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-array_002dmap_002din_002dorder_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-map-in-order!</strong> <var class="def-var-arguments">dst proc src …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dmap_002din_002dorder_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fmap_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_map_x</strong> <var class="def-var-arguments">(dst, proc, srclist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fmap_005fx"> ¶</a></span></dt>
<dd><p>Set each element of the <var class="var">dst</var> array to values obtained from calls to
<var class="var">proc</var>.  The list of <var class="var">src</var> arguments may be empty.  The value
returned is unspecified.
</p>
<p>Each call is <code class="code">(<var class="var">proc</var> <var class="var">elem</var> …)</code>, where each
<var class="var">elem</var> is from the corresponding <var class="var">src</var> array, at the
<var class="var">dst</var> index.  <code class="code">array-map-in-order!</code> makes the calls in
row-major order, <code class="code">array-map!</code> makes them in an unspecified order.
</p>
<p>The <var class="var">src</var> arrays must have the same number of dimensions as
<var class="var">dst</var>, and must have a range for each dimension which covers the
range in <var class="var">dst</var>.  This ensures all <var class="var">dst</var> indices are valid in
each <var class="var">src</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-for-each</strong> <var class="def-var-arguments">proc src1 src2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_for_each</strong> <var class="def-var-arguments">(proc, src1, srclist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005ffor_005feach"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to each tuple of elements of <var class="var">src1</var> <var class="var">src2</var>
…, in row-major order.  The value returned is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dindex_002dmap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-index-map!</strong> <var class="def-var-arguments">dst proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dindex_002dmap_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005findex_005fmap_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_index_map_x</strong> <var class="def-var-arguments">(dst, proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005findex_005fmap_005fx"> ¶</a></span></dt>
<dd><p>Set each element of the <var class="var">dst</var> array to values returned by calls to
<var class="var">proc</var>.  The value returned is unspecified.
</p>
<p>Each call is <code class="code">(<var class="var">proc</var> <var class="var">i1</var> … <var class="var">iN</var>)</code>, where
<var class="var">i1</var>…<var class="var">iN</var> is the destination index, one parameter for
each dimension.  The order in which the calls are made is unspecified.
</p>
<p>For example, to create a <em class="math">4x4</em> matrix representing a
cyclic group,
</p>
<div class="example">
<pre class="example-preformatted">    / 0 1 2 3 \
    | 1 2 3 0 |
    | 2 3 0 1 |
    \ 3 0 1 2 /
</pre></div>

<div class="example">
<pre class="example-preformatted">(define a (make-array #f 4 4))
(array-index-map! a (lambda (i j)
                      (modulo (+ i j) 4)))
</pre></div>
</dd></dl>

<p>An additional array function is available in the module
<code class="code">(ice-9 arrays)</code>. It can be used with:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 arrays))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-copy</strong> <var class="def-var-arguments">src</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcopy"> ¶</a></span></dt>
<dd><p>Return a new array with the same elements, type and shape as
<var class="var">src</var>. However, the array increments may not be the same as those of
<var class="var">src</var>. In the current implementation, the returned array will be in
row-major order, but that might change in the future. Use
<code class="code">array-copy!</code> on an array of known order if that is a concern.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Shared-Arrays">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays-as-arrays-of-arrays" accesskey="n" rel="next">Arrays as arrays of arrays</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Array-Procedures" accesskey="p" rel="prev">Array Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="u" rel="up">Arrays</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Shared-Arrays-1">6.6.13.3 Shared Arrays</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dshared_002darray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-shared-array</strong> <var class="def-var-arguments">oldarray mapfunc bound …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dshared_002darray"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fshared_005farray"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_shared_array</strong> <var class="def-var-arguments">(oldarray, mapfunc, boundlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fshared_005farray"> ¶</a></span></dt>
<dd><p>Return a new array which shares the storage of <var class="var">oldarray</var>.
Changes made through either affect the same underlying storage.  The
<var class="var">bound</var> … arguments are the shape of the new array, the same
as <code class="code">make-array</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Array-Procedures">Array Procedures</a>).
</p>
<p><var class="var">mapfunc</var> translates coordinates from the new array to the
<var class="var">oldarray</var>.  It’s called as <code class="code">(<var class="var">mapfunc</var> newidx1 …)</code>
with one parameter for each dimension of the new array, and should
return a list of indices for <var class="var">oldarray</var>, one for each dimension of
<var class="var">oldarray</var>.
</p>
<p><var class="var">mapfunc</var> must be affine linear, meaning that each <var class="var">oldarray</var>
index must be formed by adding integer multiples (possibly negative)
of some or all of <var class="var">newidx1</var> etc, plus a possible integer offset.
The multiples and offset must be the same in each call.
</p>
<br>
<p>One good use for a shared array is to restrict the range of some
dimensions, so as to apply say <code class="code">array-for-each</code> or
<code class="code">array-fill!</code> to only part of an array.  The plain <code class="code">list</code>
function can be used for <var class="var">mapfunc</var> in this case, making no changes
to the index values.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #2((a b c) (d e f) (g h i)) list 3 2)
⇒ #2((a b) (d e) (g h))
</pre></div>

<p>The new array can have fewer dimensions than <var class="var">oldarray</var>, for
example to take a column from an array.
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i) (list i 2))
                   '(0 2))
⇒ #1(c f i)
</pre></div>

<p>A diagonal can be taken by using the single new array index for both
row and column in the old array.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i) (list i i))
                   '(0 2))
⇒ #1(a e i)
</pre></div>

<p>Dimensions can be increased by for instance considering portions of a
one dimensional array as rows in a two dimensional array.
(<code class="code">array-contents</code> below can do the opposite, flattening an
array.)
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #1(a b c d e f g h i j k l)
                   (lambda (i j) (list (+ (* i 3) j)))
                   4 3)
⇒ #2((a b c) (d e f) (g h i) (j k l))
</pre></div>

<p>By negating an index the order that elements appear can be reversed.
The following just reverses the column order,
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #2((a b c) (d e f) (g h i))
                   (lambda (i j) (list i (- 2 j)))
                   3 3)
⇒ #2((c b a) (f e d) (i h g))
</pre></div>

<p>A fixed offset on indexes allows for instance a change from a 0 based
to a 1 based array,
</p>
<div class="example">
<pre class="example-preformatted">(define x #2((a b c) (d e f) (g h i)))
(define y (make-shared-array x
                             (lambda (i j) (list (1- i) (1- j)))
                             '(1 3) '(1 3)))
(array-ref x 0 0) ⇒ a
(array-ref y 1 1) ⇒ a
</pre></div>

<p>A multiple on an index allows every Nth element of an array to be
taken.  The following is every third element,
</p>
<div class="example">
<pre class="example-preformatted">(make-shared-array #1(a b c d e f g h i j k l)
                   (lambda (i) (list (* i 3)))
                   4)
⇒ #1(a d g j)
</pre></div>

<p>The above examples can be combined to make weird and wonderful
selections from an array, but it’s important to note that because
<var class="var">mapfunc</var> must be affine linear, arbitrary permutations are not
possible.
</p>
<p>In the current implementation, <var class="var">mapfunc</var> is not called for every
access to the new array but only on some sample points to establish a
base and stride for new array indices in <var class="var">oldarray</var> data.  A few
sample points are enough because <var class="var">mapfunc</var> is linear.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-shared_002darray_002dincrements"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">shared-array-increments</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-shared_002darray_002dincrements"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fshared_005farray_005fincrements"><span class="category-def">C Function: </span><span><strong class="def-name">scm_shared_array_increments</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fshared_005farray_005fincrements"> ¶</a></span></dt>
<dd><p>For each dimension, return the distance between elements in the root vector.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-shared_002darray_002doffset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">shared-array-offset</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-shared_002darray_002doffset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fshared_005farray_005foffset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_shared_array_offset</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fshared_005farray_005foffset"> ¶</a></span></dt>
<dd><p>Return the root vector index of the first element in the array.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-shared_002darray_002droot"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">shared-array-root</strong> <var class="def-var-arguments">array</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-shared_002darray_002droot"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fshared_005farray_005froot"><span class="category-def">C Function: </span><span><strong class="def-name">scm_shared_array_root</strong> <var class="def-var-arguments">(array)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fshared_005farray_005froot"> ¶</a></span></dt>
<dd><p>Return the root vector of a shared array.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dcontents"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-contents</strong> <var class="def-var-arguments">array [strict]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcontents"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fcontents"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_contents</strong> <var class="def-var-arguments">(array, strict)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fcontents"> ¶</a></span></dt>
<dd><p>If <var class="var">array</var> may be <em class="dfn">unrolled</em> into a one dimensional shared array
without changing their order (last subscript changing fastest), then
<code class="code">array-contents</code> returns that shared array, otherwise it returns
<code class="code">#f</code>.  All arrays made by <code class="code">make-array</code> and
<code class="code">make-typed-array</code> may be unrolled, some arrays made by
<code class="code">make-shared-array</code> may not be.
</p>
<p>If the optional argument <var class="var">strict</var> is provided, a shared array will
be returned only if its elements are stored internally contiguous in
memory.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-transpose_002darray"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">transpose-array</strong> <var class="def-var-arguments">array dim1 dim2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-transpose_002darray"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftranspose_005farray"><span class="category-def">C Function: </span><span><strong class="def-name">scm_transpose_array</strong> <var class="def-var-arguments">(array, dimlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftranspose_005farray"> ¶</a></span></dt>
<dd><p>Return an array sharing contents with <var class="var">array</var>, but with
dimensions arranged in a different order.  There must be one
<var class="var">dim</var> argument for each dimension of <var class="var">array</var>.
<var class="var">dim1</var>, <var class="var">dim2</var>, … should be integers between 0
and the rank of the array to be returned.  Each integer in that
range must appear at least once in the argument list.
</p>
<p>The values of <var class="var">dim1</var>, <var class="var">dim2</var>, … correspond to
dimensions in the array to be returned, and their positions in the
argument list to dimensions of <var class="var">array</var>.  Several <var class="var">dim</var>s
may have the same value, in which case the returned array will
have smaller rank than <var class="var">array</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(transpose-array '#2((a b) (c d)) 1 0) ⇒ #2((a c) (b d))
(transpose-array '#2((a b) (c d)) 0 0) ⇒ #1(a d)
(transpose-array '#3(((a b c) (d e f)) ((1 2 3) (4 5 6))) 1 1 0) ⇒
                #2((a 4) (b 5) (c 6))
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Arrays-as-arrays-of-arrays">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Arrays-from-C" accesskey="n" rel="next">Accessing Arrays from C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Shared-Arrays" accesskey="p" rel="prev">Shared Arrays</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="u" rel="up">Arrays</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Arrays-as-arrays-of-arrays-1">6.6.13.4 Arrays as arrays of arrays</h4>

<a class="index-entry-id" id="index-array-cell"></a>

<p>One can see an array of rank <em class="math">n</em> (an
<em class="math">n</em>-array) as an array of lower rank where the elements are
themselves arrays (‘cells’).
</p>
<a class="index-entry-id" id="index-array-frame"></a>
<a class="index-entry-id" id="index-frame-rank"></a>

<p>We speak of the first <em class="math">n-k</em> dimensions of the array as the
<em class="math">n-k</em>-‘frame’ of the array, while the last <em class="math">k</em> dimensions are
the dimensions of the <em class="math">k</em>-‘cells’. For example, a 3-array can be
seen as a 2-array of vectors (1-arrays) or as a 1-array of matrices
(2-arrays). In each case, the vectors or matrices are the 1-cells or
2-cells of the array. This terminology originates in the J language.
</p>
<a class="index-entry-id" id="index-array-slice"></a>
<a class="index-entry-id" id="index-prefix-slice"></a>

<p>The more vague concept of a ‘slice’ refers to a subset of the array
where some indices are fixed and others are left free. As a Guile data
object, a cell is the same as a ‘prefix slice’ (the first <em class="math">n-k</em>
indices into the original array are fixed), except that a 0-cell is not
a shared array of the original array, but a 0-slice (where all the
indices into the original array are fixed) is.
</p>
<a class="index-entry-id" id="index-enclosed-array"></a>

<p>Before version&nbsp;2.0<!-- /@w -->, Guile had a feature called ‘enclosed arrays’ to
create special ‘array of arrays’ objects. The functions in this section
do not need special types; instead, the frame rank is stated in each
function call, either implicitly or explicitly.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-array_002dcell_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-cell-ref</strong> <var class="def-var-arguments">array idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcell_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fcell_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_cell_ref</strong> <var class="def-var-arguments">(array, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fcell_005fref"> ¶</a></span></dt>
<dd><p>If the length of <var class="var">idxlist</var> equals the rank <em class="math">n</em> of <var class="var">array</var>,
return the element at <code class="code">(idx …)</code>, just like <code class="code">(array-ref
array idx …)</code>. If, however, the length <em class="math">k</em> of <var class="var">idxlist</var>
is smaller than <em class="math">n</em>, then return the <em class="math">(n-k)</em>-cell of
<var class="var">array</var> given by <var class="var">idxlist</var>, as a shared array.
</p>
<p>For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(array-cell-ref #2((a b) (c d)) 0) ⇒ #(a b)
(array-cell-ref #2((a b) (c d)) 1) ⇒ #(c d)
(array-cell-ref #2((a b) (c d)) 1 1) ⇒ d
(array-cell-ref #2((a b) (c d))) ⇒ #2((a b) (c d))
</pre></div>

<p><code class="code">(apply array-cell-ref array indices)</code> is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((len (length indices)))
  (if (= (array-rank a) len)
    (apply array-ref a indices)
    (apply make-shared-array a
           (lambda t (append indices t))
           (drop (array-dimensions a) len))))
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dslice"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-slice</strong> <var class="def-var-arguments">array idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dslice"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fslice"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_slice</strong> <var class="def-var-arguments">(array, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fslice"> ¶</a></span></dt>
<dd><p>Like <code class="code">(array-cell-ref array idx …)</code>, but return a 0-rank
shared array into <var class="var">ARRAY</var> if the length of <var class="var">idxlist</var> matches the
rank of <var class="var">array</var>. This can be useful when using <var class="var">ARRAY</var> as a
place to write to.
</p>
<p>Compare:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(array-cell-ref #2((a b) (c d)) 1 1) ⇒ d
(array-slice #2((a b) (c d)) 1 1) ⇒ #0(d)
(define a (make-array 'a 2 2))
(array-fill! (array-slice a 1 1) 'b)
a ⇒ #2((a a) (a b)).
(array-fill! (array-cell-ref a 1 1) 'b) ⇒ error: not an array
</pre></div>

<p><code class="code">(apply array-slice array indices)</code> is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(apply make-shared-array a
  (lambda t (append indices t))
  (drop (array-dimensions a) (length indices)))
</pre></div>
</dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-array_002dcell_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-cell-set!</strong> <var class="def-var-arguments">array x idx …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dcell_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fcell_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_cell_set_x</strong> <var class="def-var-arguments">(array, x, idxlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fcell_005fset_005fx"> ¶</a></span></dt>
<dd><p>If the length of <var class="var">idxlist</var> equals the rank <em class="math">n</em> of
<var class="var">array</var>, set the element at <code class="code">(idx …)</code> of <var class="var">array</var> to
<var class="var">x</var>, just like <code class="code">(array-set! array x idx …)</code>. If,
however, the length <em class="math">k</em> of <var class="var">idxlist</var> is smaller than
<em class="math">n</em>, then copy the <em class="math">(n-k)</em>-rank array <var class="var">x</var>
into the <em class="math">(n-k)</em>-cell of <var class="var">array</var> given by
<var class="var">idxlist</var>. In this case, the last <em class="math">(n-k)</em> dimensions of
<var class="var">array</var> and the dimensions of <var class="var">x</var> must match exactly.
</p>
<p>This function returns the modified <var class="var">array</var>.
</p>
<p>For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(array-cell-set! (make-array 'a 2 2) b 1 1)
  ⇒ #2((a a) (a b))
(array-cell-set! (make-array 'a 2 2) #(x y) 1)
  ⇒ #2((a a) (x y))
</pre></div>

<p>Note that <code class="code">array-cell-set!</code> will expect elements, not arrays, when
the destination has rank 0. Use <code class="code">array-slice</code> for the opposite
behavior.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(array-cell-set! (make-array 'a 2 2) #0(b) 1 1)
  ⇒ #2((a a) (a #0(b)))
(let ((a (make-array 'a 2 2)))
  (array-copy! #0(b) (array-slice a 1 1)) a)
  ⇒ #2((a a) (a b))
</pre></div>

<p><code class="code">(apply array-cell-set! array x indices)</code> is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((len (length indices)))
  (if (= (array-rank array) len)
    (apply array-set! array x indices)
    (array-copy! x (apply array-cell-ref array indices)))
  array)
</pre></div>

</dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-array_002dslice_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-slice-for-each</strong> <var class="def-var-arguments">frame-rank op x …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dslice_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fslice_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_slice_for_each</strong> <var class="def-var-arguments">(array, frame_rank, op, xlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fslice_005ffor_005feach"> ¶</a></span></dt>
<dd><p>Each <var class="var">x</var> must be an array of rank ≥ <var class="var">frame-rank</var>, and
the first <var class="var">frame-rank</var> dimensions of each <var class="var">x</var> must all be the
same. <var class="var">array-slice-for-each</var> calls <var class="var">op</var> with each set of
(rank(<var class="var">x</var>) - <var class="var">frame-rank</var>)-cells from <var class="var">x</var>, in unspecified order.
</p>
<p><var class="var">array-slice-for-each</var> allows you to loop over cells of any rank
without having to carry an index list or construct shared arrays
manually. The slices passed to <var class="var">op</var> are always shared arrays of
<var class="var">X</var>, even if they are of rank 0, so it is possible to write to them.
</p>
<p>This function returns an unspecified value.
</p>
<p>For example, to sort the rows of rank-2 array <code class="code">a</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(array-slice-for-each 1 (lambda (x) (sort! x &lt;)) a)
</pre></div>

<p>As another example, let <code class="code">a</code> be a rank-2 array where each row is a
2-element vector <em class="math">(x,y)</em>.  Let’s compute the arguments of these
vectors and store them in rank-1 array <code class="code">b</code>.
</p><div class="example lisp">
<pre class="lisp-preformatted">(array-slice-for-each 1
  (lambda (a b)
    (array-set! b (atan (array-ref a 1) (array-ref a 0))))
  a b)
</pre></div>

<p><code class="code">(apply array-slice-for-each frame-rank op x)</code> is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((frame (take (array-dimensions (car x)) frank)))
  (unless (every (lambda (x)
                   (equal? frame (take (array-dimensions x) frank)))
                 (cdr x))
    (error))
  (array-index-map!
    (apply make-shared-array (make-array #t) (const '()) frame)
    (lambda i (apply op (map (lambda (x) (apply array-slice x i)) x)))))
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-array_002dslice_002dfor_002deach_002din_002dorder"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">array-slice-for-each-in-order</strong> <var class="def-var-arguments">frame-rank op x …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dslice_002dfor_002deach_002din_002dorder"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005farray_005fslice_005ffor_005feach_005fin_005forder"><span class="category-def">C Function: </span><span><strong class="def-name">scm_array_slice_for_each_in_order</strong> <var class="def-var-arguments">(array, frame_rank, op, xlist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fslice_005ffor_005feach_005fin_005forder"> ¶</a></span></dt>
<dd><p>Same as <code class="code">array-slice-for-each</code>, but the arguments are traversed
sequentially and in row-major order.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Accessing-Arrays-from-C">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays-as-arrays-of-arrays" accesskey="p" rel="prev">Arrays as arrays of arrays</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="u" rel="up">Arrays</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Accessing-Arrays-from-C-1">6.6.13.5 Accessing Arrays from C</h4>

<p>For interworking with external C code, Guile provides an API to allow C
code to access the elements of a Scheme array.  In particular, for
uniform numeric arrays, the API exposes the underlying uniform data as a
C array of numbers of the relevant type.
</p>
<p>While pointers to the elements of an array are in use, the array itself
must be protected so that the pointer remains valid.  Such a protected
array is said to be <em class="dfn">reserved</em>.  A reserved array can be read but
modifications to it that would cause the pointer to its elements to
become invalid are prevented.  When you attempt such a modification, an
error is signalled.
</p>
<p>(This is similar to locking the array while it is in use, but without
the danger of a deadlock.  In a multi-threaded program, you will need
additional synchronization to avoid modifying reserved arrays.)
</p>
<p>You must take care to always unreserve an array after reserving it,
even in the presence of non-local exits.  If a non-local exit can
happen between these two calls, you should install a dynwind context
that releases the array when it is left (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).
</p>
<p>In addition, array reserving and unreserving must be properly
paired.  For instance, when reserving two or more arrays in a certain
order, you need to unreserve them in the opposite order.
</p>
<p>Once you have reserved an array and have retrieved the pointer to its
elements, you must figure out the layout of the elements in memory.
Guile allows slices to be taken out of arrays without actually making a
copy, such as making an alias for the diagonal of a matrix that can be
treated as a vector.  Arrays that result from such an operation are not
stored contiguously in memory and when working with their elements
directly, you need to take this into account.
</p>
<p>The layout of array elements in memory can be defined via a
<em class="emph">mapping function</em> that computes a scalar position from a vector of
indices.  The scalar position then is the offset of the element with the
given indices from the start of the storage block of the array.
</p>
<p>In Guile, this mapping function is restricted to be <em class="dfn">affine</em>: all
mapping functions of Guile arrays can be written as <code class="code">p = b +
c[0]*i[0] + c[1]*i[1] + ... + c[n-1]*i[n-1]</code> where <code class="code">i[k]</code> is the
<code class="code">k</code>th index and <code class="code">n</code> is the rank of the array.  For
example, a matrix of size 3x3 would have <code class="code">b == 0</code>, <code class="code">c[0] ==
3</code> and <code class="code">c[1] == 1</code>.  When you transpose this matrix (with
<code class="code">transpose-array</code>, say), you will get an array whose mapping
function has <code class="code">b == 0</code>, <code class="code">c[0] == 1</code> and <code class="code">c[1] == 3</code>.
</p>
<p>The function <code class="code">scm_array_handle_dims</code> gives you (indirect) access to
the coefficients <code class="code">c[k]</code>.
</p>
<p>Note that there are no functions for accessing the elements of a
character array yet.  Once the string implementation of Guile has been
changed to use Unicode, we will provide them.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005farray_005fhandle"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_array_handle</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005farray_005fhandle"> ¶</a></span></dt>
<dd><p>This is a structure type that holds all information necessary to manage
the reservation of arrays as explained above.  Structures of this type
must be allocated on the stack and must only be accessed by the
functions listed below.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fget_005fhandle"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_array_get_handle</strong> <code class="def-code-arguments">(SCM array, scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fget_005fhandle"> ¶</a></span></dt>
<dd><p>Reserve <var class="var">array</var>, which must be an array, and prepare <var class="var">handle</var> to
be used with the functions below.  You must eventually call
<code class="code">scm_array_handle_release</code> on <var class="var">handle</var>, and do this in a
properly nested fashion, as explained above.  The structure pointed to
by <var class="var">handle</var> does not need to be initialized before calling this
function.
</p></dd></dl>

<a class="anchor" id="x_002dscm_005farray_005fhandle_005frelease"></a><dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005frelease"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_array_handle_release</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005frelease"> ¶</a></span></dt>
<dd><p>End the array reservation represented by <var class="var">handle</var>.  After a call to
this function, <var class="var">handle</var> might be used for another reservation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005frank"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_array_handle_rank</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005frank"> ¶</a></span></dt>
<dd><p>Return the rank of the array represented by <var class="var">handle</var>.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005farray_005fdim"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_array_dim</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005farray_005fdim"> ¶</a></span></dt>
<dd><p>This structure type holds information about the layout of one dimension
of an array.  It includes the following fields:
</p>
<dl class="table">
<dt><code class="code">ssize_t lbnd</code></dt>
<dt><code class="code">ssize_t ubnd</code></dt>
<dd><p>The lower and upper bounds (both inclusive) of the permissible index
range for the given dimension.  Both values can be negative, but
<var class="var">lbnd</var> is always less than or equal to <var class="var">ubnd</var>.
</p>
</dd>
<dt><code class="code">ssize_t inc</code></dt>
<dd><p>The distance from one element of this dimension to the next.  Note, too,
that this can be negative.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fdims"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_array_dim *</code> <strong class="def-name">scm_array_handle_dims</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fdims"> ¶</a></span></dt>
<dd><p>Return a pointer to a C vector of information about the dimensions of
the array represented by <var class="var">handle</var>.  This pointer is valid as long as
the array remains reserved.  As explained above, the
<code class="code">scm_t_array_dim</code> structures returned by this function can be used
calculate the position of an element in the storage block of the array
from its indices.
</p>
<p>This position can then be used as an index into the C array pointer
returned by the various <code class="code">scm_array_handle_&lt;foo&gt;_elements</code>
functions, or with <code class="code">scm_array_handle_ref</code> and
<code class="code">scm_array_handle_set</code>.
</p>
<p>Here is how one can compute the position <var class="var">pos</var> of an element given
its indices in the vector <var class="var">indices</var>:
</p>
<div class="example">
<pre class="example-preformatted">ssize_t indices[RANK];
scm_t_array_dim *dims;
ssize_t pos;
size_t i;

pos = 0;
for (i = 0; i &lt; RANK; i++)
  {
    if (indices[i] &lt; dims[i].lbnd || indices[i] &gt; dims[i].ubnd)
      out_of_range ();
    pos += (indices[i] - dims[i].lbnd) * dims[i].inc;
  }
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fpos"><span class="category-def">C Function: </span><span><code class="def-type">ssize_t</code> <strong class="def-name">scm_array_handle_pos</strong> <code class="def-code-arguments">(scm_t_array_handle *handle, SCM indices)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fpos"> ¶</a></span></dt>
<dd><p>Compute the position corresponding to <var class="var">indices</var>, a list of
indices.  The position is computed as described above for
<code class="code">scm_array_handle_dims</code>.  The number of the indices and their
range is checked and an appropriate error is signalled for invalid
indices.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_array_handle_ref</strong> <code class="def-code-arguments">(scm_t_array_handle *handle, ssize_t pos)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fref"> ¶</a></span></dt>
<dd><p>Return the element at position <var class="var">pos</var> in the storage block of the
array represented by <var class="var">handle</var>.  Any kind of array is acceptable.  No
range checking is done on <var class="var">pos</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fset"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_array_handle_set</strong> <code class="def-code-arguments">(scm_t_array_handle *handle, ssize_t pos, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fset"> ¶</a></span></dt>
<dd><p>Set the element at position <var class="var">pos</var> in the storage block of the array
represented by <var class="var">handle</var> to <var class="var">val</var>.  Any kind of array is
acceptable.  No range checking is done on <var class="var">pos</var>.  An error is
signalled when the array can not store <var class="var">val</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const SCM *</code> <strong class="def-name">scm_array_handle_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005felements"> ¶</a></span></dt>
<dd><p>Return a pointer to the elements of a ordinary array of general Scheme
values (i.e., a non-uniform array) for reading.  This pointer is valid
as long as the array remains reserved.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">SCM *</code> <strong class="def-name">scm_array_handle_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_array_handle_elements</code>, but the pointer is good for
reading and writing.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005funiform_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const void *</code> <strong class="def-name">scm_array_handle_uniform_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005funiform_005felements"> ¶</a></span></dt>
<dd><p>Return a pointer to the elements of a uniform numeric array for reading.
This pointer is valid as long as the array remains reserved.  The size
of each element is given by <code class="code">scm_array_handle_uniform_element_size</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005funiform_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_array_handle_uniform_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005funiform_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_array_handle_uniform_elements</code>, but the pointer is good
reading and writing.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005funiform_005felement_005fsize"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_array_handle_uniform_element_size</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005funiform_005felement_005fsize"> ¶</a></span></dt>
<dd><p>Return the size of one element of the uniform numeric array represented
by <var class="var">handle</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fu8_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint8 *</code> <strong class="def-name">scm_array_handle_u8_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu8_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs8_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int8 *</code> <strong class="def-name">scm_array_handle_s8_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs8_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu16_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint16 *</code> <strong class="def-name">scm_array_handle_u16_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu16_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs16_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int16 *</code> <strong class="def-name">scm_array_handle_s16_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs16_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu32_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint32 *</code> <strong class="def-name">scm_array_handle_u32_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu32_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs32_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int32 *</code> <strong class="def-name">scm_array_handle_s32_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs32_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu64_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint64 *</code> <strong class="def-name">scm_array_handle_u64_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu64_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs64_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int64 *</code> <strong class="def-name">scm_array_handle_s64_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs64_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005ff32_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const float *</code> <strong class="def-name">scm_array_handle_f32_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005ff32_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005ff64_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const double *</code> <strong class="def-name">scm_array_handle_f64_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005ff64_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fc32_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const float *</code> <strong class="def-name">scm_array_handle_c32_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fc32_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fc64_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const double *</code> <strong class="def-name">scm_array_handle_c64_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fc64_005felements"> ¶</a></span></dt>
<dd><p>Return a pointer to the elements of a uniform numeric array of the
indicated kind for reading.  This pointer is valid as long as the array
remains reserved.
</p>
<p>The pointers for <code class="code">c32</code> and <code class="code">c64</code> uniform numeric arrays point
to pairs of floating point numbers.  The even index holds the real part,
the odd index the imaginary part of the complex number.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fu8_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint8 *</code> <strong class="def-name">scm_array_handle_u8_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu8_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs8_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int8 *</code> <strong class="def-name">scm_array_handle_s8_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs8_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu16_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint16 *</code> <strong class="def-name">scm_array_handle_u16_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu16_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs16_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int16 *</code> <strong class="def-name">scm_array_handle_s16_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs16_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu32_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint32 *</code> <strong class="def-name">scm_array_handle_u32_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu32_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs32_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int32 *</code> <strong class="def-name">scm_array_handle_s32_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs32_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fu64_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint64 *</code> <strong class="def-name">scm_array_handle_u64_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fu64_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fs64_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int64 *</code> <strong class="def-name">scm_array_handle_s64_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fs64_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005ff32_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">float *</code> <strong class="def-name">scm_array_handle_f32_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005ff32_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005ff64_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">double *</code> <strong class="def-name">scm_array_handle_f64_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005ff64_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fc32_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">float *</code> <strong class="def-name">scm_array_handle_c32_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fc32_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005farray_005fhandle_005fc64_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">double *</code> <strong class="def-name">scm_array_handle_c64_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fc64_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_array_handle_&lt;kind&gt;_elements</code>, but the pointer is good
for reading and writing.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fbit_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint32 *</code> <strong class="def-name">scm_array_handle_bit_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fbit_005felements"> ¶</a></span></dt>
<dd><p>Return a pointer to the words that store the bits of the represented
array, which must be a bit array.
</p>
<p>Unlike other arrays, bit arrays have an additional offset that must be
figured into index calculations.  That offset is returned by
<code class="code">scm_array_handle_bit_elements_offset</code>.
</p>
<p>To find a certain bit you first need to calculate its position as
explained above for <code class="code">scm_array_handle_dims</code> and then add the
offset.  This gives the absolute position of the bit, which is always a
non-negative integer.
</p>
<p>Each word of the bit array storage block contains exactly 32 bits, with
the least significant bit in that word having the lowest absolute
position number.  The next word contains the next 32 bits.
</p>
<p>Thus, the following code can be used to access a bit whose position
according to <code class="code">scm_array_handle_dims</code> is given in <var class="var">pos</var>:
</p>
<div class="example">
<pre class="example-preformatted">SCM bit_array;
scm_t_array_handle handle;
scm_t_uint32 *bits;
ssize_t pos;
size_t abs_pos;
size_t word_pos, mask;

scm_array_get_handle (&amp;bit_array, &amp;handle);
bits = scm_array_handle_bit_elements (&amp;handle);

pos = ...
abs_pos = pos + scm_array_handle_bit_elements_offset (&amp;handle);
word_pos = abs_pos / 32;
mask = 1L &lt;&lt; (abs_pos % 32);

if (bits[word_pos] &amp; mask)
  /* bit is set. */

scm_array_handle_release (&amp;handle);
</pre></div>

</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005farray_005fhandle_005fbit_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint32 *</code> <strong class="def-name">scm_array_handle_bit_writable_elements</strong> <code class="def-code-arguments">(scm_t_array_handle *handle)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005farray_005fhandle_005fbit_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_array_handle_bit_elements</code> but the pointer is good for
reading and writing.  You must take care not to modify bits outside of
the allowed index range of the array, even for contiguous arrays.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="VLists">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Record-Overview" accesskey="n" rel="next">Record Overview</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Arrays" accesskey="p" rel="prev">Arrays</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="VLists-1">6.6.14 VLists</h4>

<a class="index-entry-id" id="index-vlist"></a>

<p>The <code class="code">(ice-9 vlist)</code> module provides an implementation of the <em class="dfn">VList</em>
data structure designed by Phil Bagwell in 2002.  VLists are immutable lists,
which can contain any Scheme object.  They improve on standard Scheme linked
lists in several areas:
</p>
<ul class="itemize mark-bullet">
<li>Random access has typically constant-time complexity.

</li><li>Computing the length of a VList has time complexity logarithmic in the number of
elements.

</li><li>VLists use less storage space than standard lists.

</li><li>VList elements are stored in contiguous regions, which improves memory locality
and leads to more efficient use of hardware caches.
</li></ul>

<p>The idea behind VLists is to store vlist elements in increasingly large
contiguous blocks (implemented as vectors here).  These blocks are linked to one
another using a pointer to the next block and an offset within that block.  The
size of these blocks form a geometric series with ratio
<code class="code">block-growth-factor</code> (2 by default).
</p>
<p>The VList structure also serves as the basis for the <em class="dfn">VList-based hash
lists</em> or “vhashes”, an immutable dictionary type (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#VHashes">VList-Based Hash Lists or “VHashes”</a>).
</p>
<p>However, the current implementation in <code class="code">(ice-9 vlist)</code> has several
noteworthy shortcomings:
</p>
<ul class="itemize mark-bullet">
<li>It is <em class="emph">not</em> thread-safe.  Although operations on vlists are all
<em class="dfn">referentially transparent</em> (i.e., purely functional), adding elements to a
vlist with <code class="code">vlist-cons</code> mutates part of its internal structure, which makes
it non-thread-safe.  This could be fixed, but it would slow down
<code class="code">vlist-cons</code>.

</li><li><code class="code">vlist-cons</code> always allocates at least as much memory as <code class="code">cons</code>.
Again, Phil Bagwell describes how to fix it, but that would require tuning the
garbage collector in a way that may not be generally beneficial.

</li><li><code class="code">vlist-cons</code> is a Scheme procedure compiled to bytecode, and it does not
compete with the straightforward C implementation of <code class="code">cons</code>, and with the
fact that the VM has a special <code class="code">cons</code> instruction.

</li></ul>

<p>We hope to address these in the future.
</p>
<p>The programming interface exported by <code class="code">(ice-9 vlist)</code> is defined below.
Most of it is the same as SRFI-1 with an added <code class="code">vlist-</code> prefix to function
names.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-vlist_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a VList.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-vlist_002dnull"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">vlist-null</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dnull"> ¶</a></span></dt>
<dd><p>The empty VList.  Note that it’s possible to create an empty VList not
<code class="code">eq?</code> to <code class="code">vlist-null</code>; thus, callers should always use
<code class="code">vlist-null?</code> when testing whether a VList is empty.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dnull_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-null?</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dnull_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">vlist</var> is empty.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dcons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-cons</strong> <var class="def-var-arguments">item vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dcons"> ¶</a></span></dt>
<dd><p>Return a new vlist with <var class="var">item</var> as its head and <var class="var">vlist</var> as its tail.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dhead"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-head</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dhead"> ¶</a></span></dt>
<dd><p>Return the head of <var class="var">vlist</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dtail"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-tail</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dtail"> ¶</a></span></dt>
<dd><p>Return the tail of <var class="var">vlist</var>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-block_002dgrowth_002dfactor"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">block-growth-factor</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-block_002dgrowth_002dfactor"> ¶</a></span></dt>
<dd><p>A fluid that defines the growth factor of VList blocks, 2 by default.
</p></dd></dl>

<p>The functions below provide the usual set of higher-level list operations.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-fold</strong> <var class="def-var-arguments">proc init vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vlist_002dfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-fold-right</strong> <var class="def-var-arguments">proc init vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dfold_002dright"> ¶</a></span></dt>
<dd><p>Fold over <var class="var">vlist</var>, calling <var class="var">proc</var> for each element, as for SRFI-1
<code class="code">fold</code> and <code class="code">fold-right</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1"><code class="code">fold</code></a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-ref</strong> <var class="def-var-arguments">vlist index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dref"> ¶</a></span></dt>
<dd><p>Return the element at index <var class="var">index</var> in <var class="var">vlist</var>.  This is typically a
constant-time operation.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-length</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dlength"> ¶</a></span></dt>
<dd><p>Return the length of <var class="var">vlist</var>.  This is typically logarithmic in the number
of elements in <var class="var">vlist</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dreverse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-reverse</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dreverse"> ¶</a></span></dt>
<dd><p>Return a new <var class="var">vlist</var> whose content are those of <var class="var">vlist</var> in reverse
order.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-map</strong> <var class="def-var-arguments">proc vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dmap"> ¶</a></span></dt>
<dd><p>Map <var class="var">proc</var> over the elements of <var class="var">vlist</var> and return a new vlist.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-for-each</strong> <var class="def-var-arguments">proc vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dfor_002deach"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> on each element of <var class="var">vlist</var>.  The result is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002ddrop"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-drop</strong> <var class="def-var-arguments">vlist count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002ddrop"> ¶</a></span></dt>
<dd><p>Return a new vlist that does not contain the <var class="var">count</var> first elements of
<var class="var">vlist</var>.  This is typically a constant-time operation.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dtake"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-take</strong> <var class="def-var-arguments">vlist count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dtake"> ¶</a></span></dt>
<dd><p>Return a new vlist that contains only the <var class="var">count</var> first elements of
<var class="var">vlist</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dfilter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-filter</strong> <var class="def-var-arguments">pred vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dfilter"> ¶</a></span></dt>
<dd><p>Return a new vlist containing all the elements from <var class="var">vlist</var> that satisfy
<var class="var">pred</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-delete</strong> <var class="def-var-arguments">x vlist [equal?]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002ddelete"> ¶</a></span></dt>
<dd><p>Return a new vlist corresponding to <var class="var">vlist</var> without the elements
<var class="var">equal?</var> to <var class="var">x</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dunfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-unfold</strong> <var class="def-var-arguments">p f g seed [tail-gen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dunfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vlist_002dunfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-unfold-right</strong> <var class="def-var-arguments">p f g seed [tail]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dunfold_002dright"> ¶</a></span></dt>
<dd><p>Return a new vlist, as for SRFI-1 <code class="code">unfold</code> and <code class="code">unfold-right</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1"><code class="code">unfold</code></a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002dappend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-append</strong> <var class="def-var-arguments">vlist …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002dappend"> ¶</a></span></dt>
<dd><p>Append the given vlists and return the resulting vlist.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003evlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;vlist</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003evlist"> ¶</a></span></dt>
<dd><p>Return a new vlist whose contents correspond to <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vlist_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vlist-&gt;list</strong> <var class="def-var-arguments">vlist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vlist_002d_003elist"> ¶</a></span></dt>
<dd><p>Return a new list whose contents match those of <var class="var">vlist</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Record-Overview">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records" accesskey="n" rel="next">SRFI-9 Records</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#VLists" accesskey="p" rel="prev">VLists</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Record-Overview-1">6.6.15 Record Overview</h4>

<a class="index-entry-id" id="index-record"></a>
<a class="index-entry-id" id="index-structure"></a>

<p><em class="dfn">Records</em>, also called <em class="dfn">structures</em>, are Scheme’s primary
mechanism to define new disjoint types.  A <em class="dfn">record type</em> defines a
list of <em class="dfn">fields</em> that instances of the type consist of.  This is like
C’s <code class="code">struct</code>.
</p>
<p>Historically, Guile has offered several different ways to define record
types and to create records, offering different features, and making
different trade-offs.  Over the years, each “standard” has also come
with its own new record interface, leading to a maze of record APIs.
</p>
<p>At the highest level is SRFI-9, a high-level record interface
implemented by most Scheme implementations (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records">SRFI-9 Records</a>).  It
defines a simple and efficient syntactic abstraction of record types and
their associated type predicate, fields, and field accessors.  SRFI-9 is
suitable for most uses, and this is the recommended way to create record
types in Guile.  Similar high-level record APIs include SRFI-35
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d35">SRFI-35 - Conditions</a>) and R6RS records (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-records-syntactic">rnrs records syntactic</a>).
</p>
<p>Then comes Guile’s historical “records” API (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a>).  Record
types defined this way are first-class objects.  Introspection
facilities are available, allowing users to query the list of fields or
the value of a specific field at run-time, without prior knowledge of
the type.
</p>
<p>Finally, the common denominator of these interfaces is Guile’s
<em class="dfn">structure</em> API (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Structures">Structures</a>).  Guile’s structures are the
low-level building block for all other record APIs.  Application writers
will normally not need to use it.
</p>
<p>Records created with these APIs may all be pattern-matched using Guile’s
standard pattern matcher (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Pattern-Matching">Pattern Matching</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d9-Records">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Records" accesskey="n" rel="next">Records</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Record-Overview" accesskey="p" rel="prev">Record Overview</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d9-Records-1">6.6.16 SRFI-9 Records</h4>

<a class="index-entry-id" id="index-SRFI_002d9"></a>
<a class="index-entry-id" id="index-record-1"></a>

<p>SRFI-9 standardizes a syntax for defining new record types and creating
predicate, constructor, and field getter and setter functions.  In Guile
this is the recommended option to create new record types (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Record-Overview">Record Overview</a>).  It can be used with:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-9))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002drecord_002dtype"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-record-type</strong> <var class="def-var-arguments">type <br> (constructor fieldname …) <br> predicate <br> (fieldname accessor [modifier]) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002drecord_002dtype"> ¶</a></span></dt>
<dd><br>
<p>Create a new record type, and make various <code class="code">define</code>s for using
it.  This syntax can only occur at the top-level, not nested within
some other form.
</p>
<p><var class="var">type</var> is bound to the record type, which is as per the return
from the core <code class="code">make-record-type</code>.  <var class="var">type</var> also provides the
name for the record, as per <code class="code">record-type-name</code>.
</p>
<p><var class="var">constructor</var> is bound to a function to be called as
<code class="code">(<var class="var">constructor</var> fieldval …)</code> to create a new record of
this type.  The arguments are initial values for the fields, one
argument for each field, in the order they appear in the
<code class="code">define-record-type</code> form.
</p>
<p>The <var class="var">fieldname</var>s provide the names for the record fields, as per
the core <code class="code">record-type-fields</code> etc, and are referred to in the
subsequent accessor/modifier forms.
</p>
<p><var class="var">predicate</var> is bound to a function to be called as
<code class="code">(<var class="var">predicate</var> obj)</code>.  It returns <code class="code">#t</code> or <code class="code">#f</code>
according to whether <var class="var">obj</var> is a record of this type.
</p>
<p>Each <var class="var">accessor</var> is bound to a function to be called
<code class="code">(<var class="var">accessor</var> record)</code> to retrieve the respective field from a
<var class="var">record</var>.  Similarly each <var class="var">modifier</var> is bound to a function to
be called <code class="code">(<var class="var">modifier</var> record val)</code> to set the respective
field in a <var class="var">record</var>.
</p></dd></dl>

<p>An example will illustrate typical usage,
</p>
<div class="example">
<pre class="example-preformatted">(define-record-type &lt;employee&gt;
  (make-employee name age salary)
  employee?
  (name    employee-name)
  (age     employee-age    set-employee-age!)
  (salary  employee-salary set-employee-salary!))
</pre></div>

<p>This creates a new employee data type, with name, age and salary
fields.  Accessor functions are created for each field, but no
modifier function for the name (the intention in this example being
that it’s established only when an employee object is created).  These
can all then be used as for example,
</p>
<div class="example">
<pre class="example-preformatted">&lt;employee&gt; ⇒ #&lt;record-type &lt;employee&gt;&gt;

(define fred (make-employee "Fred" 45 20000.00))

(employee? fred)        ⇒ #t
(employee-age fred)     ⇒ 45
(set-employee-salary! fred 25000.00)  ;; pay rise
</pre></div>

<p>The functions created by <code class="code">define-record-type</code> are ordinary
top-level <code class="code">define</code>s.  They can be redefined or <code class="code">set!</code> as
desired, exported from a module, etc.
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dtoplevel-Record-Definitions" accesskey="1">Non-toplevel Record Definitions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Printers" accesskey="2">Custom Printers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Functional-_0060_0060Setters_0027_0027" accesskey="3">Functional “Setters”</a></li>
</ul>
<div class="unnumberedsubsubsec-level-extent" id="Non_002dtoplevel-Record-Definitions">
<h4 class="unnumberedsubsubsec">Non-toplevel Record Definitions</h4>

<p>The SRFI-9 specification explicitly disallows record definitions in a
non-toplevel context, such as inside <code class="code">lambda</code> body or inside a
<var class="var">let</var> block.  However, Guile’s implementation does not enforce that
restriction.
</p>
</div>
<div class="unnumberedsubsubsec-level-extent" id="Custom-Printers">
<h4 class="unnumberedsubsubsec">Custom Printers</h4>

<p>You may use <code class="code">set-record-type-printer!</code> to customize the default printing
behavior of records.  This is a Guile extension and is not part of SRFI-9.  It
is located in the <code class="code">(srfi srfi-9 gnu)</code> module.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002drecord_002dtype_002dprinter_0021"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">set-record-type-printer!</strong> <var class="def-var-arguments">type proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002drecord_002dtype_002dprinter_0021"> ¶</a></span></dt>
<dd><p>Where <var class="var">type</var> corresponds to the first argument of <code class="code">define-record-type</code>,
and <var class="var">proc</var> is a procedure accepting two arguments, the record to print, and
an output port.
</p></dd></dl>

<p>This example prints the employee’s name in brackets, for instance <code class="code">[Fred]</code>.
</p>
<div class="example">
<pre class="example-preformatted">(set-record-type-printer! &lt;employee&gt;
  (lambda (record port)
    (write-char #\[ port)
    (display (employee-name record) port)
    (write-char #\] port)))
</pre></div>

</div>
<div class="unnumberedsubsubsec-level-extent" id="Functional-_0060_0060Setters_0027_0027">
<h4 class="unnumberedsubsubsec">Functional “Setters”</h4>

<a class="index-entry-id" id="index-functional-setters"></a>

<p>When writing code in a functional style, it is desirable to never alter
the contents of records.  For such code, a simple way to return new
record instances based on existing ones is highly desirable.
</p>
<p>The <code class="code">(srfi srfi-9 gnu)</code> module extends SRFI-9 with facilities to
return new record instances based on existing ones, only with one or
more field values changed—<em class="dfn">functional setters</em>.  First, the
<code class="code">define-immutable-record-type</code> works like
<code class="code">define-record-type</code>, except that fields are immutable and setters
are defined as functional setters.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dimmutable_002drecord_002dtype"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-immutable-record-type</strong> <var class="def-var-arguments">type <br> (constructor fieldname …) <br> predicate <br> (fieldname accessor [modifier]) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dimmutable_002drecord_002dtype"> ¶</a></span></dt>
<dd><p>Define <var class="var">type</var> as a new record type, like <code class="code">define-record-type</code>.
However, the record type is made <em class="emph">immutable</em> (records may not be
mutated, even with <code class="code">struct-set!</code>), and any <var class="var">modifier</var> is
defined to be a functional setter—a procedure that returns a new
record instance with the specified field changed, and leaves the
original unchanged (see example below.)
</p></dd></dl>

<p>In addition, the generic <code class="code">set-field</code> and <code class="code">set-fields</code> macros
may be applied to any SRFI-9 record.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002dfield"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">set-field</strong> <var class="def-var-arguments">record (field sub-fields ...) value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dfield"> ¶</a></span></dt>
<dd><p>Return a new record of <var class="var">record</var>’s type whose fields are equal to
the corresponding fields of <var class="var">record</var> except for the one specified by
<var class="var">field</var>.
</p>
<p><var class="var">field</var> must be the name of the getter corresponding to the field of
<var class="var">record</var> being “set”.  Subsequent <var class="var">sub-fields</var> must be record
getters designating sub-fields within that field value to be set (see
example below.)
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dfields"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">set-fields</strong> <var class="def-var-arguments">record ((field sub-fields ...) value) ...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dfields"> ¶</a></span></dt>
<dd><p>Like <code class="code">set-field</code>, but can be used to set more than one field at a
time.  This expands to code that is more efficient than a series of
single <code class="code">set-field</code> calls.
</p></dd></dl>

<p>To illustrate the use of functional setters, let’s assume these two
record type definitions:
</p>
<div class="example">
<pre class="example-preformatted">(define-record-type &lt;address&gt;
  (address street city country)
  address?
  (street  address-street)
  (city    address-city)
  (country address-country))

(define-immutable-record-type &lt;person&gt;
  (person age email address)
  person?
  (age     person-age set-person-age)
  (email   person-email set-person-email)
  (address person-address set-person-address))
</pre></div>

<p>First, note that the <code class="code">&lt;person&gt;</code> record type definition introduces
named functional setters.  These may be used like this:
</p>
<div class="example">
<pre class="example-preformatted">(define fsf-address
  (address "Franklin Street" "Boston" "USA"))

(define rms
  (person 30 "rms@gnu.org" fsf-address))

(and (equal? (set-person-age rms 60)
             (person 60 "rms@gnu.org" fsf-address))
     (= (person-age rms) 30))
⇒ #t
</pre></div>

<p>Here, the original <code class="code">&lt;person&gt;</code> record, to which <var class="var">rms</var> is bound,
is left unchanged.
</p>
<p>Now, suppose we want to change both the street and age of <var class="var">rms</var>.
This can be achieved using <code class="code">set-fields</code>:
</p>
<div class="example">
<pre class="example-preformatted">(set-fields rms
  ((person-age) 60)
  ((person-address address-street) "Temple Place"))
⇒ #&lt;&lt;person&gt; age: 60 email: "rms@gnu.org"
  address: #&lt;&lt;address&gt; street: "Temple Place" city: "Boston" country: "USA"&gt;&gt;
</pre></div>

<p>Notice how the above changed two fields of <var class="var">rms</var>, including the
<code class="code">street</code> field of its <code class="code">address</code> field, in a concise way.  Also
note that <code class="code">set-fields</code> works equally well for types defined with
just <code class="code">define-record-type</code>.
</p>
<hr>
</div>
</div>
<div class="subsection-level-extent" id="Records">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="n" rel="next">Structures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records" accesskey="p" rel="prev">SRFI-9 Records</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Records-1">6.6.17 Records</h4>

<p>A <em class="dfn">record type</em> is a first class object representing a user-defined
data type.  A <em class="dfn">record</em> is an instance of a record type.
</p>
<p>Note that in many ways, this interface is too low-level for every-day
use.  Most uses of records are better served by SRFI-9 records.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records">SRFI-9 Records</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-record_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a record of any type and <code class="code">#f</code>
otherwise.
</p>
<p>Note that <code class="code">record?</code> may be true of any Scheme value; there is no
promise that records are disjoint with other Scheme types.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002drecord_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-record-type</strong> <var class="def-var-arguments">type-name field-names [print]        [#:parent=<code class="code">#f</code>] [#:uid=<code class="code">#f</code>]        [#:extensible?=<code class="code">#f</code>] [#:opaque?=<code class="code">#f</code>]        [#:allow-duplicate-field-names?=<code class="code">#t</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002drecord_002dtype"> ¶</a></span></dt>
<dd><p>Create and return a new <em class="dfn">record-type descriptor</em>.
</p>
<p><var class="var">type-name</var> is a string naming the type.  Currently it’s only used
in the printed representation of records, and in diagnostics.
<var class="var">field-names</var> is a list of elements of the form <code class="code">(immutable
<var class="var">name</var>)</code>, <code class="code">(mutable <var class="var">name</var>)</code>, or <var class="var">name</var>, where
<var class="var">name</var> are symbols naming the fields of a record of the type.
Duplicates are not allowed among these symbols, unless
<var class="var">allow-duplicate-field-names?</var> is true.
</p>
<div class="example">
<pre class="example-preformatted">(make-record-type "employee" '(name age salary))
</pre></div>

<p>The optional <var class="var">print</var> argument is a function used by
<code class="code">display</code>, <code class="code">write</code>, etc, for printing a record of the new
type.  It’s called as <code class="code">(<var class="var">print</var> record port)</code> and should look
at <var class="var">record</var> and write to <var class="var">port</var>.
</p>
<p>Pass the <code class="code">#:parent</code> keyword to derive a record type from a
supertype.  A derived record type has the fields from its parent type,
followed by fields declared in the <code class="code">make-record-type</code> call.  Record
predicates and field accessors for instance of a parent type will also
work on any instance of a subtype.
</p>
<a class="index-entry-id" id="index-extensible-record-types"></a>
<a class="index-entry-id" id="index-record-types_002c-extensible"></a>
<p>Allowing record subtyping has a small amount of overhead.  To avoid this
overhead, prevent extensibility by passing <code class="code">#:extensible? #f</code>.
By default, record types in Guile are not extensible.
</p>
<a class="index-entry-id" id="index-prefab-record-types"></a>
<a class="index-entry-id" id="index-record-types_002c-prefab"></a>
<a class="index-entry-id" id="index-record-types_002c-nongenerative"></a>
<p>Generally speaking, calling <code class="code">make-record-type</code> returns a fresh
record type; it <em class="emph">generates</em> new record types.  However sometimes
you only want to define a record type if one hasn’t been defined
already.  For a <em class="emph">nongenerative</em> record type definition, pass a
symbol as the <code class="code">#:uid</code> keyword parameter.  If a record with the
given <var class="var">uid</var> was already defined, it will be returned instead.  The
type name, fields, parent (if any), and so on for the previously-defined
type must be compatible.
</p>
<a class="index-entry-id" id="index-record-types_002c-opaque"></a>
<p>R6RS defines a notion of “opaque” record types.  Given an instance of
an opaque record type, one cannot obtain a run-time representation of
the record type.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-records-procedural">rnrs records procedural</a>, for full details.  The
<code class="code">#:opaque?</code> flag is used by Guile’s R6RS layer to record this
information.  The default is determined by whether the parent type, if
any, was opaque.
</p>
<p>Fields are mutable by default, meaning that <code class="code">record-modifier</code> will
return a procedure that can update a record in place.  Specifying a
field using the form <code class="code">(immutable <var class="var">name</var>)</code> instead marks a field
as immutable.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dconstructor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-constructor</strong> <var class="def-var-arguments">rtd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dconstructor"> ¶</a></span></dt>
<dd><p>Return a procedure for constructing new members of the type represented
by <var class="var">rtd</var>.  The result will be a procedure accepting exactly as many
arguments as there are fields in the record type.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dpredicate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-predicate</strong> <var class="def-var-arguments">rtd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dpredicate"> ¶</a></span></dt>
<dd><p>Return a procedure for testing membership in the type represented by
<var class="var">rtd</var>.  The returned procedure accepts exactly one argument and
returns a true value if the argument is a member of the indicated record
type; it returns a false value otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002daccessor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-accessor</strong> <var class="def-var-arguments">rtd field-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002daccessor"> ¶</a></span></dt>
<dd><p>Return a procedure for reading the value of a particular field of a
member of the type represented by <var class="var">rtd</var>.  The returned procedure
accepts exactly one argument which must be a record of the appropriate
type; it returns the current value of the field named by the symbol
<var class="var">field-name</var> in that record.
</p>
<p>If <var class="var">field-name</var> is a symbol, it must be a member of the list of
field-names in the call to <code class="code">make-record-type</code> that created the type
represented by <var class="var">rtd</var>.  If multiple fields in <var class="var">rtd</var> have the same
name, <code class="code">record-accessor</code> returns the first one.
</p>
<p>If <var class="var">field-name</var> is an integer, it should be an index into
<code class="code">(record-type-fields <var class="var">rtd</var>)</code>.  This allows accessing fields
with duplicate names.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dmodifier"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-modifier</strong> <var class="def-var-arguments">rtd field-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dmodifier"> ¶</a></span></dt>
<dd><p>Return a procedure for writing the value of a particular field of a
member of the type represented by <var class="var">rtd</var>.  The returned procedure
accepts exactly two arguments: first, a record of the appropriate type,
and second, an arbitrary Scheme value; it modifies the field named by
the symbol <var class="var">field-name</var> in that record to contain the given value.
The returned value of the modifier procedure is unspecified.  The symbol
<var class="var">field-name</var> is a field name or a field index, as in
<code class="code">record-modifier</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dtype_002ddescriptor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-type-descriptor</strong> <var class="def-var-arguments">record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dtype_002ddescriptor"> ¶</a></span></dt>
<dd><p>Return a record-type descriptor representing the type of the given
record.  That is, for example, if the returned descriptor were passed to
<code class="code">record-predicate</code>, the resulting predicate would return a true
value when passed the given record.  Note that it is not necessarily the
case that the returned descriptor is the one that was passed to
<code class="code">record-constructor</code> in the call that created the constructor
procedure that created the given record.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dtype_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-type-name</strong> <var class="def-var-arguments">rtd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dtype_002dname"> ¶</a></span></dt>
<dd><p>Return the type-name associated with the type represented by rtd.  The
returned value is <code class="code">eqv?</code> to the <var class="var">type-name</var> argument given in
the call to <code class="code">make-record-type</code> that created the type represented by
<var class="var">rtd</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-record_002dtype_002dfields"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">record-type-fields</strong> <var class="def-var-arguments">rtd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-record_002dtype_002dfields"> ¶</a></span></dt>
<dd><p>Return a list of the symbols naming the fields in members of the type
represented by <var class="var">rtd</var>.  The returned value is <code class="code">equal?</code> to the
field-names argument given in the call to <code class="code">make-record-type</code> that
created the type represented by <var class="var">rtd</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Structures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dictionary-Types" accesskey="n" rel="next">Dictionary Types</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Records" accesskey="p" rel="prev">Records</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Structures-1">6.6.18 Structures</h4>
<a class="index-entry-id" id="index-Structures"></a>

<p>A <em class="dfn">structure</em> is a first class data type which holds Scheme values
or C words in fields numbered 0 upwards.  A <em class="dfn">vtable</em> is a structure
that represents a structure type, giving field types and permissions,
and an optional print function for <code class="code">write</code> etc.
</p>
<p>Structures are lower level than records (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a>).  Usually,
when you need to represent structured data, you just want to use
records.  But sometimes you need to implement new kinds of structured
data abstractions, and for that purpose structures are useful.  Indeed,
records in Guile are implemented with structures.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vtables" accesskey="1">Vtables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Structure-Basics" accesskey="2">Structure Basics</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents" accesskey="3">Vtable Contents</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Meta_002dVtables" accesskey="4">Meta-Vtables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Example" accesskey="5">Vtable Example</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Vtables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structure-Basics" accesskey="n" rel="next">Structure Basics</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Vtables-1">6.6.18.1 Vtables</h4>

<p>A vtable is a structure type, specifying its layout, and other
information.  A vtable is actually itself a structure, but there’s no
need to worry about that initially (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents">Vtable Contents</a>.)
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dvtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-vtable</strong> <var class="def-var-arguments">fields [print]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dvtable"> ¶</a></span></dt>
<dd><p>Create a new vtable.
</p>
<p><var class="var">fields</var> is a string describing the fields in the structures to be
created.  Each field is represented by two characters, a type letter
and a permissions letter, for example <code class="code">"pw"</code>.  The types are as
follows.
</p>
<ul class="itemize mark-bullet">
<li><code class="code">p</code> – a Scheme value.  “p” stands for “protected” meaning
it’s protected against garbage collection.

</li><li><code class="code">u</code> – an arbitrary word of data (an <code class="code">scm_t_bits</code>).  At the
Scheme level it’s read and written as an unsigned integer.  “u” stands
for “unboxed”, as it’s stored as a raw value without additional type
annotations.
</li></ul>

<p>It used to be that the second letter for each field was a permission
code, such as <code class="code">w</code> for writable or <code class="code">r</code> for read-only.  However
over time structs have become more of a raw low-level facility; access
control is better implemented as a layer on top.  After all,
<code class="code">struct-set!</code> is a cross-cutting operator that can bypass
abstractions made by higher-level record facilities; it’s not generally
safe (in the sense of abstraction-preserving) to expose
<code class="code">struct-set!</code> to “untrusted” code, even if the fields happen to
be writable.  Additionally, permission checks added overhead to every
structure access in a way that couldn’t be optimized out, hampering the
ability of structs to act as a low-level building block.  For all of
these reasons, all fields in Guile structs are now writable; attempting
to make a read-only field will now issue a deprecation warning, and the
field will be writable regardless.
</p>
<div class="example">
<pre class="example-preformatted">(make-vtable "pw")      ;; one scheme field
(make-vtable "pwuwuw")  ;; one scheme and two unboxed fields
</pre></div>

<p>The optional <var class="var">print</var> argument is a function called by
<code class="code">display</code> and <code class="code">write</code> (etc) to give a printed representation
of a structure created from this vtable.  It’s called
<code class="code">(<var class="var">print</var> struct port)</code> and should look at <var class="var">struct</var> and
write to <var class="var">port</var>.  The default print merely gives a form like
‘<samp class="samp">#&lt;struct ADDR:ADDR&gt;</samp>’ with a pair of machine addresses.
</p>
<p>The following print function for example shows the two fields of its
structure.
</p>
<div class="example">
<pre class="example-preformatted">(make-vtable "pwpw"
             (lambda (struct port)
               (format port "#&lt;~a and ~a&gt;"
                       (struct-ref struct 0)
                       (struct-ref struct 1))))
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Structure-Basics">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents" accesskey="n" rel="next">Vtable Contents</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vtables" accesskey="p" rel="prev">Vtables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Structure-Basics-1">6.6.18.2 Structure Basics</h4>

<p>This section describes the basic procedures for working with structures.
<code class="code">make-struct/no-tail</code> creates a structure, and <code class="code">struct-ref</code>
and <code class="code">struct-set!</code> access its fields.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dstruct_002fno_002dtail"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-struct/no-tail</strong> <var class="def-var-arguments">vtable init …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dstruct_002fno_002dtail"> ¶</a></span></dt>
<dd><p>Create a new structure, with layout per the given <var class="var">vtable</var>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vtables">Vtables</a>).
</p>
<p>The optional <var class="var">init</var>… arguments are initial values for the
fields of the structure.  This is the only way to
put values in read-only fields.  If there are fewer <var class="var">init</var>
arguments than fields then the defaults are <code class="code">#f</code> for a Scheme
field (type <code class="code">p</code>) or 0 for an unboxed field (type <code class="code">u</code>).
</p>
<p>The name is a bit strange, we admit.  The reason for it is that Guile
used to have a <code class="code">make-struct</code> that took an additional argument;
while we deprecate that old interface, <code class="code">make-struct/no-tail</code> is the
new name for this functionality.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example-preformatted">(define v (make-vtable "pwpwpw"))
(define s (make-struct/no-tail v 123 "abc" 456))
(struct-ref s 0) ⇒ 123
(struct-ref s 1) ⇒ "abc"
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmake_005fstruct"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_struct</strong> <code class="def-code-arguments">(SCM vtable, SCM tail_size, SCM init_list)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fstruct"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fmake_005fstruct"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_struct</strong> <code class="def-code-arguments">(SCM vtable, SCM tail_size, SCM init, ...)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fstruct"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fmake_005fstructv"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_structv</strong> <code class="def-code-arguments">(SCM vtable, SCM tail_size, size_t n_inits, scm_t_bits init[])</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fstructv"> ¶</a></span></dt>
<dd><p>There are a few ways to make structures from C.  <code class="code">scm_make_struct</code>
takes a list, <code class="code">scm_c_make_struct</code> takes variable arguments
terminated with SCM_UNDEFINED, and <code class="code">scm_c_make_structv</code> takes a
packed array.
</p>
<p>For all of these, <var class="var">tail_size</var> should be zero (as a SCM value).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-struct_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a structure, or <code class="code">#f</code> if not.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-ref</strong> <var class="def-var-arguments">struct n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_ref</strong> <var class="def-var-arguments">(struct, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fref"> ¶</a></span></dt>
<dd><p>Return the contents of field number <var class="var">n</var> in <var class="var">struct</var>.  The
first field is number 0.
</p>
<p>An error is thrown if <var class="var">n</var> is out of range.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-set!</strong> <var class="def-var-arguments">struct n value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_set_x</strong> <var class="def-var-arguments">(struct, n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set field number <var class="var">n</var> in <var class="var">struct</var> to <var class="var">value</var>.  The first
field is number 0.
</p>
<p>An error is thrown if <var class="var">n</var> is out of range, or if the field cannot
be written because it’s <code class="code">r</code> read-only.
</p></dd></dl>

<p>Unboxed fields (those with type <code class="code">u</code>) need to be accessed with
special procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dref_002funboxed"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-ref/unboxed</strong> <var class="def-var-arguments">struct n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dref_002funboxed"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-struct_002dset_0021_002funboxed"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-set!/unboxed</strong> <var class="def-var-arguments">struct n value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dset_0021_002funboxed"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fref_005funboxed"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_ref_unboxed</strong> <var class="def-var-arguments">(struct, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fref_005funboxed"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fset_005fx_005funboxed"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_set_x_unboxed</strong> <var class="def-var-arguments">(struct, n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fset_005fx_005funboxed"> ¶</a></span></dt>
<dd><p>Like <code class="code">struct-ref</code> and <code class="code">struct-set!</code>, except that these may
only be used on unboxed fields.  <code class="code">struct-ref/unboxed</code> will always
return a positive integer.  Likewise, <code class="code">struct-set!/unboxed</code> takes
an unsigned integer as the <var class="var">value</var> argument, and will signal an
error otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dvtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-vtable</strong> <var class="def-var-arguments">struct</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dvtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fvtable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_vtable</strong> <var class="def-var-arguments">(struct)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fvtable"> ¶</a></span></dt>
<dd><p>Return the vtable that describes <var class="var">struct</var>.
</p>
<p>The vtable is effectively the type of the structure.  See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents">Vtable Contents</a>, for more on vtables.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Vtable-Contents">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Meta_002dVtables" accesskey="n" rel="next">Meta-Vtables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structure-Basics" accesskey="p" rel="prev">Structure Basics</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Vtable-Contents-1">6.6.18.3 Vtable Contents</h4>

<p>A vtable is itself a structure.  It has a specific set of fields
describing various aspects of its <em class="dfn">instances</em>: the structures
created from a vtable.  Some of the fields are internal to Guile, some
of them are part of the public interface, and there may be additional
fields added on by the user.
</p>
<p>Every vtable has a field for the layout of their instances, a field for
the procedure used to print its instances, and a field for the name of
the vtable itself.  Access to the layout and printer is exposed directly
via field indexes.  Access to the vtable name is exposed via accessor
procedures.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-vtable_002dindex_002dlayout"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">vtable-index-layout</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vtable_002dindex_002dlayout"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fvtable_005findex_005flayout"><span class="category-def">C Macro: </span><span><strong class="def-name">scm_vtable_index_layout</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvtable_005findex_005flayout"> ¶</a></span></dt>
<dd><p>The field number of the layout specification in a vtable.  The layout
specification is a symbol like <code class="code">pwpw</code> formed from the fields
string passed to <code class="code">make-vtable</code>, or created by
<code class="code">make-struct-layout</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Meta_002dVtables">Meta-Vtables</a>).
</p>
<div class="example">
<pre class="example-preformatted">(define v (make-vtable "pwpw" 0))
(struct-ref v vtable-index-layout) ⇒ pwpw
</pre></div>

<p>This field is read-only, since the layout of structures using a vtable
cannot be changed.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-vtable_002dindex_002dprinter"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">vtable-index-printer</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vtable_002dindex_002dprinter"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fvtable_005findex_005fprinter"><span class="category-def">C Macro: </span><span><strong class="def-name">scm_vtable_index_printer</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvtable_005findex_005fprinter"> ¶</a></span></dt>
<dd><p>The field number of the printer function.  This field contains <code class="code">#f</code>
if the default print function should be used.
</p>
<div class="example">
<pre class="example-preformatted">(define (my-print-func struct port)
  ...)
(define v (make-vtable "pwpw" my-print-func))
(struct-ref v vtable-index-printer) ⇒ my-print-func
</pre></div>

<p>This field is writable, allowing the print function to be changed
dynamically.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dvtable_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-vtable-name</strong> <var class="def-var-arguments">vtable</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dvtable_002dname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dstruct_002dvtable_002dname_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-struct-vtable-name!</strong> <var class="def-var-arguments">vtable name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dstruct_002dvtable_002dname_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fvtable_005fname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_vtable_name</strong> <var class="def-var-arguments">(vtable)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fvtable_005fname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fstruct_005fvtable_005fname_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_struct_vtable_name_x</strong> <var class="def-var-arguments">(vtable, name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fstruct_005fvtable_005fname_005fx"> ¶</a></span></dt>
<dd><p>Get or set the name of <var class="var">vtable</var>.  <var class="var">name</var> is a symbol and is
used in the default print function when printing structures created
from <var class="var">vtable</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define v (make-vtable "pw"))
(set-struct-vtable-name! v 'my-name)

(define s (make-struct v 0))
(display s) -| #&lt;my-name b7ab3ae0:b7ab3730&gt;
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Meta_002dVtables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Example" accesskey="n" rel="next">Vtable Example</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Vtable-Contents" accesskey="p" rel="prev">Vtable Contents</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Meta_002dVtables-1">6.6.18.4 Meta-Vtables</h4>

<p>As a structure, a vtable also has a vtable, which is also a structure.
Structures, their vtables, the vtables of the vtables, and so on form a
tree of structures.  Making a new structure adds a leaf to the tree, and
if that structure is a vtable, it may be used to create other leaves.
</p>
<p>If you traverse up the tree of vtables, via calling
<code class="code">struct-vtable</code>, eventually you reach a root which is the vtable of
itself:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; (current-module)
$1 = #&lt;directory (guile-user) 221b090&gt;
scheme@(guile-user)&gt; (struct-vtable $1)
$2 = #&lt;record-type module&gt;
scheme@(guile-user)&gt; (struct-vtable $2)
$3 = #&lt;&lt;standard-vtable&gt; 12c30a0&gt;
scheme@(guile-user)&gt; (struct-vtable $3)
$4 = #&lt;&lt;standard-vtable&gt; 12c3fa0&gt;
scheme@(guile-user)&gt; (struct-vtable $4)
$5 = #&lt;&lt;standard-vtable&gt; 12c3fa0&gt;
scheme@(guile-user)&gt; &lt;standard-vtable&gt;
$6 = #&lt;&lt;standard-vtable&gt; 12c3fa0&gt;
</pre></div>

<p>In this example, we can say that <code class="code">$1</code> is an instance of <code class="code">$2</code>,
<code class="code">$2</code> is an instance of <code class="code">$3</code>, <code class="code">$3</code> is an instance of
<code class="code">$4</code>, and <code class="code">$4</code>, strangely enough, is an instance of itself.
The value bound to <code class="code">$4</code> in this console session also bound to
<code class="code">&lt;standard-vtable&gt;</code> in the default environment.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-_003cstandard_002dvtable_003e"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">&lt;standard-vtable&gt;</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003cstandard_002dvtable_003e"> ¶</a></span></dt>
<dd><p>A meta-vtable, useful for making new vtables.
</p></dd></dl>

<p>All of these values are structures.  All but <code class="code">$1</code> are vtables.  As
<code class="code">$2</code> is an instance of <code class="code">$3</code>, and <code class="code">$3</code> is a vtable, we can
say that <code class="code">$3</code> is a <em class="dfn">meta-vtable</em>: a vtable that can create
vtables.
</p>
<p>With this definition, we can specify more precisely what a vtable is: a
vtable is a structure made from a meta-vtable.  Making a structure from
a meta-vtable runs some special checks to ensure that the first field of
the structure is a valid layout.  Additionally, if these checks see that
the layout of the child vtable contains all the required fields of a
vtable, in the correct order, then the child vtable will also be a
meta-table, inheriting a magical bit from the parent.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-struct_002dvtable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">struct-vtable?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-struct_002dvtable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstruct_005fvtable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_struct_vtable_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstruct_005fvtable_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a vtable structure: an instance of a
meta-vtable.
</p></dd></dl>

<p><code class="code">&lt;standard-vtable&gt;</code> is a root of the vtable tree.  (Normally there
is only one root in a given Guile process, but due to some legacy
interfaces there may be more than one.)
</p>
<p>The set of required fields of a vtable is the set of fields in the
<code class="code">&lt;standard-vtable&gt;</code>, and is bound to <code class="code">standard-vtable-fields</code>
in the default environment.  It is possible to create a meta-vtable that
with additional fields in its layout, which can be used to create
vtables with additional data:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; (struct-ref $3 vtable-index-layout)
$6 = pwuhuhpwphuhuhpwpwpw
scheme@(guile-user)&gt; (struct-ref $4 vtable-index-layout)
$7 = pwuhuhpwphuhuh
scheme@(guile-user)&gt; standard-vtable-fields 
$8 = "pwuhuhpwphuhuh"
scheme@(guile-user)&gt; (struct-ref $2 vtable-offset-user)
$9 = module
</pre></div>

<p>In this continuation of our earlier example, <code class="code">$2</code> is a vtable that
has extra fields, because its vtable, <code class="code">$3</code>, was made from a
meta-vtable with an extended layout.  <code class="code">vtable-offset-user</code> is a
convenient definition that indicates the number of fields in
<code class="code">standard-vtable-fields</code>.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-standard_002dvtable_002dfields"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">standard-vtable-fields</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-standard_002dvtable_002dfields"> ¶</a></span></dt>
<dd><p>A string containing the ordered set of fields that a vtable must have.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-vtable_002doffset_002duser"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">vtable-offset-user</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vtable_002doffset_002duser"> ¶</a></span></dt>
<dd><p>The first index in a vtable that is available for a user.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dstruct_002dlayout"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-struct-layout</strong> <var class="def-var-arguments">fields</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dstruct_002dlayout"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fstruct_005flayout"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_struct_layout</strong> <var class="def-var-arguments">(fields)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fstruct_005flayout"> ¶</a></span></dt>
<dd><p>Return a structure layout symbol, from a <var class="var">fields</var> string.
<var class="var">fields</var> is as described under <code class="code">make-vtable</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vtables">Vtables</a>).  An invalid <var class="var">fields</var> string is an error.
</p></dd></dl>

<p>With these definitions, one can define <code class="code">make-vtable</code> in this way:
</p>
<div class="example">
<pre class="example-preformatted">(define* (make-vtable fields #:optional printer)
  (make-struct/no-tail &lt;standard-vtable&gt;
    (make-struct-layout fields)
    printer))
</pre></div>


<hr>
</div>
<div class="subsubsection-level-extent" id="Vtable-Example">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Meta_002dVtables" accesskey="p" rel="prev">Meta-Vtables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="u" rel="up">Structures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Vtable-Example-1">6.6.18.5 Vtable Example</h4>

<p>Let us bring these points together with an example.  Consider a simple
object system with single inheritance.  Objects will be normal
structures, and classes will be vtables with three extra class fields:
the name of the class, the parent class, and the list of fields.
</p>
<p>So, first we need a meta-vtable that allocates instances with these
extra class fields.
</p>
<div class="example">
<pre class="example-preformatted">(define &lt;class&gt;
  (make-vtable
   (string-append standard-vtable-fields "pwpwpw")
   (lambda (x port)
     (format port "&lt;&lt;class&gt; ~a&gt;" (class-name x)))))

(define (class? x)
  (and (struct? x)
       (eq? (struct-vtable x) &lt;class&gt;)))
</pre></div>

<p>To make a structure with a specific meta-vtable, we will use
<code class="code">make-struct/no-tail</code>, passing it the computed instance layout and
printer, as with <code class="code">make-vtable</code>, and additionally the extra three
class fields.
</p>
<div class="example">
<pre class="example-preformatted">(define (make-class name parent fields)
  (let* ((fields (compute-fields parent fields))
         (layout (compute-layout fields)))
    (make-struct/no-tail &lt;class&gt;
      layout 
      (lambda (x port)
        (print-instance x port))
      name
      parent
      fields)))
</pre></div>

<p>Instances will store their associated data in slots in the structure: as
many slots as there are fields.  The <code class="code">compute-layout</code> procedure
below can compute a layout, and <code class="code">field-index</code> returns the slot
corresponding to a field.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax-rule (define-accessor name n)
  (define (name obj)
    (struct-ref obj n)))

;; Accessors for classes
(define-accessor class-name (+ vtable-offset-user 0))
(define-accessor class-parent (+ vtable-offset-user 1))
(define-accessor class-fields (+ vtable-offset-user 2))

(define (compute-fields parent fields)
  (if parent
      (append (class-fields parent) fields)
      fields))

(define (compute-layout fields)
  (make-struct-layout
   (string-concatenate (make-list (length fields) "pw"))))

(define (field-index class field)
  (list-index (class-fields class) field))

(define (print-instance x port)
  (format port "&lt;~a" (class-name (struct-vtable x)))
  (for-each (lambda (field idx)
              (format port " ~a: ~a" field (struct-ref x idx)))
            (class-fields (struct-vtable x))
            (iota (length (class-fields (struct-vtable x)))))
  (format port "&gt;"))
</pre></div>

<p>So, at this point we can actually make a few classes:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax-rule (define-class name parent field ...)
  (define name (make-class 'name parent '(field ...))))

(define-class &lt;surface&gt; #f
  width height)

(define-class &lt;window&gt; &lt;surface&gt;
  x y)
</pre></div>

<p>And finally, make an instance:
</p>
<div class="example">
<pre class="example-preformatted">(make-struct/no-tail &lt;window&gt; 400 300 10 20)
⇒ &lt;&lt;window&gt; width: 400 height: 300 x: 10 y: 20&gt;
</pre></div>

<p>And that’s that.  Note that there are many possible optimizations and
feature enhancements that can be made to this object system, and the
included GOOPS system does make most of them.  For more simple use
cases, the records facility is usually sufficient.  But sometimes you
need to make new kinds of data abstractions, and for that purpose,
structs are here.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Dictionary-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="n" rel="next">Association Lists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Structures" accesskey="p" rel="prev">Structures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Dictionary-Types-1">6.6.19 Dictionary Types</h4>

<p>A <em class="dfn">dictionary</em> object is a data structure used to index
information in a user-defined way.  In standard Scheme, the main
aggregate data types are lists and vectors.  Lists are not really
indexed at all, and vectors are indexed only by number
(e.g. <code class="code">(vector-ref foo 5)</code>).  Often you will find it useful
to index your data on some other type; for example, in a library
catalog you might want to look up a book by the name of its
author.  Dictionaries are used to help you organize information in
such a way.
</p>
<p>An <em class="dfn">association list</em> (or <em class="dfn">alist</em> for short) is a list of
key-value pairs.  Each pair represents a single quantity or
object; the <code class="code">car</code> of the pair is a key which is used to
identify the object, and the <code class="code">cdr</code> is the object’s value.
</p>
<p>A <em class="dfn">hash table</em> also permits you to index objects with
arbitrary keys, but in a way that makes looking up any one object
extremely fast.  A well-designed hash system makes hash table
lookups almost as fast as conventional array or vector references.
</p>
<p>Alists are popular among Lisp programmers because they use only
the language’s primitive operations (lists, <em class="dfn">car</em>, <em class="dfn">cdr</em>
and the equality primitives).  No changes to the language core are
necessary.  Therefore, with Scheme’s built-in list manipulation
facilities, it is very convenient to handle data stored in an
association list.  Also, alists are highly portable and can be
easily implemented on even the most minimal Lisp systems.
</p>
<p>However, alists are inefficient, especially for storing large
quantities of data.  Because we want Guile to be useful for large
software systems as well as small ones, Guile provides a rich set
of tools for using either association lists or hash tables.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Association-Lists">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#VHashes" accesskey="n" rel="next">VList-Based Hash Lists or “VHashes”</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dictionary-Types" accesskey="p" rel="prev">Dictionary Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Association-Lists-1">6.6.20 Association Lists</h4>
<a class="index-entry-id" id="index-Association-Lists"></a>
<a class="index-entry-id" id="index-Alist"></a>
<a class="index-entry-id" id="index-association-List"></a>
<a class="index-entry-id" id="index-alist"></a>
<a class="index-entry-id" id="index-database"></a>

<p>An association list is a conventional data structure that is often used
to implement simple key-value databases.  It consists of a list of
entries in which each entry is a pair.  The <em class="dfn">key</em> of each entry is
the <code class="code">car</code> of the pair and the <em class="dfn">value</em> of each entry is the
<code class="code">cdr</code>.
</p>
<div class="example">
<pre class="example-preformatted">ASSOCIATION LIST ::=  '( (KEY1 . VALUE1)
                         (KEY2 . VALUE2)
                         (KEY3 . VALUE3)
                         …
                       )
</pre></div>

<p>Association lists are also known, for short, as <em class="dfn">alists</em>.
</p>
<p>The structure of an association list is just one example of the infinite
number of possible structures that can be built using pairs and lists.
As such, the keys and values in an association list can be manipulated
using the general list structure procedures <code class="code">cons</code>, <code class="code">car</code>,
<code class="code">cdr</code>, <code class="code">set-car!</code>, <code class="code">set-cdr!</code> and so on.  However,
because association lists are so useful, Guile also provides specific
procedures for manipulating them.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Key-Equality" accesskey="1">Alist Key Equality</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Adding-or-Setting-Alist-Entries" accesskey="2">Adding or Setting Alist Entries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries" accesskey="3">Retrieving Alist Entries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Removing-Alist-Entries" accesskey="4">Removing Alist Entries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Sloppy-Alist-Functions" accesskey="5">Sloppy Alist Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Example" accesskey="6">Alist Example</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Alist-Key-Equality">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Adding-or-Setting-Alist-Entries" accesskey="n" rel="next">Adding or Setting Alist Entries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Alist-Key-Equality-1">6.6.20.1 Alist Key Equality</h4>

<p>All of Guile’s dedicated association list procedures, apart from
<code class="code">acons</code>, come in three flavours, depending on the level of equality
that is required to decide whether an existing key in the association
list is the same as the key that the procedure call uses to identify the
required entry.
</p>
<ul class="itemize mark-bullet">
<li>Procedures with <em class="dfn">assq</em> in their name use <code class="code">eq?</code> to determine key
equality.

</li><li>Procedures with <em class="dfn">assv</em> in their name use <code class="code">eqv?</code> to determine
key equality.

</li><li>Procedures with <em class="dfn">assoc</em> in their name use <code class="code">equal?</code> to
determine key equality.
</li></ul>

<p><code class="code">acons</code> is an exception because it is used to build association
lists which do not require their entries’ keys to be unique.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Adding-or-Setting-Alist-Entries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries" accesskey="n" rel="next">Retrieving Alist Entries</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Key-Equality" accesskey="p" rel="prev">Alist Key Equality</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Adding-or-Setting-Alist-Entries-1">6.6.20.2 Adding or Setting Alist Entries</h4>

<p><code class="code">acons</code> adds a new entry to an association list and returns the
combined association list.  The combined alist is formed by consing the
new entry onto the head of the alist specified in the <code class="code">acons</code>
procedure call.  So the specified alist is not modified, but its
contents become shared with the tail of the combined alist that
<code class="code">acons</code> returns.
</p>
<p>In the most common usage of <code class="code">acons</code>, a variable holding the
original association list is updated with the combined alist:
</p>
<div class="example">
<pre class="example-preformatted">(set! address-list (acons name address address-list))
</pre></div>

<p>In such cases, it doesn’t matter that the old and new values of
<code class="code">address-list</code> share some of their contents, since the old value is
usually no longer independently accessible.
</p>
<p>Note that <code class="code">acons</code> adds the specified new entry regardless of
whether the alist may already contain entries with keys that are, in
some sense, the same as that of the new entry.  Thus <code class="code">acons</code> is
ideal for building alists where there is no concept of key uniqueness.
</p>
<div class="example">
<pre class="example-preformatted">(set! task-list (acons 3 "pay gas bill" '()))
task-list
⇒
((3 . "pay gas bill"))

(set! task-list (acons 3 "tidy bedroom" task-list))
task-list
⇒
((3 . "tidy bedroom") (3 . "pay gas bill"))
</pre></div>

<p><code class="code">assq-set!</code>, <code class="code">assv-set!</code> and <code class="code">assoc-set!</code> are used to add
or replace an entry in an association list where there <em class="emph">is</em> a
concept of key uniqueness.  If the specified association list already
contains an entry whose key is the same as that specified in the
procedure call, the existing entry is replaced by the new one.
Otherwise, the new entry is consed onto the head of the old association
list to create the combined alist.  In all cases, these procedures
return the combined alist.
</p>
<p><code class="code">assq-set!</code> and friends <em class="emph">may</em> destructively modify the
structure of the old association list in such a way that an existing
variable is correctly updated without having to <code class="code">set!</code> it to the
value returned:
</p>
<div class="example">
<pre class="example-preformatted">address-list
⇒
(("mary" . "34 Elm Road") ("james" . "16 Bow Street"))

(assoc-set! address-list "james" "1a London Road")
⇒
(("mary" . "34 Elm Road") ("james" . "1a London Road"))

address-list
⇒
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
</pre></div>

<p>Or they may not:
</p>
<div class="example">
<pre class="example-preformatted">(assoc-set! address-list "bob" "11 Newington Avenue")
⇒
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

address-list
⇒
(("mary" . "34 Elm Road") ("james" . "1a London Road"))
</pre></div>

<p>The only safe way to update an association list variable when adding or
replacing an entry like this is to <code class="code">set!</code> the variable to the
returned value:
</p>
<div class="example">
<pre class="example-preformatted">(set! address-list
      (assoc-set! address-list "bob" "11 Newington Avenue"))
address-list
⇒
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))
</pre></div>

<p>Because of this slight inconvenience, you may find it more convenient to
use hash tables to store dictionary data.  If your application will not
be modifying the contents of an alist very often, this may not make much
difference to you.
</p>
<p>If you need to keep the old value of an association list in a form
independent from the list that results from modification by
<code class="code">acons</code>, <code class="code">assq-set!</code>, <code class="code">assv-set!</code> or <code class="code">assoc-set!</code>,
use <code class="code">list-copy</code> to copy the old association list before modifying
it.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-acons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">acons</strong> <var class="def-var-arguments">key value alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-acons"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005facons"><span class="category-def">C Function: </span><span><strong class="def-name">scm_acons</strong> <var class="def-var-arguments">(key, value, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005facons"> ¶</a></span></dt>
<dd><p>Add a new key-value pair to <var class="var">alist</var>.  A new pair is
created whose car is <var class="var">key</var> and whose cdr is <var class="var">value</var>, and the
pair is consed onto <var class="var">alist</var>, and the new list is returned.  This
function is <em class="emph">not</em> destructive; <var class="var">alist</var> is not modified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-assq_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assq-set!</strong> <var class="def-var-arguments">alist key val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assq_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assv_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assv-set!</strong> <var class="def-var-arguments">alist key value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assv_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assoc_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assoc-set!</strong> <var class="def-var-arguments">alist key value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assoc_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassq_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assq_set_x</strong> <var class="def-var-arguments">(alist, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassq_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassv_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assv_set_x</strong> <var class="def-var-arguments">(alist, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassv_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassoc_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assoc_set_x</strong> <var class="def-var-arguments">(alist, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassoc_005fset_005fx"> ¶</a></span></dt>
<dd><p>Reassociate <var class="var">key</var> in <var class="var">alist</var> with <var class="var">value</var>: find any existing
<var class="var">alist</var> entry for <var class="var">key</var> and associate it with the new
<var class="var">value</var>.  If <var class="var">alist</var> does not contain an entry for <var class="var">key</var>,
add a new one.  Return the (possibly new) alist.
</p>
<p>These functions do not attempt to verify the structure of <var class="var">alist</var>,
and so may cause unusual results if passed an object that is not an
association list.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Retrieving-Alist-Entries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Removing-Alist-Entries" accesskey="n" rel="next">Removing Alist Entries</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Adding-or-Setting-Alist-Entries" accesskey="p" rel="prev">Adding or Setting Alist Entries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Retrieving-Alist-Entries-1">6.6.20.3 Retrieving Alist Entries</h4>
<a class="index-entry-id" id="index-assq-2"></a>
<a class="index-entry-id" id="index-assv-2"></a>
<a class="index-entry-id" id="index-assoc-3"></a>

<p><code class="code">assq</code>, <code class="code">assv</code> and <code class="code">assoc</code> find the entry in an alist
for a given key, and return the <code class="code">(<var class="var">key</var> . <var class="var">value</var>)</code> pair.
<code class="code">assq-ref</code>, <code class="code">assv-ref</code> and <code class="code">assoc-ref</code> do a similar
lookup, but return just the <var class="var">value</var>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-assq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assq</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assv</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assoc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assoc</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assoc"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assq</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assv</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassoc"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assoc</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassoc"> ¶</a></span></dt>
<dd><p>Return the first entry in <var class="var">alist</var> with the given <var class="var">key</var>.  The
return is the pair <code class="code">(KEY . VALUE)</code> from <var class="var">alist</var>.  If there’s
no matching entry the return is <code class="code">#f</code>.
</p>
<p><code class="code">assq</code> compares keys with <code class="code">eq?</code>, <code class="code">assv</code> uses
<code class="code">eqv?</code> and <code class="code">assoc</code> uses <code class="code">equal?</code>.  See also SRFI-1
which has an extended <code class="code">assoc</code> (<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists">Association Lists</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-assq_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assq-ref</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assq_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assv_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assv-ref</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assv_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assoc_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assoc-ref</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assoc_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassq_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assq_ref</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassq_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassv_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assv_ref</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassv_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassoc_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assoc_ref</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassoc_005fref"> ¶</a></span></dt>
<dd><p>Return the value from the first entry in <var class="var">alist</var> with the given
<var class="var">key</var>, or <code class="code">#f</code> if there’s no such entry.
</p>
<p><code class="code">assq-ref</code> compares keys with <code class="code">eq?</code>, <code class="code">assv-ref</code> uses
<code class="code">eqv?</code> and <code class="code">assoc-ref</code> uses <code class="code">equal?</code>.
</p>
<p>Notice these functions have the <var class="var">key</var> argument last, like other
<code class="code">-ref</code> functions, but this is opposite to what <code class="code">assq</code>
etc above use.
</p>
<p>When the return is <code class="code">#f</code> it can be either <var class="var">key</var> not found, or
an entry which happens to have value <code class="code">#f</code> in the <code class="code">cdr</code>.  Use
<code class="code">assq</code> etc above if you need to differentiate these cases.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Removing-Alist-Entries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sloppy-Alist-Functions" accesskey="n" rel="next">Sloppy Alist Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries" accesskey="p" rel="prev">Retrieving Alist Entries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Removing-Alist-Entries-1">6.6.20.4 Removing Alist Entries</h4>

<p>To remove the element from an association list whose key matches a
specified key, use <code class="code">assq-remove!</code>, <code class="code">assv-remove!</code> or
<code class="code">assoc-remove!</code> (depending, as usual, on the level of equality
required between the key that you specify and the keys in the
association list).
</p>
<p>As with <code class="code">assq-set!</code> and friends, the specified alist may or may not
be modified destructively, and the only safe way to update a variable
containing the alist is to <code class="code">set!</code> it to the value that
<code class="code">assq-remove!</code> and friends return.
</p>
<div class="example">
<pre class="example-preformatted">address-list
⇒
(("bob" . "11 Newington Avenue") ("mary" . "34 Elm Road")
 ("james" . "1a London Road"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
⇒
(("bob" . "11 Newington Avenue") ("james" . "1a London Road"))
</pre></div>

<p>Note that, when <code class="code">assq/v/oc-remove!</code> is used to modify an
association list that has been constructed only using the corresponding
<code class="code">assq/v/oc-set!</code>, there can be at most one matching entry in the
alist, so the question of multiple entries being removed in one go does
not arise.  If <code class="code">assq/v/oc-remove!</code> is applied to an association
list that has been constructed using <code class="code">acons</code>, or an
<code class="code">assq/v/oc-set!</code> with a different level of equality, or any mixture
of these, it removes only the first matching entry from the alist, even
if the alist might contain further matching entries.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(define address-list '())
(set! address-list (assq-set! address-list "mary" "11 Elm Street"))
(set! address-list (assq-set! address-list "mary" "57 Pine Drive"))
address-list
⇒
(("mary" . "57 Pine Drive") ("mary" . "11 Elm Street"))

(set! address-list (assoc-remove! address-list "mary"))
address-list
⇒
(("mary" . "11 Elm Street"))
</pre></div>

<p>In this example, the two instances of the string "mary" are not the same
when compared using <code class="code">eq?</code>, so the two <code class="code">assq-set!</code> calls add
two distinct entries to <code class="code">address-list</code>.  When compared using
<code class="code">equal?</code>, both "mary"s in <code class="code">address-list</code> are the same as the
"mary" in the <code class="code">assoc-remove!</code> call, but <code class="code">assoc-remove!</code> stops
after removing the first matching entry that it finds, and so one of the
"mary" entries is left in place.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-assq_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assq-remove!</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assq_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assv_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assv-remove!</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assv_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-assoc_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assoc-remove!</strong> <var class="def-var-arguments">alist key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assoc_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassq_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assq_remove_x</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassq_005fremove_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassv_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assv_remove_x</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassv_005fremove_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fassoc_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_assoc_remove_x</strong> <var class="def-var-arguments">(alist, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassoc_005fremove_005fx"> ¶</a></span></dt>
<dd><p>Delete the first entry in <var class="var">alist</var> associated with <var class="var">key</var>, and return
the resulting alist.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Sloppy-Alist-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Alist-Example" accesskey="n" rel="next">Alist Example</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Removing-Alist-Entries" accesskey="p" rel="prev">Removing Alist Entries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Sloppy-Alist-Functions-1">6.6.20.5 Sloppy Alist Functions</h4>

<p><code class="code">sloppy-assq</code>, <code class="code">sloppy-assv</code> and <code class="code">sloppy-assoc</code> behave
like the corresponding non-<code class="code">sloppy-</code> procedures, except that they
return <code class="code">#f</code> when the specified association list is not well-formed,
where the non-<code class="code">sloppy-</code> versions would signal an error.
</p>
<p>Specifically, there are two conditions for which the non-<code class="code">sloppy-</code>
procedures signal an error, which the <code class="code">sloppy-</code> procedures handle
instead by returning <code class="code">#f</code>.  Firstly, if the specified alist as a
whole is not a proper list:
</p>
<div class="example">
<pre class="example-preformatted">(assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
⇒
ERROR: In procedure assoc in expression (assoc "mary" (quote #)):
ERROR: Wrong type argument in position 2 (expecting
   association list): ((1 . 2) ("key" . "door") . "open sesame")

(sloppy-assoc "mary" '((1 . 2) ("key" . "door") . "open sesame"))
⇒
#f
</pre></div>

<p>Secondly, if one of the entries in the specified alist is not a pair:
</p>
<div class="example">
<pre class="example-preformatted">(assoc 2 '((1 . 1) 2 (3 . 9)))
⇒
ERROR: In procedure assoc in expression (assoc 2 (quote #)):
ERROR: Wrong type argument in position 2 (expecting
   association list): ((1 . 1) 2 (3 . 9))

(sloppy-assoc 2 '((1 . 1) 2 (3 . 9)))
⇒
#f
</pre></div>

<p>Unless you are explicitly working with badly formed association lists,
it is much safer to use the non-<code class="code">sloppy-</code> procedures, because they
help to highlight coding and data errors that the <code class="code">sloppy-</code>
versions would silently cover up.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-sloppy_002dassq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sloppy-assq</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sloppy_002dassq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsloppy_005fassq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sloppy_assq</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsloppy_005fassq"> ¶</a></span></dt>
<dd><p>Behaves like <code class="code">assq</code> but does not do any error checking.
Recommended only for use in Guile internals.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sloppy_002dassv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sloppy-assv</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sloppy_002dassv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsloppy_005fassv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sloppy_assv</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsloppy_005fassv"> ¶</a></span></dt>
<dd><p>Behaves like <code class="code">assv</code> but does not do any error checking.
Recommended only for use in Guile internals.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sloppy_002dassoc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sloppy-assoc</strong> <var class="def-var-arguments">key alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sloppy_002dassoc"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsloppy_005fassoc"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sloppy_assoc</strong> <var class="def-var-arguments">(key, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsloppy_005fassoc"> ¶</a></span></dt>
<dd><p>Behaves like <code class="code">assoc</code> but does not do any error checking.
Recommended only for use in Guile internals.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Alist-Example">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sloppy-Alist-Functions" accesskey="p" rel="prev">Sloppy Alist Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="u" rel="up">Association Lists</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Alist-Example-1">6.6.20.6 Alist Example</h4>

<p>Here is a longer example of how alists may be used in practice.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define capitals '(("New York" . "Albany")
                   ("Oregon"   . "Salem")
                   ("Florida"  . "Miami")))

;; What's the capital of Oregon?
(assoc "Oregon" capitals)       ⇒ ("Oregon" . "Salem")
(assoc-ref capitals "Oregon")   ⇒ "Salem"

;; We left out South Dakota.
(set! capitals
      (assoc-set! capitals "South Dakota" "Pierre"))
capitals
⇒ (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Miami"))

;; And we got Florida wrong.
(set! capitals
      (assoc-set! capitals "Florida" "Tallahassee"))
capitals
⇒ (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Oregon" . "Salem")
    ("Florida" . "Tallahassee"))

;; After Oregon secedes, we can remove it.
(set! capitals
      (assoc-remove! capitals "Oregon"))
capitals
⇒ (("South Dakota" . "Pierre")
    ("New York" . "Albany")
    ("Florida" . "Tallahassee"))
</pre></div>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="VHashes">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables" accesskey="n" rel="next">Hash Tables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists" accesskey="p" rel="prev">Association Lists</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="VList_002dBased-Hash-Lists-or-_0060_0060VHashes_0027_0027">6.6.21 VList-Based Hash Lists or “VHashes”</h4>

<a class="index-entry-id" id="index-VList_002dbased-hash-lists"></a>
<a class="index-entry-id" id="index-VHash"></a>

<p>The <code class="code">(ice-9 vlist)</code> module provides an implementation of <em class="dfn">VList-based
hash lists</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#VLists">VLists</a>).  VList-based hash lists, or <em class="dfn">vhashes</em>, are an
immutable dictionary type similar to association lists that maps <em class="dfn">keys</em> to
<em class="dfn">values</em>.  However, unlike association lists, accessing a value given its
key is typically a constant-time operation.
</p>
<p>The VHash programming interface of <code class="code">(ice-9 vlist)</code> is mostly the same as
that of association lists found in SRFI-1, with procedure names prefixed by
<code class="code">vhash-</code> instead of <code class="code">alist-</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists">Association Lists</a>).
</p>
<p>In addition, vhashes can be manipulated using VList operations:
</p>
<div class="example">
<pre class="example-preformatted">(vlist-head (vhash-consq 'a 1 vlist-null))
⇒ (a . 1)

(define vh1 (vhash-consq 'b 2 (vhash-consq 'a 1 vlist-null)))
(define vh2 (vhash-consq 'c 3 (vlist-tail vh1)))

(vhash-assq 'a vh2)
⇒ (a . 1)
(vhash-assq 'b vh2)
⇒ #f
(vhash-assq 'c vh2)
⇒ (c . 3)
(vlist-&gt;list vh2)
⇒ ((c . 3) (a . 1))
</pre></div>

<p>However, keep in mind that procedures that construct new VLists
(<code class="code">vlist-map</code>, <code class="code">vlist-filter</code>, etc.) return raw VLists, not vhashes:
</p>
<div class="example">
<pre class="example-preformatted">(define vh (alist-&gt;vhash '((a . 1) (b . 2) (c . 3)) hashq))
(vhash-assq 'a vh)
⇒ (a . 1)

(define vl
  ;; This will create a raw vlist.
  (vlist-filter (lambda (key+value) (odd? (cdr key+value))) vh))
(vhash-assq 'a vl)
⇒ ERROR: Wrong type argument in position 2

(vlist-&gt;list vl)
⇒ ((a . 1) (c . 3))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a vhash.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_002dcons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-cons</strong> <var class="def-var-arguments">key value vhash [hash-proc]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dcons"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dconsq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-consq</strong> <var class="def-var-arguments">key value vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dconsq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dconsv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-consv</strong> <var class="def-var-arguments">key value vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dconsv"> ¶</a></span></dt>
<dd><p>Return a new hash list based on <var class="var">vhash</var> where <var class="var">key</var> is associated with
<var class="var">value</var>, using <var class="var">hash-proc</var> to compute the hash of <var class="var">key</var>.
<var class="var">vhash</var> must be either <code class="code">vlist-null</code> or a vhash returned by a previous
call to <code class="code">vhash-cons</code>.  <var class="var">hash-proc</var> defaults to <code class="code">hash</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Reference"><code class="code">hash</code> procedure</a>).  With <code class="code">vhash-consq</code>, the
<code class="code">hashq</code> hash function is used; with <code class="code">vhash-consv</code> the <code class="code">hashv</code>
hash function is used.
</p>
<p>All <code class="code">vhash-cons</code> calls made to construct a vhash should use the same
<var class="var">hash-proc</var>.  Failing to do that, the result is undefined.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_002dassoc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-assoc</strong> <var class="def-var-arguments">key vhash [equal? [hash-proc]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dassoc"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dassq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-assq</strong> <var class="def-var-arguments">key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dassq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dassv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-assv</strong> <var class="def-var-arguments">key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dassv"> ¶</a></span></dt>
<dd><p>Return the first key/value pair from <var class="var">vhash</var> whose key is equal to <var class="var">key</var>
according to the <var class="var">equal?</var> equality predicate (which defaults to
<code class="code">equal?</code>), and using <var class="var">hash-proc</var> (which defaults to <code class="code">hash</code>) to
compute the hash of <var class="var">key</var>.  The second form uses <code class="code">eq?</code> as the equality
predicate and <code class="code">hashq</code> as the hash function; the last form uses <code class="code">eqv?</code>
and <code class="code">hashv</code>.
</p>
<p>Note that it is important to consistently use the same hash function for
<var class="var">hash-proc</var> as was passed to <code class="code">vhash-cons</code>.  Failing to do that, the
result is unpredictable.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-delete</strong> <var class="def-var-arguments">key vhash [equal? [hash-proc]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002ddelete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002ddelq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-delq</strong> <var class="def-var-arguments">key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002ddelq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002ddelv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-delv</strong> <var class="def-var-arguments">key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002ddelv"> ¶</a></span></dt>
<dd><p>Remove all associations from <var class="var">vhash</var> with <var class="var">key</var>, comparing keys with
<var class="var">equal?</var> (which defaults to <code class="code">equal?</code>), and computing the hash of
<var class="var">key</var> using <var class="var">hash-proc</var> (which defaults to <code class="code">hash</code>).  The second
form uses <code class="code">eq?</code> as the equality predicate and <code class="code">hashq</code> as the hash
function; the last one uses <code class="code">eqv?</code> and <code class="code">hashv</code>.
</p>
<p>Again the choice of <var class="var">hash-proc</var> must be consistent with previous calls to
<code class="code">vhash-cons</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-fold</strong> <var class="def-var-arguments">proc init vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-fold-right</strong> <var class="def-var-arguments">proc init vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dfold_002dright"> ¶</a></span></dt>
<dd><p>Fold over the key/value elements of <var class="var">vhash</var> in the given direction,
with each call to <var class="var">proc</var> having the form <code class="code">(<var class="var">proc</var> key value
result)</code>, where <var class="var">result</var> is the result of the previous call to
<var class="var">proc</var> and <var class="var">init</var> the value of <var class="var">result</var> for the first call
to <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vhash_002dfold_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-fold*</strong> <var class="def-var-arguments">proc init key vhash [equal? [hash]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dfold_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dfoldq_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-foldq*</strong> <var class="def-var-arguments">proc init key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dfoldq_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vhash_002dfoldv_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vhash-foldv*</strong> <var class="def-var-arguments">proc init key vhash</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vhash_002dfoldv_002a"> ¶</a></span></dt>
<dd><p>Fold over all the values associated with <var class="var">key</var> in <var class="var">vhash</var>, with each
call to <var class="var">proc</var> having the form <code class="code">(proc value result)</code>, where
<var class="var">result</var> is the result of the previous call to <var class="var">proc</var> and <var class="var">init</var> the
value of <var class="var">result</var> for the first call to <var class="var">proc</var>.
</p>
<p>Keys in <var class="var">vhash</var> are hashed using <var class="var">hash</var> are compared using <var class="var">equal?</var>.
The second form uses <code class="code">eq?</code> as the equality predicate and <code class="code">hashq</code> as
the hash function; the third one uses <code class="code">eqv?</code> and <code class="code">hashv</code>.
</p>
<p>Example:
</p>
<div class="example">
<pre class="example-preformatted">(define vh
  (alist-&gt;vhash '((a . 1) (a . 2) (z . 0) (a . 3))))

(vhash-fold* cons '() 'a vh)
⇒ (3 2 1)

(vhash-fold* cons '() 'z vh)
⇒ (0)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alist_002d_003evhash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-&gt;vhash</strong> <var class="def-var-arguments">alist [hash-proc]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002d_003evhash"> ¶</a></span></dt>
<dd><p>Return the vhash corresponding to <var class="var">alist</var>, an association list, using
<var class="var">hash-proc</var> to compute key hashes.  When omitted, <var class="var">hash-proc</var> defaults
to <code class="code">hash</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Hash-Tables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Types" accesskey="n" rel="next">Other Types</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#VHashes" accesskey="p" rel="prev">VList-Based Hash Lists or “VHashes”</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Hash-Tables-1">6.6.22 Hash Tables</h4>
<a class="index-entry-id" id="index-Hash-Tables"></a>

<p>Hash tables are dictionaries which offer similar functionality as
association lists: They provide a mapping from keys to values.  The
difference is that association lists need time linear in the size of
elements when searching for entries, whereas hash tables can normally
search in constant time.  The drawback is that hash tables require a
little bit more memory, and that you can not use the normal list
procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lists">Lists</a>) for working with them.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Examples" accesskey="1">Hash Table Examples</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Reference" accesskey="2">Hash Table Reference</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Hash-Table-Examples">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Reference" accesskey="n" rel="next">Hash Table Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables" accesskey="u" rel="up">Hash Tables</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hash-Table-Examples-1">6.6.22.1 Hash Table Examples</h4>

<p>For demonstration purposes, this section gives a few usage examples of
some hash table procedures, together with some explanation what they do.
</p>
<p>First we start by creating a new hash table with 31 slots, and
populate it with two key/value pairs.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define h (make-hash-table 31))

;; This is an opaque object
h
⇒
#&lt;hash-table 0/31&gt;

;; Inserting into a hash table can be done with hashq-set!
(hashq-set! h 'foo "bar")
⇒
"bar"

(hashq-set! h 'braz "zonk")
⇒
"zonk"

;; Or with hash-create-handle!
(hashq-create-handle! h 'frob #f)
⇒
(frob . #f)
</pre></div>

<p>You can get the value for a given key with the procedure
<code class="code">hashq-ref</code>, but the problem with this procedure is that you
cannot reliably determine whether a key does exists in the table.  The
reason is that the procedure returns <code class="code">#f</code> if the key is not in
the table, but it will return the same value if the key is in the
table and just happens to have the value <code class="code">#f</code>, as you can see in
the following examples.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(hashq-ref h 'foo)
⇒
"bar"

(hashq-ref h 'frob)
⇒
#f

(hashq-ref h 'not-there)
⇒
#f
</pre></div>

<p>It is often better is to use the procedure <code class="code">hashq-get-handle</code>,
which makes a distinction between the two cases.  Just like <code class="code">assq</code>,
this procedure returns a key/value-pair on success, and <code class="code">#f</code> if the
key is not found.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(hashq-get-handle h 'foo)
⇒
(foo . "bar")

(hashq-get-handle h 'not-there)
⇒
#f
</pre></div>

<p>Interesting results can be computed by using <code class="code">hash-fold</code> to work
through each element.  This example will count the total number of
elements:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(hash-fold (lambda (key value seed) (+ 1 seed)) 0 h)
⇒
3
</pre></div>

<p>The same thing can be done with the procedure <code class="code">hash-count</code>, which
can also count the number of elements matching a particular predicate.
For example, count the number of elements with string values:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(hash-count (lambda (key value) (string? value)) h)
⇒
2
</pre></div>

<p>Counting all the elements is a simple task using <code class="code">const</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(hash-count (const #t) h)
⇒
3
</pre></div>

<hr>
</div>
<div class="subsubsection-level-extent" id="Hash-Table-Reference">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Table-Examples" accesskey="p" rel="prev">Hash Table Examples</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables" accesskey="u" rel="up">Hash Tables</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hash-Table-Reference-1">6.6.22.2 Hash Table Reference</h4>


<p>Like the association list functions, the hash table functions come in
several varieties, according to the equality test used for the keys.
Plain <code class="code">hash-</code> functions use <code class="code">equal?</code>, <code class="code">hashq-</code>
functions use <code class="code">eq?</code>, <code class="code">hashv-</code> functions use <code class="code">eqv?</code>, and
the <code class="code">hashx-</code> functions use an application supplied test.
</p>
<p>A single <code class="code">make-hash-table</code> creates a hash table suitable for use
with any set of functions, but it’s imperative that just one set is
then used consistently, or results will be unpredictable.
</p>
<p>Hash tables are implemented as a vector indexed by a hash value formed
from the key, with an association list of key/value pairs for each
bucket in case distinct keys hash together.  Direct access to the
pairs in those lists is provided by the <code class="code">-handle-</code> functions.
</p>
<p>When the number of entries in a hash table goes above a threshold, the
vector is made larger and the entries are rehashed, to prevent the
bucket lists from becoming too long and slowing down accesses.  When the
number of entries goes below a threshold, the vector is shrunk to save
space.
</p>
<p>For the <code class="code">hashx-</code> “extended” routines, an application supplies a
<var class="var">hash</var> function producing an integer index like <code class="code">hashq</code> etc
below, and an <var class="var">assoc</var> alist search function like <code class="code">assq</code> etc
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries">Retrieving Alist Entries</a>).  Here’s an example of such
functions implementing case-insensitive hashing of string keys,
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-1)
             (srfi srfi-13))

(define (my-hash str size)
  (remainder (string-hash-ci str) size))
(define (my-assoc str alist)
  (find (lambda (pair) (string-ci=? str (car pair))) alist))

(define my-table (make-hash-table))
(hashx-set! my-hash my-assoc my-table "foo" 123)

(hashx-ref my-hash my-assoc my-table "FOO")
⇒ 123
</pre></div>

<p>In a <code class="code">hashx-</code> <var class="var">hash</var> function the aim is to spread keys
across the vector, so bucket lists don’t become long.  But the actual
values are arbitrary as long as they’re in the range 0 to
<em class="math"><var class="var">size</var>-1</em>.  Helpful functions for forming a hash value, in
addition to <code class="code">hashq</code> etc below, include <code class="code">symbol-hash</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Keys">Symbols as Lookup Keys</a>), <code class="code">string-hash</code> and <code class="code">string-hash-ci</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#String-Comparison">String Comparison</a>), and <code class="code">char-set-hash</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Set-Predicates_002fComparison">Character Set Predicates/Comparison</a>).
</p>
<br>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dhash_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-hash-table</strong> <var class="def-var-arguments">[size]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dhash_002dtable"> ¶</a></span></dt>
<dd><p>Create a new hash table object, with an optional minimum
vector <var class="var">size</var>.
</p>
<p>When <var class="var">size</var> is given, the table vector will still grow and shrink
automatically, as described above, but with <var class="var">size</var> as a minimum.
If an application knows roughly how many entries the table will hold
then it can use <var class="var">size</var> to avoid rehashing when initial entries are
added.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alist_002d_003ehash_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-&gt;hash-table</strong> <var class="def-var-arguments">alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002d_003ehash_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-alist_002d_003ehashq_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-&gt;hashq-table</strong> <var class="def-var-arguments">alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002d_003ehashq_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-alist_002d_003ehashv_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-&gt;hashv-table</strong> <var class="def-var-arguments">alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002d_003ehashv_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-alist_002d_003ehashx_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-&gt;hashx-table</strong> <var class="def-var-arguments">hash assoc alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002d_003ehashx_002dtable"> ¶</a></span></dt>
<dd><p>Convert <var class="var">alist</var> into a hash table. When keys are repeated in
<var class="var">alist</var>, the leftmost association takes precedence.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 hash-table))
(alist-&gt;hash-table '((foo . 1) (bar . 2)))
</pre></div>

<p>When converting to an extended hash table, custom <var class="var">hash</var> and
<var class="var">assoc</var> procedures must be provided.
</p>
<div class="example">
<pre class="example-preformatted">(alist-&gt;hashx-table hash assoc '((foo . 1) (bar . 2)))
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dtable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-table?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dtable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005ftable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_table_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005ftable_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a abstract hash table object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dclear_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-clear!</strong> <var class="def-var-arguments">table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dclear_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fclear_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_clear_x</strong> <var class="def-var-arguments">(table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fclear_005fx"> ¶</a></span></dt>
<dd><p>Remove all items from <var class="var">table</var> (without triggering a resize).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-ref</strong> <var class="def-var-arguments">table key [dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq-ref</strong> <var class="def-var-arguments">table key [dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv-ref</strong> <var class="def-var-arguments">table key [dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashx_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashx-ref</strong> <var class="def-var-arguments">hash assoc table key [dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashx_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_ref</strong> <var class="def-var-arguments">(table, key, dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq_ref</strong> <var class="def-var-arguments">(table, key, dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv_ref</strong> <var class="def-var-arguments">(table, key, dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashx_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashx_ref</strong> <var class="def-var-arguments">(hash, assoc, table, key, dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashx_005fref"> ¶</a></span></dt>
<dd><p>Lookup <var class="var">key</var> in the given hash <var class="var">table</var>, and return the
associated value.  If <var class="var">key</var> is not found, return <var class="var">dflt</var>, or
<code class="code">#f</code> if <var class="var">dflt</var> is not given.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-set!</strong> <var class="def-var-arguments">table key val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq-set!</strong> <var class="def-var-arguments">table key val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv-set!</strong> <var class="def-var-arguments">table key val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashx_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashx-set!</strong> <var class="def-var-arguments">hash assoc table key val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashx_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_set_x</strong> <var class="def-var-arguments">(table, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq_set_x</strong> <var class="def-var-arguments">(table, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv_set_x</strong> <var class="def-var-arguments">(table, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashx_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashx_set_x</strong> <var class="def-var-arguments">(hash, assoc, table, key, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashx_005fset_005fx"> ¶</a></span></dt>
<dd><p>Associate <var class="var">val</var> with <var class="var">key</var> in the given hash <var class="var">table</var>.  If
<var class="var">key</var> is already present then it’s associated value is changed.
If it’s not present then a new entry is created.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-remove!</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq-remove!</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv-remove!</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashx_002dremove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashx-remove!</strong> <var class="def-var-arguments">hash assoc table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashx_002dremove_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_remove_x</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fremove_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq_remove_x</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq_005fremove_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv_remove_x</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv_005fremove_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashx_005fremove_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashx_remove_x</strong> <var class="def-var-arguments">(hash, assoc, table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashx_005fremove_005fx"> ¶</a></span></dt>
<dd><p>Remove any association for <var class="var">key</var> in the given hash <var class="var">table</var>.
If <var class="var">key</var> is not in <var class="var">table</var> then nothing is done.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash</strong> <var class="def-var-arguments">key size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq</strong> <var class="def-var-arguments">key size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv</strong> <var class="def-var-arguments">key size</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash</strong> <var class="def-var-arguments">(key, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq</strong> <var class="def-var-arguments">(key, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv</strong> <var class="def-var-arguments">(key, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv"> ¶</a></span></dt>
<dd><p>Return a hash value for <var class="var">key</var>.  This is a number in the range
<em class="math">0</em> to <em class="math"><var class="var">size</var>-1</em>, which is suitable for use in a hash
table of the given <var class="var">size</var>.
</p>
<p>Note that <code class="code">hashq</code> and <code class="code">hashv</code> may use internal addresses of
objects, so if an object is garbage collected and re-created it can
have a different hash value, even when the two are notionally
<code class="code">eq?</code>.  For instance with symbols,
</p>
<div class="example">
<pre class="example-preformatted">(hashq 'something 123)   ⇒ 19
(gc)
(hashq 'something 123)   ⇒ 62
</pre></div>

<p>In normal use this is not a problem, since an object entered into a
hash table won’t be garbage collected until removed.  It’s only if
hashing calculations are somehow separated from normal references that
its lifetime needs to be considered.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dget_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-get-handle</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dget_002dhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq_002dget_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq-get-handle</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq_002dget_002dhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv_002dget_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv-get-handle</strong> <var class="def-var-arguments">table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv_002dget_002dhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashx_002dget_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashx-get-handle</strong> <var class="def-var-arguments">hash assoc table key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashx_002dget_002dhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fget_005fhandle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_get_handle</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fget_005fhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq_005fget_005fhandle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq_get_handle</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq_005fget_005fhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv_005fget_005fhandle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv_get_handle</strong> <var class="def-var-arguments">(table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv_005fget_005fhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashx_005fget_005fhandle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashx_get_handle</strong> <var class="def-var-arguments">(hash, assoc, table, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashx_005fget_005fhandle"> ¶</a></span></dt>
<dd><p>Return the <code class="code">(<var class="var">key</var> . <var class="var">value</var>)</code> pair for <var class="var">key</var> in the
given hash <var class="var">table</var>, or <code class="code">#f</code> if <var class="var">key</var> is not in
<var class="var">table</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dcreate_002dhandle_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-create-handle!</strong> <var class="def-var-arguments">table key init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dcreate_002dhandle_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashq_002dcreate_002dhandle_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashq-create-handle!</strong> <var class="def-var-arguments">table key init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashq_002dcreate_002dhandle_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashv_002dcreate_002dhandle_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashv-create-handle!</strong> <var class="def-var-arguments">table key init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashv_002dcreate_002dhandle_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hashx_002dcreate_002dhandle_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hashx-create-handle!</strong> <var class="def-var-arguments">hash assoc table key init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hashx_002dcreate_002dhandle_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fcreate_005fhandle_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_create_handle_x</strong> <var class="def-var-arguments">(table, key, init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fcreate_005fhandle_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashq_005fcreate_005fhandle_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashq_create_handle_x</strong> <var class="def-var-arguments">(table, key, init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashq_005fcreate_005fhandle_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashv_005fcreate_005fhandle_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashv_create_handle_x</strong> <var class="def-var-arguments">(table, key, init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashv_005fcreate_005fhandle_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhashx_005fcreate_005fhandle_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hashx_create_handle_x</strong> <var class="def-var-arguments">(hash, assoc, table, key, init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhashx_005fcreate_005fhandle_005fx"> ¶</a></span></dt>
<dd><p>Return the <code class="code">(<var class="var">key</var> . <var class="var">value</var>)</code> pair for <var class="var">key</var> in the
given hash <var class="var">table</var>.  If <var class="var">key</var> is not in <var class="var">table</var> then
create an entry for it with <var class="var">init</var> as the value, and return that
pair.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dmap_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-map-&gt;list</strong> <var class="def-var-arguments">proc table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dmap_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-hash_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-for-each</strong> <var class="def-var-arguments">proc table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fmap_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_map_to_list</strong> <var class="def-var-arguments">(proc, table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fmap_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_for_each</strong> <var class="def-var-arguments">(proc, table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005ffor_005feach"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to the entries in the given hash <var class="var">table</var>.  Each
call is <code class="code">(<var class="var">proc</var> <var class="var">key</var> <var class="var">value</var>)</code>.  <code class="code">hash-map-&gt;list</code>
returns a list of the results from these calls, <code class="code">hash-for-each</code>
discards the results and returns an unspecified value.
</p>
<p>Calls are made over the table entries in an unspecified order, and for
<code class="code">hash-map-&gt;list</code> the order of the values in the returned list is
unspecified.  Results will be unpredictable if <var class="var">table</var> is modified
while iterating.
</p>
<p>For example the following returns a new alist comprising all the
entries from <code class="code">mytable</code>, in no particular order.
</p>
<div class="example">
<pre class="example-preformatted">(hash-map-&gt;list cons mytable)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dfor_002deach_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-for-each-handle</strong> <var class="def-var-arguments">proc table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dfor_002deach_002dhandle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005ffor_005feach_005fhandle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_for_each_handle</strong> <var class="def-var-arguments">(proc, table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005ffor_005feach_005fhandle"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to the entries in the given hash <var class="var">table</var>.  Each
call is <code class="code">(<var class="var">proc</var> <var class="var">handle</var>)</code>, where <var class="var">handle</var> is a
<code class="code">(<var class="var">key</var> . <var class="var">value</var>)</code> pair. Return an unspecified value.
</p>
<p><code class="code">hash-for-each-handle</code> differs from <code class="code">hash-for-each</code> only in
the argument list of <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-fold</strong> <var class="def-var-arguments">proc init table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005ffold"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_fold</strong> <var class="def-var-arguments">(proc, init, table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005ffold"> ¶</a></span></dt>
<dd><p>Accumulate a result by applying <var class="var">proc</var> to the elements of the
given hash <var class="var">table</var>.  Each call is <code class="code">(<var class="var">proc</var> <var class="var">key</var>
<var class="var">value</var> <var class="var">prior-result</var>)</code>, where <var class="var">key</var> and <var class="var">value</var> are
from the <var class="var">table</var> and <var class="var">prior-result</var> is the return from the
previous <var class="var">proc</var> call.  For the first call, <var class="var">prior-result</var> is
the given <var class="var">init</var> value.
</p>
<p>Calls are made over the table entries in an unspecified order.
Results will be unpredictable if <var class="var">table</var> is modified while
<code class="code">hash-fold</code> is running.
</p>
<p>For example, the following returns a count of how many keys in
<code class="code">mytable</code> are strings.
</p>
<div class="example">
<pre class="example-preformatted">(hash-fold (lambda (key value prior)
             (if (string? key) (1+ prior) prior))
           0 mytable)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hash_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hash-count</strong> <var class="def-var-arguments">pred table</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhash_005fcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hash_count</strong> <var class="def-var-arguments">(pred, table)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhash_005fcount"> ¶</a></span></dt>
<dd><p>Return the number of elements in the given hash <var class="var">table</var> that cause
<code class="code">(<var class="var">pred</var> <var class="var">key</var> <var class="var">value</var>)</code> to return true.  To quickly
determine the total number of elements, use <code class="code">(const #t)</code> for
<var class="var">pred</var>.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Other-Types">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables" accesskey="p" rel="prev">Hash Tables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="u" rel="up">Data Types</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Other-Types-1">6.6.23 Other Types</h4>

<p>Procedures are documented in their own section.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures">Procedures</a>.
</p>
<p>Variable objects are documented as part of the description of Guile’s
module system: see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Variables">Variables</a>.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling">Threads, Mutexes, Asyncs and Dynamic Roots</a>, for discussion of threads, mutexes, and so on.
</p>
<p>Ports are described in the section on I/O: see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output">Input and Output</a>.
</p>
<p>Regular expressions are described in their own section: see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions">Regular Expressions</a>.
</p>
<p>There are quite a number of additional data types documented in this
manual; if you feel a link is missing here, please file a bug.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="Procedures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="n" rel="next">Macros</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Data-Types" accesskey="p" rel="prev">Data Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Procedures-1">6.7 Procedures</h3>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Lambda" accesskey="1">Lambda: Basic Procedure Creation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures" accesskey="2">Primitive Procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures" accesskey="3">Compiled Procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" accesskey="4">Optional Arguments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda" accesskey="5">Case-lambda</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions" accesskey="6">Higher-Order Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties" accesskey="7">Procedure Properties and Meta-information</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters" accesskey="8">Procedures with Setters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Inlinable-Procedures" accesskey="9">Inlinable Procedures</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Lambda">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures" accesskey="n" rel="next">Primitive Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Lambda_003a-Basic-Procedure-Creation">6.7.1 Lambda: Basic Procedure Creation</h4>
<a class="index-entry-id" id="index-lambda"></a>

<p>A <code class="code">lambda</code> expression evaluates to a procedure.  The environment
which is in effect when a <code class="code">lambda</code> expression is evaluated is
enclosed in the newly created procedure, this is referred to as a
<em class="dfn">closure</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The Concept of Closure</a>).
</p>
<p>When a procedure created by <code class="code">lambda</code> is called with some actual
arguments, the environment enclosed in the procedure is extended by
binding the variables named in the formal argument list to new locations
and storing the actual arguments into these locations.  Then the body of
the <code class="code">lambda</code> expression is evaluated sequentially.  The result of
the last expression in the procedure body is then the result of the
procedure invocation.
</p>
<p>The following examples will show how procedures can be created using
<code class="code">lambda</code>, and what you can do with these procedures.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda (x) (+ x x))       ⇒ <span class="r">a procedure</span>
((lambda (x) (+ x x)) 4)   ⇒ 8
</pre></div>

<p>The fact that the environment in effect when creating a procedure is
enclosed in the procedure is shown with this example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                   ⇒ 10
</pre></div>


<dl class="first-deffn">
<dt class="deffn" id="index-lambda-1"><span class="category-def">syntax: </span><span><strong class="def-name">lambda</strong> <var class="def-var-arguments">formals body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lambda-1"> ¶</a></span></dt>
<dd><p><var class="var">formals</var> should be a formal argument list as described in the
following table.
</p>
<dl class="table">
<dt><code class="code">(<var class="var">variable1</var> …)</code></dt>
<dd><p>The procedure takes a fixed number of arguments; when the procedure is
called, the arguments will be stored into the newly created location for
the formal variables.
</p></dd>
<dt><code class="code"><var class="var">variable</var></code></dt>
<dd><p>The procedure takes any number of arguments; when the procedure is
called, the sequence of actual arguments will be converted into a list
and stored into the newly created location for the formal variable.
</p></dd>
<dt><code class="code">(<var class="var">variable1</var> … <var class="var">variablen</var> . <var class="var">variablen+1</var>)</code></dt>
<dd><p>If a space-delimited period precedes the last variable, then the
procedure takes <var class="var">n</var> or more variables where <var class="var">n</var> is the number
of formal arguments before the period.  There must be at least one
argument before the period.  The first <var class="var">n</var> actual arguments will be
stored into the newly allocated locations for the first <var class="var">n</var> formal
arguments and the sequence of the remaining actual arguments is
converted into a list and the stored into the location for the last
formal argument.  If there are exactly <var class="var">n</var> actual arguments, the
empty list is stored into the location of the last formal argument.
</p></dd>
</dl>

<p>The list in <var class="var">variable</var> or <var class="var">variablen+1</var> is always newly
created and the procedure can modify it if desired.  This is the case
even when the procedure is invoked via <code class="code">apply</code>, the required part
of the list argument there will be copied (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">Procedures for On the Fly Evaluation</a>).
</p>
<p><var class="var">body</var> is a sequence of Scheme expressions which are evaluated in
order when the procedure is invoked.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Primitive-Procedures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures" accesskey="n" rel="next">Compiled Procedures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Lambda" accesskey="p" rel="prev">Lambda: Basic Procedure Creation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Primitive-Procedures-1">6.7.2 Primitive Procedures</h4>
<a class="index-entry-id" id="index-primitives"></a>
<a class="index-entry-id" id="index-primitive-procedures"></a>

<p>Procedures written in C can be registered for use from Scheme,
provided they take only arguments of type <code class="code">SCM</code> and return
<code class="code">SCM</code> values.  <code class="code">scm_c_define_gsubr</code> is likely to be the most
useful mechanism, combining the process of registration
(<code class="code">scm_c_make_gsubr</code>) and definition (<code class="code">scm_define</code>).
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fc_005fmake_005fgsubr"><span class="category-def">Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_gsubr</strong> <code class="def-code-arguments">(const char *name, int req, int opt, int rst, fcn)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fgsubr"> ¶</a></span></dt>
<dd><p>Register a C procedure <var class="var">fcn</var> as a “subr” — a primitive
subroutine that can be called from Scheme.  It will be associated with
the given <var class="var">name</var> but no environment binding will be created.  The
arguments <var class="var">req</var>, <var class="var">opt</var> and <var class="var">rst</var> specify the number of
required, optional and “rest” arguments respectively.  The total
number of these arguments should match the actual number of arguments
to <var class="var">fcn</var>, but may not exceed 10.  The number of rest arguments should be 0 or 1.
<code class="code">scm_c_make_gsubr</code> returns a value of type <code class="code">SCM</code> which is a
“handle” for the procedure.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fc_005fdefine_005fgsubr"><span class="category-def">Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_define_gsubr</strong> <code class="def-code-arguments">(const char *name, int req, int opt, int rst, fcn)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fdefine_005fgsubr"> ¶</a></span></dt>
<dd><p>Register a C procedure <var class="var">fcn</var>, as for <code class="code">scm_c_make_gsubr</code>
above, and additionally create a top-level Scheme binding for the
procedure in the “current environment” using <code class="code">scm_define</code>.
<code class="code">scm_c_define_gsubr</code> returns a handle for the procedure in the
same way as <code class="code">scm_c_make_gsubr</code>, which is usually not further
required.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Compiled-Procedures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" accesskey="n" rel="next">Optional Arguments</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures" accesskey="p" rel="prev">Primitive Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Compiled-Procedures-1">6.7.3 Compiled Procedures</h4>

<p>The evaluation strategy given in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a> describes how procedures
are <em class="dfn">interpreted</em>. Interpretation operates directly on expanded
Scheme source code, recursively calling the evaluator to obtain the
value of nested expressions.
</p>
<p>Most procedures are compiled, however. This means that Guile has done
some pre-computation on the procedure, to determine what it will need to
do each time the procedure runs. Compiled procedures run faster than
interpreted procedures.
</p>
<p>Loading files is the normal way that compiled procedures come to
being. If Guile sees that a file is uncompiled, or that its compiled
file is out of date, it will attempt to compile the file when it is
loaded, and save the result to disk. Procedures can be compiled at
runtime as well. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile">Reading and Evaluating Scheme Code</a>, for more information
on runtime compilation.
</p>
<p>Compiled procedures, also known as <em class="dfn">programs</em>, respond to all
procedures that operate on procedures: you can pass a program to
<code class="code">procedure?</code>, <code class="code">procedure-name</code>, and so on (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties">Procedure Properties and Meta-information</a>).  In addition, there are a few more accessors for low-level
details on programs.
</p>
<p>Most people won’t need to use the routines described in this section,
but it’s good to have them documented. You’ll have to include the
appropriate module first, though:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system vm program))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-program_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005fp"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a compiled procedure, or <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002dcode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-code</strong> <var class="def-var-arguments">program</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dcode"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005fcode"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_code</strong> <var class="def-var-arguments">(program)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005fcode"> ¶</a></span></dt>
<dd><p>Returns the address of the program’s entry, as an integer.  This address
is mostly useful to procedures in <code class="code">(system vm debug)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002dnum_002dfree_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-num-free-variable</strong> <var class="def-var-arguments">program</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dnum_002dfree_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005fnum_005ffree_005fvariables"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_num_free_variables</strong> <var class="def-var-arguments">(program)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005fnum_005ffree_005fvariables"> ¶</a></span></dt>
<dd><p>Return the number of free variables captured by this program.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002dfree_002dvariable_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-free-variable-ref</strong> <var class="def-var-arguments">program n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dfree_002dvariable_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005ffree_005fvariable_002dref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_free_variable-ref</strong> <var class="def-var-arguments">(program, n)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005ffree_005fvariable_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-program_002dfree_002dvariable_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-free-variable-set!</strong> <var class="def-var-arguments">program n val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dfree_002dvariable_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005ffree_005fvariable_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_free_variable_set_x</strong> <var class="def-var-arguments">(program, n, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005ffree_005fvariable_005fset_005fx"> ¶</a></span></dt>
<dd><p>Accessors for a program’s free variables.  Some of the values captured
are actually in variable “boxes”.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Variables-and-the-VM">Variables and the VM</a>, for
more information.
</p>
<p>Users must not modify the returned value unless they think they’re
really clever.
</p></dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-program_002dbindings"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-bindings</strong> <var class="def-var-arguments">program</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dbindings"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dbinding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-binding</strong> <var class="def-var-arguments">name boxed? index start end</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dbinding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding:name</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_003aname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_003aboxed_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding:boxed?</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_003aboxed_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_003aindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding:index</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_003aindex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_003astart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding:start</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_003astart"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_003aend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding:end</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_003aend"> ¶</a></span></dt>
<dd><p>Bindings annotations for programs, along with their accessors.
</p>
<p>Bindings declare names and liveness extents for block-local variables.
The best way to see what these are is to play around with them at a
REPL. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Concepts">VM Concepts</a>, for more information.
</p>
<p>Note that bindings information is stored in a program as part of its
metadata thunk, so including it in the generated object code does not
impose a runtime performance penalty.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002dsources"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-sources</strong> <var class="def-var-arguments">program</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dsources"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-source_003aaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source:addr</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_003aaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-source_003aline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source:line</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_003aline"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-source_003acolumn"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source:column</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_003acolumn"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-source_003afile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source:file</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_003afile"> ¶</a></span></dt>
<dd><p>Source location annotations for programs, along with their accessors.
</p>
<p>Source location information propagates through the compiler and ends
up being serialized to the program’s metadata. This information is
keyed by the offset of the instruction pointer within the object code
of the program. Specifically, it is keyed on the <code class="code">ip</code> <em class="emph">just
following</em> an instruction, so that backtraces can find the source
location of a call that is in progress.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002darities"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-arities</strong> <var class="def-var-arguments">program</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002darities"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005farities"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_arities</strong> <var class="def-var-arguments">(program)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005farities"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-program_002darity"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-arity</strong> <var class="def-var-arguments">program ip</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002darity"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003astart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:start</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003astart"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003aend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:end</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003aend"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003anreq"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:nreq</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003anreq"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003anopt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:nopt</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003anopt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003arest_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:rest?</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003arest_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003akw"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:kw</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003akw"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-arity_003aallow_002dother_002dkeys_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">arity:allow-other-keys?</strong> <var class="def-var-arguments">arity</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-arity_003aallow_002dother_002dkeys_003f"> ¶</a></span></dt>
<dd><p>Accessors for a representation of the “arity” of a program.
</p>
<p>The normal case is that a procedure has one arity. For example,
<code class="code">(lambda (x) x)</code>, takes one required argument, and that’s it. One
could access that number of required arguments via <code class="code">(arity:nreq
(program-arities (lambda (x) x)))</code>. Similarly, <code class="code">arity:nopt</code> gets
the number of optional arguments, and <code class="code">arity:rest?</code> returns a true
value if the procedure has a rest arg.
</p>
<p><code class="code">arity:kw</code> returns a list of <code class="code">(<var class="var">kw</var> . <var class="var">idx</var>)</code> pairs,
if the procedure has keyword arguments. The <var class="var">idx</var> refers to the
<var class="var">idx</var>th local variable; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Variables-and-the-VM">Variables and the VM</a>, for more
information. Finally <code class="code">arity:allow-other-keys?</code> returns a true
value if other keys are allowed. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments">Optional Arguments</a>, for more
information.
</p>
<p>So what about <code class="code">arity:start</code> and <code class="code">arity:end</code>, then? They
return the range of bytes in the program’s bytecode for which a given
arity is valid. You see, a procedure can actually have more than one
arity. The question, “what is a procedure’s arity” only really makes
sense at certain points in the program, delimited by these
<code class="code">arity:start</code> and <code class="code">arity:end</code> values.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002darguments_002dalist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-arguments-alist</strong> <var class="def-var-arguments">program [ip]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002darguments_002dalist"> ¶</a></span></dt>
<dd><p>Return an association list describing the arguments that <var class="var">program</var> accepts, or
<code class="code">#f</code> if the information cannot be obtained.
</p>
<p>The alist keys that are currently defined are ‘required’, ‘optional’,
‘keyword’, ‘allow-other-keys?’, and ‘rest’.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(program-arguments-alist
 (lambda* (a b #:optional c #:key (d 1) #:rest e)
   #t)) ⇒
((required . (a b))
 (optional . (c))
 (keyword . ((#:d . 4)))
 (allow-other-keys? . #f)
 (rest . d))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002dlambda_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-lambda-list</strong> <var class="def-var-arguments">program [ip]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002dlambda_002dlist"> ¶</a></span></dt>
<dd><p>Return a representation of the arguments of <var class="var">program</var> as a lambda
list, or <code class="code">#f</code> if this information is not available.
</p>
<p>For example:
</p>
<div class="example">
<pre class="example-preformatted">(program-lambda-list
 (lambda* (a b #:optional c #:key (d 1) #:rest e)
   #t)) ⇒
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Optional-Arguments">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda" accesskey="n" rel="next">Case-lambda</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compiled-Procedures" accesskey="p" rel="prev">Compiled Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Optional-Arguments-1">6.7.4 Optional Arguments</h4>

<p>Scheme procedures, as defined in R5RS, can either handle a fixed number
of actual arguments, or a fixed number of actual arguments followed by
arbitrarily many additional arguments.  Writing procedures of variable
arity can be useful, but unfortunately, the syntactic means for handling
argument lists of varying length is a bit inconvenient.  It is possible
to give names to the fixed number of arguments, but the remaining
(optional) arguments can be only referenced as a list of values
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a>).
</p>
<p>For this reason, Guile provides an extension to <code class="code">lambda</code>,
<code class="code">lambda*</code>, which allows the user to define procedures with
optional and keyword arguments. In addition, Guile’s virtual machine
has low-level support for optional and keyword argument dispatch.
Calls to procedures with optional and keyword arguments can be made
cheaply, without allocating a rest list.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#lambda_002a-and-define_002a" accesskey="1">lambda* and define*.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#ice_002d9-optargs" accesskey="2">(ice-9 optargs)</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="lambda_002a-and-define_002a">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#ice_002d9-optargs" accesskey="n" rel="next">(ice-9 optargs)</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" accesskey="u" rel="up">Optional Arguments</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="lambda_002a-and-define_002a_002e">6.7.4.1 lambda* and define*.</h4>

<p><code class="code">lambda*</code> is like <code class="code">lambda</code>, except with some extensions to
allow optional and keyword arguments.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-lambda_002a"><span class="category-def">library syntax: </span><span><strong class="def-name">lambda*</strong> <var class="def-var-arguments">([var…] <br>                         [#:optional vardef…] <br>                         [#:key  vardef… [#:allow-other-keys]] <br>                         [#:rest var | . var]) <br>                         body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lambda_002a"> ¶</a></span></dt>
<dd><br>
<p>Create a procedure which takes optional and/or keyword arguments
specified with <code class="code">#:optional</code> and <code class="code">#:key</code>.  For example,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda* (a b #:optional c d . e) '())
</pre></div>

<p>is a procedure with fixed arguments <var class="var">a</var> and <var class="var">b</var>, optional
arguments <var class="var">c</var> and <var class="var">d</var>, and rest argument <var class="var">e</var>.  If the
optional arguments are omitted in a call, the variables for them are
bound to <code class="code">#f</code>.
</p>
<a class="index-entry-id" id="index-define_002a"></a>
<p>Likewise, <code class="code">define*</code> is syntactic sugar for defining procedures
using <code class="code">lambda*</code>.
</p>
<p><code class="code">lambda*</code> can also make procedures with keyword arguments. For
example, a procedure defined like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define* (sir-yes-sir #:key action how-high)
  (list action how-high))
</pre></div>

<p>can be called as <code class="code">(sir-yes-sir #:action 'jump)</code>,
<code class="code">(sir-yes-sir #:how-high 13)</code>, <code class="code">(sir-yes-sir #:action
'lay-down #:how-high 0)</code>, or just <code class="code">(sir-yes-sir)</code>. Whichever
arguments are given as keywords are bound to values (and those not
given are <code class="code">#f</code>).
</p>
<p>Optional and keyword arguments can also have default values to take
when not present in a call, by giving a two-element list of variable
name and expression.  For example in
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define* (frob foo #:optional (bar 42) #:key (baz 73))
  (list foo bar baz))
</pre></div>

<p><var class="var">foo</var> is a fixed argument, <var class="var">bar</var> is an optional argument with
default value 42, and baz is a keyword argument with default value 73.
Default value expressions are not evaluated unless they are needed,
and until the procedure is called.
</p>
<p>Normally it’s an error if a call has keywords other than those
specified by <code class="code">#:key</code>, but adding <code class="code">#:allow-other-keys</code> to the
definition (after the keyword argument declarations) will ignore
unknown keywords.
</p>
<p>If a call has a keyword given twice, the last value is used.  For
example,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define* (flips #:key (heads 0) (tails 0))
  (display (list heads tails)))

(flips #:heads 37 #:tails 42 #:heads 99)
-| (99 42)
</pre></div>

<p><code class="code">#:rest</code> is a synonym for the dotted syntax rest argument.  The
argument lists <code class="code">(a . b)</code> and <code class="code">(a #:rest b)</code> are equivalent
in all respects.  This is provided for more similarity to DSSSL,
MIT-Scheme and Kawa among others, as well as for refugees from other
Lisp dialects.
</p>
<p>When <code class="code">#:key</code> is used together with a rest argument, the keyword
parameters in a call all remain in the rest list.  This is the same as
Common Lisp.  For example,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((lambda* (#:key (x 0) #:allow-other-keys #:rest r)
   (display r))
 #:x 123 #:y 456)
-| (#:x 123 #:y 456)
</pre></div>

<p><code class="code">#:optional</code> and <code class="code">#:key</code> establish their bindings
successively, from left to right. This means default expressions can
refer back to prior parameters, for example
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(lambda* (start #:optional (end (+ 10 start)))
  (do ((i start (1+ i)))
      ((&gt; i end))
    (display i)))
</pre></div>

<p>The exception to this left-to-right scoping rule is the rest argument.
If there is a rest argument, it is bound after the optional arguments,
but before the keyword arguments.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="ice_002d9-optargs">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#lambda_002a-and-define_002a" accesskey="p" rel="prev">lambda* and define*.</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" accesskey="u" rel="up">Optional Arguments</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="g_t_0028ice_002d9-optargs_0029">6.7.4.2 (ice-9 optargs)</h4>

<p>Before Guile 2.0, <code class="code">lambda*</code> and <code class="code">define*</code> were implemented
using macros that processed rest list arguments. This was not optimal,
as calling procedures with optional arguments had to allocate rest
lists at every procedure invocation. Guile 2.0 improved this
situation by bringing optional and keyword arguments into Guile’s
core.
</p>
<p>However there are occasions in which you have a list and want to parse
it for optional or keyword arguments. Guile’s <code class="code">(ice-9 optargs)</code>
provides some macros to help with that task.
</p>
<p>The syntax <code class="code">let-optional</code> and <code class="code">let-optional*</code> are for
destructuring rest argument lists and giving names to the various list
elements.  <code class="code">let-optional</code> binds all variables simultaneously, while
<code class="code">let-optional*</code> binds them sequentially, consistent with <code class="code">let</code>
and <code class="code">let*</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let_002doptional"><span class="category-def">library syntax: </span><span><strong class="def-name">let-optional</strong> <var class="def-var-arguments">rest-arg (binding …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002doptional"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-let_002doptional_002a"><span class="category-def">library syntax: </span><span><strong class="def-name">let-optional*</strong> <var class="def-var-arguments">rest-arg (binding …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002doptional_002a"> ¶</a></span></dt>
<dd><p>These two macros give you an optional argument interface that is very
<em class="dfn">Schemey</em> and introduces no fancy syntax. They are compatible with
the scsh macros of the same name, but are slightly extended. Each of
<var class="var">binding</var> may be of one of the forms <var class="var">var</var> or <code class="code">(<var class="var">var</var>
<var class="var">default-value</var>)</code>. <var class="var">rest-arg</var> should be the rest-argument of the
procedures these are used from.  The items in <var class="var">rest-arg</var> are
sequentially bound to the variable names are given. When <var class="var">rest-arg</var>
runs out, the remaining vars are bound either to the default values or
<code class="code">#f</code> if no default value was specified. <var class="var">rest-arg</var> remains
bound to whatever may have been left of <var class="var">rest-arg</var>.
</p>
<p>After binding the variables, the expressions <var class="var">body1</var> <var class="var">body2</var> …
are evaluated in order.
</p></dd></dl>

<p>Similarly, <code class="code">let-keywords</code> and <code class="code">let-keywords*</code> extract values
from keyword style argument lists, binding local variables to those
values or to defaults.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let_002dkeywords"><span class="category-def">library syntax: </span><span><strong class="def-name">let-keywords</strong> <var class="def-var-arguments">args allow-other-keys? (binding …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002dkeywords"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-let_002dkeywords_002a"><span class="category-def">library syntax: </span><span><strong class="def-name">let-keywords*</strong> <var class="def-var-arguments">args allow-other-keys? (binding …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002dkeywords_002a"> ¶</a></span></dt>
<dd><p><var class="var">args</var> is evaluated and should give a list of the form
<code class="code">(#:keyword1 value1 #:keyword2 value2 …)</code>.  The
<var class="var">binding</var>s are variables and default expressions, with the variables
to be set (by name) from the keyword values.  The <var class="var">body1</var>
<var class="var">body2</var> …  forms are then evaluated and the last is the
result.  An example will make the syntax clearest,
</p>
<div class="example">
<pre class="example-preformatted">(define args '(#:xyzzy "hello" #:foo "world"))

(let-keywords args #t
      ((foo  "default for foo")
       (bar  (string-append "default" "for" "bar")))
  (display foo)
  (display ", ")
  (display bar))
-| world, defaultforbar
</pre></div>

<p>The binding for <code class="code">foo</code> comes from the <code class="code">#:foo</code> keyword in
<code class="code">args</code>.  But the binding for <code class="code">bar</code> is the default in the
<code class="code">let-keywords</code>, since there’s no <code class="code">#:bar</code> in the args.
</p>
<p><var class="var">allow-other-keys?</var> is evaluated and controls whether unknown
keywords are allowed in the <var class="var">args</var> list.  When true other keys are
ignored (such as <code class="code">#:xyzzy</code> in the example), when <code class="code">#f</code> an
error is thrown for anything unknown.
</p></dd></dl>

<p><code class="code">(ice-9 optargs)</code> also provides some more <code class="code">define*</code> sugar,
which is not so useful with modern Guile coding, but still supported:
<code class="code">define*-public</code> is the <code class="code">lambda*</code> version of
<code class="code">define-public</code>; <code class="code">defmacro*</code> and <code class="code">defmacro*-public</code>
exist for defining macros with the improved argument list handling
possibilities. The <code class="code">-public</code> versions not only define the
procedures/macros, but also export them from the current module.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002a_002dpublic"><span class="category-def">library syntax: </span><span><strong class="def-name">define*-public</strong> <var class="def-var-arguments">formals body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002a_002dpublic"> ¶</a></span></dt>
<dd><p>Like a mix of <code class="code">define*</code> and <code class="code">define-public</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-defmacro_002a"><span class="category-def">library syntax: </span><span><strong class="def-name">defmacro*</strong> <var class="def-var-arguments">name formals body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-defmacro_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-defmacro_002a_002dpublic"><span class="category-def">library syntax: </span><span><strong class="def-name">defmacro*-public</strong> <var class="def-var-arguments">name formals body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-defmacro_002a_002dpublic"> ¶</a></span></dt>
<dd><p>These are just like <code class="code">defmacro</code> and <code class="code">defmacro-public</code> except that they
take <code class="code">lambda*</code>-style extended parameter lists, where <code class="code">#:optional</code>,
<code class="code">#:key</code>, <code class="code">#:allow-other-keys</code> and <code class="code">#:rest</code> are allowed with the usual
semantics. Here is an example of a macro with an optional argument:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defmacro* transmogrify (a #:optional b)
  (a 1))
</pre></div>
</dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Case_002dlambda">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions" accesskey="n" rel="next">Higher-Order Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Optional-Arguments" accesskey="p" rel="prev">Optional Arguments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Case_002dlambda-1">6.7.5 Case-lambda</h4>
<a class="index-entry-id" id="index-SRFI_002d16"></a>
<a class="index-entry-id" id="index-variable-arity"></a>
<a class="index-entry-id" id="index-arity_002c-variable"></a>

<p>R5RS’s rest arguments are indeed useful and very general, but they
often aren’t the most appropriate or efficient means to get the job
done. For example, <code class="code">lambda*</code> is a much better solution to the
optional argument problem than <code class="code">lambda</code> with rest arguments.
</p>
<a class="index-entry-id" id="index-case_002dlambda"></a>
<p>Likewise, <code class="code">case-lambda</code> works well for when you want one
procedure to do double duty (or triple, or ...), without the penalty
of consing a rest list.
</p>
<p>For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-accum n)
  (case-lambda
    (() n)
    ((m) (set! n (+ n m)) n)))

(define a (make-accum 20))
(a) ⇒ 20
(a 10) ⇒ 30
(a) ⇒ 30
</pre></div>

<p>The value returned by a <code class="code">case-lambda</code> form is a procedure which
matches the number of actual arguments against the formals in the
various clauses, in order. The first matching clause is selected, the
corresponding values from the actual parameter list are bound to the
variable names in the clauses and the body of the clause is evaluated.
If no clause matches, an error is signalled.
</p>
<p>The syntax of the <code class="code">case-lambda</code> form is defined in the following
EBNF grammar. <em class="dfn">Formals</em> means a formal argument list just like
with <code class="code">lambda</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a>).
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">&lt;case-lambda&gt;
   --&gt; (case-lambda &lt;case-lambda-clause&gt;*)
   --&gt; (case-lambda &lt;docstring&gt; &lt;case-lambda-clause&gt;*)
&lt;case-lambda-clause&gt;
   --&gt; (&lt;formals&gt; &lt;definition-or-command&gt;*)
&lt;formals&gt;
   --&gt; (&lt;identifier&gt;*)
     | (&lt;identifier&gt;* . &lt;identifier&gt;)
     | &lt;identifier&gt;
</pre></div></div>

<p>Rest lists can be useful with <code class="code">case-lambda</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define plus
  (case-lambda
    "Return the sum of all arguments."
    (() 0)
    ((a) a)
    ((a b) (+ a b))
    ((a b . rest) (apply plus (+ a b) rest))))
(plus 1 2 3) ⇒ 6
</pre></div>

<a class="index-entry-id" id="index-case_002dlambda_002a"></a>
<p>Also, for completeness. Guile defines <code class="code">case-lambda*</code> as well,
which is like <code class="code">case-lambda</code>, except with <code class="code">lambda*</code> clauses.
A <code class="code">case-lambda*</code> clause matches if the arguments fill the
required arguments, but are not too many for the optional and/or rest
arguments.
</p>
<p>Keyword arguments are possible with <code class="code">case-lambda*</code> as well, but
they do not contribute to the “matching” behavior, and their
interactions with required, optional, and rest arguments can be
surprising.
</p>
<p>For the purposes of <code class="code">case-lambda*</code> (and of <code class="code">case-lambda</code>, as a
special case), a clause <em class="dfn">matches</em> if it has enough required
arguments, and not too many positional arguments.  The required
arguments are any arguments before the <code class="code">#:optional</code>, <code class="code">#:key</code>,
and <code class="code">#:rest</code> arguments.  <em class="dfn">Positional</em> arguments are the
required arguments, together with the optional arguments.
</p>
<p>In the absence of <code class="code">#:key</code> or <code class="code">#:rest</code> arguments, it’s easy to
see how there could be too many positional arguments: you pass 5
arguments to a function that only takes 4 arguments, including optional
arguments.  If there is a <code class="code">#:rest</code> argument, there can never be too
many positional arguments: any application with enough required
arguments for a clause will match that clause, even if there are also
<code class="code">#:key</code> arguments.
</p>
<p>Otherwise, for applications to a clause with <code class="code">#:key</code> arguments (and
without a <code class="code">#:rest</code> argument), a clause will match there only if
there are enough required arguments and if the next argument after
binding required and optional arguments, if any, is a keyword.  For
efficiency reasons, Guile is currently unable to include keyword
arguments in the matching algorithm.  Clauses match on positional
arguments only, not by comparing a given keyword to the available set of
keyword arguments that a function has.
</p>
<p>Some examples follow.
</p>
<div class="example">
<pre class="example-preformatted">(define f
  (case-lambda*
    ((a #:optional b) 'clause-1)
    ((a #:optional b #:key c) 'clause-2)
    ((a #:key d) 'clause-3)
    ((#:key e #:rest f) 'clause-4)))

(f) ⇒ clause-4
(f 1) ⇒ clause-1
(f) ⇒ clause-4
(f #:e 10) clause-1
(f 1 #:foo) clause-1
(f 1 #:c 2) clause-2
(f #:a #:b #:c #:d #:e) clause-4

;; clause-2 will match anything that clause-3 would match.
(f 1 #:d 2) ⇒ error: bad keyword args in clause 2
</pre></div>

<p>Don’t forget that the clauses are matched in order, and the first
matching clause will be taken.  This can result in a keyword being bound
to a required argument, as in the case of <code class="code">f #:e 10</code>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Higher_002dOrder-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties" accesskey="n" rel="next">Procedure Properties and Meta-information</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda" accesskey="p" rel="prev">Case-lambda</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Higher_002dOrder-Functions-1">6.7.6 Higher-Order Functions</h4>

<a class="index-entry-id" id="index-higher_002dorder-functions"></a>

<p>As a functional programming language, Scheme allows the definition of
<em class="dfn">higher-order functions</em>, i.e., functions that take functions as
arguments and/or return functions.  Utilities to derive procedures from
other procedures are provided and described below.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-const"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">const</strong> <var class="def-var-arguments">value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-const"> ¶</a></span></dt>
<dd><p>Return a procedure that accepts any number of arguments and returns
<var class="var">value</var>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(procedure? (const 3))        ⇒ #t
((const 'hello))              ⇒ hello
((const 'hello) 'world)       ⇒ hello
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-negate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">negate</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-negate"> ¶</a></span></dt>
<dd><p>Return a procedure with the same arity as <var class="var">proc</var> that returns the
<code class="code">not</code> of <var class="var">proc</var>’s result.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(procedure? (negate number?)) ⇒ #t
((negate odd?) 2)             ⇒ #t
((negate real?) 'dream)       ⇒ #t
((negate string-prefix?) "GNU" "GNU Guile")
                              ⇒ #f
(filter (negate number?) '(a 2 "b"))
                              ⇒ (a "b")
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-compose"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">compose</strong> <var class="def-var-arguments">proc1 proc2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compose"> ¶</a></span></dt>
<dd><p>Compose <var class="var">proc1</var> with the procedures <var class="var">proc2</var> …  such that
the last <var class="var">proc</var> argument is applied first and <var class="var">proc1</var> last, and
return the resulting procedure.  The given procedures must have
compatible arity.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(procedure? (compose 1+ 1-)) ⇒ #t
((compose sqrt 1+ 1+) 2)     ⇒ 2.0
((compose 1+ sqrt) 3)        ⇒ 2.73205080756888
(eq? (compose 1+) 1+)        ⇒ #t

((compose zip unzip2) '((1 2) (a b)))
                             ⇒ ((1 2) (a b))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-identity"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">identity</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-identity"> ¶</a></span></dt>
<dd><p>Return X.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-and_003d_003e"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">and=&gt;</strong> <var class="def-var-arguments">value proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-and_003d_003e"> ¶</a></span></dt>
<dd><p>When <var class="var">value</var> is <code class="code">#f</code>, return <code class="code">#f</code>.  Otherwise, return
<code class="code">(<var class="var">proc</var> <var class="var">value</var>)</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Procedure-Properties">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters" accesskey="n" rel="next">Procedures with Setters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dOrder-Functions" accesskey="p" rel="prev">Higher-Order Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Procedure-Properties-and-Meta_002dinformation">6.7.7 Procedure Properties and Meta-information</h4>

<p>In addition to the information that is strictly necessary to run,
procedures may have other associated information. For example, the
name of a procedure is information not for the procedure, but about
the procedure. This meta-information can be accessed via the procedure
properties interface.
</p>
<p>The first group of procedures in this meta-interface are predicates to
test whether a Scheme object is a procedure, or a special procedure,
respectively.  <code class="code">procedure?</code> is the most general predicates, it
returns <code class="code">#t</code> for any kind of procedure.
</p>
<a class="index-entry-id" id="index-procedure_003f-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-procedure_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a procedure.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-thunk_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">thunk?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thunk_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fthunk_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_thunk_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fthunk_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a procedure that can be called with
zero arguments.
</p></dd></dl>

<a class="index-entry-id" id="index-procedure-properties"></a>
<p>Procedure properties are general properties associated with
procedures. These can be the name of a procedure or other relevant
information, such as debug hints.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-name</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_name</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fname"> ¶</a></span></dt>
<dd><p>Return the name of the procedure <var class="var">proc</var>
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dsource"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-source</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dsource"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fsource"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_source</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fsource"> ¶</a></span></dt>
<dd><p>Return the source of the procedure <var class="var">proc</var>. Returns <code class="code">#f</code> if
the source code is not available.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dproperties"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-properties</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dproperties"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fproperties"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_properties</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fproperties"> ¶</a></span></dt>
<dd><p>Return the properties associated with <var class="var">proc</var>, as an association
list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dproperty"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-property</strong> <var class="def-var-arguments">proc key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dproperty"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fproperty"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_property</strong> <var class="def-var-arguments">(proc, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fproperty"> ¶</a></span></dt>
<dd><p>Return the property of <var class="var">proc</var> with name <var class="var">key</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dprocedure_002dproperties_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-procedure-properties!</strong> <var class="def-var-arguments">proc alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dprocedure_002dproperties_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fprocedure_005fproperties_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_procedure_properties_x</strong> <var class="def-var-arguments">(proc, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fprocedure_005fproperties_005fx"> ¶</a></span></dt>
<dd><p>Set <var class="var">proc</var>’s property list to <var class="var">alist</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dprocedure_002dproperty_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-procedure-property!</strong> <var class="def-var-arguments">proc key value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dprocedure_002dproperty_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fprocedure_005fproperty_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_procedure_property_x</strong> <var class="def-var-arguments">(proc, key, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fprocedure_005fproperty_005fx"> ¶</a></span></dt>
<dd><p>In <var class="var">proc</var>’s property list, set the property named <var class="var">key</var> to
<var class="var">value</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-procedure-documentation"></a>
<p>Documentation for a procedure can be accessed with the procedure
<code class="code">procedure-documentation</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002ddocumentation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-documentation</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002ddocumentation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fdocumentation"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_documentation</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fdocumentation"> ¶</a></span></dt>
<dd><p>Return the documentation string associated with <code class="code">proc</code>.  By
convention, if a procedure contains more than one expression and the
first expression is a string constant, that string is assumed to contain
documentation for that procedure.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Procedures-with-Setters">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Inlinable-Procedures" accesskey="n" rel="next">Inlinable Procedures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedure-Properties" accesskey="p" rel="prev">Procedure Properties and Meta-information</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Procedures-with-Setters-1">6.7.8 Procedures with Setters</h4>



<a class="index-entry-id" id="index-procedure-with-setter"></a>
<a class="index-entry-id" id="index-setter"></a>
<p>A <em class="dfn">procedure with setter</em> is a special kind of procedure which
normally behaves like any accessor procedure, that is a procedure which
accesses a data structure.  The difference is that this kind of
procedure has a so-called <em class="dfn">setter</em> attached, which is a procedure
for storing something into a data structure.
</p>
<p>Procedures with setters are treated specially when the procedure appears
in the special form <code class="code">set!</code>. How it works is best shown by example.
</p>
<p>Suppose we have a procedure called <code class="code">foo-ref</code>, which accepts two
arguments, a value of type <code class="code">foo</code> and an integer.  The procedure
returns the value stored at the given index in the <code class="code">foo</code> object.
Let <code class="code">f</code> be a variable containing such a <code class="code">foo</code> data
structure.<a class="footnote" id="DOCF12" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT12"><sup>12</sup></a>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(foo-ref f 0)       ⇒ bar
(foo-ref f 1)       ⇒ braz
</pre></div>

<p>Also suppose that a corresponding setter procedure called
<code class="code">foo-set!</code> does exist.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(foo-set! f 0 'bla)
(foo-ref f 0)       ⇒ bla
</pre></div>

<p>Now we could create a new procedure called <code class="code">foo</code>, which is a
procedure with setter, by calling <code class="code">make-procedure-with-setter</code> with
the accessor and setter procedures <code class="code">foo-ref</code> and <code class="code">foo-set!</code>.
Let us call this new procedure <code class="code">foo</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define foo (make-procedure-with-setter foo-ref foo-set!))
</pre></div>

<p><code class="code">foo</code> can from now on be used to either read from the data
structure stored in <code class="code">f</code>, or to write into the structure.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! (foo f 0) 'dum)
(foo f 0)          ⇒ dum
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dprocedure_002dwith_002dsetter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-procedure-with-setter</strong> <var class="def-var-arguments">procedure setter</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dprocedure_002dwith_002dsetter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fprocedure_005fwith_005fsetter"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_procedure_with_setter</strong> <var class="def-var-arguments">(procedure, setter)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fprocedure_005fwith_005fsetter"> ¶</a></span></dt>
<dd><p>Create a new procedure which behaves like <var class="var">procedure</var>, but
with the associated setter <var class="var">setter</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dwith_002dsetter_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-with-setter?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dwith_002dsetter_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fwith_005fsetter_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_with_setter_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fwith_005fsetter_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a procedure with an
associated setter procedure.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure"> ¶</a></span></dt>
<dd><p>Return the procedure of <var class="var">proc</var>, which must be an
applicable struct.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setter-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setter</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setter-1"> ¶</a></span></dt>
<dd><p>Return the setter of <var class="var">proc</var>, which must be either a procedure with
setter or an operator struct.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Inlinable-Procedures">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters" accesskey="p" rel="prev">Procedures with Setters</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="u" rel="up">Procedures</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Inlinable-Procedures-1">6.7.9 Inlinable Procedures</h4>

<a class="index-entry-id" id="index-inlining"></a>
<a class="index-entry-id" id="index-procedure-inlining"></a>
<p>You can define an <em class="dfn">inlinable procedure</em> by using
<code class="code">define-inlinable</code> instead of <code class="code">define</code>.  An inlinable
procedure behaves the same as a regular procedure, but direct calls will
result in the procedure body being inlined into the caller.
</p>
<a class="index-entry-id" id="index-partial-evaluator"></a>
<p>Bear in mind that starting from version 2.0.3, Guile has a partial
evaluator that can inline the body of inner procedures when deemed
appropriate:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; ,optimize (define (foo x)
                                 (define (bar) (+ x 3))
                                 (* (bar) 2))
$1 = (define foo
       (lambda (#{x 94}#) (* (+ #{x 94}# 3) 2)))
</pre></div>

<p>The partial evaluator does not inline top-level bindings, though, so
this is a situation where you may find it interesting to use
<code class="code">define-inlinable</code>.
</p>
<p>Procedures defined with <code class="code">define-inlinable</code> are <em class="emph">always</em>
inlined, at all direct call sites.  This eliminates function call
overhead at the expense of an increase in code size.  Additionally, the
caller will not transparently use the new definition if the inline
procedure is redefined.  It is not possible to trace an inlined
procedures or install a breakpoint in it (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Traps">Traps</a>).  For these
reasons, you should not make a procedure inlinable unless it
demonstrably improves performance in a crucial way.
</p>
<p>In general, only small procedures should be considered for inlining, as
making large procedures inlinable will probably result in an increase in
code size.  Additionally, the elimination of the call overhead rarely
matters for large procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dinlinable"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-inlinable</strong> <var class="def-var-arguments">(name parameter …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dinlinable"> ¶</a></span></dt>
<dd><p>Define <var class="var">name</var> as a procedure with parameters <var class="var">parameter</var>s and
bodies <var class="var">body1</var>, <var class="var">body2</var>, <small class="enddots">...</small>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="section-level-extent" id="Macros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="n" rel="next">General Utility Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Procedures" accesskey="p" rel="prev">Procedures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Macros-1">6.8 Macros</h3>

<p>At its best, programming in Lisp is an iterative process of building up a
language appropriate to the problem at hand, and then solving the problem in
that language. Defining new procedures is part of that, but Lisp also allows
the user to extend its syntax, with its famous <em class="dfn">macros</em>.
</p>
<a class="index-entry-id" id="index-macros"></a>
<a class="index-entry-id" id="index-transformation"></a>
<p>Macros are syntactic extensions which cause the expression that they appear in
to be transformed in some way <em class="emph">before</em> being evaluated. In expressions that
are intended for macro transformation, the identifier that names the relevant
macro must appear as the first element, like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">macro-name</var> <var class="var">macro-args</var> …)
</pre></div>

<a class="index-entry-id" id="index-macro-expansion"></a>
<a class="index-entry-id" id="index-domain_002dspecific-language"></a>
<a class="index-entry-id" id="index-embedded-domain_002dspecific-language"></a>
<a class="index-entry-id" id="index-DSL"></a>
<a class="index-entry-id" id="index-EDSL"></a>
<p>Macro expansion is a separate phase of evaluation, run before code is
interpreted or compiled. A macro is a program that runs on programs, translating
an embedded language into core Scheme<a class="footnote" id="DOCF13" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT13"><sup>13</sup></a>.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Macros" accesskey="1">Defining Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules" accesskey="2">Syntax-rules Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Case" accesskey="3">Support for the <code class="code">syntax-case</code> System</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers" accesskey="4">Syntax Transformer Helpers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros" accesskey="5">Lisp-style Macro Definitions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Identifier-Macros" accesskey="6">Identifier Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Parameters" accesskey="7">Syntax Parameters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When" accesskey="8">Eval-when</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Macro-Expansion" accesskey="9">Macro Expansion</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene-and-the-Top_002dLevel">Hygiene and the Top-Level</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Macros">Internal Macros</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Defining-Macros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules" accesskey="n" rel="next">Syntax-rules Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Defining-Macros-1">6.8.1 Defining Macros</h4>

<p>A macro is a binding between a keyword and a syntax transformer. Since it’s
difficult to discuss <code class="code">define-syntax</code> without discussing the format of
transformers, consider the following example macro definition:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax when
  (syntax-rules ()
    ((when condition exp ...)
     (if condition
         (begin exp ...)))))

(when #t
  (display "hey ho\n")
  (display "let's go\n"))
-| hey ho
-| let's go
</pre></div>

<p>In this example, the <code class="code">when</code> binding is bound with <code class="code">define-syntax</code>.
Syntax transformers are discussed in more depth in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules">Syntax-rules Macros</a> and
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Case">Support for the <code class="code">syntax-case</code> System</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">define-syntax</strong> <var class="def-var-arguments">keyword transformer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dsyntax"> ¶</a></span></dt>
<dd><p>Bind <var class="var">keyword</var> to the syntax transformer obtained by evaluating
<var class="var">transformer</var>.
</p>
<p>After a macro has been defined, further instances of <var class="var">keyword</var> in Scheme
source code will invoke the syntax transformer defined by <var class="var">transformer</var>.
</p></dd></dl>

<p>One can also establish local syntactic bindings with <code class="code">let-syntax</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">let-syntax</strong> <var class="def-var-arguments">((keyword transformer) …) exp1 exp2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002dsyntax"> ¶</a></span></dt>
<dd><p>Bind each <var class="var">keyword</var> to its corresponding <var class="var">transformer</var> while
expanding <var class="var">exp1</var> <var class="var">exp2</var> <small class="enddots">...</small>.
</p>
<p>A <code class="code">let-syntax</code> binding only exists at expansion-time.
</p>
<div class="example">
<pre class="example-preformatted">(let-syntax ((unless
              (syntax-rules ()
                ((unless condition exp ...)
                 (if (not condition)
                     (begin exp ...))))))
  (unless #t
    (primitive-exit 1))
  "rock rock rock")
⇒ "rock rock rock"
</pre></div>
</dd></dl>

<p>A <code class="code">define-syntax</code> form is valid anywhere a definition may appear: at the
top-level, or locally. Just as a local <code class="code">define</code> expands out to an instance
of <code class="code">letrec</code>, a local <code class="code">define-syntax</code> expands out to
<code class="code">letrec-syntax</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-letrec_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">letrec-syntax</strong> <var class="def-var-arguments">((keyword transformer) …) exp1 exp2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-letrec_002dsyntax"> ¶</a></span></dt>
<dd><p>Bind each <var class="var">keyword</var> to its corresponding <var class="var">transformer</var> while
expanding <var class="var">exp1</var> <var class="var">exp2</var> <small class="enddots">...</small>.
</p>
<p>In the spirit of <code class="code">letrec</code> versus <code class="code">let</code>, an expansion produced by
<var class="var">transformer</var> may reference a <var class="var">keyword</var> bound by the
same <var class="var">letrec-syntax</var>.
</p>
<div class="example">
<pre class="example-preformatted">(letrec-syntax ((my-or
                 (syntax-rules ()
                   ((my-or)
                    #t)
                   ((my-or exp)
                    exp)
                   ((my-or exp rest ...)
                    (let ((t exp))
                      (if t
                          t
                          (my-or rest ...)))))))
  (my-or #f "rockaway beach"))
⇒ "rockaway beach"
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Syntax-Rules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Case" accesskey="n" rel="next">Support for the <code class="code">syntax-case</code> System</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defining-Macros" accesskey="p" rel="prev">Defining Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Syntax_002drules-Macros">6.8.2 Syntax-rules Macros</h4>

<p><code class="code">syntax-rules</code> macros are simple, pattern-driven syntax transformers, with
a beauty worthy of Scheme.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002drules"><span class="category-def">Syntax: </span><span><strong class="def-name">syntax-rules</strong> <var class="def-var-arguments">literals (pattern template) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002drules"> ¶</a></span></dt>
<dd><p>Create a syntax transformer that will rewrite an expression using the rules
embodied in the <var class="var">pattern</var> and <var class="var">template</var> clauses.
</p></dd></dl>

<p>A <code class="code">syntax-rules</code> macro consists of three parts: the literals (if any), the
patterns, and as many templates as there are patterns.
</p>
<p>When the syntax expander sees the invocation of a <code class="code">syntax-rules</code> macro, it
matches the expression against the patterns, in order, and rewrites the
expression using the template from the first matching pattern. If no pattern
matches, a syntax error is signalled.
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Patterns" accesskey="1">Patterns</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene" accesskey="2">Hygiene</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Shorthands" accesskey="3">Shorthands</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Reporting-Syntax-Errors-in-Macros" accesskey="4">Reporting Syntax Errors in Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Specifying-a-Custom-Ellipsis-Identifier" accesskey="5">Specifying a Custom Ellipsis Identifier</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Further-Information" accesskey="6">Further Information</a></li>
</ul>
<div class="subsubsection-level-extent" id="Patterns">
<h4 class="subsubsection">6.8.2.1 Patterns</h4>

<p>We have already seen some examples of patterns in the previous section:
<code class="code">(unless condition exp ...)</code>, <code class="code">(my-or exp)</code>, and so on. A pattern is
structured like the expression that it is to match. It can have nested structure
as well, like <code class="code">(let ((var val) ...) exp exp* ...)</code>. Broadly speaking,
patterns are made of lists, improper lists, vectors, identifiers, and datums.
Users can match a sequence of patterns using the ellipsis (<code class="code">...</code>).
</p>
<p>Identifiers in a pattern are called <em class="dfn">literals</em> if they are present in the
<code class="code">syntax-rules</code> literals list, and <em class="dfn">pattern variables</em> otherwise. When
building up the macro output, the expander replaces instances of a pattern
variable in the template with the matched subexpression.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax kwote
  (syntax-rules ()
    ((kwote exp)
     (quote exp))))
(kwote (foo . bar))
⇒ (foo . bar)
</pre></div>

<p>An improper list of patterns matches as rest arguments do:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax let1
  (syntax-rules ()
    ((_ (var val) . exps)
     (let ((var val)) . exps))))
</pre></div>

<p>However this definition of <code class="code">let1</code> probably isn’t what you want, as the tail
pattern <var class="var">exps</var> will match non-lists, like <code class="code">(let1 (foo 'bar) . baz)</code>. So
often instead of using improper lists as patterns, ellipsized patterns are
better. Instances of a pattern variable in the template must be followed by an
ellipsis.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax let1
  (syntax-rules ()
    ((_ (var val) exp ...)
     (let ((var val)) exp ...))))
</pre></div>

<p>This <code class="code">let1</code> probably still doesn’t do what we want, because the body
matches sequences of zero expressions, like <code class="code">(let1 (foo 'bar))</code>. In this
case we need to assert we have at least one body expression. A common idiom for
this is to name the ellipsized pattern variable with an asterisk:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax let1
  (syntax-rules ()
    ((_ (var val) exp exp* ...)
     (let ((var val)) exp exp* ...))))
</pre></div>

<p>A vector of patterns matches a vector whose contents match the patterns,
including ellipsizing and tail patterns.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax letv
  (syntax-rules ()
    ((_ #((var val) ...) exp exp* ...)
     (let ((var val) ...) exp exp* ...))))
(letv #((foo 'bar)) foo)
⇒ bar
</pre></div>

<p>Literals are used to match specific datums in an expression, like the use of
<code class="code">=&gt;</code> and <code class="code">else</code> in <code class="code">cond</code> expressions.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax cond1
  (syntax-rules (=&gt; else)
    ((cond1 test =&gt; fun)
     (let ((exp test))
       (if exp (fun exp) #f)))
    ((cond1 test exp exp* ...)
     (if test (begin exp exp* ...)))
    ((cond1 else exp exp* ...)
     (begin exp exp* ...))))

(define (square x) (* x x))
(cond1 10 =&gt; square)
⇒ 100
(let ((=&gt; #t))
  (cond1 10 =&gt; square))
⇒ #&lt;procedure square (x)&gt;
</pre></div>

<p>A literal matches an input expression if the input expression is an identifier
with the same name as the literal, and both are unbound<a class="footnote" id="DOCF14" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT14"><sup>14</sup></a>.
</p>
<a class="index-entry-id" id="index-auxiliary-syntax"></a>
<a class="index-entry-id" id="index-syntax_002c-auxiliary"></a>
<p>Although literals can be unbound, usually they are bound to allow them
to be imported, exported, and renamed.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Modules">Modules</a>, for more
information on imports and exports.  In Guile there are a few standard
auxiliary syntax definitions, as specified by R6RS and R7RS:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-else"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">else</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-else"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_003d_003e"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">=&gt;</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_003d_003e"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_005f"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">_</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_005f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_002e_002e_002e"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">...</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002e_002e_002e"> ¶</a></span></dt>
<dd><p>Auxiliary syntax definitions.
</p>
<p>These are defined as if with a macro that never matches, e.g.:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax else (syntax-rules ()))
</pre></div>
</dd></dl>

<p>If a pattern is not a list, vector, or an identifier, it matches as a literal,
with <code class="code">equal?</code>.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax define-matcher-macro
  (syntax-rules ()
    ((_ name lit)
     (define-syntax name
       (syntax-rules ()
        ((_ lit) #t)
        ((_ else) #f))))))

(define-matcher-macro is-literal-foo? "foo")

(is-literal-foo? "foo")
⇒ #t
(is-literal-foo? "bar")
⇒ #f
(let ((foo "foo"))
  (is-literal-foo? foo))
⇒ #f
</pre></div>

<p>The last example indicates that matching happens at expansion-time, not
at run-time.
</p>
<p>Syntax-rules macros are always used as <code class="code">(<var class="var">macro</var> . <var class="var">args</var>)</code>, and
the <var class="var">macro</var> will always be a symbol. Correspondingly, a <code class="code">syntax-rules</code>
pattern must be a list (proper or improper), and the first pattern in that list
must be an identifier. Incidentally it can be any identifier – it doesn’t have
to actually be the name of the macro. Thus the following three are equivalent:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax when
  (syntax-rules ()
    ((when c e ...)
     (if c (begin e ...)))))

(define-syntax when
  (syntax-rules ()
    ((_ c e ...)
     (if c (begin e ...)))))

(define-syntax when
  (syntax-rules ()
    ((something-else-entirely c e ...)
     (if c (begin e ...)))))
</pre></div>

<p>For clarity, use one of the first two variants. Also note that since the pattern
variable will always match the macro itself (e.g., <code class="code">cond1</code>), it is actually
left unbound in the template.
</p>
</div>
<div class="subsubsection-level-extent" id="Hygiene">
<h4 class="subsubsection">6.8.2.2 Hygiene</h4>

<p><code class="code">syntax-rules</code> macros have a magical property: they preserve referential
transparency. When you read a macro definition, any free bindings in that macro
are resolved relative to the macro definition; and when you read a macro
instantiation, all free bindings in that expression are resolved relative to the
expression.
</p>
<p>This property is sometimes known as <em class="dfn">hygiene</em>, and it does aid in code
cleanliness. In your macro definitions, you can feel free to introduce temporary
variables, without worrying about inadvertently introducing bindings into the
macro expansion.
</p>
<p>Consider the definition of <code class="code">my-or</code> from the previous section:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax my-or
  (syntax-rules ()
    ((my-or)
     #t)
    ((my-or exp)
     exp)
    ((my-or exp rest ...)
     (let ((t exp))
       (if t
           t
           (my-or rest ...))))))
</pre></div>

<p>A naive expansion of <code class="code">(let ((t #t)) (my-or #f t))</code> would yield:
</p>
<div class="example">
<pre class="example-preformatted">(let ((t #t))
  (let ((t #f))
    (if t t t)))
⇒ #f
</pre></div>

<p>Which clearly is not what we want. Somehow the <code class="code">t</code> in the definition is
distinct from the <code class="code">t</code> at the site of use; and it is indeed this distinction
that is maintained by the syntax expander, when expanding hygienic macros.
</p>
<p>This discussion is mostly relevant in the context of traditional Lisp macros
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros">Lisp-style Macro Definitions</a>), which do not preserve referential transparency. Hygiene
adds to the expressive power of Scheme.
</p>
</div>
<div class="subsubsection-level-extent" id="Shorthands">
<h4 class="subsubsection">6.8.2.3 Shorthands</h4>

<p>One often ends up writing simple one-clause <code class="code">syntax-rules</code> macros.
There is a convenient shorthand for this idiom, in the form of
<code class="code">define-syntax-rule</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dsyntax_002drule"><span class="category-def">Syntax: </span><span><strong class="def-name">define-syntax-rule</strong> <var class="def-var-arguments">(keyword . pattern) [docstring] template</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dsyntax_002drule"> ¶</a></span></dt>
<dd><p>Define <var class="var">keyword</var> as a new <code class="code">syntax-rules</code> macro with one clause.
</p></dd></dl>

<p>Cast into this form, our <code class="code">when</code> example is significantly shorter:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax-rule (when c e ...)
  (if c (begin e ...)))
</pre></div>

</div>
<div class="subsubsection-level-extent" id="Reporting-Syntax-Errors-in-Macros">
<h4 class="subsubsection">6.8.2.4 Reporting Syntax Errors in Macros</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002derror"><span class="category-def">Syntax: </span><span><strong class="def-name">syntax-error</strong> <var class="def-var-arguments">message [arg ...]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002derror"> ¶</a></span></dt>
<dd><p>Report an error at macro-expansion time.  <var class="var">message</var> must be a string
literal, and the optional <var class="var">arg</var> operands can be arbitrary expressions
providing additional information.
</p></dd></dl>

<p><code class="code">syntax-error</code> is intended to be used within <code class="code">syntax-rules</code>
templates.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax simple-let
  (syntax-rules ()
    ((_ (head ... ((x . y) val) . tail)
        body1 body2 ...)
     (syntax-error
      "expected an identifier but got"
      (x . y)))
    ((_ ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))))
</pre></div>

</div>
<div class="subsubsection-level-extent" id="Specifying-a-Custom-Ellipsis-Identifier">
<h4 class="subsubsection">6.8.2.5 Specifying a Custom Ellipsis Identifier</h4>

<p>When writing macros that generate macro definitions, it is convenient to
use a different ellipsis identifier at each level.  Guile allows the
desired ellipsis identifier to be specified as the first operand to
<code class="code">syntax-rules</code>, as specified by SRFI-46 and R7RS.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax define-quotation-macros
  (syntax-rules ()
    ((_ (macro-name head-symbol) ...)
     (begin (define-syntax macro-name
              (syntax-rules ::: ()
                ((_ x :::)
                 (quote (head-symbol x :::)))))
            ...))))
(define-quotation-macros (quote-a a) (quote-b b) (quote-c c))
(quote-a 1 2 3) ⇒ (a 1 2 3)
</pre></div>

</div>
<div class="subsubsection-level-extent" id="Further-Information">
<h4 class="subsubsection">6.8.2.6 Further Information</h4>

<p>For a formal definition of <code class="code">syntax-rules</code> and its pattern language, see
See <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Macros">Macros</a> in <cite class="cite">Revised(5) Report on the Algorithmic Language
Scheme</cite>.
</p>
<p><code class="code">syntax-rules</code> macros are simple and clean, but do they have limitations.
They do not lend themselves to expressive error messages: patterns either match
or they don’t. Their ability to generate code is limited to template-driven
expansion; often one needs to define a number of helper macros to get real work
done. Sometimes one wants to introduce a binding into the lexical context of the
generated code; this is impossible with <code class="code">syntax-rules</code>. Relatedly, they
cannot programmatically generate identifiers.
</p>
<p>The solution to all of these problems is to use <code class="code">syntax-case</code> if you need
its features. But if for some reason you’re stuck with <code class="code">syntax-rules</code>, you
might enjoy Joe Marshall’s
<a class="uref" href="http://sites.google.com/site/evalapply/eccentric.txt"><code class="code">syntax-rules</code>
Primer for the Merely Eccentric</a>.
</p>
<hr>
</div>
</div>
<div class="subsection-level-extent" id="Syntax-Case">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers" accesskey="n" rel="next">Syntax Transformer Helpers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules" accesskey="p" rel="prev">Syntax-rules Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Support-for-the-syntax_002dcase-System">6.8.3 Support for the <code class="code">syntax-case</code> System</h4>

<p><code class="code">syntax-case</code> macros are procedural syntax transformers, with a power
worthy of Scheme.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dcase"><span class="category-def">Syntax: </span><span><strong class="def-name">syntax-case</strong> <var class="def-var-arguments">syntax literals (pattern [guard] exp) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dcase"> ¶</a></span></dt>
<dd><p>Match the syntax object <var class="var">syntax</var> against the given patterns, in order. If a
<var class="var">pattern</var> matches, return the result of evaluating the associated <var class="var">exp</var>.
</p></dd></dl>

<p>Compare the following definitions of <code class="code">when</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax when
  (syntax-rules ()
    ((_ test e e* ...)
     (if test (begin e e* ...)))))

(define-syntax when
  (lambda (x)
    (syntax-case x ()
      ((_ test e e* ...)
       #'(if test (begin e e* ...))))))
</pre></div>

<p>Clearly, the <code class="code">syntax-case</code> definition is similar to its <code class="code">syntax-rules</code>
counterpart, and equally clearly there are some differences. The
<code class="code">syntax-case</code> definition is wrapped in a <code class="code">lambda</code>, a function of one
argument; that argument is passed to the <code class="code">syntax-case</code> invocation; and the
“return value” of the macro has a <code class="code">#'</code> prefix.
</p>
<p>All of these differences stem from the fact that <code class="code">syntax-case</code> does not
define a syntax transformer itself – instead, <code class="code">syntax-case</code> expressions
provide a way to destructure a <em class="dfn">syntax object</em>, and to rebuild syntax
objects as output.
</p>
<p>So the <code class="code">lambda</code> wrapper is simply a leaky implementation detail, that
syntax transformers are just functions that transform syntax to syntax. This
should not be surprising, given that we have already described macros as
“programs that write programs”. <code class="code">syntax-case</code> is simply a way to take
apart and put together program text, and to be a valid syntax transformer it
needs to be wrapped in a procedure.
</p>
<p>Unlike traditional Lisp macros (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros">Lisp-style Macro Definitions</a>), <code class="code">syntax-case</code> macros
transform syntax objects, not raw Scheme forms. Recall the naive expansion of
<code class="code">my-or</code> given in the previous section:
</p>
<div class="example">
<pre class="example-preformatted">(let ((t #t))
  (my-or #f t))
;; naive expansion:
(let ((t #t))
  (let ((t #f))
    (if t t t)))
</pre></div>

<p>Raw Scheme forms simply don’t have enough information to distinguish the first
two <code class="code">t</code> instances in <code class="code">(if t t t)</code> from the third <code class="code">t</code>. So instead
of representing identifiers as symbols, the syntax expander represents
identifiers as annotated syntax objects, attaching such information to those
syntax objects as is needed to maintain referential transparency.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-syntax"><span class="category-def">Syntax: </span><span><strong class="def-name">syntax</strong> <var class="def-var-arguments">form</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax"> ¶</a></span></dt>
<dd><p>Create a syntax object wrapping <var class="var">form</var> within the current lexical context.
</p></dd></dl>

<p>Syntax objects are typically created internally to the process of expansion, but
it is possible to create them outside of syntax expansion:
</p>
<div class="example">
<pre class="example-preformatted">(syntax (foo bar baz))
⇒ #&lt;some representation of that syntax&gt;
</pre></div>

<p>However it is more common, and useful, to create syntax objects when building
output from a <code class="code">syntax-case</code> expression.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax add1
  (lambda (x)
    (syntax-case x ()
      ((_ exp)
       (syntax (+ exp 1))))))
</pre></div>

<p>It is not strictly necessary for a <code class="code">syntax-case</code> expression to return a
syntax object, because <code class="code">syntax-case</code> expressions can be used in helper
functions, or otherwise used outside of syntax expansion itself. However a
syntax transformer procedure must return a syntax object, so most uses of
<code class="code">syntax-case</code> do end up returning syntax objects.
</p>
<p>Here in this case, the form that built the return value was <code class="code">(syntax (+ exp
1))</code>. The interesting thing about this is that within a <code class="code">syntax</code>
expression, any appearance of a pattern variable is substituted into the
resulting syntax object, carrying with it all relevant metadata from the source
expression, such as lexical identity and source location.
</p>
<p>Indeed, a pattern variable may only be referenced from inside a <code class="code">syntax</code>
form. The syntax expander would raise an error when defining <code class="code">add1</code> if it
found <var class="var">exp</var> referenced outside a <code class="code">syntax</code> form.
</p>
<p>Since <code class="code">syntax</code> appears frequently in macro-heavy code, it has a special
reader macro: <code class="code">#'</code>. <code class="code">#'foo</code> is transformed by the reader into
<code class="code">(syntax foo)</code>, just as <code class="code">'foo</code> is transformed into <code class="code">(quote foo)</code>.
</p>
<p>The pattern language used by <code class="code">syntax-case</code> is conveniently the same
language used by <code class="code">syntax-rules</code>. Given this, Guile actually defines
<code class="code">syntax-rules</code> in terms of <code class="code">syntax-case</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      ((_ (k ...) ((keyword . pattern) template) ...)
       #'(lambda (x)
           (syntax-case x (k ...)
             ((dummy . pattern) #'template)
             ...))))))
</pre></div>

<p>And that’s that.
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Why-syntax_002dcase_003f" accesskey="1">Why <code class="code">syntax-case</code>?</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ellipsis-Identifiers-for-syntax_002dcase-Macros" accesskey="2">Custom Ellipsis Identifiers for syntax-case Macros</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-objects-can-be-data-too" accesskey="3">Syntax objects can be data too</a></li>
</ul>
<div class="subsubsection-level-extent" id="Why-syntax_002dcase_003f">
<h4 class="subsubsection">6.8.3.1 Why <code class="code">syntax-case</code>?</h4>

<p>The examples we have shown thus far could just as well have been expressed with
<code class="code">syntax-rules</code>, and have just shown that <code class="code">syntax-case</code> is more
verbose, which is true. But there is a difference: <code class="code">syntax-case</code> creates
<em class="emph">procedural</em> macros, giving the full power of Scheme to the macro expander.
This has many practical applications.
</p>
<p>A common desire is to be able to match a form only if it is an identifier. This
is impossible with <code class="code">syntax-rules</code>, given the datum matching forms. But with
<code class="code">syntax-case</code> it is easy:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-identifier_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">identifier?</strong> <var class="def-var-arguments">syntax-object</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-identifier_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">syntax-object</var> is an identifier, or <code class="code">#f</code>
otherwise.
</p></dd></dl>

<div class="example">
<pre class="example-preformatted">;; relying on previous add1 definition
(define-syntax add1!
  (lambda (x)
    (syntax-case x ()
      ((_ var) (identifier? #'var)
       #'(set! var (add1 var))))))

(define foo 0)
(add1! foo)
foo ⇒ 1
(add1! "not-an-identifier") ⇒ error
</pre></div>

<p>With <code class="code">syntax-rules</code>, the error for <code class="code">(add1! "not-an-identifier")</code> would
be something like “invalid <code class="code">set!</code>”. With <code class="code">syntax-case</code>, it will say
something like “invalid <code class="code">add1!</code>”, because we attach the <em class="dfn">guard
clause</em> to the pattern: <code class="code">(identifier? #'var)</code>. This becomes more important
with more complicated macros. It is necessary to use <code class="code">identifier?</code>, because
to the expander, an identifier is more than a bare symbol.
</p>
<p>Note that even in the guard clause, we reference the <var class="var">var</var> pattern variable
within a <code class="code">syntax</code> form, via <code class="code">#'var</code>.
</p>
<p>Another common desire is to introduce bindings into the lexical context of the
output expression. One example would be in the so-called “anaphoric macros”,
like <code class="code">aif</code>. Anaphoric macros bind some expression to a well-known
identifier, often <code class="code">it</code>, within their bodies. For example, in <code class="code">(aif
(foo) (bar it))</code>, <code class="code">it</code> would be bound to the result of <code class="code">(foo)</code>.
</p>
<p>To begin with, we should mention a solution that doesn’t work:
</p>
<div class="example">
<pre class="example-preformatted">;; doesn't work
(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((_ test then else)
       #'(let ((it test))
           (if it then else))))))
</pre></div>

<p>The reason that this doesn’t work is that, by default, the expander will
preserve referential transparency; the <var class="var">then</var> and <var class="var">else</var> expressions
won’t have access to the binding of <code class="code">it</code>.
</p>
<p>But they can, if we explicitly introduce a binding via <code class="code">datum-&gt;syntax</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-datum_002d_003esyntax"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">datum-&gt;syntax</strong> <var class="def-var-arguments">template-id datum [#:source=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-datum_002d_003esyntax"> ¶</a></span></dt>
<dd><p>Create a syntax object that wraps <var class="var">datum</var>, within the lexical
context corresponding to the identifier <var class="var">template-id</var>.  If
<var class="var">template-id</var> is false, the datum will have no lexical context
information.
</p>
<p>Syntax objects have an associated source location.  Internally this is
represented as a 3-element vector of filename, line, and column.
Usually this location ultimately is provided by <code class="code">read-syntax</code>;
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read">Reading Scheme Code, For the Compiler</a>.
</p>
<p>If a syntax object is passed as <var class="var">source</var>, the resulting syntax
object will have the source location of <var class="var">source</var>.  Otherwise if
<var class="var">source</var> is a 3-element source location vector, that vector will be
the source location of the resulting syntax object.  If <var class="var">source</var> is
a source properties alist, those will be parsed and set as the source
location of the resulting syntax object.  Otherwise if <var class="var">source</var> is
false, the source properties are looked up from <code class="code">(source-properties
<var class="var">datum</var>)</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties">Source Properties</a>.
</p></dd></dl>

<p>For completeness, we should mention that it is possible to strip the metadata
from a syntax object, returning a raw Scheme datum:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002d_003edatum"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-&gt;datum</strong> <var class="def-var-arguments">syntax-object</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002d_003edatum"> ¶</a></span></dt>
<dd><p>Strip the metadata from <var class="var">syntax-object</var>, returning its contents as a raw
Scheme datum.
</p></dd></dl>

<p>In this case we want to introduce <code class="code">it</code> in the context of the whole
expression, so we can create a syntax object as <code class="code">(datum-&gt;syntax x 'it)</code>,
where <code class="code">x</code> is the whole expression, as passed to the transformer procedure.
</p>
<p>Here’s another solution that doesn’t work:
</p>
<div class="example">
<pre class="example-preformatted">;; doesn't work either
(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((_ test then else)
       (let ((it (datum-&gt;syntax x 'it)))
         #'(let ((it test))
             (if it then else)))))))
</pre></div>

<p>The reason that this one doesn’t work is that there are really two
environments at work here – the environment of pattern variables, as
bound by <code class="code">syntax-case</code>, and the environment of lexical variables,
as bound by normal Scheme. The outer let form establishes a binding in
the environment of lexical variables, but the inner let form is inside a
syntax form, where only pattern variables will be substituted. Here we
need to introduce a piece of the lexical environment into the pattern
variable environment, and we can do so using <code class="code">syntax-case</code> itself:
</p>
<div class="example">
<pre class="example-preformatted">;; works, but is obtuse
(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((_ test then else)
       ;; invoking syntax-case on the generated
       ;; syntax object to expose it to `syntax'
       (syntax-case (datum-&gt;syntax x 'it) ()
         (it
           #'(let ((it test))
               (if it then else))))))))

(aif (getuid) (display it) (display "none")) (newline)
-| 500
</pre></div>

<p>However there are easier ways to write this. <code class="code">with-syntax</code> is often
convenient:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">with-syntax</strong> <var class="def-var-arguments">((pat val) …) exp …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dsyntax"> ¶</a></span></dt>
<dd><p>Bind patterns <var class="var">pat</var> from their corresponding values <var class="var">val</var>, within the
lexical context of <var class="var">exp</var> <small class="enddots">...</small>.
</p>
<div class="example">
<pre class="example-preformatted">;; better
(define-syntax aif
  (lambda (x)
    (syntax-case x ()
      ((_ test then else)
       (with-syntax ((it (datum-&gt;syntax x 'it)))
         #'(let ((it test))
             (if it then else)))))))
</pre></div>
</dd></dl>

<p>As you might imagine, <code class="code">with-syntax</code> is defined in terms of
<code class="code">syntax-case</code>. But even that might be off-putting to you if you are an old
Lisp macro hacker, used to building macro output with <code class="code">quasiquote</code>. The
issue is that <code class="code">with-syntax</code> creates a separation between the point of
definition of a value and its point of substitution.
</p>
<a class="index-entry-id" id="index-quasisyntax-1"></a>
<a class="index-entry-id" id="index-unsyntax-1"></a>
<a class="index-entry-id" id="index-unsyntax_002dsplicing-1"></a>
<p>So for cases in which a <code class="code">quasiquote</code> style makes more sense,
<code class="code">syntax-case</code> also defines <code class="code">quasisyntax</code>, and the related
<code class="code">unsyntax</code> and <code class="code">unsyntax-splicing</code>, abbreviated by the reader as
<code class="code">#`</code>, <code class="code">#,</code>, and <code class="code">#,@</code>, respectively.
</p>
<p>For example, to define a macro that inserts a compile-time timestamp into a
source file, one may write:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax display-compile-timestamp
  (lambda (x)
    (syntax-case x ()
      ((_)
       #`(begin
          (display "The compile timestamp was: ")
          (display #,(current-time))
          (newline))))))
</pre></div>

<p>Readers interested in further information on <code class="code">syntax-case</code> macros should
see R. Kent Dybvig’s excellent <cite class="cite">The Scheme Programming Language</cite>, either
edition 3 or 4, in the chapter on syntax. Dybvig was the primary author of the
<code class="code">syntax-case</code> system. The book itself is available online at
<a class="uref" href="http://scheme.com/tspl4/">http://scheme.com/tspl4/</a>.
</p>
</div>
<div class="subsubsection-level-extent" id="Custom-Ellipsis-Identifiers-for-syntax_002dcase-Macros">
<h4 class="subsubsection">6.8.3.2 Custom Ellipsis Identifiers for syntax-case Macros</h4>

<p>When writing procedural macros that generate macro definitions, it is
convenient to use a different ellipsis identifier at each level.  Guile
supports this for procedural macros using the <code class="code">with-ellipsis</code>
special form:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dellipsis"><span class="category-def">Syntax: </span><span><strong class="def-name">with-ellipsis</strong> <var class="def-var-arguments">ellipsis body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dellipsis"> ¶</a></span></dt>
<dd><p><var class="var">ellipsis</var> must be an identifier.  Evaluate <var class="var">body</var> in a special
lexical environment such that all macro patterns and templates within
<var class="var">body</var> will use <var class="var">ellipsis</var> as the ellipsis identifier instead of
the usual three dots (<code class="code">...</code>).
</p></dd></dl>

<p>For example:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax define-quotation-macros
  (lambda (x)
    (syntax-case x ()
      ((_ (macro-name head-symbol) ...)
       #'(begin (define-syntax macro-name
                  (lambda (x)
                    (with-ellipsis :::
                      (syntax-case x ()
                        ((_ x :::)
                         #'(quote (head-symbol x :::)))))))
                ...)))))
(define-quotation-macros (quote-a a) (quote-b b) (quote-c c))
(quote-a 1 2 3) ⇒ (a 1 2 3)
</pre></div>

<p>Note that <code class="code">with-ellipsis</code> does not affect the ellipsis identifier
of the generated code, unless <code class="code">with-ellipsis</code> is included around
the generated code.
</p>
</div>
<div class="subsubsection-level-extent" id="Syntax-objects-can-be-data-too">
<h4 class="subsubsection">6.8.3.3 Syntax objects can be data too</h4>

<p>Generally speaking, you want the macro expander to pick apart all syntax
objects in a source term.  The source and scope annotations attached to
the syntax object are of interest to how the macro expander computes the
result, but no syntax object itself should appear in the expanded
term—usually.  Sometimes, though, a macro will want a syntax object to
appear in the expanded output.  Normally you would just use <code class="code">quote</code>
to introduce the syntax object as a value, but the expander strips
syntax objects from subexpression of <code class="code">quote</code>.  For this rare use
case, Guile has <code class="code">quote-syntax</code>, which does not strip its
subexpression.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-quote_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">quote-syntax</strong> <var class="def-var-arguments">form</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quote_002dsyntax"> ¶</a></span></dt>
<dd><p>Expand to the syntax object <code class="code">form</code>, as a constant literal.  Like
<code class="code">quote</code>, but without calling <code class="code">syntax-&gt;datum</code>.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Syntax-Transformer-Helpers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros" accesskey="n" rel="next">Lisp-style Macro Definitions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Case" accesskey="p" rel="prev">Support for the <code class="code">syntax-case</code> System</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Syntax-Transformer-Helpers-1">6.8.4 Syntax Transformer Helpers</h4>

<p>As noted in the previous section, Guile’s syntax expander operates on
syntax objects.  Procedural macros consume and produce syntax objects.
This section describes some of the auxiliary helpers that procedural
macros can use to compare, generate, and query objects of this data
type.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-bound_002didentifier_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bound-identifier=?</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bound_002didentifier_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the syntax objects <var class="var">a</var> and <var class="var">b</var> refer to the
same lexically-bound identifier, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-free_002didentifier_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">free-identifier=?</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-free_002didentifier_003d_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the syntax objects <var class="var">a</var> and <var class="var">b</var> refer to the
same free identifier, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-generate_002dtemporaries"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">generate-temporaries</strong> <var class="def-var-arguments">ls</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-generate_002dtemporaries"> ¶</a></span></dt>
<dd><p>Return a list of temporary identifiers as long as <var class="var">ls</var> is long.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dsource"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-source</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dsource"> ¶</a></span></dt>
<dd><p>Return the source properties that correspond to the syntax object
<var class="var">x</var>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties">Source Properties</a>, for more information.
</p></dd></dl>

<p>Guile also offers some more experimental interfaces in a separate
module.  As was the case with the Large Hadron Collider, it is unclear
to our senior macrologists whether adding these interfaces will result
in awesomeness or in the destruction of Guile via the creation of a
singularity.  We will preserve their functionality through the 2.0
series, but we reserve the right to modify them in a future stable
series, to a more than usual degree.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system syntax))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-module</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dmodule"> ¶</a></span></dt>
<dd><p>Return the name of the module whose source contains the identifier
<var class="var">id</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dsourcev"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-sourcev</strong> <var class="def-var-arguments">stx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dsourcev"> ¶</a></span></dt>
<dd><p>Like <code class="code">syntax-source</code>, but returns its result in a more compact
<code class="code">#(<var class="var">filename</var> <var class="var">line</var> <var class="var">column</var>)</code> format.  This format is
used as the internal representation of source locations for syntax
objects.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dlocal_002dbinding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-local-binding</strong> <var class="def-var-arguments">id [#:resolve-syntax-parameters?=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dlocal_002dbinding"> ¶</a></span></dt>
<dd><p>Resolve the identifer <var class="var">id</var>, a syntax object, within the current
lexical environment, and return two values, the binding type and a
binding value.  The binding type is a symbol, which may be one of the
following:
</p>
<dl class="table">
<dt><code class="code">lexical</code></dt>
<dd><p>A lexically-bound variable.  The value is a unique token (in the sense
of <code class="code">eq?</code>) identifying this binding.
</p></dd>
<dt><code class="code">macro</code></dt>
<dd><p>A syntax transformer, either local or global.  The value is the
transformer procedure.
</p></dd>
<dt><code class="code">syntax-parameter</code></dt>
<dd><p>A syntax parameter (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Parameters">Syntax Parameters</a>).  By default,
<code class="code">syntax-local-binding</code> will resolve syntax parameters, so that this
value will not be returned.  Pass <code class="code">#:resolve-syntax-parameters? #f</code>
to indicate that you are interested in syntax parameters.  The value is
the default transformer procedure, as in <code class="code">macro</code>.
</p></dd>
<dt><code class="code">pattern-variable</code></dt>
<dd><p>A pattern variable, bound via <code class="code">syntax-case</code>.  The value is an
opaque object, internal to the expander.
</p></dd>
<dt><code class="code">ellipsis</code></dt>
<dd><p>An internal binding, bound via <code class="code">with-ellipsis</code>.  The value is the
(anti-marked) local ellipsis identifier.
</p></dd>
<dt><code class="code">displaced-lexical</code></dt>
<dd><p>A lexical variable that has gone out of scope.  This can happen if a
badly-written procedural macro saves a syntax object, then attempts to
introduce it in a context in which it is unbound.  The value is
<code class="code">#f</code>.
</p></dd>
<dt><code class="code">global</code></dt>
<dd><p>A global binding.  The value is a pair, whose head is the symbol, and
whose tail is the name of the module in which to resolve the symbol.
</p></dd>
<dt><code class="code">other</code></dt>
<dd><p>Some other binding, like <code class="code">lambda</code> or other core bindings.  The
value is <code class="code">#f</code>.
</p></dd>
</dl>

<p>This is a very low-level procedure, with limited uses.  One case in
which it is useful is to build abstractions that associate auxiliary
information with macros:
</p>
<div class="example">
<pre class="example-preformatted">(define aux-property (make-object-property))
(define-syntax-rule (with-aux aux value)
  (let ((trans value))
    (set! (aux-property trans) aux)
    trans))
(define-syntax retrieve-aux
  (lambda (x)
    (syntax-case x ()
      ((x id)
       (call-with-values (lambda () (syntax-local-binding #'id))
         (lambda (type val)
           (with-syntax ((aux (datum-&gt;syntax #'here
                                             (and (eq? type 'macro)
                                                  (aux-property val)))))
             #''aux)))))))
(define-syntax foo
  (with-aux 'bar
    (syntax-rules () ((_) 'foo))))
(foo)
⇒ foo
(retrieve-aux foo)
⇒ bar
</pre></div>

<p><code class="code">syntax-local-binding</code> must be called within the dynamic extent of
a syntax transformer; to call it otherwise will signal an error.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dlocally_002dbound_002didentifiers"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-locally-bound-identifiers</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dlocally_002dbound_002didentifiers"> ¶</a></span></dt>
<dd><p>Return a list of identifiers that were visible lexically when the
identifier <var class="var">id</var> was created, in order from outermost to innermost.
</p>
<p>This procedure is intended to be used in specialized procedural macros,
to provide a macro with the set of bound identifiers that the macro can
reference.
</p>
<p>As a technical implementation detail, the identifiers returned by
<code class="code">syntax-locally-bound-identifiers</code> will be anti-marked, like the
syntax object that is given as input to a macro.  This is to signal to
the macro expander that these bindings were present in the original
source, and do not need to be hygienically renamed, as would be the case
with other introduced identifiers.  See the discussion of hygiene in
section 12.1 of the R6RS, for more information on marks.
</p>
<div class="example">
<pre class="example-preformatted">(define (local-lexicals id)
  (filter (lambda (x)
            (eq? (syntax-local-binding x) 'lexical))
          (syntax-locally-bound-identifiers id)))
(define-syntax lexicals
  (lambda (x)
    (syntax-case x ()
      ((lexicals) #'(lexicals lexicals))
      ((lexicals scope)
       (with-syntax (((id ...) (local-lexicals #'scope)))
         #'(list (cons 'id id) ...))))))

(let* ((x 10) (x 20)) (lexicals))
⇒ ((x . 10) (x . 20))
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Defmacros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Identifier-Macros" accesskey="n" rel="next">Identifier Macros</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers" accesskey="p" rel="prev">Syntax Transformer Helpers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Lisp_002dstyle-Macro-Definitions">6.8.5 Lisp-style Macro Definitions</h4>

<p>The traditional way to define macros in Lisp is very similar to procedure
definitions. The key differences are that the macro definition body should
return a list that describes the transformed expression, and that the definition
is marked as a macro definition (rather than a procedure definition) by the use
of a different definition keyword: in Lisp, <code class="code">defmacro</code> rather than
<code class="code">defun</code>, and in Scheme, <code class="code">define-macro</code> rather than <code class="code">define</code>.
</p>
<a class="index-entry-id" id="index-defmacro"></a>
<a class="index-entry-id" id="index-define_002dmacro"></a>
<p>Guile supports this style of macro definition using both <code class="code">defmacro</code>
and <code class="code">define-macro</code>.  The only difference between them is how the
macro name and arguments are grouped together in the definition:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defmacro <var class="var">name</var> (<var class="var">args</var> …) <var class="var">body</var> …)
</pre></div>

<p>is the same as
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-macro (<var class="var">name</var> <var class="var">args</var> …) <var class="var">body</var> …)
</pre></div>

<p>The difference is analogous to the corresponding difference between
Lisp’s <code class="code">defun</code> and Scheme’s <code class="code">define</code>.
</p>
<p>Having read the previous section on <code class="code">syntax-case</code>, it’s probably clear that
Guile actually implements defmacros in terms of <code class="code">syntax-case</code>, applying the
transformer on the expression between invocations of <code class="code">syntax-&gt;datum</code> and
<code class="code">datum-&gt;syntax</code>. This realization leads us to the problem with defmacros,
that they do not preserve referential transparency. One can be careful to not
introduce bindings into expanded code, via liberal use of <code class="code">gensym</code>, but
there is no getting around the lack of referential transparency for free
bindings in the macro itself.
</p>
<p>Even a macro as simple as our <code class="code">when</code> from before is difficult to get right:
</p>
<div class="example">
<pre class="example-preformatted">(define-macro (when cond exp . rest)
  `(if ,cond
       (begin ,exp . ,rest)))

(when #f (display "Launching missiles!\n"))
⇒ #f

(let ((if list))
  (when #f (display "Launching missiles!\n")))
-| Launching missiles!
⇒ (#f #&lt;unspecified&gt;)
</pre></div>

<p>Guile’s perspective is that defmacros have had a good run, but that modern
macros should be written with <code class="code">syntax-rules</code> or <code class="code">syntax-case</code>. There
are still many uses of defmacros within Guile itself, but we will be phasing
them out over time. Of course we won’t take away <code class="code">defmacro</code> or
<code class="code">define-macro</code> themselves, as there is lots of code out there that uses
them.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Identifier-Macros">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Parameters" accesskey="n" rel="next">Syntax Parameters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros" accesskey="p" rel="prev">Lisp-style Macro Definitions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Identifier-Macros-1">6.8.6 Identifier Macros</h4>

<p>When the syntax expander sees a form in which the first element is a macro, the
whole form gets passed to the macro’s syntax transformer. One may visualize this
as:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax foo foo-transformer)
(foo <var class="var">arg</var>...)
;; expands via
(foo-transformer #'(foo <var class="var">arg</var>...))
</pre></div>

<p>If, on the other hand, a macro is referenced in some other part of a form, the
syntax transformer is invoked with only the macro reference, not the whole form.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax foo foo-transformer)
foo
;; expands via
(foo-transformer #'foo)
</pre></div>

<p>This allows bare identifier references to be replaced programmatically via a
macro. <code class="code">syntax-rules</code> provides some syntax to effect this transformation
more easily.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-identifier_002dsyntax"><span class="category-def">Syntax: </span><span><strong class="def-name">identifier-syntax</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-identifier_002dsyntax"> ¶</a></span></dt>
<dd><p>Returns a macro transformer that will replace occurrences of the macro with
<var class="var">exp</var>.
</p></dd></dl>

<p>For example, if you are importing external code written in terms of <code class="code">fx+</code>,
the fixnum addition operator, but Guile doesn’t have <code class="code">fx+</code>, you may use the
following to replace <code class="code">fx+</code> with <code class="code">+</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax fx+ (identifier-syntax +))
</pre></div>

<p>There is also special support for recognizing identifiers on the
left-hand side of a <code class="code">set!</code> expression, as in the following:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax foo foo-transformer)
(set! foo <var class="var">val</var>)
;; expands via
(foo-transformer #'(set! foo <var class="var">val</var>))
;; if foo-transformer is a "variable transformer"
</pre></div>

<p>As the example notes, the transformer procedure must be explicitly
marked as being a “variable transformer”, as most macros aren’t
written to discriminate on the form in the operator position.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dvariable_002dtransformer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-variable-transformer</strong> <var class="def-var-arguments">transformer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dvariable_002dtransformer"> ¶</a></span></dt>
<dd><p>Mark the <var class="var">transformer</var> procedure as being a “variable
transformer”. In practice this means that, when bound to a syntactic
keyword, it may detect references to that keyword on the left-hand-side
of a <code class="code">set!</code>.
</p>
<div class="example">
<pre class="example-preformatted">(define bar 10)
(define-syntax bar-alias
  (make-variable-transformer
   (lambda (x)
     (syntax-case x (set!)
       ((set! var val) #'(set! bar val))
       ((var arg ...) #'(bar arg ...))
       (var (identifier? #'var) #'bar)))))

bar-alias ⇒ 10
(set! bar-alias 20)
bar ⇒ 20
(set! bar 30)
bar-alias ⇒ 30
</pre></div>
</dd></dl>

<p>There is an extension to identifier-syntax which allows it to handle the
<code class="code">set!</code> case as well:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-identifier_002dsyntax-1"><span class="category-def">Syntax: </span><span><strong class="def-name">identifier-syntax</strong> <var class="def-var-arguments">(var exp1) ((set! var val) exp2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-identifier_002dsyntax-1"> ¶</a></span></dt>
<dd><p>Create a variable transformer. The first clause is used for references
to the variable in operator or operand position, and the second for
appearances of the variable on the left-hand-side of an assignment.
</p>
<p>For example, the previous <code class="code">bar-alias</code> example could be expressed
more succinctly like this:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax bar-alias
  (identifier-syntax
    (var bar)
    ((set! var val) (set! bar val))))
</pre></div>

<p>As before, the templates in <code class="code">identifier-syntax</code> forms do not need
wrapping in <code class="code">#'</code> syntax forms.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Syntax-Parameters">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When" accesskey="n" rel="next">Eval-when</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Identifier-Macros" accesskey="p" rel="prev">Identifier Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Syntax-Parameters-1">6.8.7 Syntax Parameters</h4>

<p>Syntax parameters<a class="footnote" id="DOCF15" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT15"><sup>15</sup></a> are a
mechanism for rebinding a macro definition within the dynamic extent of
a macro expansion.  This provides a convenient solution to one of the
most common types of unhygienic macro: those that introduce a unhygienic
binding each time the macro is used.  Examples include a <code class="code">lambda</code>
form with a <code class="code">return</code> keyword, or class macros that introduce a
special <code class="code">self</code> binding.
</p>
<p>With syntax parameters, instead of introducing the binding
unhygienically each time, we instead create one binding for the keyword,
which we can then adjust later when we want the keyword to have a
different meaning.  As no new bindings are introduced, hygiene is
preserved. This is similar to the dynamic binding mechanisms we have at
run-time (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d39">parameters</a>), except that the dynamic binding
only occurs during macro expansion.  The code after macro expansion
remains lexically scoped.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dsyntax_002dparameter"><span class="category-def">Syntax: </span><span><strong class="def-name">define-syntax-parameter</strong> <var class="def-var-arguments">keyword transformer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dsyntax_002dparameter"> ¶</a></span></dt>
<dd><p>Binds <var class="var">keyword</var> to the value obtained by evaluating
<var class="var">transformer</var>.  The <var class="var">transformer</var> provides the default expansion
for the syntax parameter, and in the absence of
<code class="code">syntax-parameterize</code>, is functionally equivalent to
<code class="code">define-syntax</code>.  Usually, you will just want to have the
<var class="var">transformer</var> throw a syntax error indicating that the <var class="var">keyword</var>
is supposed to be used in conjunction with another macro, for example:
</p><div class="example">
<pre class="example-preformatted">(define-syntax-parameter return
  (lambda (stx)
    (syntax-violation 'return "return used outside of a lambda^" stx)))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-syntax_002dparameterize"><span class="category-def">Syntax: </span><span><strong class="def-name">syntax-parameterize</strong> <var class="def-var-arguments">((keyword transformer) …) exp …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002dparameterize"> ¶</a></span></dt>
<dd><p>Adjusts <var class="var">keyword</var> … to use the values obtained by evaluating
their <var class="var">transformer</var> …, in the expansion of the <var class="var">exp</var>
… forms.  Each <var class="var">keyword</var> must be bound to a syntax-parameter.
<code class="code">syntax-parameterize</code> differs from <code class="code">let-syntax</code>, in that the
binding is not shadowed, but adjusted, and so uses of the keyword in the
expansion of <var class="var">exp</var> … use the new transformers. This is
somewhat similar to how <code class="code">parameterize</code> adjusts the values of
regular parameters, rather than creating new bindings.
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax lambda^
  (syntax-rules ()
    [(lambda^ argument-list body body* ...)
     (lambda argument-list
       (call-with-current-continuation
        (lambda (escape)
          ;; In the body we adjust the 'return' keyword so that calls
          ;; to 'return' are replaced with calls to the escape
          ;; continuation.
          (syntax-parameterize ([return (syntax-rules ()
                                          [(return vals (... ...))
                                           (escape vals (... ...))])])
            body body* ...))))]))

;; Now we can write functions that return early.  Here, 'product' will
;; return immediately if it sees any 0 element.
(define product
  (lambda^ (list)
           (fold (lambda (n o)
                   (if (zero? n)
                       (return 0)
                       (* n o)))
                 1
                 list)))
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Eval-When">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macro-Expansion" accesskey="n" rel="next">Macro Expansion</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Parameters" accesskey="p" rel="prev">Syntax Parameters</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Eval_002dwhen">6.8.8 Eval-when</h4>

<p>As <code class="code">syntax-case</code> macros have the whole power of Scheme available to them,
they present a problem regarding time: when a macro runs, what parts of the
program are available for the macro to use?
</p>
<p>The default answer to this question is that when you import a module (via
<code class="code">define-module</code> or <code class="code">use-modules</code>), that module will be loaded up at
expansion-time, as well as at run-time. Additionally, top-level syntactic
definitions within one compilation unit made by <code class="code">define-syntax</code> are also
evaluated at expansion time, in the order that they appear in the compilation
unit (file).
</p>
<p>But if a syntactic definition needs to call out to a normal procedure at
expansion-time, it might well need need special declarations to indicate that
the procedure should be made available at expansion-time.
</p>
<p>For example, the following code tries to embed a compilation
timestamp in the compiled bytecode using a macro that expands
to the date as a string literal.  It will work at a REPL, but
not in a file, as it cannot be byte-compiled:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-19))
(define start-date (date-&gt;string (current-date)))
(define-syntax *compilation-date*
 (lambda (sintax)
    start-date))
(display *compilation-date*)
(newline)
</pre></div>

<p>It works at a REPL because the expressions are evaluated one-by-one, in order,
but if placed in a file, the expressions are expanded one-by-one, but not
evaluated until the compiled file is loaded.
</p>
<p>The fix is to use <code class="code">eval-when</code>.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-19))
(eval-when (expand load eval)
  (define start-date (date-&gt;string (current-date))))
(define-syntax *compilation-date*
 (lambda (sintax)
    start-date))
(display *compilation-date*)
(newline)
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-eval_002dwhen"><span class="category-def">Syntax: </span><span><strong class="def-name">eval-when</strong> <var class="def-var-arguments">conditions exp...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eval_002dwhen"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">exp...</var> under the given <var class="var">conditions</var>.  Valid
conditions include:
</p>
<dl class="table">
<dt><code class="code">expand</code></dt>
<dd><p>Evaluate during macro expansion, whether compiling or not.
</p>
</dd>
<dt><code class="code">load</code></dt>
<dd><p>Evaluate during the evaluation phase of compiled code, e.g. when loading
a compiled module or running compiled code at the REPL.
</p>
</dd>
<dt><code class="code">eval</code></dt>
<dd><p>Evaluate during the evaluation phase of non-compiled code.
</p>
</dd>
<dt><code class="code">compile</code></dt>
<dd><p>Evaluate during macro expansion, but only when compiling.
</p></dd>
</dl>

<p>In other words, when using the primitive evaluator, <code class="code">eval-when</code>
expressions with <code class="code">expand</code> are run during macro expansion, and those
with <code class="code">eval</code> are run during the evaluation phase.
</p>
<p>When using the compiler, <code class="code">eval-when</code> expressions with either
<code class="code">expand</code> or <code class="code">compile</code> are run during macro expansion, and
those with <code class="code">load</code> are run during the evaluation phase.
</p>
<p>When in doubt, use the three conditions <code class="code">(expand load eval)</code>, as in
the example above.  Other uses of <code class="code">eval-when</code> may void your
warranty or poison your cat.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Macro-Expansion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene-and-the-Top_002dLevel" accesskey="n" rel="next">Hygiene and the Top-Level</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When" accesskey="p" rel="prev">Eval-when</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Macro-Expansion-1">6.8.9 Macro Expansion</h4>

<p>Usually, macros are expanded on behalf of the user as needed.  Macro
expansion is an integral part of <code class="code">eval</code> and <code class="code">compile</code>.  Users
can also expand macros at the REPL prompt via the <code class="code">expand</code> REPL
command; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compile-Commands">Compile Commands</a>.
</p>
<p>Macros can also be expanded programmatically, via <code class="code">macroexpand</code>,
but the details get a bit hairy for two reasons.
</p>
<p>The first complication is that the result of macro-expansion isn’t
Scheme: it’s Tree-IL, Guile’s high-level intermediate language.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Tree_002dIL">Tree-IL</a>.  As “hygienic macros” can produce identifiers that are
distinct but have the same name, the output format needs to be able to
represent distinctions between variable identities and names.  Again,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Tree_002dIL">Tree-IL</a>, for all the details.  The easiest thing is to just run
<code class="code">tree-il-&gt;scheme</code> on the result of macro-expansion:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(macroexpand '(+ 1 2))
⇒
#&lt;tree-il (call (toplevel +) (const 1) (const 2))&gt;

(use-modules (language tree-il))
(tree-il-&gt;scheme (macroexpand '(+ 1 2)))
⇒
(+ 1 2)
</pre></div>

<p>The second complication involves <code class="code">eval-when</code>.  As an example, what
would it mean to macro-expand the definition of a macro?
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(macroexpand '(define-syntax qux (identifier-syntax 'bar)))
⇒
?
</pre></div>

<p>The answer is that it depends who is macro-expanding, and why.  Do you
define the macro in the current environment?  Residualize a macro
definition?  Both?  Neither?  The default is to expand in “eval” mode,
which means an <code class="code">eval-when</code> clauses will only proceed when
<code class="code">eval</code> (or <code class="code">expand</code>) is in its condition set.  Top-level
macros will be <code class="code">eval</code>’d in the top-level environment.
</p>
<p>In this way <code class="code">(macroexpand <var class="var">foo</var>)</code> is equivalent to
<code class="code">(macroexpand <var class="var">foo</var> 'e '(eval))</code>.  The second argument is the
mode (<code class="code">'e</code> for “eval”) and the third is the
eval-syntax-expanders-when parameter (only <code class="code">eval</code> in this default
setting).
</p>
<p>But if you are compiling the macro definition, probably you want to
reify the macro definition itself.  In that case you pass <code class="code">'c</code> as
the second argument to <code class="code">macroexpand</code>.  But probably you want the
macro definition to be present at compile time as well, so you pass
<code class="code">'(compile load eval)</code> as the <var class="var">esew</var> parameter.  In fact
<code class="code">(compile <var class="var">foo</var> #:to 'tree-il)</code> is entirely equivalent to
<code class="code">(macroexpand <var class="var">foo</var> 'c '(compile load eval))</code>; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-Compiler">The Scheme Compiler</a>.
</p>
<p>It’s a terrible interface; we know.  The macroexpander is somewhat
tricksy regarding modes, so unless you are building a macro-expanding
tool, we suggest to avoid invoking it directly.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Hygiene-and-the-Top_002dLevel">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Macros" accesskey="n" rel="next">Internal Macros</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macro-Expansion" accesskey="p" rel="prev">Macro Expansion</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Hygiene-and-the-Top_002dLevel-1">6.8.10 Hygiene and the Top-Level</h4>

<p>Consider the following macro.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-syntax-rule (defconst name val)
  (begin
    (define t val)
    (define-syntax-rule (name) t)))
</pre></div>

<p>If we use it to make a couple of bindings:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defconst foo 42)
(defconst bar 37)
</pre></div>

<p>The expansion would look something like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(begin
  (define t 42)
  (define-syntax-rule (foo) t))
(begin
  (define t 37)
  (define-syntax-rule (bar) t))
</pre></div>

<p>As the two <code class="code">t</code> bindings were introduced by the macro, they should
be introduced hygienically – and indeed they are, inside a lexical
contour (a <code class="code">let</code> or some other lexical scope).  The <code class="code">t</code>
reference in <code class="code">foo</code> is distinct to the reference in <code class="code">bar</code>.
</p>
<p>At the top-level things are more complicated.  Before Guile 2.2, a use
of <code class="code">defconst</code> at the top-level would not introduce a fresh binding
for <code class="code">t</code>.  This was consistent with a weaselly interpretation of the
Scheme standard, in which all possible bindings may be assumed to exist,
at the top-level, and in which we merely take advantage of toplevel
<code class="code">define</code> of an existing binding being equivalent to <code class="code">set!</code>.
But it’s not a good reason.
</p>
<p>The solution is to create fresh names for all bindings introduced by
macros – not just bindings in lexical contours, but also bindings
introduced at the top-level.
</p>
<p>However, the obvious strategy of just giving random names to introduced
toplevel identifiers poses a problem for separate compilation.  Consider
without loss of generality a <code class="code">defconst</code> of <code class="code">foo</code> in module
<code class="code">a</code> that introduces the fresh top-level name <code class="code">t-1</code>.  If we
then compile a module <code class="code">b</code> that uses <code class="code">foo</code>, there is now a
reference to <code class="code">t-1</code> in module <code class="code">b</code>.  If module <code class="code">a</code> is then
expanded again, for whatever reason, for example in a simple
recompilation, the introduced <code class="code">t</code> gets a fresh name; say,
<code class="code">t-2</code>.  Now module <code class="code">b</code> has broken because module <code class="code">a</code> no
longer has a binding for <code class="code">t-1</code>.
</p>
<p>If introduced top-level identifiers “escape” a module, in whatever
way, they then form part of the binary interface (ABI) of a module.  It
is unacceptable from an engineering point of view to allow the ABI to
change randomly.  (It also poses practical problems in meeting the
recompilation conditions of the Lesser GPL license, for such modules.)
For this reason many people prefer to never use identifier-introducing
macros at the top-level, instead making those macros receive the names
for their introduced identifiers as part of their arguments, or to
construct them programmatically and use <code class="code">datum-&gt;syntax</code>.  But this
approach requires omniscience as to the implementation of all macros one
might use, and also limits the expressive power of Scheme macros.
</p>
<p>There is no perfect solution to this issue.  Guile does a terrible thing
here.  When it goes to introduce a top-level identifier, Guile gives the
identifier a pseudo-fresh name: a name that depends on the hash of the
source expression in which the name occurs.  The result in this case is
that the introduced definitions expand as:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(begin
  (define t-1dc5e42de7c1050c 42)
  (define-syntax-rule (foo) t-1dc5e42de7c1050c))
(begin
  (define t-10cb8ce9fdddd6e9 37)
  (define-syntax-rule (bar) t-10cb8ce9fdddd6e9))
</pre></div>

<p>However, note that as the hash depends solely on the expression
introducing the definition, we also have:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(defconst baz 42)
⇒ (begin
    (define t-1dc5e42de7c1050c 42)
    (define-syntax-rule (baz) t-1dc5e42de7c1050c))
</pre></div>

<p>Note that the introduced binding has the same name!  This is because the
source expression, <code class="code">(define t 42)</code>, was the same.  Probably you
will never see an error in this area, but it is important to understand
the components of the interface of a module, and that interface may
include macro-introduced identifiers.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Internal-Macros">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hygiene-and-the-Top_002dLevel" accesskey="p" rel="prev">Hygiene and the Top-Level</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="u" rel="up">Macros</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Internal-Macros-1">6.8.11 Internal Macros</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsyntax_002dtransformer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-syntax-transformer</strong> <var class="def-var-arguments">name type binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsyntax_002dtransformer"> ¶</a></span></dt>
<dd><p>Construct a syntax transformer object. This is part of Guile’s low-level support
for syntax-case.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-macro_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">macro?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmacro_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_macro_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmacro_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a syntax transformer, or <code class="code">#f</code>
otherwise.
</p>
<p>Note that it’s a bit difficult to actually get a macro as a first-class object;
simply naming it (like <code class="code">case</code>) will produce a syntax error. But it is
possible to get these objects using <code class="code">module-ref</code>:
</p>
<div class="example">
<pre class="example-preformatted">(macro? (module-ref (current-module) 'case))
⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-macro_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">macro-type</strong> <var class="def-var-arguments">m</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_002dtype"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmacro_005ftype"><span class="category-def">C Function: </span><span><strong class="def-name">scm_macro_type</strong> <var class="def-var-arguments">(m)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmacro_005ftype"> ¶</a></span></dt>
<dd><p>Return the <var class="var">type</var> that was given when <var class="var">m</var> was constructed, via
<code class="code">make-syntax-transformer</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-macro_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">macro-name</strong> <var class="def-var-arguments">m</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_002dname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmacro_005fname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_macro_name</strong> <var class="def-var-arguments">(m)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmacro_005fname"> ¶</a></span></dt>
<dd><p>Return the name of the macro <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-macro_002dbinding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">macro-binding</strong> <var class="def-var-arguments">m</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_002dbinding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmacro_005fbinding"><span class="category-def">C Function: </span><span><strong class="def-name">scm_macro_binding</strong> <var class="def-var-arguments">(m)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmacro_005fbinding"> ¶</a></span></dt>
<dd><p>Return the binding of the macro <var class="var">m</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-macro_002dtransformer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">macro-transformer</strong> <var class="def-var-arguments">m</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_002dtransformer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmacro_005ftransformer"><span class="category-def">C Function: </span><span><strong class="def-name">scm_macro_transformer</strong> <var class="def-var-arguments">(m)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmacro_005ftransformer"> ¶</a></span></dt>
<dd><p>Return the transformer of the macro <var class="var">m</var>. This will return a procedure, for
which one may ask the docstring. That’s the whole reason this section is
documented. Actually a part of the result of <code class="code">macro-binding</code>.
</p></dd></dl>



<hr>
</div>
</div>
<div class="section-level-extent" id="Utility-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="n" rel="next">Definitions and Variable Bindings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Macros" accesskey="p" rel="prev">Macros</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="General-Utility-Functions">6.9 General Utility Functions</h3>


<p>This chapter contains information about procedures which are not cleanly
tied to a specific data type.  Because of their wide range of
applications, they are collected in a <em class="dfn">utility</em> chapter.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Equality" accesskey="1">Equality</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Object-Properties" accesskey="2">Object Properties</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Sorting" accesskey="3">Sorting</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Copying" accesskey="4">Copying Deep Structures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#General-Conversion" accesskey="5">General String Conversion</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="6">Hooks</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Equality">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Object-Properties" accesskey="n" rel="next">Object Properties</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Equality-1">6.9.1 Equality</h4>
<a class="index-entry-id" id="index-sameness"></a>
<a class="index-entry-id" id="index-equality"></a>

<p>There are three kinds of core equality predicates in Scheme, described
below.  The same kinds of comparisons arise in other functions, like
<code class="code">memq</code> and friends (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching">List Searching</a>).
</p>
<p>For all three tests, objects of different types are never equal.  So
for instance a list and a vector are not <code class="code">equal?</code>, even if their
contents are the same.  Exact and inexact numbers are considered
different types too, and are hence not equal even if their values are
the same.
</p>
<p><code class="code">eq?</code> tests just for the same object (essentially a pointer
comparison).  This is fast, and can be used when searching for a
particular object, or when working with symbols or keywords (which are
always unique objects).
</p>
<p><code class="code">eqv?</code> extends <code class="code">eq?</code> to look at the value of numbers and
characters.  It can for instance be used somewhat like <code class="code">=</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Comparison">Comparison Predicates</a>) but without an error if one operand isn’t a
number.
</p>
<p><code class="code">equal?</code> goes further, it looks (recursively) into the contents
of lists, vectors, etc.  This is good for instance on lists that have
been read or calculated in various places and are the same, just not
made up of the same pairs.  Such lists look the same (when printed),
and <code class="code">equal?</code> will consider them the same.
</p>
<br>
<dl class="first-deffn">
<dt class="deffn" id="index-eq_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eq?</strong> <var class="def-var-arguments">…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eq_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feq_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eq_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feq_005fp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-eq_003f-3"></a>
<p>The Scheme procedure returns <code class="code">#t</code> if all of its arguments are the
same object, except for numbers and characters.  The C function does the
same but takes exactly two arguments.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(define x (vector 1 2 3))
(define y (vector 1 2 3))

(eq? x x)  ⇒ #t
(eq? x y)  ⇒ #f
</pre></div>

<p>Numbers and characters are not equal to any other object, but the
problem is they’re not necessarily <code class="code">eq?</code> to themselves either.
This is even so when the number comes directly from a variable,
</p>
<div class="example">
<pre class="example-preformatted">(let ((n (+ 2 3)))
  (eq? n n))       ⇒ *unspecified*
</pre></div>

<p>Generally <code class="code">eqv?</code> below should be used when comparing numbers or
characters.  <code class="code">=</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Comparison">Comparison Predicates</a>) or <code class="code">char=?</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Characters">Characters</a>) can be used too.
</p>
<p>It’s worth noting that end-of-list <code class="code">()</code>, <code class="code">#t</code>, <code class="code">#f</code>, a
symbol of a given name, and a keyword of a given name, are unique
objects.  There’s just one of each, so for instance no matter how
<code class="code">()</code> arises in a program, it’s the same object and can be
compared with <code class="code">eq?</code>,
</p>
<div class="example">
<pre class="example-preformatted">(define x (cdr '(123)))
(define y (cdr '(456)))
(eq? x y) ⇒ #t

(define x (string-&gt;symbol "foo"))
(eq? x 'foo) ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005feq"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_eq</strong> <code class="def-code-arguments">(SCM x, SCM y)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005feq"> ¶</a></span></dt>
<dd><p>Return <code class="code">1</code> when <var class="var">x</var> and <var class="var">y</var> are equal in the sense of
<code class="code">eq?</code>, otherwise return <code class="code">0</code>.
</p>
<a class="index-entry-id" id="index-_003d_003d"></a>
<p>The <code class="code">==</code> operator should not be used on <code class="code">SCM</code> values, an
<code class="code">SCM</code> is a C type which cannot necessarily be compared using
<code class="code">==</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#The-SCM-Type">The SCM Type</a>).
</p></dd></dl>

<br>
<dl class="first-deffn">
<dt class="deffn" id="index-eqv_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eqv?</strong> <var class="def-var-arguments">…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eqv_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feqv_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eqv_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feqv_005fp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-eqv_003f-2"></a>
<p>The Scheme procedure returns <code class="code">#t</code> if all of its arguments are the
same object, or for characters and numbers the same value.  The C function
is similar but takes exactly two arguments.
</p>
<p>On objects except characters and numbers, <code class="code">eqv?</code> is the same as
<code class="code">eq?</code> above.  <code class="code">(eqv? x y)</code> is true if <var class="var">x</var> and <var class="var">y</var> are
the same object.
</p>
<p>If <var class="var">x</var> and <var class="var">y</var> are numbers or characters, <code class="code">eqv?</code> compares
their type and value.  An exact number is not <code class="code">eqv?</code> to an
inexact number (even if their value is the same).
</p>
<div class="example">
<pre class="example-preformatted">(eqv? 3 (+ 1 2)) ⇒ #t
(eqv? 1 1.0)     ⇒ #f
</pre></div>
</dd></dl>
<br>
<dl class="first-deffn">
<dt class="deffn" id="index-equal_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">equal?</strong> <var class="def-var-arguments">…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-equal_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fequal_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_equal_p</strong> <var class="def-var-arguments">(x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fequal_005fp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-equal_003f-2"></a>
<p>The Scheme procedure returns <code class="code">#t</code> if all of its arguments are the
same type, and their contents or value are equal.  The C function is
similar, but takes exactly two arguments.
</p>
<p>For a pair, string, vector, array or structure, <code class="code">equal?</code> compares the
contents, and does so using the same <code class="code">equal?</code> recursively,
so a deep structure can be traversed.
</p>
<div class="example">
<pre class="example-preformatted">(equal? (list 1 2 3) (list 1 2 3))   ⇒ #t
(equal? (list 1 2 3) (vector 1 2 3)) ⇒ #f
</pre></div>

<p>For other objects, <code class="code">equal?</code> compares as per <code class="code">eqv?</code> above,
which means characters and numbers are compared by type and value (and
like <code class="code">eqv?</code>, exact and inexact numbers are not <code class="code">equal?</code>,
even if their value is the same).
</p>
<div class="example">
<pre class="example-preformatted">(equal? 3 (+ 1 2)) ⇒ #t
(equal? 1 1.0)     ⇒ #f
</pre></div>

<p>Hash tables are currently only compared as per <code class="code">eq?</code>, so two
different tables are not <code class="code">equal?</code>, even if their contents are the
same.
</p>
<p><code class="code">equal?</code> does not support circular data structures, it may go
into an infinite loop if asked to compare two circular lists or
similar.
</p>
<p>GOOPS object types (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS">GOOPS</a>), including foreign object types
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types">Defining New Foreign Object Types</a>), can have an <code class="code">equal?</code>
implementation specialized on two values of the same type.  If
<code class="code">equal?</code> is called on two GOOPS objects of the same type,
<code class="code">equal?</code> will dispatch out to a generic function.  This lets an
application traverse the contents or control what is considered
<code class="code">equal?</code> for two objects of such a type.  If there’s no such
handler, the default is to just compare as per <code class="code">eq?</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Object-Properties">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sorting" accesskey="n" rel="next">Sorting</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Equality" accesskey="p" rel="prev">Equality</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Object-Properties-1">6.9.2 Object Properties</h4>

<p>It’s often useful to associate a piece of additional information with a
Scheme object even though that object does not have a dedicated slot
available in which the additional information could be stored.  Object
properties allow you to do just that.
</p>
<p>Guile’s representation of an object property is a procedure-with-setter
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</a>) that can be used with the generalized
form of <code class="code">set!</code> to set and retrieve that property for any Scheme object.  So, setting a
property looks like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! (my-property obj1) value-for-obj1)
(set! (my-property obj2) value-for-obj2)
</pre></div>

<p>And retrieving values of the same property looks like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(my-property obj1)
⇒
value-for-obj1

(my-property obj2)
⇒
value-for-obj2
</pre></div>

<p>To create an object property in the first place, use the
<code class="code">make-object-property</code> procedure:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define my-property (make-object-property))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dobject_002dproperty"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-object-property</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dobject_002dproperty"> ¶</a></span></dt>
<dd><p>Create and return an object property.  An object property is a
procedure-with-setter that can be called in two ways.  <code class="code">(set!
(<var class="var">property</var> <var class="var">obj</var>) <var class="var">val</var>)</code> sets <var class="var">obj</var>’s <var class="var">property</var>
to <var class="var">val</var>.  <code class="code">(<var class="var">property</var> <var class="var">obj</var>)</code> returns the current
setting of <var class="var">obj</var>’s <var class="var">property</var>.
</p></dd></dl>

<p>A single object property created by <code class="code">make-object-property</code> can
associate distinct property values with all Scheme values that are
distinguishable by <code class="code">eq?</code> (ruling out numeric values).
</p>
<p>Internally, object properties are implemented using a weak key hash
table.  This means that, as long as a Scheme value with property values
is protected from garbage collection, its property values are also
protected.  When the Scheme value is collected, its entry in the
property table is removed and so the (ex-) property values are no longer
protected by the table.
</p>
<p>Guile also implements a more traditional Lispy interface to properties,
in which each object has an list of key-value pairs associated with it.
Properties in that list are keyed by symbols.  This is a legacy
interface; you should use weak hash tables or object properties instead.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-object_002dproperties"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">object-properties</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-object_002dproperties"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fobject_005fproperties"><span class="category-def">C Function: </span><span><strong class="def-name">scm_object_properties</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fobject_005fproperties"> ¶</a></span></dt>
<dd><p>Return <var class="var">obj</var>’s property list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dobject_002dproperties_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-object-properties!</strong> <var class="def-var-arguments">obj alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dobject_002dproperties_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fobject_005fproperties_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_object_properties_x</strong> <var class="def-var-arguments">(obj, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fobject_005fproperties_005fx"> ¶</a></span></dt>
<dd><p>Set <var class="var">obj</var>’s property list to <var class="var">alist</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-object_002dproperty"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">object-property</strong> <var class="def-var-arguments">obj key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-object_002dproperty"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fobject_005fproperty"><span class="category-def">C Function: </span><span><strong class="def-name">scm_object_property</strong> <var class="def-var-arguments">(obj, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fobject_005fproperty"> ¶</a></span></dt>
<dd><p>Return the property of <var class="var">obj</var> with name <var class="var">key</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dobject_002dproperty_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-object-property!</strong> <var class="def-var-arguments">obj key value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dobject_002dproperty_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fobject_005fproperty_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_object_property_x</strong> <var class="def-var-arguments">(obj, key, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fobject_005fproperty_005fx"> ¶</a></span></dt>
<dd><p>In <var class="var">obj</var>’s property list, set the property named <var class="var">key</var>
to <var class="var">value</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Sorting">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Copying" accesskey="n" rel="next">Copying Deep Structures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Object-Properties" accesskey="p" rel="prev">Object Properties</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Sorting-1">6.9.3 Sorting</h4>


<a class="index-entry-id" id="index-sorting"></a>
<a class="index-entry-id" id="index-sorting-lists"></a>
<a class="index-entry-id" id="index-sorting-vectors"></a>

<p>Sorting is very important in computer programs.  Therefore, Guile comes
with several sorting procedures built-in.  As always, procedures with
names ending in <code class="code">!</code> are side-effecting, that means that they may
modify their parameters in order to produce their results.
</p>
<p>The first group of procedures can be used to merge two lists (which must
be already sorted on their own) and produce sorted lists containing
all elements of the input lists.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-merge"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">merge</strong> <var class="def-var-arguments">alist blist less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-merge"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmerge"><span class="category-def">C Function: </span><span><strong class="def-name">scm_merge</strong> <var class="def-var-arguments">(alist, blist, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmerge"> ¶</a></span></dt>
<dd><p>Merge two already sorted lists into one.
Given two lists <var class="var">alist</var> and <var class="var">blist</var>, such that
<code class="code">(sorted? alist less?)</code> and <code class="code">(sorted? blist less?)</code>,
return a new list in which the elements of <var class="var">alist</var> and
<var class="var">blist</var> have been stably interleaved so that
<code class="code">(sorted? (merge alist blist less?) less?)</code>.
Note:  this does _not_ accept vectors.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-merge_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">merge!</strong> <var class="def-var-arguments">alist blist less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-merge_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmerge_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_merge_x</strong> <var class="def-var-arguments">(alist, blist, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmerge_005fx"> ¶</a></span></dt>
<dd><p>Takes two lists <var class="var">alist</var> and <var class="var">blist</var> such that
<code class="code">(sorted? alist less?)</code> and <code class="code">(sorted? blist less?)</code> and
returns a new list in which the elements of <var class="var">alist</var> and
<var class="var">blist</var> have been stably interleaved so that
 <code class="code">(sorted? (merge alist blist less?) less?)</code>.
This is the destructive variant of <code class="code">merge</code>
Note:  this does _not_ accept vectors.
</p></dd></dl>

<p>The following procedures can operate on sequences which are either
vectors or list.  According to the given arguments, they return sorted
vectors or lists, respectively.  The first of the following procedures
determines whether a sequence is already sorted, the other sort a given
sequence.  The variants with names starting with <code class="code">stable-</code> are
special in that they maintain a special property of the input sequences:
If two or more elements are the same according to the comparison
predicate, they are left in the same order as they appeared in the
input.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-sorted_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sorted?</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sorted_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsorted_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sorted_p</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsorted_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">items</var> is a list or vector such that,
for each element <var class="var">x</var> and the next element <var class="var">y</var> of
<var class="var">items</var>, <code class="code">(<var class="var">less</var> <var class="var">y</var> <var class="var">x</var>)</code> returns
<code class="code">#f</code>.  Otherwise return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sort"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sort</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sort"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsort"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sort</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsort"> ¶</a></span></dt>
<dd><p>Sort the sequence <var class="var">items</var>, which may be a list or a
vector.  <var class="var">less</var> is used for comparing the sequence
elements.  This is not a stable sort.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sort_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sort!</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sort_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsort_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sort_x</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsort_005fx"> ¶</a></span></dt>
<dd><p>Sort the sequence <var class="var">items</var>, which may be a list or a
vector.  <var class="var">less</var> is used for comparing the sequence
elements.  The sorting is destructive, that means that the
input sequence is modified to produce the sorted result.
This is not a stable sort.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stable_002dsort"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stable-sort</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stable_002dsort"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstable_005fsort"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stable_sort</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstable_005fsort"> ¶</a></span></dt>
<dd><p>Sort the sequence <var class="var">items</var>, which may be a list or a
vector. <var class="var">less</var> is used for comparing the sequence elements.
This is a stable sort.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stable_002dsort_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stable-sort!</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stable_002dsort_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstable_005fsort_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stable_sort_x</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstable_005fsort_005fx"> ¶</a></span></dt>
<dd><p>Sort the sequence <var class="var">items</var>, which may be a list or a
vector. <var class="var">less</var> is used for comparing the sequence elements.
The sorting is destructive, that means that the input sequence
is modified to produce the sorted result.
This is a stable sort.
</p></dd></dl>

<p>The procedures in the last group only accept lists or vectors as input,
as their names indicate.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-sort_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sort-list</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sort_002dlist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsort_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sort_list</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsort_005flist"> ¶</a></span></dt>
<dd><p>Sort the list <var class="var">items</var>, using <var class="var">less</var> for comparing the
list elements. This is a stable sort.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sort_002dlist_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sort-list!</strong> <var class="def-var-arguments">items less</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sort_002dlist_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsort_005flist_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sort_list_x</strong> <var class="def-var-arguments">(items, less)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsort_005flist_005fx"> ¶</a></span></dt>
<dd><p>Sort the list <var class="var">items</var>, using <var class="var">less</var> for comparing the
list elements. The sorting is destructive, that means that the
input list is modified to produce the sorted result.
This is a stable sort.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-restricted_002dvector_002dsort_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">restricted-vector-sort!</strong> <var class="def-var-arguments">vec less startpos endpos</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-restricted_002dvector_002dsort_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frestricted_005fvector_005fsort_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_restricted_vector_sort_x</strong> <var class="def-var-arguments">(vec, less, startpos, endpos)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frestricted_005fvector_005fsort_005fx"> ¶</a></span></dt>
<dd><p>Sort the vector <var class="var">vec</var>, using <var class="var">less</var> for comparing
the vector elements.  <var class="var">startpos</var> (inclusively) and
<var class="var">endpos</var> (exclusively) delimit
the range of the vector which gets sorted.  The return value
is not specified.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Copying">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Conversion" accesskey="n" rel="next">General String Conversion</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sorting" accesskey="p" rel="prev">Sorting</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Copying-Deep-Structures">6.9.4 Copying Deep Structures</h4>

<p>The procedures for copying lists (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lists">Lists</a>) only produce a flat
copy of the input list, and currently Guile does not even contain
procedures for copying vectors.  The <code class="code">(ice-9 copy-tree)</code> module
contains a <code class="code">copy-tree</code> function that can be used for this purpose,
as it does not only copy the spine of a list, but also copies any pairs
in the cars of the input lists.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 copy-tree))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-copy_002dtree"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">copy-tree</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-copy_002dtree"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcopy_005ftree"><span class="category-def">C Function: </span><span><strong class="def-name">scm_copy_tree</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcopy_005ftree"> ¶</a></span></dt>
<dd><p>Recursively copy the data tree that is bound to <var class="var">obj</var>, and return
the new data structure.  <code class="code">copy-tree</code> recurses down the
contents of both pairs and vectors (since both cons cells and vector
cells may point to arbitrary objects), and stops recursing when it hits
any other object.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="General-Conversion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="n" rel="next">Hooks</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Copying" accesskey="p" rel="prev">Copying Deep Structures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="General-String-Conversion">6.9.5 General String Conversion</h4>


<p>When debugging Scheme programs, but also for providing a human-friendly
interface, a procedure for converting any Scheme object into string
format is very useful.  Conversion from/to strings can of course be done
with specialized procedures when the data type of the object to convert
is known, but with this procedure, it is often more comfortable.
</p>
<p><code class="code">object-&gt;string</code> converts an object by using a print procedure for
writing to a string port, and then returning the resulting string.
Converting an object back from the string is only possible if the object
type has a read syntax and the read syntax is preserved by the printing
procedure.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-object_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">object-&gt;string</strong> <var class="def-var-arguments">obj [printer]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-object_002d_003estring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fobject_005fto_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_object_to_string</strong> <var class="def-var-arguments">(obj, printer)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fobject_005fto_005fstring"> ¶</a></span></dt>
<dd><p>Return a Scheme string obtained by printing <var class="var">obj</var>.
Printing function can be specified by the optional second
argument <var class="var">printer</var> (default: <code class="code">write</code>).
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Hooks">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Conversion" accesskey="p" rel="prev">General String Conversion</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="u" rel="up">General Utility Functions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Hooks-1">6.9.6 Hooks</h4>
<a class="index-entry-id" id="index-Hooks"></a>

<p>A hook is a list of procedures to be called at well defined points in
time.  Typically, an application provides a hook <var class="var">h</var> and promises
its users that it will call all of the procedures in <var class="var">h</var> at a
defined point in the application’s processing.  By adding its own
procedure to <var class="var">h</var>, an application user can tap into or even influence
the progress of the application.
</p>
<p>Guile itself provides several such hooks for debugging and customization
purposes: these are listed in a subsection below.
</p>
<p>When an application first creates a hook, it needs to know how many
arguments will be passed to the hook’s procedures when the hook is run.
The chosen number of arguments (which may be none) is declared when the
hook is created, and all the procedures that are added to that hook must
be capable of accepting that number of arguments.
</p>
<p>A hook is created using <code class="code">make-hook</code>.  A procedure can be added to
or removed from a hook using <code class="code">add-hook!</code> or <code class="code">remove-hook!</code>,
and all of a hook’s procedures can be removed together using
<code class="code">reset-hook!</code>.  When an application wants to run a hook, it does so
using <code class="code">run-hook</code>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Example" accesskey="1">Hook Usage by Example</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Reference" accesskey="2">Hook Reference</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#C-Hooks" accesskey="3">Hooks For C Code.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#GC-Hooks" accesskey="4">Hooks for Garbage Collection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Hooks" accesskey="5">Hooks into the Guile REPL</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Hook-Example">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Reference" accesskey="n" rel="next">Hook Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="u" rel="up">Hooks</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hook-Usage-by-Example">6.9.6.1 Hook Usage by Example</h4>

<p>Hook usage is shown by some examples in this section.  First, we will
define a hook of arity 2 — that is, the procedures stored in the hook
will have to accept two arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define hook (make-hook 2))
hook
⇒ #&lt;hook 2 40286c90&gt;
</pre></div>

<p>Now we are ready to add some procedures to the newly created hook with
<code class="code">add-hook!</code>.  In the following example, two procedures are added,
which print different messages and do different things with their
arguments.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(add-hook! hook (lambda (x y)
                    (display "Foo: ")
                    (display (+ x y))
                    (newline)))
(add-hook! hook (lambda (x y)
                    (display "Bar: ")
                    (display (* x y))
                    (newline)))
</pre></div>

<p>Once the procedures have been added, we can invoke the hook using
<code class="code">run-hook</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(run-hook hook 3 4)
-| Bar: 12
-| Foo: 7
</pre></div>

<p>Note that the procedures are called in the reverse of the order with
which they were added.  This is because the default behaviour of
<code class="code">add-hook!</code> is to add its procedure to the <em class="emph">front</em> of the
hook’s procedure list.  You can force <code class="code">add-hook!</code> to add its
procedure to the <em class="emph">end</em> of the list instead by providing a third
<code class="code">#t</code> argument on the second call to <code class="code">add-hook!</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(add-hook! hook (lambda (x y)
                    (display "Foo: ")
                    (display (+ x y))
                    (newline)))
(add-hook! hook (lambda (x y)
                    (display "Bar: ")
                    (display (* x y))
                    (newline))
                    #t)             ; <span class="r">&lt;- Change here!</span>

(run-hook hook 3 4)
-| Foo: 7
-| Bar: 12
</pre></div>


<hr>
</div>
<div class="subsubsection-level-extent" id="Hook-Reference">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#C-Hooks" accesskey="n" rel="next">Hooks For C Code.</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Example" accesskey="p" rel="prev">Hook Usage by Example</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="u" rel="up">Hooks</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hook-Reference-1">6.9.6.2 Hook Reference</h4>

<p>When you create a hook with <code class="code">make-hook</code>, you must specify the arity
of the procedures which can be added to the hook.  If the arity is not
given explicitly as an argument to <code class="code">make-hook</code>, it defaults to
zero.  All procedures of a given hook must have the same arity, and when
the procedures are invoked using <code class="code">run-hook</code>, the number of
arguments passed must match the arity specified at hook creation time.
</p>
<p>The order in which procedures are added to a hook matters.  If the third
parameter to <code class="code">add-hook!</code> is omitted or is equal to <code class="code">#f</code>, the
procedure is added in front of the procedures which might already be on
that hook, otherwise the procedure is added at the end.  The procedures
are always called from the front to the end of the list when they are
invoked via <code class="code">run-hook</code>.
</p>
<p>The ordering of the list of procedures returned by <code class="code">hook-&gt;list</code>
matches the order in which those procedures would be called if the hook
was run using <code class="code">run-hook</code>.
</p>
<p>Note that the C functions in the following entries are for handling
<em class="dfn">Scheme-level</em> hooks in C.  There are also <em class="dfn">C-level</em> hooks which
have their own interface (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#C-Hooks">Hooks For C Code.</a>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dhook"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-hook</strong> <var class="def-var-arguments">[n_args]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dhook"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fhook"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_hook</strong> <var class="def-var-arguments">(n_args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fhook"> ¶</a></span></dt>
<dd><p>Create a hook for storing procedure of arity <var class="var">n_args</var>.
<var class="var">n_args</var> defaults to zero.  The returned value is a hook
object to be used with the other hook procedures.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hook_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hook?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hook_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhook_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hook_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhook_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is a hook, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hook_002dempty_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hook-empty?</strong> <var class="def-var-arguments">hook</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hook_002dempty_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhook_005fempty_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hook_empty_p</strong> <var class="def-var-arguments">(hook)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhook_005fempty_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">hook</var> is an empty hook, <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-hook!</strong> <var class="def-var-arguments">hook proc [append_p]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fadd_005fhook_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_add_hook_x</strong> <var class="def-var-arguments">(hook, proc, append_p)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fadd_005fhook_005fx"> ¶</a></span></dt>
<dd><p>Add the procedure <var class="var">proc</var> to the hook <var class="var">hook</var>. The
procedure is added to the end if <var class="var">append_p</var> is true,
otherwise it is added to the front.  The return value of this
procedure is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-remove_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">remove-hook!</strong> <var class="def-var-arguments">hook proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-remove_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fremove_005fhook_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_remove_hook_x</strong> <var class="def-var-arguments">(hook, proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fremove_005fhook_005fx"> ¶</a></span></dt>
<dd><p>Remove the procedure <var class="var">proc</var> from the hook <var class="var">hook</var>.  The
return value of this procedure is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-reset_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reset-hook!</strong> <var class="def-var-arguments">hook</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reset_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freset_005fhook_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_reset_hook_x</strong> <var class="def-var-arguments">(hook)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freset_005fhook_005fx"> ¶</a></span></dt>
<dd><p>Remove all procedures from the hook <var class="var">hook</var>.  The return
value of this procedure is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-hook_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hook-&gt;list</strong> <var class="def-var-arguments">hook</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hook_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fhook_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_hook_to_list</strong> <var class="def-var-arguments">(hook)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fhook_005fto_005flist"> ¶</a></span></dt>
<dd><p>Convert the procedure list of <var class="var">hook</var> to a list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-run_002dhook"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">run-hook</strong> <var class="def-var-arguments">hook arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-run_002dhook"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frun_005fhook"><span class="category-def">C Function: </span><span><strong class="def-name">scm_run_hook</strong> <var class="def-var-arguments">(hook, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frun_005fhook"> ¶</a></span></dt>
<dd><p>Apply all procedures from the hook <var class="var">hook</var> to the arguments <var class="var">arg</var>
<small class="enddots">...</small>.  The order of the procedure application is first to last.
The return value of this procedure is not specified.
</p></dd></dl>

<p>If, in C code, you are certain that you have a hook object and well
formed argument list for that hook, you can also use
<code class="code">scm_c_run_hook</code>, which is identical to <code class="code">scm_run_hook</code> but
does no type checking.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005frun_005fhook"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_run_hook</strong> <code class="def-code-arguments">(SCM hook, SCM args)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005frun_005fhook"> ¶</a></span></dt>
<dd><p>The same as <code class="code">scm_run_hook</code> but without any type checking to confirm
that <var class="var">hook</var> is actually a hook object and that <var class="var">args</var> is a
well-formed list matching the arity of the hook.
</p></dd></dl>

<p>For C code, <code class="code">SCM_HOOKP</code> is a faster alternative to
<code class="code">scm_hook_p</code>:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fHOOKP"><span class="category-def">C Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_HOOKP</strong> <code class="def-code-arguments">(x)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fHOOKP"> ¶</a></span></dt>
<dd><p>Return 1 if <var class="var">x</var> is a Scheme-level hook, 0 otherwise.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="C-Hooks">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#GC-Hooks" accesskey="n" rel="next">Hooks for Garbage Collection</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hook-Reference" accesskey="p" rel="prev">Hook Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="u" rel="up">Hooks</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hooks-For-C-Code_002e">6.9.6.3 Hooks For C Code.</h4>

<p>The hooks already described are intended to be populated by Scheme-level
procedures.  In addition to this, the Guile library provides an
independent set of interfaces for the creation and manipulation of hooks
that are designed to be populated by functions implemented in C.
</p>
<p>The original motivation here was to provide a kind of hook that could
safely be invoked at various points during garbage collection.
Scheme-level hooks are unsuitable for this purpose as running them could
itself require memory allocation, which would then invoke garbage
collection recursively …  However, it is also the case that these
hooks are easier to work with than the Scheme-level ones if you only
want to register C functions with them.  So if that is mainly what your
code needs to do, you may prefer to use this interface.
</p>
<p>To create a C hook, you should allocate storage for a structure of type
<code class="code">scm_t_c_hook</code> and then initialize it using <code class="code">scm_c_hook_init</code>.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fc_005fhook"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fc_005fhook"> ¶</a></span></dt>
<dd><p>Data type for a C hook.  The internals of this type should be treated as
opaque.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fc_005fhook_005ftype"><span class="category-def">C Enum: </span><span><strong class="def-name">scm_t_c_hook_type</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fc_005fhook_005ftype"> ¶</a></span></dt>
<dd><p>Enumeration of possible hook types, which are:
</p>
<dl class="table">
<dt id="index-SCM_005fC_005fHOOK_005fNORMAL"><span><code class="code">SCM_C_HOOK_NORMAL</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fC_005fHOOK_005fNORMAL"> ¶</a></span></dt>
<dd><p>Type of hook for which all the registered functions will always be called.
</p></dd>
<dt id="index-SCM_005fC_005fHOOK_005fOR"><span><code class="code">SCM_C_HOOK_OR</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fC_005fHOOK_005fOR"> ¶</a></span></dt>
<dd><p>Type of hook for which the sequence of registered functions will be
called only until one of them returns C true (a non-NULL pointer).
</p></dd>
<dt id="index-SCM_005fC_005fHOOK_005fAND"><span><code class="code">SCM_C_HOOK_AND</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fC_005fHOOK_005fAND"> ¶</a></span></dt>
<dd><p>Type of hook for which the sequence of registered functions will be
called only until one of them returns C false (a NULL pointer).
</p></dd>
</dl>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fhook_005finit"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_hook_init</strong> <code class="def-code-arguments">(scm_t_c_hook *hook, void *hook_data, scm_t_c_hook_type type)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fhook_005finit"> ¶</a></span></dt>
<dd><p>Initialize the C hook at memory pointed to by <var class="var">hook</var>.  <var class="var">type</var>
should be one of the values of the <code class="code">scm_t_c_hook_type</code> enumeration,
and controls how the hook functions will be called.  <var class="var">hook_data</var> is
a closure parameter that will be passed to all registered hook functions
when they are called.
</p></dd></dl>

<p>To add or remove a C function from a C hook, use <code class="code">scm_c_hook_add</code>
or <code class="code">scm_c_hook_remove</code>.  A hook function must expect three
<code class="code">void *</code> parameters which are, respectively:
</p>
<dl class="table">
<dt><var class="var">hook_data</var></dt>
<dd><p>The hook closure data that was specified at the time the hook was
initialized by <code class="code">scm_c_hook_init</code>.
</p>
</dd>
<dt><var class="var">func_data</var></dt>
<dd><p>The function closure data that was specified at the time that that
function was registered with the hook by <code class="code">scm_c_hook_add</code>.
</p>
</dd>
<dt><var class="var">data</var></dt>
<dd><p>The call closure data specified by the <code class="code">scm_c_hook_run</code> call that
runs the hook.
</p></dd>
</dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fc_005fhook_005ffunction"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_c_hook_function</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fc_005fhook_005ffunction"> ¶</a></span></dt>
<dd><p>Function type for a C hook function: takes three <code class="code">void *</code>
parameters and returns a <code class="code">void *</code> result.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fhook_005fadd"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_hook_add</strong> <code class="def-code-arguments">(scm_t_c_hook *hook, scm_t_c_hook_function func, void *func_data, int appendp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fhook_005fadd"> ¶</a></span></dt>
<dd><p>Add function <var class="var">func</var>, with function closure data <var class="var">func_data</var>, to
the C hook <var class="var">hook</var>.  The new function is appended to the hook’s list
of functions if <var class="var">appendp</var> is non-zero, otherwise prepended.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fhook_005fremove"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_hook_remove</strong> <code class="def-code-arguments">(scm_t_c_hook *hook, scm_t_c_hook_function func, void *func_data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fhook_005fremove"> ¶</a></span></dt>
<dd><p>Remove function <var class="var">func</var>, with function closure data <var class="var">func_data</var>,
from the C hook <var class="var">hook</var>.  <code class="code">scm_c_hook_remove</code> checks both
<var class="var">func</var> and <var class="var">func_data</var> so as to allow for the same <var class="var">func</var>
being registered multiple times with different closure data.
</p></dd></dl>

<p>Finally, to invoke a C hook, call the <code class="code">scm_c_hook_run</code> function
specifying the hook and the call closure data for this run:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fhook_005frun"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_c_hook_run</strong> <code class="def-code-arguments">(scm_t_c_hook *hook, void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fhook_005frun"> ¶</a></span></dt>
<dd><p>Run the C hook <var class="var">hook</var> will call closure data <var class="var">data</var>.  Subject to
the variations for hook types <code class="code">SCM_C_HOOK_OR</code> and
<code class="code">SCM_C_HOOK_AND</code>, <code class="code">scm_c_hook_run</code> calls <var class="var">hook</var>’s
registered functions in turn, passing them the hook’s closure data, each
function’s closure data, and the call closure data.
</p>
<p><code class="code">scm_c_hook_run</code>’s return value is the return value of the last
function to be called.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="GC-Hooks">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Hooks" accesskey="n" rel="next">Hooks into the Guile REPL</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#C-Hooks" accesskey="p" rel="prev">Hooks For C Code.</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="u" rel="up">Hooks</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hooks-for-Garbage-Collection">6.9.6.4 Hooks for Garbage Collection</h4>

<p>Whenever Guile performs a garbage collection, it calls the following
hooks in the order shown.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fbefore_005fgc_005fc_005fhook"><span class="category-def">C Hook: </span><span><strong class="def-name">scm_before_gc_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbefore_005fgc_005fc_005fhook"> ¶</a></span></dt>
<dd><p>C hook called at the very start of a garbage collection, after setting
<code class="code">scm_gc_running_p</code> to 1, but before entering the GC critical
section.
</p>
<p>If garbage collection is blocked because <code class="code">scm_block_gc</code> is
non-zero, GC exits early soon after calling this hook, and no further
hooks will be called.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fbefore_005fmark_005fc_005fhook"><span class="category-def">C Hook: </span><span><strong class="def-name">scm_before_mark_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbefore_005fmark_005fc_005fhook"> ¶</a></span></dt>
<dd><p>C hook called before beginning the mark phase of garbage collection,
after the GC thread has entered a critical section.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fbefore_005fsweep_005fc_005fhook"><span class="category-def">C Hook: </span><span><strong class="def-name">scm_before_sweep_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbefore_005fsweep_005fc_005fhook"> ¶</a></span></dt>
<dd><p>C hook called before beginning the sweep phase of garbage collection.
This is the same as at the end of the mark phase, since nothing else
happens between marking and sweeping.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fafter_005fsweep_005fc_005fhook"><span class="category-def">C Hook: </span><span><strong class="def-name">scm_after_sweep_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fafter_005fsweep_005fc_005fhook"> ¶</a></span></dt>
<dd><p>C hook called after the end of the sweep phase of garbage collection,
but while the GC thread is still inside its critical section.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-scm_005fafter_005fgc_005fc_005fhook"><span class="category-def">C Hook: </span><span><strong class="def-name">scm_after_gc_c_hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fafter_005fgc_005fc_005fhook"> ¶</a></span></dt>
<dd><p>C hook called at the very end of a garbage collection, after the GC
thread has left its critical section.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-after_002dgc_002dhook"><span class="category-def">Scheme Hook: </span><span><strong class="def-name">after-gc-hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-after_002dgc_002dhook"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-scm_005fafter_005fgc_005fhook"></a>
<p>Scheme hook with arity 0.  This hook is run asynchronously
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>) soon after the GC has completed and any other events
that were deferred during garbage collection have been processed.  (Also
accessible from C with the name <code class="code">scm_after_gc_hook</code>.)
</p></dd></dl>

<p>All the C hooks listed here have type <code class="code">SCM_C_HOOK_NORMAL</code>, are
initialized with hook closure data NULL, are invoked by
<code class="code">scm_c_hook_run</code> with call closure data NULL.
</p>
<a class="index-entry-id" id="index-guardians_002c-testing-for-GC_0027d-objects"></a>
<p>The Scheme hook <code class="code">after-gc-hook</code> is particularly useful in
conjunction with guardians (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Guardians">Guardians</a>).  Typically, if you are
using a guardian, you want to call the guardian after garbage collection
to see if any of the objects added to the guardian have been collected.
By adding a thunk that performs this call to <code class="code">after-gc-hook</code>, you
can ensure that your guardian is tested after every garbage collection
cycle.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="REPL-Hooks">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#GC-Hooks" accesskey="p" rel="prev">Hooks for Garbage Collection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Hooks" accesskey="u" rel="up">Hooks</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Hooks-into-the-Guile-REPL">6.9.6.5 Hooks into the Guile REPL</h4>



<hr>
</div>
</div>
</div>
<div class="section-level-extent" id="Binding-Constructs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="n" rel="next">Controlling the Flow of Program Execution</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Utility-Functions" accesskey="p" rel="prev">General Utility Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Definitions-and-Variable-Bindings">6.10 Definitions and Variable Bindings</h3>

<p>Scheme supports the definition of variables in different contexts.
Variables can be defined at the top level, so that they are visible in
the entire program, and variables can be defined locally to procedures
and expressions.  This is important for modularity and data abstraction.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level" accesskey="1">Top Level Variable Definitions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings" accesskey="2">Local Variable Bindings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions" accesskey="3">Internal definitions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection" accesskey="4">Querying variable bindings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Multiple-Values" accesskey="5">Binding multiple return values</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Top-Level">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings" accesskey="n" rel="next">Local Variable Bindings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="u" rel="up">Definitions and Variable Bindings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Top-Level-Variable-Definitions">6.10.1 Top Level Variable Definitions</h4>

<a class="index-entry-id" id="index-variable-definition"></a>

<p>At the top level of a program (i.e., not nested within any other
expression), a definition of the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define a <var class="var">value</var>)
</pre></div>

<p>defines a variable called <code class="code">a</code> and sets it to the value <var class="var">value</var>.
</p>
<p>If the variable already exists in the current module, because it has
already been created by a previous <code class="code">define</code> expression with the
same name, its value is simply changed to the new <var class="var">value</var>.  In this
case, then, the above form is completely equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(set! a <var class="var">value</var>)
</pre></div>

<p>This equivalence means that <code class="code">define</code> can be used interchangeably
with <code class="code">set!</code> to change the value of variables at the top level of
the REPL or a Scheme source file.  It is useful during interactive
development when reloading a Scheme file that you have modified, because
it allows the <code class="code">define</code> expressions in that file to work as expected
both the first time that the file is loaded and on subsequent occasions.
</p>
<p>Note, though, that <code class="code">define</code> and <code class="code">set!</code> are not always
equivalent.  For example, a <code class="code">set!</code> is not allowed if the named
variable does not already exist, and the two expressions can behave
differently in the case where there are imported variables visible from
another module.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define</strong> <var class="def-var-arguments">name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define"> ¶</a></span></dt>
<dd><p>Create a top level variable named <var class="var">name</var> with value <var class="var">value</var>.
If the named variable already exists, just change its value.  The return
value of a <code class="code">define</code> expression is unspecified.
</p></dd></dl>

<p>The C API equivalents of <code class="code">define</code> are <code class="code">scm_define</code> and
<code class="code">scm_c_define</code>, which differ from each other in whether the
variable name is specified as a <code class="code">SCM</code> symbol or as a
null-terminated C string.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-scm_005fdefine"><span class="category-def">C Function: </span><span><strong class="def-name">scm_define</strong> <var class="def-var-arguments">(sym, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdefine"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc_005fdefine"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c_define</strong> <var class="def-var-arguments">(const char *name, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fdefine"> ¶</a></span></dt>
<dd><p>C equivalents of <code class="code">define</code>, with variable name specified either by
<var class="var">sym</var>, a symbol, or by <var class="var">name</var>, a null-terminated C string.  Both
variants return the new or preexisting variable object.
</p></dd></dl>

<p><code class="code">define</code> (when it occurs at top level), <code class="code">scm_define</code> and
<code class="code">scm_c_define</code> all create or set the value of a variable in the top
level environment of the current module.  If there was not already a
variable with the specified name belonging to the current module, but a
similarly named variable from another module was visible through having
been imported, the newly created variable in the current module will
shadow the imported variable, such that the imported variable is no
longer visible.
</p>
<p>Attention: Scheme definitions inside local binding constructs
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>) act differently (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">Internal definitions</a>).
</p>
<p>Many people end up in a development style of adding and changing
definitions at runtime, building out their program without restarting
it.  (You can do this using <code class="code">reload-module</code>, the <code class="code">reload</code> REPL
command, the <code class="code">load</code> procedure, or even just pasting code into a
REPL.)  If you are one of these people, you will find that sometimes
there are some variables that you <em class="emph">don’t</em> want to redefine all the
time.  For these, use <code class="code">define-once</code>.
</p>
<a class="index-entry-id" id="index-defvar"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002donce"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-once</strong> <var class="def-var-arguments">name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002donce"> ¶</a></span></dt>
<dd><p>Create a top level variable named <var class="var">name</var> with value <var class="var">value</var>, but
only if <var class="var">name</var> is not already bound in the current module.
</p></dd></dl>

<p>Old Lispers probably know <code class="code">define-once</code> under its Lisp name,
<code class="code">defvar</code>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Local-Bindings">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions" accesskey="n" rel="next">Internal definitions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level" accesskey="p" rel="prev">Top Level Variable Definitions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="u" rel="up">Definitions and Variable Bindings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Local-Variable-Bindings">6.10.2 Local Variable Bindings</h4>

<a class="index-entry-id" id="index-local-bindings"></a>
<a class="index-entry-id" id="index-local-variables"></a>

<p>As opposed to definitions at the top level, which creates bindings that
are visible to all code in a module, it is also possible to define
variables which are only visible in a well-defined part of the program.
Normally, this part of a program will be a procedure or a subexpression
of a procedure.
</p>
<p>With the constructs for local binding (<code class="code">let</code>, <code class="code">let*</code>,
<code class="code">letrec</code>, and <code class="code">letrec*</code>), the Scheme language has a block
structure like most other programming languages since the days of
<small class="sc">ALGOL 60</small>.  Readers familiar to languages like C or Java should
already be used to this concept, but the family of <code class="code">let</code>
expressions has a few properties which are well worth knowing.
</p>
<p>The most basic local binding construct is <code class="code">let</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let"><span class="category-def">syntax: </span><span><strong class="def-name">let</strong> <var class="def-var-arguments">bindings body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let"> ¶</a></span></dt>
<dd><p><var class="var">bindings</var> has the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((<var class="var">variable1</var> <var class="var">init1</var>) …)
</pre></div>

<p>that is zero or more two-element lists of a variable and an arbitrary
expression each.  All <var class="var">variable</var> names must be distinct.
</p>
<p>A <code class="code">let</code> expression is evaluated as follows.
</p>
<ul class="itemize mark-bullet">
<li>All <var class="var">init</var> expressions are evaluated.

</li><li>New storage is allocated for the <var class="var">variables</var>.

</li><li>The values of the <var class="var">init</var> expressions are stored into the variables.

</li><li>The expressions in <var class="var">body</var> are evaluated in order, and the value of
the last expression is returned as the value of the <code class="code">let</code>
expression.
</li></ul>

<p>The <var class="var">init</var> expressions are not allowed to refer to any of the
<var class="var">variables</var>.
</p></dd></dl>

<p>The other binding constructs are variations on the same theme: making new
values, binding them to variables, and executing a body in that new,
extended lexical context.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let_002a"><span class="category-def">syntax: </span><span><strong class="def-name">let*</strong> <var class="def-var-arguments">bindings body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002a"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">let</code>, but the variable bindings are performed
sequentially, that means that all <var class="var">init</var> expression are allowed to
use the variables defined on their left in the binding list.
</p>
<p>A <code class="code">let*</code> expression can always be expressed with nested <code class="code">let</code>
expressions.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let* ((a 1) (b a))
   b)
≡
(let ((a 1))
  (let ((b a))
    b))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-letrec"><span class="category-def">syntax: </span><span><strong class="def-name">letrec</strong> <var class="def-var-arguments">bindings body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-letrec"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">let</code>, but it is possible to refer to the <var class="var">variable</var>
from lambda expression created in any of the <var class="var">inits</var>.  That is,
procedures created in the <var class="var">init</var> expression can recursively refer to
the defined variables.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(letrec ((even? (lambda (n)
                  (if (zero? n)
                      #t
                      (odd? (- n 1)))))
         (odd? (lambda (n)
                  (if (zero? n)
                      #f
                      (even? (- n 1))))))
  (even? 88))
⇒
#t
</pre></div>

<p>Note that while the <var class="var">init</var> expressions may refer to the new
variables, they may not access their values.  For example, making the
<code class="code">even?</code> function above creates a closure (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The Concept of Closure</a>)
referencing the <code class="code">odd?</code> variable.  But <code class="code">odd?</code> can’t be called
until after execution has entered the body.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-letrec_002a"><span class="category-def">syntax: </span><span><strong class="def-name">letrec*</strong> <var class="def-var-arguments">bindings body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-letrec_002a"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">letrec</code>, except the <var class="var">init</var> expressions are bound to
their variables in order.
</p>
<p><code class="code">letrec*</code> thus relaxes the letrec restriction, in that later
<var class="var">init</var> expressions may refer to the values of previously bound
variables.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(letrec ((a 42)
         (b (+ a 10)))  ;; Illegal access
  (* a b))
;; The behavior of the expression above is unspecified

(letrec* ((a 42)
          (b (+ a 10)))
  (* a b))
⇒ 2184
</pre></div>
</dd></dl>

<p>There is also an alternative form of the <code class="code">let</code> form, which is used
for expressing iteration.  Because of the use as a looping construct,
this form (the <em class="dfn">named let</em>) is documented in the section about
iteration (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#while-do">Iteration</a>)
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Internal-Definitions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection" accesskey="n" rel="next">Querying variable bindings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings" accesskey="p" rel="prev">Local Variable Bindings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="u" rel="up">Definitions and Variable Bindings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Internal-definitions">6.10.3 Internal definitions</h4>


<p>A <code class="code">define</code> form which appears inside the body of a <code class="code">lambda</code>,
<code class="code">let</code>, <code class="code">let*</code>, <code class="code">letrec</code>, <code class="code">letrec*</code> or equivalent
expression is called an <em class="dfn">internal definition</em>.  An internal
definition differs from a top level definition (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level Variable Definitions</a>),
because the definition is only visible inside the complete body of the
enclosing form.  Let us examine the following example.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((frumble "froz"))
  (define banana (lambda () (apple 'peach)))
  (define apple (lambda (x) x))
  (banana))
⇒
peach
</pre></div>

<p>Here the enclosing form is a <code class="code">let</code>, so the <code class="code">define</code>s in the
<code class="code">let</code>-body are internal definitions.  Because the scope of the
internal definitions is the <strong class="strong">complete</strong> body of the
<code class="code">let</code>-expression, the <code class="code">lambda</code>-expression which gets bound to
the variable <code class="code">banana</code> may refer to the variable <code class="code">apple</code>, even
though its definition appears lexically <em class="emph">after</em> the definition of
<code class="code">banana</code>.  This is because a sequence of internal definition acts
as if it were a <code class="code">letrec*</code> expression.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ()
  (define a 1)
  (define b 2)
  (+ a b))
</pre></div>

<p>is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ()
  (letrec* ((a 1) (b 2))
    (+ a b)))
</pre></div>

<p>Internal definitions may be mixed with non-definition expressions.  If
an expression precedes a definition, it is treated as if it were a
definition of an unreferenced variable.  So this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ()
  (define a 1)
  (foo)
  (define b 2)
  (+ a b))
</pre></div>

<p>is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ()
  (letrec* ((a 1) (_ (begin (foo) #f)) (b 2))
    (+ a b)))
</pre></div>

<p>Another noteworthy difference to top level definitions is that within
one group of internal definitions all variable names must be distinct.
Whereas on the top level a second define for a given variable acts like
a <code class="code">set!</code>, for internal definitions, duplicate bound identifiers
signals an error.
</p>
<p>As a historical note, it used to be that internal bindings were expanded
in terms of <code class="code">letrec</code>, not <code class="code">letrec*</code>. This was the situation
for the R5RS report and before. However with the R6RS, it was recognized
that sequential definition was a more intuitive expansion, as in the
following case:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ()
  (define a 1)
  (define b (+ a a))
  (+ a b))
</pre></div>

<p>Guile decided to follow the R6RS in this regard, and now expands
internal definitions using <code class="code">letrec*</code>.  Relatedly, it used to be
that internal definitions had to precede all expressions in the body;
this restriction was relaxed in Guile 3.0.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Binding-Reflection">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Multiple-Values" accesskey="n" rel="next">Binding multiple return values</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions" accesskey="p" rel="prev">Internal definitions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="u" rel="up">Definitions and Variable Bindings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Querying-variable-bindings">6.10.4 Querying variable bindings</h4>

<p>Guile provides a procedure for checking whether a symbol is bound in the
top level environment.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-defined_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">defined?</strong> <var class="def-var-arguments">sym [module]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-defined_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdefined_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_defined_p</strong> <var class="def-var-arguments">(sym, module)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdefined_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">sym</var> is defined in the module <var class="var">module</var> or
the current module when <var class="var">module</var> is not specified; otherwise return
<code class="code">#f</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Binding-Multiple-Values">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Reflection" accesskey="p" rel="prev">Querying variable bindings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="u" rel="up">Definitions and Variable Bindings</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Binding-multiple-return-values">6.10.5 Binding multiple return values</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002dvalues"><span class="category-def">Syntax: </span><span><strong class="def-name">define-values</strong> <var class="def-var-arguments">formals expression</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dvalues"> ¶</a></span></dt>
<dd><p>The <var class="var">expression</var> is evaluated, and the <var class="var">formals</var> are bound to
the return values in the same way that the formals in a <code class="code">lambda</code>
expression are matched to the arguments in a procedure call.
</p></dd></dl>

<div class="example">
<pre class="example-preformatted">(define-values (q r) (floor/ 10 3))
(list q r) ⇒ (3 1)

(define-values (x . y) (values 1 2 3))
x ⇒ 1
y ⇒ (2 3)

(define-values x (values 1 2 3))
x ⇒ (1 2 3)
</pre></div>



<hr>
</div>
</div>
<div class="section-level-extent" id="Control-Mechanisms">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="n" rel="next">Input and Output</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binding-Constructs" accesskey="p" rel="prev">Definitions and Variable Bindings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Controlling-the-Flow-of-Program-Execution">6.11 Controlling the Flow of Program Execution</h3>

<p>See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Control-Flow">Control Flow</a> for a discussion of how the more general control
flow of Scheme affects C code.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#begin" accesskey="1">Sequencing and Splicing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals" accesskey="2">Simple Conditional Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#and-or" accesskey="3">Conditional Evaluation of a Sequence of Expressions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#while-do" accesskey="4">Iteration mechanisms</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Prompts" accesskey="5">Prompts</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Continuations" accesskey="6">Continuations</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values" accesskey="7">Returning and Accepting Multiple Values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="8">Exceptions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting" accesskey="9">Procedures for Signaling Errors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Errors">How to Handle Errors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Continuation-Barriers">Continuation Barriers</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="begin">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals" accesskey="n" rel="next">Simple Conditional Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Sequencing-and-Splicing">6.11.1 Sequencing and Splicing</h4>

<a class="index-entry-id" id="index-begin"></a>
<a class="index-entry-id" id="index-sequencing"></a>
<a class="index-entry-id" id="index-expression-sequencing"></a>

<p>As an expression, the <code class="code">begin</code> syntax is used to evaluate a sequence
of sub-expressions in order.  Consider the conditional expression below:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(if (&gt; x 0)
    (begin (display "greater") (newline)))
</pre></div>

<p>If the test is true, we want to display “greater” to the current
output port, then display a newline.  We use <code class="code">begin</code> to form a
compound expression out of this sequence of sub-expressions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-begin-1"><span class="category-def">syntax: </span><span><strong class="def-name">begin</strong> <var class="def-var-arguments">expr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-begin-1"> ¶</a></span></dt>
<dd><p>The expression(s) are evaluated in left-to-right order and the value of
the last expression is returned as the value of the
<code class="code">begin</code>-expression.  This expression type is used when the
expressions before the last one are evaluated for their side effects.
</p></dd></dl>

<a class="index-entry-id" id="index-splicing"></a>
<a class="index-entry-id" id="index-definition-splicing"></a>

<p>The <code class="code">begin</code> syntax has another role in definition context
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Internal-Definitions">Internal definitions</a>).  A <code class="code">begin</code> form in a definition
context <em class="dfn">splices</em> its subforms into its place.  For example,
consider the following procedure:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-seal)
  (define-sealant seal open)
  (values seal open))
</pre></div>

<p>Let us assume the existence of a <code class="code">define-sealant</code> macro that
expands out to some definitions wrapped in a <code class="code">begin</code>, like so:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (make-seal)
  (begin
    (define seal-tag
      (list 'seal))
    (define (seal x)
      (cons seal-tag x))
    (define (sealed? x)
      (and (pair? x) (eq? (car x) seal-tag)))
    (define (open x)
      (if (sealed? x)
          (cdr x)
          (error "Expected a sealed value:" x))))
  (values seal open))
</pre></div>

<p>Here, because the <code class="code">begin</code> is in definition context, its subforms
are <em class="dfn">spliced</em> into the place of the <code class="code">begin</code>.  This allows the
definitions created by the macro to be visible to the following
expression, the <code class="code">values</code> form.
</p>
<p>It is a fine point, but splicing and sequencing are different.  It can
make sense to splice zero forms, because it can make sense to have zero
internal definitions before the expressions in a procedure or lexical
binding form.  However it does not make sense to have a sequence of zero
expressions, because in that case it would not be clear what the value
of the sequence would be, because in a sequence of zero expressions,
there can be no last value.  Sequencing zero expressions is an error.
</p>
<p>It would be more elegant in some ways to eliminate splicing from the
Scheme language, and without macros (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Macros">Macros</a>), that would be a
good idea.  But it is useful to be able to write macros that expand out
to multiple definitions, as in <code class="code">define-sealant</code> above, so Scheme
abuses the <code class="code">begin</code> form for these two tasks.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Conditionals">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#and-or" accesskey="n" rel="next">Conditional Evaluation of a Sequence of Expressions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#begin" accesskey="p" rel="prev">Sequencing and Splicing</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Simple-Conditional-Evaluation">6.11.2 Simple Conditional Evaluation</h4>

<a class="index-entry-id" id="index-conditional-evaluation"></a>
<a class="index-entry-id" id="index-if"></a>
<a class="index-entry-id" id="index-when"></a>
<a class="index-entry-id" id="index-unless"></a>
<a class="index-entry-id" id="index-case"></a>
<a class="index-entry-id" id="index-cond"></a>

<p>Guile provides three syntactic constructs for conditional evaluation.
<code class="code">if</code> is the normal if-then-else expression (with an optional else
branch), <code class="code">cond</code> is a conditional expression with multiple branches
and <code class="code">case</code> branches if an expression has one of a set of constant
values.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-if-1"><span class="category-def">syntax: </span><span><strong class="def-name">if</strong> <var class="def-var-arguments">test consequent [alternate]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if-1"> ¶</a></span></dt>
<dd><p>All arguments may be arbitrary expressions.  First, <var class="var">test</var> is
evaluated.  If it returns a true value, the expression <var class="var">consequent</var>
is evaluated and <var class="var">alternate</var> is ignored.  If <var class="var">test</var> evaluates to
<code class="code">#f</code>, <var class="var">alternate</var> is evaluated instead.  The values of the
evaluated branch (<var class="var">consequent</var> or <var class="var">alternate</var>) are returned as
the values of the <code class="code">if</code> expression.
</p>
<p>When <var class="var">alternate</var> is omitted and the <var class="var">test</var> evaluates to
<code class="code">#f</code>, the value of the expression is not specified.
</p></dd></dl>

<p>When you go to write an <code class="code">if</code> without an alternate (a <em class="dfn">one-armed
<code class="code">if</code></em>), part of what you are expressing is that you don’t care
about the return value (or values) of the expression.  As such, you are
more interested in the <em class="emph">effect</em> of evaluating the consequent
expression.  (By convention, we use the word <em class="dfn">statement</em> to refer to
an expression that is evaluated for effect, not for value).
</p>
<p>In such a case, it is considered more clear to express these intentions
with these special forms, <code class="code">when</code> and <code class="code">unless</code>.  As an added
bonus, these forms accept multiple statements to evaluate, which are
implicitly wrapped in a <code class="code">begin</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-when-1"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">when</strong> <var class="def-var-arguments">test statement1 statement2 ...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-when-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-unless-1"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">unless</strong> <var class="def-var-arguments">test statement1 statement2 ...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unless-1"> ¶</a></span></dt>
<dd><p>The actual definitions of these forms are in many ways their most clear
documentation:
</p>
<div class="example">
<pre class="example-preformatted">(define-syntax-rule (when test stmt stmt* ...)
  (if test (begin stmt stmt* ...)))

(define-syntax-rule (unless test stmt stmt* ...)
  (if (not test) (begin stmt stmt* ...)))
</pre></div>

<p>That is to say, <code class="code">when</code> evaluates its consequent statements in order
if <var class="var">test</var> is true.  <code class="code">unless</code> is the opposite: it evaluates the
statements if <var class="var">test</var> is false.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-cond-1"><span class="category-def">syntax: </span><span><strong class="def-name">cond</strong> <var class="def-var-arguments">clause1 clause2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cond-1"> ¶</a></span></dt>
<dd><p>Each <code class="code">cond</code>-clause must look like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">test</var> <var class="var">expression</var> …)
</pre></div>

<p>where <var class="var">test</var> and <var class="var">expression</var> are arbitrary expressions, or like
this
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">test</var> =&gt; <var class="var">expression</var>)
</pre></div>

<p>where <var class="var">expression</var> must evaluate to a procedure.
</p>
<p>The <var class="var">test</var>s of the clauses are evaluated in order and as soon as one
of them evaluates to a true value, the corresponding <var class="var">expression</var>s
are evaluated in order and the last value is returned as the value of
the <code class="code">cond</code>-expression.  For the <code class="code">=&gt;</code> clause type,
<var class="var">expression</var> is evaluated and the resulting procedure is applied to
the value of <var class="var">test</var>.  The result of this procedure application is
then the result of the <code class="code">cond</code>-expression.
</p>
<a class="index-entry-id" id="index-SRFI_002d61"></a>
<a class="index-entry-id" id="index-general-cond-clause"></a>
<a class="index-entry-id" id="index-multiple-values-and-cond"></a>
<p>One additional <code class="code">cond</code>-clause is available as an extension to
standard Scheme:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(<var class="var">test</var> <var class="var">guard</var> =&gt; <var class="var">expression</var>)
</pre></div>

<p>where <var class="var">guard</var> and <var class="var">expression</var> must evaluate to procedures.
For this clause type, <var class="var">test</var> may return multiple values, and
<code class="code">cond</code> ignores its boolean state; instead, <code class="code">cond</code> evaluates
<var class="var">guard</var> and applies the resulting procedure to the value(s) of
<var class="var">test</var>, as if <var class="var">guard</var> were the <var class="var">consumer</var> argument of
<code class="code">call-with-values</code>.  If the result of that procedure call is a
true value, it evaluates <var class="var">expression</var> and applies the resulting
procedure to the value(s) of <var class="var">test</var>, in the same manner as the
<var class="var">guard</var> was called.
</p>
<p>The <var class="var">test</var> of the last <var class="var">clause</var> may be the symbol <code class="code">else</code>.
Then, if none of the preceding <var class="var">test</var>s is true, the
<var class="var">expression</var>s following the <code class="code">else</code> are evaluated to produce the
result of the <code class="code">cond</code>-expression.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-case-1"><span class="category-def">syntax: </span><span><strong class="def-name">case</strong> <var class="def-var-arguments">key clause1 clause2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-case-1"> ¶</a></span></dt>
<dd><p><var class="var">key</var> may be any expression, and the <var class="var">clause</var>s must have the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((<var class="var">datum1</var> …) <var class="var">expr1</var> <var class="var">expr2</var> …)
</pre></div>

<p>or
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((<var class="var">datum1</var> …) =&gt; <var class="var">expression</var>)
</pre></div>

<p>and the last <var class="var">clause</var> may have the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(else <var class="var">expr1</var> <var class="var">expr2</var> …)
</pre></div>

<p>or
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(else =&gt; <var class="var">expression</var>)
</pre></div>

<p>All <var class="var">datum</var>s must be distinct.  First, <var class="var">key</var> is evaluated.  The
result of this evaluation is compared against all <var class="var">datum</var> values using
<code class="code">eqv?</code>.  When this comparison succeeds, the expression(s) following
the <var class="var">datum</var> are evaluated from left to right, returning the value of
the last expression as the result of the <code class="code">case</code> expression.
</p>
<p>If the <var class="var">key</var> matches no <var class="var">datum</var> and there is an
<code class="code">else</code>-clause, the expressions following the <code class="code">else</code> are
evaluated.  If there is no such clause, the result of the expression is
unspecified.
</p>
<p>For the <code class="code">=&gt;</code> clause types, <var class="var">expression</var> is evaluated and the
resulting procedure is applied to the value of <var class="var">key</var>.  The result of
this procedure application is then the result of the
<code class="code">case</code>-expression.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="and-or">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#while-do" accesskey="n" rel="next">Iteration mechanisms</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conditionals" accesskey="p" rel="prev">Simple Conditional Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Conditional-Evaluation-of-a-Sequence-of-Expressions">6.11.3 Conditional Evaluation of a Sequence of Expressions</h4>

<p><code class="code">and</code> and <code class="code">or</code> evaluate all their arguments in order, similar
to <code class="code">begin</code>, but evaluation stops as soon as one of the expressions
evaluates to false or true, respectively.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-and"><span class="category-def">syntax: </span><span><strong class="def-name">and</strong> <var class="def-var-arguments">expr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-and"> ¶</a></span></dt>
<dd><p>Evaluate the <var class="var">expr</var>s from left to right and stop evaluation as soon
as one expression evaluates to <code class="code">#f</code>; the remaining expressions are
not evaluated.  The value of the last evaluated expression is returned.
If no expression evaluates to <code class="code">#f</code>, the value of the last
expression is returned.
</p>
<p>If used without expressions, <code class="code">#t</code> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-or"><span class="category-def">syntax: </span><span><strong class="def-name">or</strong> <var class="def-var-arguments">expr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-or"> ¶</a></span></dt>
<dd><p>Evaluate the <var class="var">expr</var>s from left to right and stop evaluation as soon
as one expression evaluates to a true value (that is, a value different
from <code class="code">#f</code>); the remaining expressions are not evaluated.  The value
of the last evaluated expression is returned.  If all expressions
evaluate to <code class="code">#f</code>, <code class="code">#f</code> is returned.
</p>
<p>If used without expressions, <code class="code">#f</code> is returned.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="while-do">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Prompts" accesskey="n" rel="next">Prompts</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#and-or" accesskey="p" rel="prev">Conditional Evaluation of a Sequence of Expressions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Iteration-mechanisms">6.11.4 Iteration mechanisms</h4>

<a class="index-entry-id" id="index-iteration"></a>
<a class="index-entry-id" id="index-looping"></a>
<a class="index-entry-id" id="index-named-let"></a>

<p>Scheme has only few iteration mechanisms, mainly because iteration in
Scheme programs is normally expressed using recursion.  Nevertheless,
R5RS defines a construct for programming loops, calling <code class="code">do</code>.  In
addition, Guile has an explicit looping syntax called <code class="code">while</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-do"><span class="category-def">syntax: </span><span><strong class="def-name">do</strong> <var class="def-var-arguments">((variable init [step]) …) (test expr …) body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-do"> ¶</a></span></dt>
<dd><p>Bind <var class="var">variable</var>s and evaluate <var class="var">body</var> until <var class="var">test</var> is true.
The return value is the last <var class="var">expr</var> after <var class="var">test</var>, if given.  A
simple example will illustrate the basic form,
</p>
<div class="example">
<pre class="example-preformatted">(do ((i 1 (1+ i)))
    ((&gt; i 4))
  (display i))
-| 1234
</pre></div>

<p>Or with two variables and a final return value,
</p>
<div class="example">
<pre class="example-preformatted">(do ((i 1 (1+ i))
     (p 3 (* 3 p)))
    ((&gt; i 4)
     p)
  (format #t "3**~s is ~s\n" i p))
-|
3**1 is 3
3**2 is 9
3**3 is 27
3**4 is 81
⇒
243
</pre></div>

<p>The <var class="var">variable</var> bindings are established like a <code class="code">let</code>, in that
the expressions are all evaluated and then all bindings made.  When
iterating, the optional <var class="var">step</var> expressions are evaluated with the
previous bindings in scope, then new bindings all made.
</p>
<p>The <var class="var">test</var> expression is a termination condition.  Looping stops
when the <var class="var">test</var> is true.  It’s evaluated before running the
<var class="var">body</var> each time, so if it’s true the first time then <var class="var">body</var>
is not run at all.
</p>
<p>The optional <var class="var">expr</var>s after the <var class="var">test</var> are evaluated at the end
of looping, with the final <var class="var">variable</var> bindings available.  The
last <var class="var">expr</var> gives the return value, or if there are no <var class="var">expr</var>s
the return value is unspecified.
</p>
<p>Each iteration establishes bindings to fresh locations for the
<var class="var">variable</var>s, like a new <code class="code">let</code> for each iteration.  This is
done for <var class="var">variable</var>s without <var class="var">step</var> expressions too.  The
following illustrates this, showing how a new <code class="code">i</code> is captured by
the <code class="code">lambda</code> in each iteration (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The
Concept of Closure</a>).
</p>
<div class="example">
<pre class="example-preformatted">(define lst '())
(do ((i 1 (1+ i)))
    ((&gt; i 4))
  (set! lst (cons (lambda () i) lst)))
(map (lambda (proc) (proc)) lst)
⇒
(4 3 2 1)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-while"><span class="category-def">syntax: </span><span><strong class="def-name">while</strong> <var class="def-var-arguments">cond body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-while"> ¶</a></span></dt>
<dd><p>Run a loop executing the <var class="var">body</var> forms while <var class="var">cond</var> is true.
<var class="var">cond</var> is tested at the start of each iteration, so if it’s
<code class="code">#f</code> the first time then <var class="var">body</var> is not executed at all.
</p>
<p>Within <code class="code">while</code>, two extra bindings are provided, they can be used
from both <var class="var">cond</var> and <var class="var">body</var>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-break-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">break</strong> <var class="def-var-arguments">break-arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-break-1"> ¶</a></span></dt>
<dd><p>Break out of the <code class="code">while</code> form.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-continue"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">continue</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-continue"> ¶</a></span></dt>
<dd><p>Abandon the current iteration, go back to the start and test
<var class="var">cond</var> again, etc.
</p></dd></dl>

<p>If the loop terminates normally, by the <var class="var">cond</var> evaluating to
<code class="code">#f</code>, then the <code class="code">while</code> expression as a whole evaluates to
<code class="code">#f</code>.  If it terminates by a call to <code class="code">break</code> with some number
of arguments, those arguments are returned from the <code class="code">while</code>
expression, as multiple values.  Otherwise if it terminates by a call to
<code class="code">break</code> with no arguments, then return value is <code class="code">#t</code>.
</p>
<div class="example">
<pre class="example-preformatted">(while #f (error "not reached")) ⇒ #f
(while #t (break)) ⇒ #t
(while #t (break 1 2 3)) ⇒ 1 2 3
</pre></div>

<p>Each <code class="code">while</code> form gets its own <code class="code">break</code> and <code class="code">continue</code>
procedures, operating on that <code class="code">while</code>.  This means when loops are
nested the outer <code class="code">break</code> can be used to escape all the way out.
For example,
</p>
<div class="example">
<pre class="example-preformatted">(while (test1)
  (let ((outer-break break))
    (while (test2)
      (if (something)
        (outer-break #f))
      ...)))
</pre></div>

<p>Note that each <code class="code">break</code> and <code class="code">continue</code> procedure can only be
used within the dynamic extent of its <code class="code">while</code>.  Outside the
<code class="code">while</code> their behaviour is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-named-let-1"></a>
<p>Another very common way of expressing iteration in Scheme programs is
the use of the so-called <em class="dfn">named let</em>.
</p>
<p>Named let is a variant of <code class="code">let</code> which creates a procedure and calls
it in one step.  Because of the newly created procedure, named let is
more powerful than <code class="code">do</code>–it can be used for iteration, but also
for arbitrary recursion.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-let-1"><span class="category-def">syntax: </span><span><strong class="def-name">let</strong> <var class="def-var-arguments">variable bindings body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let-1"> ¶</a></span></dt>
<dd><p>For the definition of <var class="var">bindings</var> see the documentation about
<code class="code">let</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>).
</p>
<p>Named <code class="code">let</code> works as follows:
</p>
<ul class="itemize mark-bullet">
<li>A new procedure which accepts as many arguments as are in <var class="var">bindings</var>
is created and bound locally (using <code class="code">let</code>) to <var class="var">variable</var>.  The
new procedure’s formal argument names are the name of the
<var class="var">variables</var>.

</li><li>The <var class="var">body</var> expressions are inserted into the newly created procedure.

</li><li>The procedure is called with the <var class="var">init</var> expressions as the formal
arguments.
</li></ul>

<p>The next example implements a loop which iterates (by recursion) 1000
times.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let lp ((x 1000))
  (if (positive? x)
      (lp (- x 1))
      x))
⇒
0
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Prompts">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Continuations" accesskey="n" rel="next">Continuations</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#while-do" accesskey="p" rel="prev">Iteration mechanisms</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Prompts-1">6.11.5 Prompts</h4>
<a class="index-entry-id" id="index-prompts"></a>
<a class="index-entry-id" id="index-delimited-continuations"></a>
<a class="index-entry-id" id="index-composable-continuations"></a>
<a class="index-entry-id" id="index-non_002dlocal-exit"></a>

<p>Prompts are control-flow barriers between different parts of a program. In the
same way that a user sees a shell prompt (e.g., the Bash prompt) as a barrier
between the operating system and her programs, Scheme prompts allow the Scheme
programmer to treat parts of programs as if they were running in different
operating systems.
</p>
<p>We use this roundabout explanation because, unless you’re a functional
programming junkie, you probably haven’t heard the term, “delimited, composable
continuation”. That’s OK; it’s a relatively recent topic, but a very useful
one to know about.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Prompt-Primitives" accesskey="1">Prompt Primitives</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Shift-and-Reset" accesskey="2">Shift, Reset, and All That</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Prompt-Primitives">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Shift-and-Reset" accesskey="n" rel="next">Shift, Reset, and All That</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Prompts" accesskey="u" rel="up">Prompts</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Prompt-Primitives-1">6.11.5.1 Prompt Primitives</h4>

<p>Guile’s primitive delimited control operators are
<code class="code">call-with-prompt</code> and <code class="code">abort-to-prompt</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dprompt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-prompt</strong> <var class="def-var-arguments">tag thunk handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dprompt"> ¶</a></span></dt>
<dd><p>Set up a prompt, and call <var class="var">thunk</var> within that prompt.
</p>
<p>During the dynamic extent of the call to <var class="var">thunk</var>, a prompt named <var class="var">tag</var>
will be present in the dynamic context, such that if a user calls
<code class="code">abort-to-prompt</code> (see below) with that tag, control rewinds back to the
prompt, and the <var class="var">handler</var> is run.
</p>
<p><var class="var">handler</var> must be a procedure. The first argument to <var class="var">handler</var> will be
the state of the computation begun when <var class="var">thunk</var> was called, and ending with
the call to <code class="code">abort-to-prompt</code>. The remaining arguments to <var class="var">handler</var> are
those passed to <code class="code">abort-to-prompt</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dprompt_002dtag"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-prompt-tag</strong> <var class="def-var-arguments">[stem]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dprompt_002dtag"> ¶</a></span></dt>
<dd><p>Make a new prompt tag.  A prompt tag is simply a unique object.
Currently, a prompt tag is a fresh pair.  This may change in some future
Guile version.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-default_002dprompt_002dtag"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">default-prompt-tag</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-default_002dprompt_002dtag"> ¶</a></span></dt>
<dd><p>Return the default prompt tag.  Having a distinguished default prompt
tag allows some useful prompt and abort idioms, discussed in the next
section.  Note that <code class="code">default-prompt-tag</code> is actually a parameter,
and so may be dynamically rebound using <code class="code">parameterize</code>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-abort_002dto_002dprompt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">abort-to-prompt</strong> <var class="def-var-arguments">tag val1 val2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-abort_002dto_002dprompt"> ¶</a></span></dt>
<dd><p>Unwind the dynamic and control context to the nearest prompt named <var class="var">tag</var>,
also passing the given values.
</p></dd></dl>

<p>C programmers may recognize <code class="code">call-with-prompt</code> and
<code class="code">abort-to-prompt</code> as a fancy kind of <code class="code">setjmp</code> and
<code class="code">longjmp</code>, respectively. Prompts are indeed quite useful as
non-local escape mechanisms. Guile’s <code class="code">with-exception-handler</code> and
<code class="code">raise-exception</code> are implemented in terms of prompts. Prompts are
more convenient than <code class="code">longjmp</code>, in that one has the opportunity to
pass multiple values to the jump target.
</p>
<p>Also unlike <code class="code">longjmp</code>, the prompt handler is given the full state of the
process that was aborted, as the first argument to the prompt’s handler. That
state is the <em class="dfn">continuation</em> of the computation wrapped by the prompt. It is
a <em class="dfn">delimited continuation</em>, because it is not the whole continuation of the
program; rather, just the computation initiated by the call to
<code class="code">call-with-prompt</code>.
</p>
<p>The continuation is a procedure, and may be reinstated simply by invoking it,
with any number of values. Here’s where things get interesting, and complicated
as well. Besides being described as delimited, continuations reified by prompts
are also <em class="dfn">composable</em>, because invoking a prompt-saved continuation composes
that continuation with the current one.
</p>
<p>Imagine you have saved a continuation via call-with-prompt:
</p>
<div class="example">
<pre class="example-preformatted">(define cont
  (call-with-prompt
   ;; tag
   'foo
   ;; thunk
   (lambda ()
     (+ 34 (abort-to-prompt 'foo)))
   ;; handler
   (lambda (k) k)))
</pre></div>

<p>The resulting continuation is the addition of 34. It’s as if you had written:
</p>
<div class="example">
<pre class="example-preformatted">(define cont
  (lambda (x)
    (+ 34 x)))
</pre></div>

<p>So, if we call <code class="code">cont</code> with one numeric value, we get that number,
incremented by 34:
</p>
<div class="example">
<pre class="example-preformatted">(cont 8)
⇒ 42
(* 2 (cont 8))
⇒ 84
</pre></div>

<p>The last example illustrates what we mean when we say, "composes with the
current continuation". We mean that there is a current continuation – some
remaining things to compute, like <code class="code">(lambda (x) (* x 2))</code> – and that
calling the saved continuation doesn’t wipe out the current continuation, it
composes the saved continuation with the current one.
</p>
<p>We’re belaboring the point here because traditional Scheme continuations, as
discussed in the next section, aren’t composable, and are actually less
expressive than continuations captured by prompts. But there’s a place for them
both.
</p>
<p>Before moving on, we should mention that if the handler of a prompt is a
<code class="code">lambda</code> expression, and the first argument isn’t referenced, an abort to
that prompt will not cause a continuation to be reified.  This can be an
important efficiency consideration to keep in mind.
</p>
<a class="index-entry-id" id="index-continuation_002c-escape"></a>
<p>One example where this optimization matters is <em class="dfn">escape
continuations</em>.  Escape continuations are delimited continuations whose
only use is to make a non-local exit—i.e., to escape from the current
continuation.  A common use of escape continuations is when handling an
exception (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>).
</p>
<p>The constructs below are syntactic sugar atop prompts to simplify the
use of escape continuations.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002descape_002dcontinuation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-escape-continuation</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002descape_002dcontinuation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-call_002fec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call/ec</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002fec"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> with an escape continuation.
</p>
<p>In the example below, the <var class="var">return</var> continuation is used to escape
the continuation of the call to <code class="code">fold</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 control)
             (srfi srfi-1))

(define (prefix x lst)
  ;; Return all the elements before the first occurrence
  ;; of X in LST.
  (call/ec
    (lambda (return)
      (fold (lambda (element prefix)
              (if (equal? element x)
                  (return (reverse prefix))  ; escape `fold'
                  (cons element prefix)))
            '()
            lst))))

(prefix 'a '(0 1 2 a 3 4 5))
⇒ (0 1 2)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-let_002descape_002dcontinuation"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">let-escape-continuation</strong> <var class="def-var-arguments">k body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002descape_002dcontinuation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-let_002fec"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">let/ec</strong> <var class="def-var-arguments">k body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-let_002fec"> ¶</a></span></dt>
<dd><p>Bind <var class="var">k</var> within <var class="var">body</var> to an escape continuation.
</p>
<p>This is equivalent to
<code class="code">(call/ec (lambda (<var class="var">k</var>) <var class="var">body</var> …))</code>.
</p></dd></dl>

<p>Additionally there is another helper primitive exported by <code class="code">(ice-9
control)</code>, so load up that module for <code class="code">suspendable-continuation?</code>:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 control))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-suspendable_002dcontinuation_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">suspendable-continuation?</strong> <var class="def-var-arguments">tag</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-suspendable_002dcontinuation_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if a call to <code class="code">abort-to-prompt</code> with the prompt tag
<var class="var">tag</var> would produce a delimited continuation that could be resumed
later.
</p>
<p>Almost all continuations have this property.  The exception is where
some code between the <code class="code">call-with-prompt</code> and the
<code class="code">abort-to-prompt</code> recursed through C for some reason, the
<code class="code">abort-to-prompt</code> will succeed but any attempt to resume the
continuation (by calling it) would fail.  This is because composing a
saved continuation with the current continuation involves relocating the
stack frames that were saved from the old stack onto a (possibly) new
position on the new stack, and Guile can only do this for stack frames
that it created for Scheme code, not stack frames created by the C
compiler.  It’s a bit gnarly but if you stick with Scheme, you won’t
have any problem.
</p>
<p>If no prompt is found with the given tag, this procedure just returns
<code class="code">#f</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Shift-and-Reset">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Prompt-Primitives" accesskey="p" rel="prev">Prompt Primitives</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Prompts" accesskey="u" rel="up">Prompts</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Shift_002c-Reset_002c-and-All-That">6.11.5.2 Shift, Reset, and All That</h4>

<p>There is a whole zoo of delimited control operators, and as it does not
seem to be a bounded set, Guile implements support for them in a
separate module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 control))
</pre></div>

<p>Firstly, we have a helpful abbreviation for the <code class="code">call-with-prompt</code>
operator.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_0025"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">%</strong> <var class="def-var-arguments">expr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_0025-1"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">%</strong> <var class="def-var-arguments">expr handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-_0025-2"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">%</strong> <var class="def-var-arguments">tag expr handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025-2"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">expr</var> in a prompt, optionally specifying a tag and a
handler.  If no tag is given, the default prompt tag is used.
</p>
<p>If no handler is given, a default handler is installed.  The default
handler accepts a procedure of one argument, which will be called on
the captured continuation, within a prompt.
</p>
<p>Sometimes it’s easier just to show code, as in this case:
</p>
<div class="example">
<pre class="example-preformatted">(define (default-prompt-handler k proc)
  (% (default-prompt-tag)
     (proc k)
     default-prompt-handler))
</pre></div>

<p>The <code class="code">%</code> symbol is chosen because it looks like a prompt.
</p></dd></dl>

<p>Likewise there is an abbreviation for <code class="code">abort-to-prompt</code>, which
assumes the default prompt tag:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-abort"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">abort</strong> <var class="def-var-arguments">val1 val2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-abort"> ¶</a></span></dt>
<dd><p>Abort to the default prompt tag, passing <var class="var">val1</var> <var class="var">val2</var> …
to the handler.
</p></dd></dl>

<p>As mentioned before, <code class="code">(ice-9 control)</code> also provides other
delimited control operators.  This section is a bit technical, and
first-time users of delimited continuations should probably come back to
it after some practice with <code class="code">%</code>.
</p>
<p>Still here?  So, when one implements a delimited control operator like
<code class="code">call-with-prompt</code>, one needs to make two decisions.  Firstly, does
the handler run within or outside the prompt?  Having the handler run
within the prompt allows an abort inside the handler to return to the
same prompt handler, which is often useful.  However it prevents tail
calls from the handler, so it is less general.
</p>
<p>Similarly, does invoking a captured continuation reinstate a prompt?
Again we have the tradeoff of convenience versus proper tail calls.
</p>
<p>These decisions are captured in the Felleisen <em class="dfn">F</em> operator.  If
neither the continuations nor the handlers implicitly add a prompt, the
operator is known as <em class="dfn">–F–</em>.  This is the case for Guile’s
<code class="code">call-with-prompt</code> and <code class="code">abort-to-prompt</code>.
</p>
<p>If both continuation and handler implicitly add prompts, then the
operator is <em class="dfn">+F+</em>.  <code class="code">shift</code> and <code class="code">reset</code> are such
operators.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-reset"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">reset</strong> <var class="def-var-arguments">body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reset"> ¶</a></span></dt>
<dd><p>Establish a prompt, and evaluate <var class="var">body1</var> <var class="var">body2</var> … within
that prompt.
</p>
<p>The prompt handler is designed to work with <code class="code">shift</code>, described
below.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-shift"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">shift</strong> <var class="def-var-arguments">cont body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-shift"> ¶</a></span></dt>
<dd><p>Abort to the nearest <code class="code">reset</code>, and evaluate <var class="var">body1</var> <var class="var">body2</var>
… in a context in which the captured continuation is bound to
<var class="var">cont</var>.
</p>
<p>As mentioned above, taken together, the <var class="var">body1</var> <var class="var">body2</var> …
expressions and the invocations of <var class="var">cont</var> implicitly establish a
prompt.
</p></dd></dl>

<p>Interested readers are invited to explore Oleg Kiselyov’s wonderful web
site at <a class="uref" href="http://okmij.org/ftp/">http://okmij.org/ftp/</a>, for more information on these
operators.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Continuations">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values" accesskey="n" rel="next">Returning and Accepting Multiple Values</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Prompts" accesskey="p" rel="prev">Prompts</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Continuations-1">6.11.6 Continuations</h4>
<a class="index-entry-id" id="index-continuations"></a>

<p>A “continuation” is the code that will execute when a given function
or expression returns.  For example, consider
</p>
<div class="example">
<pre class="example-preformatted">(define (foo)
  (display "hello\n")
  (display (bar)) (newline)
  (exit))
</pre></div>

<p>The continuation from the call to <code class="code">bar</code> comprises a
<code class="code">display</code> of the value returned, a <code class="code">newline</code> and an
<code class="code">exit</code>.  This can be expressed as a function of one argument.
</p>
<div class="example">
<pre class="example-preformatted">(lambda (r)
  (display r) (newline)
  (exit))
</pre></div>

<p>In Scheme, continuations are represented as special procedures just
like this.  The special property is that when a continuation is called
it abandons the current program location and jumps directly to that
represented by the continuation.
</p>
<p>A continuation is like a dynamic label, capturing at run-time a point
in program execution, including all the nested calls that have lead to
it (or rather the code that will execute when those calls return).
</p>
<p>Continuations are created with the following functions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dcurrent_002dcontinuation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-current-continuation</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dcurrent_002dcontinuation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-call_002fcc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call/cc</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002fcc"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-call_002dwith_002dcurrent_002dcontinuation-2"></a>
<p>Capture the current continuation and call <code class="code">(<var class="var">proc</var>
<var class="var">cont</var>)</code> with it.  The return value is the value returned by
<var class="var">proc</var>, or when <code class="code">(<var class="var">cont</var> <var class="var">value</var>)</code> is later invoked,
the return is the <var class="var">value</var> passed.
</p>
<p>Normally <var class="var">cont</var> should be called with one argument, but when the
location resumed is expecting multiple values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>) then they should be passed as multiple arguments, for
instance <code class="code">(<var class="var">cont</var> <var class="var">x</var> <var class="var">y</var> <var class="var">z</var>)</code>.
</p>
<p><var class="var">cont</var> may only be used from the same side of a continuation
barrier as it was created (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Continuation-Barriers">Continuation Barriers</a>), and in a
multi-threaded program only from the thread in which it was created.
</p>
<p>The call to <var class="var">proc</var> is not part of the continuation captured, it runs
only when the continuation is created.  Often a program will want to
store <var class="var">cont</var> somewhere for later use; this can be done in
<var class="var">proc</var>.
</p>
<p>The <code class="code">call</code> in the name <code class="code">call-with-current-continuation</code>
refers to the way a call to <var class="var">proc</var> gives the newly created
continuation.  It’s not related to the way a call is used later to
invoke that continuation.
</p>
<p><code class="code">call/cc</code> is an alias for <code class="code">call-with-current-continuation</code>.
This is in common use since the latter is rather long.
</p></dd></dl>

<br>
<p>Here is a simple example,
</p>
<div class="example">
<pre class="example-preformatted">(define kont #f)
(format #t "the return is ~a\n"
        (call/cc (lambda (k)
                   (set! kont k)
                   1)))
⇒ the return is 1

(kont 2)
⇒ the return is 2
</pre></div>

<p><code class="code">call/cc</code> captures a continuation in which the value returned is
going to be displayed by <code class="code">format</code>.  The <code class="code">lambda</code> stores this
in <code class="code">kont</code> and gives an initial return <code class="code">1</code> which is
displayed.  The later invocation of <code class="code">kont</code> resumes the captured
point, but this time returning <code class="code">2</code>, which is displayed.
</p>
<p>When Guile is run interactively, a call to <code class="code">format</code> like this has
an implicit return back to the read-eval-print loop.  <code class="code">call/cc</code>
captures that like any other return, which is why interactively
<code class="code">kont</code> will come back to read more input.
</p>
<br>
<p>C programmers may note that <code class="code">call/cc</code> is like <code class="code">setjmp</code> in
the way it records at runtime a point in program execution.  A call to
a continuation is like a <code class="code">longjmp</code> in that it abandons the
present location and goes to the recorded one.  Like <code class="code">longjmp</code>,
the value passed to the continuation is the value returned by
<code class="code">call/cc</code> on resuming there.  However <code class="code">longjmp</code> can only go
up the program stack, but the continuation mechanism can go anywhere.
</p>
<p>When a continuation is invoked, <code class="code">call/cc</code> and subsequent code
effectively “returns” a second time.  It can be confusing to imagine
a function returning more times than it was called.  It may help
instead to think of it being stealthily re-entered and then program
flow going on as normal.
</p>
<p><code class="code">dynamic-wind</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>) can be used to ensure setup
and cleanup code is run when a program locus is resumed or abandoned
through the continuation mechanism.
</p>
<br>
<p>Continuations are a powerful mechanism, and can be used to implement
almost any sort of control structure, such as loops, coroutines, or
exception handlers.
</p>
<p>However the implementation of continuations in Guile is not as
efficient as one might hope, because Guile is designed to cooperate
with programs written in other languages, such as C, which do not know
about continuations.  Basically continuations are captured by a block
copy of the stack, and resumed by copying back.
</p>
<p>For this reason, continuations captured by <code class="code">call/cc</code> should be used only
when there is no other simple way to achieve the desired result, or when the
elegance of the continuation mechanism outweighs the need for performance.
</p>
<p>Escapes upwards from loops or nested functions are generally best
handled with prompts (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">Prompts</a>).  Coroutines can be
efficiently implemented with cooperating threads (a thread holds a
full program stack but doesn’t copy it around the way continuations
do).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Multiple-Values">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="n" rel="next">Exceptions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Continuations" accesskey="p" rel="prev">Continuations</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Returning-and-Accepting-Multiple-Values">6.11.7 Returning and Accepting Multiple Values</h4>

<a class="index-entry-id" id="index-multiple-values"></a>
<a class="index-entry-id" id="index-receive"></a>

<p>Scheme allows a procedure to return more than one value to its caller.
This is quite different to other languages which only allow
single-value returns.  Returning multiple values is different from
returning a list (or pair or vector) of values to the caller, because
conceptually not <em class="emph">one</em> compound object is returned, but several
distinct values.
</p>
<p>The primitive procedures for handling multiple values are <code class="code">values</code>
and <code class="code">call-with-values</code>.  <code class="code">values</code> is used for returning
multiple values from a procedure.  This is done by placing a call to
<code class="code">values</code> with zero or more arguments in tail position in a
procedure body.  <code class="code">call-with-values</code> combines a procedure returning
multiple values with a procedure which accepts these values as
parameters.
</p>
<a class="index-entry-id" id="index-values-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-values"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">values</strong> <var class="def-var-arguments">arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-values"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvalues"><span class="category-def">C Function: </span><span><strong class="def-name">scm_values</strong> <var class="def-var-arguments">(args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvalues"> ¶</a></span></dt>
<dd><p>Delivers all of its arguments to its continuation.  Except for
continuations created by the <code class="code">call-with-values</code> procedure,
all continuations take exactly one value.  The effect of
passing no value or more than one value to continuations that
were not created by <code class="code">call-with-values</code> is unspecified.
</p>
<p>For <code class="code">scm_values</code>, <var class="var">args</var> is a list of arguments and the
return is a multiple-values object which the caller can return.  In
the current implementation that object shares structure with
<var class="var">args</var>, so <var class="var">args</var> should not be modified subsequently.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fvalues"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_values</strong> <code class="def-code-arguments">(SCM *base, size_t n)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fvalues"> ¶</a></span></dt>
<dd><p><code class="code">scm_c_values</code> is an alternative to <code class="code">scm_values</code>.  It creates
a new values object, and copies into it the <var class="var">n</var> values starting from
<var class="var">base</var>.
</p>
<p>Currently this creates a list and passes it to <code class="code">scm_values</code>, but we
expect that in the future we will be able to use a more efficient
representation.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fnvalues"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_nvalues</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fnvalues"> ¶</a></span></dt>
<dd><p>If <var class="var">obj</var> is a multiple-values object, returns the number of values
it contains.  Otherwise returns 1.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fvalue_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_value_ref</strong> <code class="def-code-arguments">(SCM obj, size_t idx)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fvalue_005fref"> ¶</a></span></dt>
<dd><p>Returns the value at the position specified by <var class="var">idx</var> in
<var class="var">obj</var>.  Note that <var class="var">obj</var> will ordinarily be a
multiple-values object, but it need not be.  Any other object
represents a single value (itself), and is handled appropriately.
</p></dd></dl>

<a class="index-entry-id" id="index-call_002dwith_002dvalues-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dvalues"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-values</strong> <var class="def-var-arguments">producer consumer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dvalues"> ¶</a></span></dt>
<dd><p>Calls its <var class="var">producer</var> argument with no values and a
continuation that, when passed some values, calls the
<var class="var">consumer</var> procedure with those values as arguments.  The
continuation for the call to <var class="var">consumer</var> is the continuation
of the call to <code class="code">call-with-values</code>.
</p>
<div class="example">
<pre class="example-preformatted">(call-with-values (lambda () (values 4 5))
                  (lambda (a b) b))
⇒ 5

</pre></div>
<div class="example">
<pre class="example-preformatted">(call-with-values * -)
⇒ -1
</pre></div>
</dd></dl>

<p>In addition to the fundamental procedures described above, Guile has a
module which exports a syntax called <code class="code">receive</code>, which is much
more convenient.  This is in the <code class="code">(ice-9 receive)</code> and is the
same as specified by SRFI-8 (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d8">SRFI-8 - receive</a>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 receive))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-receive-1"><span class="category-def">library syntax: </span><span><strong class="def-name">receive</strong> <var class="def-var-arguments">formals expr body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-receive-1"> ¶</a></span></dt>
<dd><p>Evaluate the expression <var class="var">expr</var>, and bind the result values (zero
or more) to the formal arguments in <var class="var">formals</var>.  <var class="var">formals</var> is a
list of symbols, like the argument list in a <code class="code">lambda</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Lambda">Lambda: Basic Procedure Creation</a>).  After binding the variables, the expressions in
<var class="var">body</var> … are evaluated in order, the return value is the
result from the last expression.
</p>
<p>For example getting results from <code class="code">partition</code> in SRFI-1
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1">SRFI-1 - List library</a>),
</p>
<div class="example">
<pre class="example-preformatted">(receive (odds evens)
    (partition odd? '(7 4 2 8 3))
  (display odds)
  (display " and ")
  (display evens))
-| (7 3) and (4 2 8)
</pre></div>

</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Exceptions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting" accesskey="n" rel="next">Procedures for Signaling Errors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values" accesskey="p" rel="prev">Returning and Accepting Multiple Values</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Exceptions-1">6.11.8 Exceptions</h4>
<a class="index-entry-id" id="index-error-handling"></a>
<a class="index-entry-id" id="index-exception-handling"></a>

<p>What happens when things go wrong?  Guile’s exception facility exists to
help answer this question, allowing programs to describe the problem and
to handle the situation in a flexible way.
</p>
<p>When a program runs into a problem, such as division by zero, it will
raise an exception.  Sometimes exceptions get raised by Guile on a
program’s behalf.  Sometimes a program will want to raise exceptions of
its own.  Raising an exception stops the current computation and instead
invokes the current exception handler, passing it an exception object
describing the unexpected situation.
</p>
<p>Usually an exception handler will unwind the computation back to some
kind of safe point.  For example, typical logic for a key press driven
application might look something like this:
</p>
<div class="example">
<pre class="example-preformatted">main-loop:
  read the next key press and call dispatch-key

dispatch-key:
  lookup the key in a keymap and call an appropriate procedure,
  say find-file

find-file:
  interactively read the required file name, then call
  find-specified-file

find-specified-file:
  check whether file exists; if not, raise an exception
  …
</pre></div>

<p>In this case, <code class="code">main-loop</code> can install an exception handler that
would cause any exception raised inside <code class="code">dispatch-key</code> to print a
warning and jump back to the main loop.
</p>
<p>The following subsections go into more detail about exception objects,
raising exceptions, and handling exceptions.  It also presents a
historical interface that was used in Guile’s first 25 years and which
won’t be going away any time soon.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Exception-Objects" accesskey="1">Exception Objects</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions" accesskey="2">Raising and Handling Exceptions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Throw-and-Catch" accesskey="3">Throw and Catch</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions-and-C" accesskey="4">Exceptions and C</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Exception-Objects">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions" accesskey="n" rel="next">Raising and Handling Exceptions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="u" rel="up">Exceptions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Exception-Objects-1">6.11.8.1 Exception Objects</h4>

<p>When Guile encounters an exceptional situation, it raises an exception,
where the exception is an object that describes the exceptional
situation.  Exception objects are structured data, built on the record
facility (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a>).
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-_0026exception"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;exception</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026exception"> ¶</a></span></dt>
<dd><p>The base exception type.  All exception objects are composed of
instances of subtypes of <code class="code">&amp;exception</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_002dtype_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-type?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dtype_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is an exception type.
</p></dd></dl>

<p>Exception types exist in a hierarchy.  New exception types can be
defined using <code class="code">make-exception-type</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception-type</strong> <var class="def-var-arguments">id parent field-names</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception_002dtype"> ¶</a></span></dt>
<dd><p>Return a new exception type named <var class="var">id</var>, inheriting from
<var class="var">parent</var>, and with the fields whose names are listed in
<var class="var">field-names</var>.  <var class="var">field-names</var> must be a list of symbols and must
not contain names already used by <var class="var">parent</var> or one of its supertypes.
</p></dd></dl>

<p>Exception type objects are record type objects, and as such, one can use
<code class="code">record-constructor</code> on an exception type to get its constructor.
The constructor will take as many arguments as the exception has fields
(including supertypes).  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a>.
</p>
<p>However, <code class="code">record-predicate</code> and <code class="code">record-accessor</code> aren’t
usually what you want to use as exception type predicates and field
accessors.  The reason is, instances of exception types can be composed
into <em class="dfn">compound exceptions</em>.  Exception accessors should pick out the
specific component of a compound exception, and then access the field on
that specific component.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception</strong> <var class="def-var-arguments">exceptions …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception"> ¶</a></span></dt>
<dd><p>Return an exception object composed of <var class="var">exceptions</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is an exception object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_002dpredicate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-predicate</strong> <var class="def-var-arguments">type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dpredicate"> ¶</a></span></dt>
<dd><p>Return a procedure that will return true if its argument is a simple
exception that is an instance of <var class="var">type</var>, or a compound exception
composed of such an instance.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_002daccessor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-accessor</strong> <var class="def-var-arguments">rtd proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002daccessor"> ¶</a></span></dt>
<dd><p>Return a procedure that will tail-call <var class="var">proc</var> on an instance of the
exception type <var class="var">rtd</var>, or on the component of a compound exception
that is an instance of <var class="var">rtd</var>.
</p></dd></dl>

<p>Compound exceptions are useful to separately express the different
aspects of a situation.  For example, compound exceptions allow a
programmer to say that “this situation is a programming error, and also
here’s a useful message to show to the user, and here are some relevant
objects that can give more information about the error”.  This error
could be composed of instances of the <code class="code">&amp;programming-error</code>,
<code class="code">&amp;message</code>, and <code class="code">&amp;irritants</code> exception types.
</p>
<p>The subtyping relationship in exceptions is useful to let
different-but-similar situations to be treated the same; for example
there are many varieties of programming errors (for example,
divide-by-zero or type mismatches), but perhaps there are common ways
that the user would like to handle them all, and that common way might
be different than how one might handle an error originating outside the
program (for example, a file-not-found error).
</p>
<p>The standard exception hierarchy in Guile takes its cues from R6RS,
though the names of some of the types are different.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#rnrs-exceptions">rnrs exceptions</a>, for more details.
</p>
<p>To have access to Guile’s exception type hierarchy, import the
<code class="code">(ice-9 exceptions)</code> module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 exceptions))
</pre></div>

<p>The following diagram gives an overview of the standard exception type
hierarchy.
</p>
<div class="example">
<pre class="example-preformatted">&amp;exception
|- &amp;warning
|- &amp;message
|- &amp;irritants
|- &amp;origin
\- &amp;error
   |- &amp;external-error
   \- &amp;programming-error
      |- &amp;assertion-failure
      |- &amp;non-continuable
      |- &amp;implementation-restriction
      |- &amp;lexical
      |- &amp;syntax
      \- &amp;undefined-variable
</pre></div>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026warning-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;warning</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026warning-1"> ¶</a></span></dt>
<dd><p>An exception type denoting warnings.  These are usually raised using
<code class="code">#:continuable? #t</code>; see the <code class="code">raise-exception</code> documentation
for more.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dwarning"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-warning</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dwarning"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-warning_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">warning?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-warning_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;warning</code> exception objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026message-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;message</strong> <var class="def-var-arguments">message</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026message-1"> ¶</a></span></dt>
<dd><p>An exception type that provides a message to display to the user.
Usually used as a component of a compound exception.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception_002dwith_002dmessage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception-with-message</strong> <var class="def-var-arguments">message</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception_002dwith_002dmessage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dwith_002dmessage_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-with-message?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dwith_002dmessage_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dmessage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-message</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dmessage"> ¶</a></span></dt>
<dd><p>Constructor, predicate, and accessor for <code class="code">&amp;message</code> exception
objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026irritants-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;irritants</strong> <var class="def-var-arguments">irritants</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026irritants-1"> ¶</a></span></dt>
<dd><p>An exception type that provides a list of objects that were unexpected
in some way.  Usually used as a component of a compound exception.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception_002dwith_002dirritants"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception-with-irritants</strong> <var class="def-var-arguments">irritants</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception_002dwith_002dirritants"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dwith_002dirritants_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-with-irritants?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dwith_002dirritants_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dirritants"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-irritants</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dirritants"> ¶</a></span></dt>
<dd><p>Constructor, predicate, and accessor for <code class="code">&amp;irritants</code> exception
objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026origin"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;origin</strong> <var class="def-var-arguments">origin</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026origin"> ¶</a></span></dt>
<dd><p>An exception type that indicates the origin of an exception, typically
expressed as a procedure name, as a symbol.  Usually used as a component
of a compound exception.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception_002dwith_002dorigin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception-with-origin</strong> <var class="def-var-arguments">origin</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception_002dwith_002dorigin"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dwith_002dorigin_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-with-origin?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dwith_002dorigin_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exception_002dorigin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-origin</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dorigin"> ¶</a></span></dt>
<dd><p>Constructor, predicate, and accessor for <code class="code">&amp;origin</code> exception
objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026error-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026error-1"> ¶</a></span></dt>
<dd><p>An exception type denoting errors: situations that are not just
exceptional, but wrong.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-error_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;error</code> exception objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026external_002derror"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;external-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026external_002derror"> ¶</a></span></dt>
<dd><p>An exception type denoting errors that proceed from the interaction of
the program with the world, for example a “file not found” error.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexternal_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-external-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexternal_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-external_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">external-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-external_002derror_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;external-error</code> exception objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026programming_002derror"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;programming-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026programming_002derror"> ¶</a></span></dt>
<dd><p>An exception type denoting errors that proceed from inside a program:
type mismatches and so on.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dprogramming_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-programming-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dprogramming_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-programming_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">programming-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-programming_002derror_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;programming-error</code> exception
objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026non_002dcontinuable-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;non-continuable</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026non_002dcontinuable-1"> ¶</a></span></dt>
<dd><p>An exception type denoting errors that proceed from inside a program:
type mismatches and so on.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dnon_002dcontinuable_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-non-continuable-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dnon_002dcontinuable_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-non_002dcontinuable_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">non-continuable-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-non_002dcontinuable_002derror_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;non-continuable</code> exception objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026lexical-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;lexical</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026lexical-1"> ¶</a></span></dt>
<dd><p>An exception type denoting lexical errors, for example unbalanced
parentheses.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dlexical_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-lexical-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dlexical_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lexical_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lexical-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lexical_002derror_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;lexical</code> exception objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026syntax-1"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;syntax</strong> <var class="def-var-arguments">form subform</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026syntax-1"> ¶</a></span></dt>
<dd><p>An exception type denoting syntax errors, for example a <code class="code">cond</code>
expression with invalid syntax.  The <var class="var">form</var> field indicates the form
containing the error, and <var class="var">subform</var> indicates the unexpected
subcomponent, or <code class="code">#f</code> if unavailable.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsyntax_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-syntax-error</strong> <var class="def-var-arguments">form subform</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsyntax_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-syntax_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002derror_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-syntax_002derror_002dform"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-error-form</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002derror_002dform"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-syntax_002derror_002dsubform"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">syntax-error-subform</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-syntax_002derror_002dsubform"> ¶</a></span></dt>
<dd><p>Constructor, predicate, and accessors for <code class="code">&amp;syntax</code> exception
objects.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-_0026undefined_002dvariable"><span class="category-def">Exception Type: </span><span><strong class="def-name">&amp;undefined-variable</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026undefined_002dvariable"> ¶</a></span></dt>
<dd><p>An exception type denoting undefined variables.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dundefine_002dvariable_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-undefine-variable-error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dundefine_002dvariable_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-undefined_002dvariable_002derror_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">undefined-variable-error?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-undefined_002dvariable_002derror_003f"> ¶</a></span></dt>
<dd><p>Constructor and predicate for <code class="code">&amp;undefined-variable</code> exception
objects.
</p></dd></dl>

<p>Incidentally, the <code class="code">(ice-9 exceptions)</code> module also includes a
<code class="code">define-exception-type</code> macro that can be used to conveniently add
new exception types to the hierarchy.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dexception_002dtype"><span class="category-def">Syntax: </span><span><strong class="def-name">define-exception-type</strong> <var class="def-var-arguments">name parent        constructor predicate        (field accessor) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dexception_002dtype"> ¶</a></span></dt>
<dd><p>Define <var class="var">name</var> to be a new exception type, inheriting from
<var class="var">parent</var>.  Define <var class="var">constructor</var> and <var class="var">predicate</var> to be the
exception constructor and predicate, respectively, and define an
<var class="var">accessor</var> for each <var class="var">field</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Raising-and-Handling-Exceptions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Throw-and-Catch" accesskey="n" rel="next">Throw and Catch</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exception-Objects" accesskey="p" rel="prev">Exception Objects</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="u" rel="up">Exceptions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Raising-and-Handling-Exceptions-1">6.11.8.2 Raising and Handling Exceptions</h4>

<p>An exception object describes an exceptional situation.  To bring that
description to the attention of the user or to handle the situation
programmatically, the first step is to <em class="dfn">raise</em> the exception.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-raise_002dexception"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">raise-exception</strong> <var class="def-var-arguments">obj [#:continuable=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-raise_002dexception"> ¶</a></span></dt>
<dd><p>Raise an exception by invoking the current exception handler on
<var class="var">obj</var>. The handler is called with a continuation whose dynamic
environment is that of the call to <code class="code">raise</code>, except that the current
exception handler is the one that was in place when the handler being
called was installed.
</p>
<p>If <var class="var">continuable?</var> is true, the handler is invoked in tail position
relative to the <code class="code">raise-exception</code> call.  Otherwise if the handler
returns, a non-continuable exception of type <code class="code">&amp;non-continuable</code> is
raised in the same dynamic environment as the handler.
</p></dd></dl>

<p>As the above description notes, Guile has a notion of a <em class="dfn">current
exception handler</em>.  At the REPL, this exception handler may enter a
recursive debugger; in a standalone program, it may simply print a
representation of the error and exit.
</p>
<p>To establish an exception handler within the dynamic extent of a call,
use <code class="code">with-exception-handler</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dexception_002dhandler"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-exception-handler</strong> <var class="def-var-arguments">handler thunk        [#:unwind?=#f] [#:unwind-for-type=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dexception_002dhandler"> ¶</a></span></dt>
<dd><p>Establish <var class="var">handler</var>, a procedure of one argument, as the current
exception handler during the dynamic extent of invoking <var class="var">thunk</var>.
</p>
<p>If <code class="code">raise-exception</code> is called during the dynamic extent of
invoking <var class="var">thunk</var>, <var class="var">handler</var> will be invoked on the argument of
<code class="code">raise-exception</code>.
</p></dd></dl>

<p>There are two kinds of exception handlers: unwinding and non-unwinding.
</p>
<p>By default, exception handlers are non-unwinding.  Unless
<code class="code">with-exception-handler</code> was invoked with <code class="code">#:unwind? #t</code>,
exception handlers are invoked within the continuation of the error,
without unwinding the stack.  The dynamic environment of the handler
call will be that of the <code class="code">raise-exception</code> call, with the
difference that the current exception handler will be “unwound” to the
\"outer\" handler (the one that was in place when the corresponding
<code class="code">with-exception-handler</code> was called).
</p>
<p>However, it’s often the case that one would like to handle an exception
by unwinding the computation to an earlier state and running the error
handler there.  After all, unless the <code class="code">raise-exception</code> call is
continuable, the exception handler needs to abort the continuation.  To
support this use case, if <code class="code">with-exception-handler</code> was invoked with
<code class="code">#:unwind? #t</code> is true, <code class="code">raise-exception</code> will first unwind
the stack by invoking an <em class="dfn">escape continuation</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompt-Primitives"><code class="code">call/ec</code></a>), and then invoke the handler with the
continuation of the <code class="code">with-exception-handler</code> call.
</p>
<p>Finally, one more wrinkle: for unwinding exception handlers, it can be
useful to Guile if it can determine whether an exception handler would
indeed handle a particular exception or not.  This is especially the
case for exceptions raised in resource-exhaustion scenarios like
<code class="code">stack-overflow</code> or <code class="code">out-of-memory</code>, where you want to
immediately shrink resource use before recovering.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Overflow">Stack Overflow</a>.  For this purpose, the <code class="code">#:unwind-for-type</code> keyword
argument allows users to specify the kind of exception handled by an
exception handler; if <code class="code">#t</code>, all exceptions will be handled; if an
exception type object, only exceptions of that type will be handled;
otherwise if a symbol, only that exceptions with the given
<code class="code">exception-kind</code> will be handled.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Throw-and-Catch">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions-and-C" accesskey="n" rel="next">Exceptions and C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions" accesskey="p" rel="prev">Raising and Handling Exceptions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="u" rel="up">Exceptions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Throw-and-Catch-1">6.11.8.3 Throw and Catch</h4>

<p>Guile only adopted <code class="code">with-exception-handler</code> and
<code class="code">raise-exception</code> as its primary exception-handling facility in
2019.  Before then, exception handling was fundamentally based on three
other primitives with a somewhat more complex interface:  <code class="code">catch</code>,
<code class="code">with-throw-handler</code>, and <code class="code">throw</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-catch"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">catch</strong> <var class="def-var-arguments">key thunk handler [pre-unwind-handler]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-catch"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcatch_005fwith_005fpre_005funwind_005fhandler"><span class="category-def">C Function: </span><span><strong class="def-name">scm_catch_with_pre_unwind_handler</strong> <var class="def-var-arguments">(key, thunk, handler, pre_unwind_handler)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcatch_005fwith_005fpre_005funwind_005fhandler"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcatch"><span class="category-def">C Function: </span><span><strong class="def-name">scm_catch</strong> <var class="def-var-arguments">(key, thunk, handler)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcatch"> ¶</a></span></dt>
<dd><p>Establish an exception handler during the dynamic extent of the call to
<var class="var">thunk</var>.  <var class="var">key</var> is either <code class="code">#t</code>, indicating that all
exceptions should be handled, or a symbol, restricting the exceptions
handled to those having the <var class="var">key</var> as their <code class="code">exception-kind</code>.
</p>
<p>If <var class="var">thunk</var> executes normally, meaning without throwing any
exceptions, the handler procedures are not called at all and the result
of the <code class="code">thunk</code> call is the result of the <code class="code">catch</code>.  Otherwise
if an exception is thrown that matches <var class="var">key</var>, <var class="var">handler</var> is
called with the continuation of the <code class="code">catch</code> call.
</p></dd></dl>

<p>Given the discussion from the previous section, it is most precise and
concise to specify what <code class="code">catch</code> does by expressing it in terms of
<code class="code">with-exception-handler</code>.  Calling <code class="code">catch</code> with the three
arguments is the same as:
</p>
<div class="example">
<pre class="example-preformatted">(define (catch key thunk handler)
  (with-exception-handler
   (lambda (exn)
     (apply handler (exception-kind exn) (exception-args exn)))
   thunk
   #:unwind? #t
   #:unwind-for-type key))
</pre></div>

<p>By invoking <code class="code">with-exception-handler</code> with <code class="code">#:unwind? #t</code>,
<code class="code">catch</code> sets up an escape continuation that will be invoked in an
exceptional situation before the handler is called.
</p>
<p>If <code class="code">catch</code> is called with four arguments, then the use of
<var class="var">thunk</var> should be replaced with:
</p>
<div class="example">
<pre class="example-preformatted">   (lambda ()
     (with-throw-handler key thunk pre-unwind-handler))
</pre></div>

<p>As can be seen above, if a pre-unwind-handler is passed to <code class="code">catch</code>,
it’s like calling <code class="code">with-throw-handler</code> inside the body thunk.
</p>
<p><code class="code">with-throw-handler</code> is the second of the older primitives, and is
used to be able to intercept an exception that is being thrown before
the stack is unwound.  This could be to clean up some related state, to
print a backtrace, or to pass information about the exception to a
debugger, for example.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dthrow_002dhandler"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-throw-handler</strong> <var class="def-var-arguments">key thunk handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dthrow_002dhandler"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwith_005fthrow_005fhandler"><span class="category-def">C Function: </span><span><strong class="def-name">scm_with_throw_handler</strong> <var class="def-var-arguments">(key, thunk, handler)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005fthrow_005fhandler"> ¶</a></span></dt>
<dd><p>Add <var class="var">handler</var> to the dynamic context as a throw handler
for key <var class="var">key</var>, then invoke <var class="var">thunk</var>.
</p></dd></dl>

<p>It’s not possible to exactly express <code class="code">with-throw-handler</code> in terms
of <code class="code">with-exception-handler</code>, but we can get close.
</p>
<div class="example">
<pre class="example-preformatted">(define (with-throw-handler key thunk handler)
  (with-exception-handler
   (lambda (exn)
     (when (or (eq? key #t) (eq? key (exception-kind exn)))
       (apply handler (exception-kind exn) (exception-args exn)))
     (raise-exception exn))
   thunk))
</pre></div>

<p>As you can see, unlike in the case of <code class="code">catch</code>, the handler for
<code class="code">with-throw-handler</code> is invoked within the continuation of
<code class="code">raise-exception</code>, before unwinding the stack.  If the throw
handler returns normally, the exception will be re-raised, to be handled
by the next exception handler.
</p>
<p>The special wrinkle of <code class="code">with-throw-handler</code> that can’t be shown
above is that if invoking the handler causes a <code class="code">raise-exception</code>
instead of completing normally, the exception is thrown in the
<em class="emph">original</em> dynamic environment of the <code class="code">raise-exception</code>.  Any
inner exception handler will get another shot at handling the exception.
Here is an example to illustrate this behavior:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(catch 'a
  (lambda ()
    (with-throw-handler 'b
      (lambda ()
        (catch 'a
          (lambda ()
            (throw 'b))
          inner-handler))
      (lambda (key . args)
        (throw 'a))))
  outer-handler)
</pre></div>

<p>This code will call <code class="code">inner-handler</code> and then continue with the
continuation of the inner <code class="code">catch</code>.
</p>
<p>Finally, we get to <code class="code">throw</code>, which is the older equivalent to
<code class="code">raise-exception</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-throw"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">throw</strong> <var class="def-var-arguments">key arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-throw"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fthrow"><span class="category-def">C Function: </span><span><strong class="def-name">scm_throw</strong> <var class="def-var-arguments">(key, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fthrow"> ¶</a></span></dt>
<dd><p>Raise an exception with kind <var class="var">key</var> and arguments <var class="var">args</var>.
<var class="var">key</var> is a symbol, denoting the “kind” of the exception.
</p></dd></dl>

<p>Again, we can specify what <code class="code">throw</code> does by expressing it in terms
of <code class="code">raise-exception</code>.
</p>
<div class="example">
<pre class="example-preformatted">(define (throw key . args)
  (raise-exception (make-exception-from-throw key args)))
</pre></div>

<p>At this point, we should mention the primitive that manage the
relationship between structured exception objects <code class="code">throw</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dexception_002dfrom_002dthrow"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-exception-from-throw</strong> <var class="def-var-arguments">key args</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dexception_002dfrom_002dthrow"> ¶</a></span></dt>
<dd><p>Create an exception object for the given <var class="var">key</var> and <var class="var">args</var> passed
to <code class="code">throw</code>.  This may be a specific type of exception, for example
<code class="code">&amp;programming-error</code>; Guile maintains a set of custom transformers
for the various <var class="var">key</var> values that have been used historically.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_002dkind"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-kind</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dkind"> ¶</a></span></dt>
<dd><p>If <var class="var">exn</var> is an exception created via
<code class="code">make-exception-from-throw</code>, return the corresponding <var class="var">key</var> for
the exception.  Otherwise, unless <var class="var">exn</var> is an exception of a type
with a known mapping to <code class="code">throw</code>, return the symbol
<code class="code">%exception</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-exception_002dargs"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exception-args</strong> <var class="def-var-arguments">exn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exception_002dargs"> ¶</a></span></dt>
<dd><p>If <var class="var">exn</var> is an exception created via
<code class="code">make-exception-from-throw</code>, return the corresponding <var class="var">args</var>
for the exception.  Otherwise, unless <var class="var">exn</var> is an exception of a
type with a known mapping to <code class="code">throw</code>, return <code class="code">(list <var class="var">exn</var>)</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Exceptions-and-C">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Throw-and-Catch" accesskey="p" rel="prev">Throw and Catch</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="u" rel="up">Exceptions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Exceptions-and-C-1">6.11.8.4 Exceptions and C</h4>

<p>There are some specific versions of Guile’s original <code class="code">catch</code> and
<code class="code">with-throw-handler</code> exception-handling primitives that are still
widely used in C code.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fcatch"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_catch</strong> <code class="def-code-arguments">(SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data, scm_t_catch_handler pre_unwind_handler, void *pre_unwind_handler_data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fcatch"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005finternal_005fcatch"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_internal_catch</strong> <code class="def-code-arguments">(SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finternal_005fcatch"> ¶</a></span></dt>
<dd><p>The above <code class="code">scm_catch_with_pre_unwind_handler</code> and <code class="code">scm_catch</code>
take Scheme procedures as body and handler arguments.
<code class="code">scm_c_catch</code> and <code class="code">scm_internal_catch</code> are equivalents taking
C functions.
</p>
<p><var class="var">body</var> is called as <code class="code"><var class="var">body</var> (<var class="var">body_data</var>)</code> with a catch
on exceptions of the given <var class="var">tag</var> type.  If an exception is caught,
<var class="var">pre_unwind_handler</var> and <var class="var">handler</var> are called as
<code class="code"><var class="var">handler</var> (<var class="var">handler_data</var>, <var class="var">key</var>, <var class="var">args</var>)</code>.
<var class="var">key</var> and <var class="var">args</var> are the <code class="code">SCM</code> key and argument list from
the <code class="code">throw</code>.
</p>
<a class="index-entry-id" id="index-scm_005ft_005fcatch_005fbody"></a>
<a class="index-entry-id" id="index-scm_005ft_005fcatch_005fhandler"></a>
<p><var class="var">body</var> and <var class="var">handler</var> should have the following prototypes.
<code class="code">scm_t_catch_body</code> and <code class="code">scm_t_catch_handler</code> are pointer
typedefs for these.
</p>
<div class="example">
<pre class="example-preformatted">SCM body (void *data);
SCM handler (void *data, SCM key, SCM args);
</pre></div>

<p>The <var class="var">body_data</var> and <var class="var">handler_data</var> parameters are passed to
the respective calls so an application can communicate extra
information to those functions.
</p>
<p>If the data consists of an <code class="code">SCM</code> object, care should be taken that
it isn’t garbage collected while still required.  If the <code class="code">SCM</code> is a
local C variable, one way to protect it is to pass a pointer to that
variable as the data parameter, since the C compiler will then know the
value must be held on the stack.  Another way is to use
<code class="code">scm_remember_upto_here_1</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwith_005fthrow_005fhandler"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_with_throw_handler</strong> <code class="def-code-arguments">(SCM tag, scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data, int lazy_catch_p)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwith_005fthrow_005fhandler"> ¶</a></span></dt>
<dd><p>The above <code class="code">scm_with_throw_handler</code> takes Scheme procedures as body
(thunk) and handler arguments.  <code class="code">scm_c_with_throw_handler</code> is an
equivalent taking C functions.  See <code class="code">scm_c_catch</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions-and-C">Exceptions and C</a>) for a description of the parameters, the
behaviour however of course follows <code class="code">with-throw-handler</code>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Error-Reporting">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind" accesskey="n" rel="next">Dynamic Wind</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions" accesskey="p" rel="prev">Exceptions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Procedures-for-Signaling-Errors">6.11.9 Procedures for Signaling Errors</h4>

<p>Guile provides a set of convenience procedures for signaling error
conditions that are implemented on top of the exception primitives just
described.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-error-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">error</strong> <var class="def-var-arguments">msg arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error-1"> ¶</a></span></dt>
<dd><p>Raise an error with key <code class="code">misc-error</code> and a message constructed by
displaying <var class="var">msg</var> and writing <var class="var">arg</var> <small class="enddots">...</small>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-scm_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">scm-error</strong> <var class="def-var-arguments">key subr message args data</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ferror_005fscm"><span class="category-def">C Function: </span><span><strong class="def-name">scm_error_scm</strong> <var class="def-var-arguments">(key, subr, message, args, data)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ferror_005fscm"> ¶</a></span></dt>
<dd><p>Raise an error with key <var class="var">key</var>.  <var class="var">subr</var> can be a string
naming the procedure associated with the error, or <code class="code">#f</code>.
<var class="var">message</var> is the error message string, possibly containing
<code class="code">~S</code> and <code class="code">~A</code> escapes.  When an error is reported,
these are replaced by formatting the corresponding members of
<var class="var">args</var>: <code class="code">~A</code> (was <code class="code">%s</code> in older versions of
Guile) formats using <code class="code">display</code> and <code class="code">~S</code> (was
<code class="code">%S</code>) formats using <code class="code">write</code>.  <var class="var">data</var> is a list or
<code class="code">#f</code> depending on <var class="var">key</var>: if <var class="var">key</var> is
<code class="code">system-error</code> then it should be a list containing the
Unix <code class="code">errno</code> value; If <var class="var">key</var> is <code class="code">signal</code> then it
should be a list containing the Unix signal number; If
<var class="var">key</var> is <code class="code">out-of-range</code>, <code class="code">wrong-type-arg</code>,
or <code class="code">keyword-argument-error</code>,
it is a list containing the bad value; otherwise
it will usually be <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-strerror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">strerror</strong> <var class="def-var-arguments">err</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-strerror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstrerror"><span class="category-def">C Function: </span><span><strong class="def-name">scm_strerror</strong> <var class="def-var-arguments">(err)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstrerror"> ¶</a></span></dt>
<dd><p>Return the Unix error message corresponding to <var class="var">err</var>, an integer
<code class="code">errno</code> value.
</p>
<p>When <code class="code">setlocale</code> has been called (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>), the message
is in the language and charset of <code class="code">LC_MESSAGES</code>.  (This is done
by the C library.)
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-false_002dif_002dexception"><span class="category-def">syntax: </span><span><strong class="def-name">false-if-exception</strong> <var class="def-var-arguments">expr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-false_002dif_002dexception"> ¶</a></span></dt>
<dd><p>Returns the result of evaluating its argument; however
if an exception occurs then <code class="code">#f</code> is returned instead.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Dynamic-Wind">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States" accesskey="n" rel="next">Fluids and Dynamic States</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting" accesskey="p" rel="prev">Procedures for Signaling Errors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Dynamic-Wind-1">6.11.10 Dynamic Wind</h4>

<p>For Scheme code, the fundamental procedure to react to non-local entry
and exits of dynamic contexts is <code class="code">dynamic-wind</code>.  C code could
use <code class="code">scm_internal_dynamic_wind</code>, but since C does not allow the
convenient construction of anonymous procedures that close over
lexical variables, this will be, well, inconvenient.
</p>
<p>Therefore, Guile offers the functions <code class="code">scm_dynwind_begin</code> and
<code class="code">scm_dynwind_end</code> to delimit a dynamic extent.  Within this
dynamic extent, which is called a <em class="dfn">dynwind context</em>, you can
perform various <em class="dfn">dynwind actions</em> that control what happens when
the dynwind context is entered or left.  For example, you can register
a cleanup routine with <code class="code">scm_dynwind_unwind_handler</code> that is
executed when the context is left.  There are several other more
specialized dynwind actions as well, for example to temporarily block
the execution of asyncs or to temporarily change the current output
port.  They are described elsewhere in this manual.
</p>
<p>Here is an example that shows how to prevent memory leaks.
</p>
<div class="example">
<pre class="example-preformatted">
/* Suppose there is a function called FOO in some library that you
   would like to make available to Scheme code (or to C code that
   follows the Scheme conventions).

   FOO takes two C strings and returns a new string.  When an error has
   occurred in FOO, it returns NULL.
*/

char *foo (char *s1, char *s2);

/* SCM_FOO interfaces the C function FOO to the Scheme way of life.
   It takes care to free up all temporary strings in the case of
   non-local exits.
 */

SCM
scm_foo (SCM s1, SCM s2)
{
  char *c_s1, *c_s2, *c_res;

  scm_dynwind_begin (0);

  c_s1 = scm_to_locale_string (s1);

  /* Call 'free (c_s1)' when the dynwind context is left. 
  */
  scm_dynwind_unwind_handler (free, c_s1, SCM_F_WIND_EXPLICITLY);

  c_s2 = scm_to_locale_string (s2);
  
  /* Same as above, but more concisely.
  */
  scm_dynwind_free (c_s2);

  c_res = foo (c_s1, c_s2);
  if (c_res == NULL)
    scm_report_out_of_memory ();

  scm_dynwind_end ();

  return scm_take_locale_string (res);
}
</pre></div>

<a class="index-entry-id" id="index-dynamic_002dwind-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-dynamic_002dwind"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dynamic-wind</strong> <var class="def-var-arguments">in_guard thunk out_guard</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dynamic_002dwind"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdynamic_005fwind"><span class="category-def">C Function: </span><span><strong class="def-name">scm_dynamic_wind</strong> <var class="def-var-arguments">(in_guard, thunk, out_guard)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynamic_005fwind"> ¶</a></span></dt>
<dd><p>All three arguments must be 0-argument procedures.
<var class="var">in_guard</var> is called, then <var class="var">thunk</var>, then
<var class="var">out_guard</var>.
</p>
<p>If, any time during the execution of <var class="var">thunk</var>, the
dynamic extent of the <code class="code">dynamic-wind</code> expression is escaped
non-locally, <var class="var">out_guard</var> is called.  If the dynamic extent of
the dynamic-wind is re-entered, <var class="var">in_guard</var> is called.  Thus
<var class="var">in_guard</var> and <var class="var">out_guard</var> may be called any number of
times.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define x 'normal-binding)
⇒ x
(define a-cont
  (call-with-current-continuation
   (lambda (escape)
     (let ((old-x x))
       (dynamic-wind
           ;; in-guard:
           ;;
           (lambda () (set! x 'special-binding))

           ;; thunk
           ;;
           (lambda () (display x) (newline)
                      (call-with-current-continuation escape)
                      (display x) (newline)
                      x)

           ;; out-guard:
           ;;
           (lambda () (set! x old-x)))))))
;; Prints:
special-binding
;; Evaluates to:
⇒ a-cont
x
⇒ normal-binding
(a-cont #f)
;; Prints:
special-binding
;; Evaluates to:
⇒ a-cont  ;; the value of the (define a-cont...)
x
⇒ normal-binding
a-cont
⇒ special-binding
</pre></div>
</dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fdynwind_005fflags"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_dynwind_flags</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fdynwind_005fflags"> ¶</a></span></dt>
<dd><p>This is an enumeration of several flags that modify the behavior of
<code class="code">scm_dynwind_begin</code>.  The flags are listed in the following
table.
</p>
<dl class="table">
<dt><code class="code">SCM_F_DYNWIND_REWINDABLE</code></dt>
<dd><p>The dynamic context is <em class="dfn">rewindable</em>.  This means that it can be
reentered non-locally (via the invocation of a continuation).  The
default is that a dynwind context can not be reentered non-locally.
</p></dd>
</dl>

</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005fbegin"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_begin</strong> <code class="def-code-arguments">(scm_t_dynwind_flags flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fbegin"> ¶</a></span></dt>
<dd><p>The function <code class="code">scm_dynwind_begin</code> starts a new dynamic context and
makes it the ‘current’ one.
</p>
<p>The <var class="var">flags</var> argument determines the default behavior of the
context.  Normally, use 0.  This will result in a context that can not
be reentered with a captured continuation.  When you are prepared to
handle reentries, include <code class="code">SCM_F_DYNWIND_REWINDABLE</code> in
<var class="var">flags</var>.
</p>
<p>Being prepared for reentry means that the effects of unwind handlers
can be undone on reentry.  In the example above, we want to prevent a
memory leak on non-local exit and thus register an unwind handler that
frees the memory.  But once the memory is freed, we can not get it
back on reentry.  Thus reentry can not be allowed.
</p>
<p>The consequence is that continuations become less useful when
non-reentrant contexts are captured, but you don’t need to worry
about that too much.
</p>
<p>The context is ended either implicitly when a non-local exit happens,
or explicitly with <code class="code">scm_dynwind_end</code>.  You must make sure that a
dynwind context is indeed ended properly.  If you fail to call
<code class="code">scm_dynwind_end</code> for each <code class="code">scm_dynwind_begin</code>, the behavior
is undefined.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005fend"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_end</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fend"> ¶</a></span></dt>
<dd><p>End the current dynamic context explicitly and make the previous one
current.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fwind_005fflags"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_wind_flags</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fwind_005fflags"> ¶</a></span></dt>
<dd><p>This is an enumeration of several flags that modify the behavior of
<code class="code">scm_dynwind_unwind_handler</code> and
<code class="code">scm_dynwind_rewind_handler</code>.  The flags are listed in the
following table.
</p>
<dl class="table">
<dt id="index-SCM_005fF_005fWIND_005fEXPLICITLY"><span><code class="code">SCM_F_WIND_EXPLICITLY</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fF_005fWIND_005fEXPLICITLY"> ¶</a></span></dt>
<dd><p>The registered action is also carried out when the dynwind context is
entered or left locally.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005funwind_005fhandler"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_unwind_handler</strong> <code class="def-code-arguments">(void (*func)(void *), void *data, scm_t_wind_flags flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005funwind_005fhandler"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fdynwind_005funwind_005fhandler_005fwith_005fscm"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_unwind_handler_with_scm</strong> <code class="def-code-arguments">(void (*func)(SCM), SCM data, scm_t_wind_flags flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005funwind_005fhandler_005fwith_005fscm"> ¶</a></span></dt>
<dd><p>Arranges for <var class="var">func</var> to be called with <var class="var">data</var> as its arguments
when the current context ends implicitly.  If <var class="var">flags</var> contains
<code class="code">SCM_F_WIND_EXPLICITLY</code>, <var class="var">func</var> is also called when the
context ends explicitly with <code class="code">scm_dynwind_end</code>.
</p>
<p>The function <code class="code">scm_dynwind_unwind_handler_with_scm</code> takes care that
<var class="var">data</var> is protected from garbage collection.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005frewind_005fhandler"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_rewind_handler</strong> <code class="def-code-arguments">(void (*func)(void *), void *data, scm_t_wind_flags flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005frewind_005fhandler"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fdynwind_005frewind_005fhandler_005fwith_005fscm"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_rewind_handler_with_scm</strong> <code class="def-code-arguments">(void (*func)(SCM), SCM data, scm_t_wind_flags flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005frewind_005fhandler_005fwith_005fscm"> ¶</a></span></dt>
<dd><p>Arrange for <var class="var">func</var> to be called with <var class="var">data</var> as its argument when
the current context is restarted by rewinding the stack.  When <var class="var">flags</var>
contains <code class="code">SCM_F_WIND_EXPLICITLY</code>, <var class="var">func</var> is called immediately
as well.
</p>
<p>The function <code class="code">scm_dynwind_rewind_handler_with_scm</code> takes care that
<var class="var">data</var> is protected from garbage collection.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005ffree"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_free</strong> <code class="def-code-arguments">(void *mem)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005ffree"> ¶</a></span></dt>
<dd><p>Arrange for <var class="var">mem</var> to be freed automatically whenever the current
context is exited, whether normally or non-locally.
<code class="code">scm_dynwind_free (mem)</code> is an equivalent shorthand for
<code class="code">scm_dynwind_unwind_handler (free, mem, SCM_F_WIND_EXPLICITLY)</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Fluids-and-Dynamic-States">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Parameters" accesskey="n" rel="next">Parameters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind" accesskey="p" rel="prev">Dynamic Wind</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Fluids-and-Dynamic-States-1">6.11.11 Fluids and Dynamic States</h4>

<a class="index-entry-id" id="index-fluids"></a>

<p>A <em class="emph">fluid</em> is a variable whose value is associated with the dynamic
extent of a function call.  In the same way that an operating system
runs a process with a given set of current input and output ports (or
file descriptors), in Guile you can arrange to call a function while
binding a fluid to a particular value.  That association between fluid
and value will exist during the dynamic extent of the function call.
</p>
<p>Fluids are therefore a building block for implementing dynamically
scoped variables.  Dynamically scoped variables are useful when you want
to set a variable to a value during some dynamic extent in the execution
of your program and have them revert to their original value when the
control flow is outside of this dynamic extent.  See the description of
<code class="code">with-fluids</code> below for details.  This association between fluids,
values, and dynamic extents is robust to multiple entries (as when a
captured continuation is invoked more than once) and early exits (for
example, when throwing exceptions).
</p>
<p>Guile uses fluids to implement parameters (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>).  Usually
you just want to use parameters directly.  However it can be useful to
know what a fluid is and how it works, so that’s what this section is
about.
</p>
<p>The current set of fluid-value associations can be captured in a
<em class="emph">dynamic state</em> object.  A dynamic extent is simply that: a
snapshot of the current fluid-value associations.  Guile users can
capture the current dynamic state with <code class="code">current-dynamic-state</code> and
restore it later via <code class="code">with-dynamic-state</code> or similar procedures.
This facility is especially useful when implementing lightweight
thread-like abstractions.
</p>
<p>New fluids are created with <code class="code">make-fluid</code> and <code class="code">fluid?</code> is
used for testing whether an object is actually a fluid.  The values
stored in a fluid can be accessed with <code class="code">fluid-ref</code> and
<code class="code">fluid-set!</code>.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Thread-Local-Variables">Thread-Local Variables</a>, for further notes on fluids, threads,
parameters, and dynamic states.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dfluid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-fluid</strong> <var class="def-var-arguments">[dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dfluid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005ffluid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_fluid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005ffluid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005ffluid_005fwith_005fdefault"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_fluid_with_default</strong> <var class="def-var-arguments">(dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005ffluid_005fwith_005fdefault"> ¶</a></span></dt>
<dd><p>Return a newly created fluid, whose initial value is <var class="var">dflt</var>, or
<code class="code">#f</code> if <var class="var">dflt</var> is not given.
Fluids are objects that can hold one
value per dynamic state.  That is, modifications to this value are
only visible to code that executes with the same dynamic state as
the modifying code.  When a new dynamic state is constructed, it
inherits the values from its parent.  Because each thread normally executes
with its own dynamic state, you can use fluids for thread local storage.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dunbound_002dfluid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-unbound-fluid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dunbound_002dfluid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005funbound_005ffluid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_unbound_fluid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005funbound_005ffluid"> ¶</a></span></dt>
<dd><p>Return a new fluid that is initially unbound (instead of being
implicitly bound to some definite value).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a fluid; otherwise, return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-ref</strong> <var class="def-var-arguments">fluid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_ref</strong> <var class="def-var-arguments">(fluid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fref"> ¶</a></span></dt>
<dd><p>Return the value associated with <var class="var">fluid</var> in the current
dynamic root.  If <var class="var">fluid</var> has not been set, then return
its default value. Calling <code class="code">fluid-ref</code> on an unbound fluid produces
a runtime error.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-set!</strong> <var class="def-var-arguments">fluid value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_set_x</strong> <var class="def-var-arguments">(fluid, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the value associated with <var class="var">fluid</var> in the current dynamic root.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dref_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-ref*</strong> <var class="def-var-arguments">fluid depth</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dref_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fref_005fstar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_ref_star</strong> <var class="def-var-arguments">(fluid, depth)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fref_005fstar"> ¶</a></span></dt>
<dd><p>Return the <var class="var">depth</var>th oldest value associated with <var class="var">fluid</var> in the
current thread.  If <var class="var">depth</var> equals or exceeds the number of values
that have been assigned to <var class="var">fluid</var>, return the default value of the
fluid.  <code class="code">(fluid-ref* f 0)</code> is equivalent to <code class="code">(fluid-ref f)</code>.
</p>
<p><code class="code">fluid-ref*</code> is useful when you want to maintain a stack-like
structure in a fluid, such as the stack of current exception handlers.
Using <code class="code">fluid-ref*</code> instead of an explicit stack allows any partial
continuation captured by <code class="code">call-with-prompt</code> to only capture the
bindings made within the limits of the prompt instead of the entire
continuation.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">Prompts</a>, for more on delimited continuations.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dunset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-unset!</strong> <var class="def-var-arguments">fluid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dunset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005funset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_unset_x</strong> <var class="def-var-arguments">(fluid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005funset_005fx"> ¶</a></span></dt>
<dd><p>Disassociate the given fluid from any value, making it unbound.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dbound_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-bound?</strong> <var class="def-var-arguments">fluid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dbound_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fbound_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_bound_p</strong> <var class="def-var-arguments">(fluid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fbound_005fp"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if the given fluid is bound to a value, otherwise
<code class="code">#f</code>.
</p></dd></dl>

<p><code class="code">with-fluids*</code> temporarily changes the values of one or more fluids,
so that the given procedure and each procedure called by it access the
given values.  After the procedure returns, the old values are restored.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dfluid_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-fluid*</strong> <var class="def-var-arguments">fluid value thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dfluid_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwith_005ffluid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_with_fluid</strong> <var class="def-var-arguments">(fluid, value, thunk)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005ffluid"> ¶</a></span></dt>
<dd><p>Set <var class="var">fluid</var> to <var class="var">value</var> temporarily, and call <var class="var">thunk</var>.
<var class="var">thunk</var> must be a procedure with no argument.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002dfluids_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-fluids*</strong> <var class="def-var-arguments">fluids values thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dfluids_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwith_005ffluids"><span class="category-def">C Function: </span><span><strong class="def-name">scm_with_fluids</strong> <var class="def-var-arguments">(fluids, values, thunk)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005ffluids"> ¶</a></span></dt>
<dd><p>Set <var class="var">fluids</var> to <var class="var">values</var> temporary, and call <var class="var">thunk</var>.
<var class="var">fluids</var> must be a list of fluids and <var class="var">values</var> must be the
same number of their values to be applied.  Each substitution is done
in the order given.  <var class="var">thunk</var> must be a procedure with no argument.
It is called inside a <code class="code">dynamic-wind</code> and the fluids are
set/restored when control enter or leaves the established dynamic
extent.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002dfluids"><span class="category-def">Scheme Macro: </span><span><strong class="def-name">with-fluids</strong> <var class="def-var-arguments">((fluid value) …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dfluids"> ¶</a></span></dt>
<dd><p>Execute body <var class="var">body1</var> <var class="var">body2</var> …  while each <var class="var">fluid</var> is
set to the corresponding <var class="var">value</var>.  Both <var class="var">fluid</var> and <var class="var">value</var>
are evaluated and <var class="var">fluid</var> must yield a fluid.  The body is executed
inside a <code class="code">dynamic-wind</code> and the fluids are set/restored when
control enter or leaves the established dynamic extent.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwith_005ffluids"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_with_fluids</strong> <code class="def-code-arguments">(SCM fluids, SCM vals, SCM (*cproc)(void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwith_005ffluids"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fwith_005ffluid"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_with_fluid</strong> <code class="def-code-arguments">(SCM fluid, SCM val, SCM (*cproc)(void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwith_005ffluid"> ¶</a></span></dt>
<dd><p>The function <code class="code">scm_c_with_fluids</code> is like <code class="code">scm_with_fluids</code>
except that it takes a C function to call instead of a Scheme thunk.
</p>
<p>The function <code class="code">scm_c_with_fluid</code> is similar but only allows one
fluid to be set instead of a list.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005ffluid"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_fluid</strong> <code class="def-code-arguments">(SCM fluid, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005ffluid"> ¶</a></span></dt>
<dd><p>This function must be used inside a pair of calls to
<code class="code">scm_dynwind_begin</code> and <code class="code">scm_dynwind_end</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).  During the dynwind context, the fluid <var class="var">fluid</var> is set to
<var class="var">val</var>.
</p>
<p>More precisely, the value of the fluid is swapped with a ‘backup’
value whenever the dynwind context is entered or left.  The backup
value is initialized with the <var class="var">val</var> argument.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dynamic_002dstate_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dynamic-state?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dynamic_002dstate_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdynamic_005fstate_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_dynamic_state_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynamic_005fstate_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a dynamic state object;
return <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fis_005fdynamic_005fstate"><span class="category-def">C Procedure: </span><span><code class="def-type">int</code> <strong class="def-name">scm_is_dynamic_state</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fis_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Return non-zero if <var class="var">obj</var> is a dynamic state object;
return zero otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002ddynamic_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-dynamic-state</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002ddynamic_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005fdynamic_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_dynamic_state</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Return a snapshot of the current fluid-value associations as a fresh
dynamic state object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dcurrent_002ddynamic_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-current-dynamic-state</strong> <var class="def-var-arguments">state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcurrent_002ddynamic_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcurrent_005fdynamic_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_current_dynamic_state</strong> <var class="def-var-arguments">(state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcurrent_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Restore the saved fluid-value associations from <var class="var">state</var>, replacing
the current fluid-value associations.  Return the current fluid-value
associatoins as a dynamic state object, as in
<code class="code">current-dynamic-state</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002ddynamic_002dstate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-dynamic-state</strong> <var class="def-var-arguments">state proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002ddynamic_002dstate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwith_005fdynamic_005fstate"><span class="category-def">C Function: </span><span><strong class="def-name">scm_with_dynamic_state</strong> <var class="def-var-arguments">(state, proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> while the fluid bindings from <var class="var">state</var> have been made
current, saving the current fluid bindings.  When control leaves the
invocation of <var class="var">proc</var>, restore the saved bindings, saving instead the
fluid bindings from inside the call.  If control later re-enters
<var class="var">proc</var>, restore those saved bindings, saving the current bindings,
and so on.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005fcurrent_005fdynamic_005fstate"><span class="category-def">C Procedure: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_current_dynamic_state</strong> <code class="def-code-arguments">(SCM state)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fcurrent_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Set the current dynamic state to <var class="var">state</var> for the current dynwind
context.  Like <code class="code">with-dynamic-state</code>, but in terms of Guile’s
“dynwind” C API.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwith_005fdynamic_005fstate"><span class="category-def">C Procedure: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_c_with_dynamic_state</strong> <code class="def-code-arguments">(SCM state, void *(*func)(void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwith_005fdynamic_005fstate"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_with_dynamic_state</code>, but call <var class="var">func</var> with
<var class="var">data</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Parameters">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Errors" accesskey="n" rel="next">How to Handle Errors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States" accesskey="p" rel="prev">Fluids and Dynamic States</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Parameters-1">6.11.12 Parameters</h4>

<a class="index-entry-id" id="index-SRFI_002d39"></a>
<a class="index-entry-id" id="index-parameter-object"></a>
<a class="index-entry-id" id="index-Parameter"></a>

<p>Parameters are Guile’s facility for dynamically bound variables.
</p>
<p>On the most basic level, a parameter object is a procedure.  Calling it
with no arguments returns its value.  Calling it with one argument sets
the value.
</p>
<div class="example">
<pre class="example-preformatted">(define my-param (make-parameter 123))
(my-param) ⇒ 123
(my-param 456)
(my-param) ⇒ 456
</pre></div>

<p>The <code class="code">parameterize</code> special form establishes new locations for
parameters, those new locations having effect within the dynamic extent
of the <code class="code">parameterize</code> body.  Leaving restores the previous
locations.  Re-entering (through a saved continuation) will again use
the new locations.
</p>
<div class="example">
<pre class="example-preformatted">(parameterize ((my-param 789))
  (my-param)) ⇒ 789
(my-param) ⇒ 456
</pre></div>

<p>Parameters are like dynamically bound variables in other Lisp dialects.
They allow an application to establish parameter settings (as the name
suggests) just for the execution of a particular bit of code, restoring
when done.  Examples of such parameters might be case-sensitivity for a
search, or a prompt for user input.
</p>
<p>Global variables are not as good as parameter objects for this sort of
thing.  Changes to them are visible to all threads, but in Guile
parameter object locations are per-thread, thereby truly limiting the
effect of <code class="code">parameterize</code> to just its dynamic execution.
</p>
<p>Passing arguments to functions is thread-safe, but that soon becomes
tedious when there’s more than a few or when they need to pass down
through several layers of calls before reaching the point they should
affect.  Introducing a new setting to existing code is often easier with
a parameter object than adding arguments.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dparameter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-parameter</strong> <var class="def-var-arguments">init [converter]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dparameter"> ¶</a></span></dt>
<dd><p>Return a new parameter object, with initial value <var class="var">init</var>.
</p>
<p>If a <var class="var">converter</var> is given, then a call <code class="code">(<var class="var">converter</var>
val)</code> is made for each value set, its return is the value stored.
Such a call is made for the <var class="var">init</var> initial value too.
</p>
<p>A <var class="var">converter</var> allows values to be validated, or put into a
canonical form.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(define my-param (make-parameter 123
                   (lambda (val)
                     (if (not (number? val))
                         (error "must be a number"))
                     (inexact-&gt;exact val))))
(my-param 0.75)
(my-param) ⇒ 3/4
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parameterize"><span class="category-def">library syntax: </span><span><strong class="def-name">parameterize</strong> <var class="def-var-arguments">((param value) …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parameterize"> ¶</a></span></dt>
<dd><p>Establish a new dynamic scope with the given <var class="var">param</var>s bound to new
locations and set to the given <var class="var">value</var>s.  <var class="var">body1</var> <var class="var">body2</var>
… is evaluated in that environment.  The value returned is that of
last body form.
</p>
<p>Each <var class="var">param</var> is an expression which is evaluated to get the
parameter object.  Often this will just be the name of a variable
holding the object, but it can be anything that evaluates to a
parameter.
</p>
<p>The <var class="var">param</var> expressions and <var class="var">value</var> expressions are all
evaluated before establishing the new dynamic bindings, and they’re
evaluated in an unspecified order.
</p>
<p>For example,
</p>
<div class="example">
<pre class="example-preformatted">(define prompt (make-parameter "Type something: "))
(define (get-input)
  (display (prompt))
  ...)

(parameterize ((prompt "Type a number: "))
  (get-input)
  ...)
</pre></div>
</dd></dl>

<p>Parameter objects are implemented using fluids (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a>), so each dynamic state has its own parameter
locations.  That includes the separate locations when outside any
<code class="code">parameterize</code> form.  When a parameter is created it gets a
separate initial location in each dynamic state, all initialized to the
given <var class="var">init</var> value.
</p>
<p>New code should probably just use parameters instead of fluids, because
the interface is better.  But for migrating old code or otherwise
providing interoperability, Guile provides the <code class="code">fluid-&gt;parameter</code>
procedure:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002d_003eparameter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-&gt;parameter</strong> <var class="def-var-arguments">fluid [conv]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002d_003eparameter"> ¶</a></span></dt>
<dd><p>Make a parameter that wraps a fluid.
</p>
<p>The value of the parameter will be the same as the value of the fluid.
If the parameter is rebound in some dynamic extent, perhaps via
<code class="code">parameterize</code>, the new value will be run through the optional
<var class="var">conv</var> procedure, as with any parameter.  Note that unlike
<code class="code">make-parameter</code>, <var class="var">conv</var> is not applied to the initial value.
</p></dd></dl>

<p>As alluded to above, because each thread usually has a separate dynamic
state, each thread has its own locations behind parameter objects, and
changes in one thread are not visible to any other.  When a new dynamic
state or thread is created, the values of parameters in the originating
context are copied, into new locations.
</p>
<a class="index-entry-id" id="index-SRFI_002d39-1"></a>
<p>Guile’s parameters conform to SRFI-39 (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d39">SRFI-39 - Parameters</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Handling-Errors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Continuation-Barriers" accesskey="n" rel="next">Continuation Barriers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Parameters" accesskey="p" rel="prev">Parameters</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="How-to-Handle-Errors">6.11.13 How to Handle Errors</h4>

<p>Guile is currently in a transition from its historical <code class="code">catch</code> and
<code class="code">throw</code> error handling and signaling operators to the new
structured exception facility; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>.  However in the
meantime, here is some documentation on errors and the older
<code class="code">catch</code> and <code class="code">throw</code> interface.
</p>
<p>Errors are always thrown with a <var class="var">key</var> and four arguments:
</p>
<ul class="itemize mark-bullet">
<li><var class="var">key</var>: a symbol which indicates the type of error.  The symbols used
by libguile are listed below.

</li><li><var class="var">subr</var>: the name of the procedure from which the error is thrown, or
<code class="code">#f</code>.

</li><li><var class="var">message</var>: a string (possibly language and system dependent)
describing the error.  The tokens <code class="code">~A</code> and <code class="code">~S</code> can be
embedded within the message: they will be replaced with members of the
<var class="var">args</var> list when the message is printed.  <code class="code">~A</code> indicates an
argument printed using <code class="code">display</code>, while <code class="code">~S</code> indicates an
argument printed using <code class="code">write</code>.  <var class="var">message</var> can also be
<code class="code">#f</code>, to allow it to be derived from the <var class="var">key</var> by the error
handler (may be useful if the <var class="var">key</var> is to be thrown from both C and
Scheme).

</li><li><var class="var">args</var>: a list of arguments to be used to expand <code class="code">~A</code> and
<code class="code">~S</code> tokens in <var class="var">message</var>.  Can also be <code class="code">#f</code> if no
arguments are required.

</li><li><var class="var">rest</var>: a list of any additional objects required. e.g., when the
key is <code class="code">'system-error</code>, this contains the C errno value.  Can also
be <code class="code">#f</code> if no additional objects are required.
</li></ul>

<p>In addition to <code class="code">catch</code> and <code class="code">throw</code>, the following Scheme
facilities are available:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-display_002derror"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">display-error</strong> <var class="def-var-arguments">frame port subr message args rest</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-display_002derror"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdisplay_005ferror"><span class="category-def">C Function: </span><span><strong class="def-name">scm_display_error</strong> <var class="def-var-arguments">(frame, port, subr, message, args, rest)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdisplay_005ferror"> ¶</a></span></dt>
<dd><p>Display an error message to the output port <var class="var">port</var>.
<var class="var">frame</var> is the frame in which the error occurred, <var class="var">subr</var> is
the name of the procedure in which the error occurred and
<var class="var">message</var> is the actual error message, which may contain
formatting instructions. These will format the arguments in
the list <var class="var">args</var> accordingly.  <var class="var">rest</var> is currently
ignored.
</p></dd></dl>

<p>The following are the error keys defined by libguile and the situations
in which they are used:
</p>
<ul class="itemize mark-bullet">
<li><a class="index-entry-id" id="index-error_002dsignal"></a>
<code class="code">error-signal</code>: thrown after receiving an unhandled fatal signal
such as SIGSEGV, SIGBUS, SIGFPE etc.  The <var class="var">rest</var> argument in the throw
contains the coded signal number (at present this is not the same as the
usual Unix signal number).

</li><li><a class="index-entry-id" id="index-system_002derror"></a>
<code class="code">system-error</code>: thrown after the operating system indicates an
error condition.  The <var class="var">rest</var> argument in the throw contains the
errno value.

</li><li><a class="index-entry-id" id="index-numerical_002doverflow"></a>
<code class="code">numerical-overflow</code>: numerical overflow.

</li><li><a class="index-entry-id" id="index-out_002dof_002drange"></a>
<code class="code">out-of-range</code>: the arguments to a procedure do not fall within the
accepted domain.

</li><li><a class="index-entry-id" id="index-wrong_002dtype_002darg"></a>
<code class="code">wrong-type-arg</code>: an argument to a procedure has the wrong type.

</li><li><a class="index-entry-id" id="index-wrong_002dnumber_002dof_002dargs"></a>
<code class="code">wrong-number-of-args</code>: a procedure was called with the wrong number
of arguments.

</li><li><a class="index-entry-id" id="index-memory_002dallocation_002derror"></a>
<code class="code">memory-allocation-error</code>: memory allocation error.

</li><li><a class="index-entry-id" id="index-stack_002doverflow"></a>
<code class="code">stack-overflow</code>: stack overflow error.

</li><li><a class="index-entry-id" id="index-regular_002dexpression_002dsyntax"></a>
<code class="code">regular-expression-syntax</code>: errors generated by the regular
expression library.

</li><li><a class="index-entry-id" id="index-misc_002derror"></a>
<code class="code">misc-error</code>: other errors.
</li></ul>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#C-Support" accesskey="1">C Support</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Signalling-Type-Errors" accesskey="2">Signalling Type Errors</a></li>
</ul>
<div class="subsubsection-level-extent" id="C-Support">
<h4 class="subsubsection">6.11.13.1 C Support</h4>

<p>In the following C functions, <var class="var">SUBR</var> and <var class="var">MESSAGE</var> parameters
can be <code class="code">NULL</code> to give the effect of <code class="code">#f</code> described above.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ferror"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_error</strong> <code class="def-code-arguments">(SCM <var class="var">key</var>, const char *<var class="var">subr</var>, const char *<var class="var">message</var>, SCM <var class="var">args</var>, SCM <var class="var">rest</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ferror"> ¶</a></span></dt>
<dd><p>Throw an error, as per <code class="code">scm-error</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting">Procedures for Signaling Errors</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fsyserror"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_syserror</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsyserror"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fsyserror_005fmsg"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_syserror_msg</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>, const char *<var class="var">message</var>, SCM <var class="var">args</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsyserror_005fmsg"> ¶</a></span></dt>
<dd><p>Throw an error with key <code class="code">system-error</code> and supply <code class="code">errno</code> in
the <var class="var">rest</var> argument.  For <code class="code">scm_syserror</code> the message is
generated using <code class="code">strerror</code>.
</p>
<p>Care should be taken that any code in between the failing operation
and the call to these routines doesn’t change <code class="code">errno</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fnum_005foverflow"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_num_overflow</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnum_005foverflow"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fout_005fof_005frange"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_out_of_range</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>, SCM <var class="var">bad_value</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fout_005fof_005frange"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fwrong_005fnum_005fargs"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_wrong_num_args</strong> <code class="def-code-arguments">(SCM <var class="var">proc</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwrong_005fnum_005fargs"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fwrong_005ftype_005farg"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_wrong_type_arg</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>, int <var class="var">argnum</var>, SCM <var class="var">bad_value</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwrong_005ftype_005farg"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fwrong_005ftype_005farg_005fmsg"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_wrong_type_arg_msg</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>, int <var class="var">argnum</var>, SCM <var class="var">bad_value</var>, const char *<var class="var">expected</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwrong_005ftype_005farg_005fmsg"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmisc_005ferror"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_misc_error</strong> <code class="def-code-arguments">(const char *<var class="var">subr</var>, const char *<var class="var">message</var>, SCM <var class="var">args</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmisc_005ferror"> ¶</a></span></dt>
<dd><p>Throw an error with the various keys described above.
</p>
<p>In <code class="code">scm_wrong_num_args</code>, <var class="var">proc</var> should be a Scheme symbol
which is the name of the procedure incorrectly invoked.  The other
routines take the name of the invoked procedure as a C string.
</p>
<p>In <code class="code">scm_wrong_type_arg_msg</code>, <var class="var">expected</var> is a C string
describing the type of argument that was expected.
</p>
<p>In <code class="code">scm_misc_error</code>, <var class="var">message</var> is the error message string,
possibly containing <code class="code">simple-format</code> escapes (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output">Simple Textual Output</a>), and the corresponding arguments in the <var class="var">args</var> list.
</p></dd></dl>


</div>
<div class="subsubsection-level-extent" id="Signalling-Type-Errors">
<h4 class="subsubsection">6.11.13.2 Signalling Type Errors</h4>

<p>Every function visible at the Scheme level should aggressively check the
types of its arguments, to avoid misinterpreting a value, and perhaps
causing a segmentation fault.  Guile provides some macros to make this
easier.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fASSERT"><span class="category-def">Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_ASSERT</strong> <code class="def-code-arguments">(int <var class="var">test</var>, SCM <var class="var">obj</var>, unsigned int <var class="var">position</var>, const char *<var class="var">subr</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fASSERT"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fASSERT_005fTYPE"><span class="category-def">Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_ASSERT_TYPE</strong> <code class="def-code-arguments">(int <var class="var">test</var>, SCM <var class="var">obj</var>, unsigned int <var class="var">position</var>, const char *<var class="var">subr</var>, const char *<var class="var">expected</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fASSERT_005fTYPE"> ¶</a></span></dt>
<dd><p>If <var class="var">test</var> is zero, signal a “wrong type argument” error,
attributed to the subroutine named <var class="var">subr</var>, operating on the value
<var class="var">obj</var>, which is the <var class="var">position</var>’th argument of <var class="var">subr</var>.
</p>
<p>In <code class="code">SCM_ASSERT_TYPE</code>, <var class="var">expected</var> is a C string describing the
type of argument that was expected.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fARG1"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG1</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG1"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG2"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG2</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG3"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG3</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG3"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG4"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG4</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG4"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG5"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG5</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG5"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG6"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG6</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG6"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fARG7"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARG7</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARG7"> ¶</a></span></dt>
<dd><p>One of the above values can be used for <var class="var">position</var> to indicate the
number of the argument of <var class="var">subr</var> which is being checked.
Alternatively, a positive integer number can be used, which allows to
check arguments after the seventh.  However, for parameter numbers up to
seven it is preferable to use <code class="code">SCM_ARGN</code> instead of the
corresponding raw number, since it will make the code easier to
understand.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fARGn"><span class="category-def">Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_ARGn</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fARGn"> ¶</a></span></dt>
<dd><p>Passing a value of zero or <code class="code">SCM_ARGn</code> for <var class="var">position</var> allows to
leave it unspecified which argument’s type is incorrect.  Again,
<code class="code">SCM_ARGn</code> should be preferred over a raw zero constant.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Continuation-Barriers">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Errors" accesskey="p" rel="prev">How to Handle Errors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="u" rel="up">Controlling the Flow of Program Execution</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Continuation-Barriers-1">6.11.14 Continuation Barriers</h4>

<p>The non-local flow of control caused by continuations might sometimes
not be wanted. You can use <code class="code">with-continuation-barrier</code> to erect
fences that continuations can not pass.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dcontinuation_002dbarrier"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-continuation-barrier</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dcontinuation_002dbarrier"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwith_005fcontinuation_005fbarrier"><span class="category-def">C Function: </span><span><strong class="def-name">scm_with_continuation_barrier</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwith_005fcontinuation_005fbarrier"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> and return its result.  Do not allow the invocation of
continuations that would leave or enter the dynamic extent of the call
to <code class="code">with-continuation-barrier</code>.  Such an attempt causes an error
to be signaled.
</p>
<p>Throws (such as errors) that are not caught from within <var class="var">proc</var> are
caught by <code class="code">with-continuation-barrier</code>.  In that case, a short
message is printed to the current error port and <code class="code">#f</code> is returned.
</p>
<p>Thus, <code class="code">with-continuation-barrier</code> returns exactly once.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwith_005fcontinuation_005fbarrier"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_c_with_continuation_barrier</strong> <code class="def-code-arguments">(void *(*func) (void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwith_005fcontinuation_005fbarrier"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_with_continuation_barrier</code> but call <var class="var">func</var> on
<var class="var">data</var>.  When an error is caught, <code class="code">NULL</code> is returned.
</p></dd></dl>



<hr>
</div>
</div>
<div class="section-level-extent" id="Input-and-Output">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" accesskey="n" rel="next">Regular Expressions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Control-Mechanisms" accesskey="p" rel="prev">Controlling the Flow of Program Execution</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Input-and-Output-1">6.12 Input and Output</h3>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Ports" accesskey="1">Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO" accesskey="2">Binary I/O</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Encoding" accesskey="3">Encoding</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO" accesskey="4">Textual I/O</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output" accesskey="5">Simple Textual Output</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Buffering" accesskey="6">Buffering</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Random-Access" accesskey="7">Random Access</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Line_002fDelimited" accesskey="8">Line Oriented and Delimited Text</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Default-Ports" accesskey="9">Default Ports for Input, Output and Errors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types">Types of Port</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Venerable-Port-Interfaces">Venerable Port Interfaces</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Ports-from-C">Using Ports from C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#I_002fO-Extensions">Implementing New Port Types in C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO">Non-Blocking I/O</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#BOM-Handling">Handling of Unicode Byte Order Marks</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO" accesskey="n" rel="next">Binary I/O</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Ports-1">6.12.1 Ports</h4>
<a class="index-entry-id" id="index-Port"></a>

<p>Ports are the way that Guile performs input and output.  Guile can read
in characters or bytes from an <em class="dfn">input port</em>, or write them out to an
<em class="dfn">output port</em>.  Some ports support both interfaces.
</p>
<p>There are a number of different port types implemented in Guile.  File
ports provide input and output over files, as you might imagine.  For
example, we might display a string to a file like this:
</p>
<div class="example">
<pre class="example-preformatted">(let ((port (open-output-file "foo.txt")))
  (display "Hello, world!\n" port)
  (close-port port))
</pre></div>

<p>There are also string ports, for taking input from a string, or
collecting output to a string; bytevector ports, for doing the same but
using a bytevector as a source or sink of data; and soft ports, for
arranging to call Scheme functions to provide input or handle output.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types">Types of Port</a>.
</p>
<p>Ports should be <em class="dfn">closed</em> when they are not needed by calling
<code class="code">close-port</code> on them, as in the example above.  This will make sure
that any pending output is successfully written out to disk, in the case
of a file port, or otherwise to whatever mutable store is backed by the
port.  Any error that occurs while writing out that buffered data would
also be raised promptly at the <code class="code">close-port</code>, and not later when the
port is closed by the garbage collector.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>, for more on
buffered output.
</p>
<p>Closing a port also releases any precious resource the file might have.
Usually in Scheme a programmer doesn’t have to clean up after their data
structures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management">Memory Management and Garbage Collection</a>), but most systems have strict
limits on how many files can be open, both on a per-process and a
system-wide basis.  A program that uses many files should take care not
to hit those limits.  The same applies to similar system resources such
as pipes and sockets.
</p>
<p>Indeed for these reasons the above example is not the most idiomatic way
to use ports.  It is more common to acquire ports via procedures like
<code class="code">call-with-output-file</code>, which handle the <code class="code">close-port</code>
automatically:
</p>
<div class="example">
<pre class="example-preformatted">(call-with-output-file "foo.txt"
  (lambda (port)
    (display "Hello, world!\n" port)))
</pre></div>

<p>Finally, all ports have associated input and output buffers, as
appropriate.  Buffering is a common strategy to limit the overhead of
small reads and writes: without buffering, each character fetched from a
file would involve at least one call into the kernel, and maybe more
depending on the character and the encoding.  Instead, Guile will batch
reads and writes into internal buffers.  However, sometimes you want to
make output on a port show up immediately.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>, for more
on interfaces to control port buffering.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-port_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fp"> ¶</a></span></dt>
<dd><p>Return a boolean indicating whether <var class="var">x</var> is a port.
</p></dd></dl>

<a class="index-entry-id" id="index-input_002dport_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-input_002dport_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">input-port?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-input_002dport_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finput_005fport_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_input_port_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finput_005fport_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an input port, otherwise return
<code class="code">#f</code>.  Any object satisfying this predicate also satisfies
<code class="code">port?</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-output_002dport_003f-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-output_002dport_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">output-port?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-output_002dport_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005foutput_005fport_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_output_port_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005foutput_005fport_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an output port, otherwise return
<code class="code">#f</code>.  Any object satisfying this predicate also satisfies
<code class="code">port?</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-Closing-ports"></a>
<a class="index-entry-id" id="index-Port_002c-close"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-close_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">close-port</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-close_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fclose_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_close_port</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fclose_005fport"> ¶</a></span></dt>
<dd><p>Close the specified port object.  Return <code class="code">#t</code> if it successfully
closes a port or <code class="code">#f</code> if it was already closed.  An exception may
be raised if an error occurs, for example when flushing buffered output.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>, for more on buffered output.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors">close</a>, for a procedure which can close file descriptors.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-port_002dclosed_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-closed?</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dclosed_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fclosed_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_closed_p</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fclosed_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">port</var> is closed or <code class="code">#f</code> if it is
open.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-port</strong> <var class="def-var-arguments">port proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dport"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var>, passing it <var class="var">port</var> and closing <var class="var">port</var> upon exit
of <var class="var">proc</var>.  Return the return values of <var class="var">proc</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Binary-I_002fO">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Encoding" accesskey="n" rel="next">Encoding</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Ports" accesskey="p" rel="prev">Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Binary-I_002fO-1">6.12.2 Binary I/O</h4>

<p>Guile’s ports are fundamentally binary in nature: at the lowest level,
they work on bytes.  This section describes Guile’s core binary I/O
operations.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>, for input and output of strings and
characters.
</p>
<p>To use these routines, first include the binary I/O module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 binary-ports))
</pre></div>

<p>Note that although this module’s name suggests that binary ports are
some different kind of port, that’s not the case: all ports in Guile are
both binary and textual ports.
</p>
<a class="index-entry-id" id="index-binary-input"></a>
<a class="anchor" id="x_002dget_002du8"></a><dl class="first-deffn">
<dt class="deffn" id="index-get_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-u8</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002du8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fu8"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_u8</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fu8"> ¶</a></span></dt>
<dd><p>Return an octet read from <var class="var">port</var>, an input port, blocking as
necessary, or the end-of-file object.
</p></dd></dl>

<a class="anchor" id="x_002dlookahead_002du8"></a><dl class="first-deffn">
<dt class="deffn" id="index-lookahead_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lookahead-u8</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lookahead_002du8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flookahead_005fu8"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lookahead_u8</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flookahead_005fu8"> ¶</a></span></dt>
<dd><p>Like <code class="code">get-u8</code> but does not update <var class="var">port</var>’s position to point
past the octet.
</p></dd></dl>

<p>The end-of-file object is unlike any other kind of object: it’s not a
pair, a symbol, or anything else.  To check if a value is the
end-of-file object, use the <code class="code">eof-object?</code> predicate.
</p>
<a class="index-entry-id" id="index-eof_002dobject_003f-4"></a>
<a class="index-entry-id" id="index-End-of-file-object"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-eof_002dobject_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eof-object?</strong> <var class="def-var-arguments">x</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eof_002dobject_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feof_005fobject_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eof_object_p</strong> <var class="def-var-arguments">(x)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feof_005fobject_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">x</var> is an end-of-file object, or <code class="code">#f</code>
otherwise.
</p></dd></dl>

<p>Note that unlike other procedures in this module, <code class="code">eof-object?</code> is
defined in the default environment.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-get_002dbytevector_002dn"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-bytevector-n</strong> <var class="def-var-arguments">port count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dbytevector_002dn"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fbytevector_005fn"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_bytevector_n</strong> <var class="def-var-arguments">(port, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fbytevector_005fn"> ¶</a></span></dt>
<dd><p>Read <var class="var">count</var> octets from <var class="var">port</var>, blocking as necessary and
return a bytevector containing the octets read.  If fewer bytes are
available, a bytevector smaller than <var class="var">count</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dbytevector_002dn_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-bytevector-n!</strong> <var class="def-var-arguments">port bv start count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dbytevector_002dn_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fbytevector_005fn_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_bytevector_n_x</strong> <var class="def-var-arguments">(port, bv, start, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fbytevector_005fn_005fx"> ¶</a></span></dt>
<dd><p>Read <var class="var">count</var> bytes from <var class="var">port</var> and store them in <var class="var">bv</var>
starting at index <var class="var">start</var>.  Return either the number of bytes
actually read or the end-of-file object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dbytevector_002dsome"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-bytevector-some</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dbytevector_002dsome"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fbytevector_005fsome"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_bytevector_some</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fbytevector_005fsome"> ¶</a></span></dt>
<dd><p>Read from <var class="var">port</var>, blocking as necessary, until bytes are available
or an end-of-file is reached.  Return either the end-of-file object or a
new bytevector containing some of the available bytes (at least one),
and update the port position to point just past these bytes.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dbytevector_002dsome_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-bytevector-some!</strong> <var class="def-var-arguments">port bv start count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dbytevector_002dsome_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fbytevector_005fsome_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_bytevector_some_x</strong> <var class="def-var-arguments">(port, bv, start, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fbytevector_005fsome_005fx"> ¶</a></span></dt>
<dd><p>Read up to <var class="var">count</var> bytes from <var class="var">port</var>, blocking as necessary
until at least one byte is available or an end-of-file is reached.
Store them in <var class="var">bv</var> starting at index <var class="var">start</var>.  Return the number
of bytes actually read, or an end-of-file object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dbytevector_002dall"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-bytevector-all</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dbytevector_002dall"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005fbytevector_005fall"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_bytevector_all</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005fbytevector_005fall"> ¶</a></span></dt>
<dd><p>Read from <var class="var">port</var>, blocking as necessary, until the end-of-file is
reached.  Return either a new bytevector containing the data read or the
end-of-file object (if no data were available).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unget_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unget-bytevector</strong> <var class="def-var-arguments">port bv [start [count]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unget_002dbytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005funget_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_unget_bytevector</strong> <var class="def-var-arguments">(port, bv, start, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funget_005fbytevector"> ¶</a></span></dt>
<dd><p>Place the contents of <var class="var">bv</var> in <var class="var">port</var>, optionally starting at
index <var class="var">start</var> and limiting to <var class="var">count</var> octets, so that its bytes
will be read from left-to-right as the next bytes from <var class="var">port</var> during
subsequent read operations.  If called multiple times, the unread bytes
will be read again in last-in first-out order.
</p></dd></dl>

<a class="index-entry-id" id="index-binary-output"></a>
<p>To perform binary output on a port, use <code class="code">put-u8</code> or
<code class="code">put-bytevector</code>.
</p>
<a class="anchor" id="x_002dput_002du8"></a><dl class="first-deffn">
<dt class="deffn" id="index-put_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-u8</strong> <var class="def-var-arguments">port octet</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002du8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fput_005fu8"><span class="category-def">C Function: </span><span><strong class="def-name">scm_put_u8</strong> <var class="def-var-arguments">(port, octet)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fput_005fu8"> ¶</a></span></dt>
<dd><p>Write <var class="var">octet</var>, an integer in the 0–255 range, to <var class="var">port</var>, a
binary output port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-put_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-bytevector</strong> <var class="def-var-arguments">port bv [start [count]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002dbytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fput_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_put_bytevector</strong> <var class="def-var-arguments">(port, bv, start, count)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fput_005fbytevector"> ¶</a></span></dt>
<dd><p>Write the contents of <var class="var">bv</var> to <var class="var">port</var>, optionally starting at
index <var class="var">start</var> and limiting to <var class="var">count</var> octets.
</p></dd></dl>

<h4 class="subsubheading" id="Binary-I_002fO-in-R7RS">Binary I/O in R7RS</h4>

<p><a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Standard-Libraries">R7RS</a> defines the following binary I/O
procedures.  Access them with
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (scheme base))
</pre></div>

<a class="anchor" id="x_002dopen_002doutput_002dbytevector"></a><dl class="first-deffn">
<dt class="deffn" id="index-open_002doutput_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-output-bytevector</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002doutput_002dbytevector"> ¶</a></span></dt>
<dd><p>Returns a binary output port that will accumulate bytes
for retrieval by <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dget_002doutput_002dbytevector"><code class="code">get-output-bytevector</code></a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-u8</strong> <var class="def-var-arguments">byte [out]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002du8"> ¶</a></span></dt>
<dd><p>Writes <var class="var">byte</var> to the given binary output port <var class="var">out</var> and returns
an unspecified value.  <var class="var">out</var> defaults to <code class="code">(current-output-port)</code>.
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dput_002du8"><code class="code">put-u8</code></a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-u8</strong> <var class="def-var-arguments">[in]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002du8"> ¶</a></span></dt>
<dd><p>Returns the next byte available from the binary input port <var class="var">in</var>,
updating the port to point to the following byte.  If no more bytes are
available, an end-of-file object is returned.  <var class="var">in</var> defaults to
<code class="code">(current-input-port)</code>.
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dget_002du8"><code class="code">get-u8</code></a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peek_002du8"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peek-u8</strong> <var class="def-var-arguments">[in]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peek_002du8"> ¶</a></span></dt>
<dd><p>Returns the next byte available from the binary input port <var class="var">in</var>,
but without updating the port to point to the following
byte.  If no more bytes are available, an end-of-file object
is returned.  <var class="var">in</var> defaults to <code class="code">(current-input-port)</code>.
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dlookahead_002du8"><code class="code">lookahead-u8</code></a>.
</p></dd></dl>

<a class="anchor" id="x_002dget_002doutput_002dbytevector"></a><dl class="first-deffn">
<dt class="deffn" id="index-get_002doutput_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-output-bytevector</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002doutput_002dbytevector"> ¶</a></span></dt>
<dd><p>Returns a bytevector consisting of the bytes that have been output to
<var class="var">port</var> so far in the order they were output.  It is an error if
<var class="var">port</var> was not created with
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dopen_002doutput_002dbytevector"><code class="code">open-output-bytevector</code></a>.
</p>
<div class="example">
<pre class="example-preformatted">(define out (open-output-bytevector))
(write-u8 1 out)
(write-u8 2 out)
(write-u8 3 out)
(get-output-bytevector out) ⇒ #vu8(1 2 3)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dinput_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-input-bytevector</strong> <var class="def-var-arguments">bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dinput_002dbytevector"> ¶</a></span></dt>
<dd><p>Takes a bytevector <var class="var">bv</var> and returns a binary input port that
delivers bytes from <var class="var">bv</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define in (open-input-bytevector #vu8(1 2 3)))
(read-u8 in) ⇒ 1
(peek-u8 in) ⇒ 2
(read-u8 in) ⇒ 2
(read-u8 in) ⇒ 3
(read-u8 in) ⇒ #&lt;eof&gt;
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dbytevector_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-bytevector!</strong> <var class="def-var-arguments">bv [port [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dbytevector_0021"> ¶</a></span></dt>
<dd><p>Reads the next <var class="var">end</var> - <var class="var">start</var> bytes, or as many as are
available before the end of file, from the binary input port into the
bytevector <var class="var">bv</var> in left-to-right order beginning at the <var class="var">start</var>
position.  If <var class="var">end</var> is not supplied, reads until the end of <var class="var">bv</var>
has been reached.  If <var class="var">start</var> is not supplied, reads beginning at
position 0.
</p>
<p>Returns the number of bytes read.  If no bytes are available, an
end-of-file object is returned.
</p>
<div class="example">
<pre class="example-preformatted">(define in (open-input-bytevector #vu8(1 2 3)))
(define bv (make-bytevector 5 0))
(read-bytevector! bv in 1 3) ⇒ 2
bv ⇒ #vu8(0 1 2 0 0 0)
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-bytevector</strong> <var class="def-var-arguments">k in</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dbytevector"> ¶</a></span></dt>
<dd><p>Reads the next <var class="var">k</var> bytes, or as many as are available before the end
of file if that is less than <var class="var">k</var>, from the binary input port
<var class="var">in</var> into a newly allocated bytevector in left-to-right order, and
returns the bytevector.  If no bytes are available before the end of
file, an end-of-file object is returned.
</p>
<div class="example">
<pre class="example-preformatted">(define bv #vu8(1 2 3))
(read-bytevector 2 (open-input-bytevector bv)) ⇒ #vu8(1 2)
(read-bytevector 10 (open-input-bytevector bv)) ⇒ #vu8(1 2 3)
</pre></div>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-bytevector</strong> <var class="def-var-arguments">bv [port [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dbytevector"> ¶</a></span></dt>
<dd><p>Writes the bytes of bytevector <var class="var">bv</var> from <var class="var">start</var> to <var class="var">end</var> in
left-to-right order to the binary output <var class="var">port</var>.  <var class="var">start</var>
defaults to 0 and <var class="var">end</var> defaults to the length of <var class="var">bv</var>.
</p>
<div class="example">
<pre class="example-preformatted">(define out (open-output-bytevector))
(write-bytevector #vu8(0 1 2 3 4) out 2 4)
(get-output-bytevector out) ⇒ #vu8(2 3)
</pre></div>

</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Encoding">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO" accesskey="n" rel="next">Textual I/O</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO" accesskey="p" rel="prev">Binary I/O</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Encoding-1">6.12.3 Encoding</h4>

<p>Textual input and output on Guile ports is layered on top of binary
operations.  To this end, each port has an associated character encoding
that controls how bytes read from the port are converted to characters,
and how characters written to the port are converted to bytes.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-port_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-encoding</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fencoding"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_encoding</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fencoding"> ¶</a></span></dt>
<dd><p>Returns, as a string, the character encoding that <var class="var">port</var> uses to
interpret its input and output.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dport_002dencoding_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-encoding!</strong> <var class="def-var-arguments">port enc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002dencoding_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005fencoding_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_encoding_x</strong> <var class="def-var-arguments">(port, enc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fencoding_005fx"> ¶</a></span></dt>
<dd><p>Sets the character encoding that will be used to interpret I/O to
<var class="var">port</var>.  <var class="var">enc</var> is a string containing the name of an encoding.
Valid encoding names are those
<a class="url" href="http://www.iana.org/assignments/character-sets">defined by IANA</a>,
for example <code class="code">"UTF-8"</code> or <code class="code">"ISO-8859-1"</code>.
</p></dd></dl>

<p>When ports are created, they are assigned an encoding.  The usual
process to determine the initial encoding for a port is to take the
value of the <code class="code">%default-port-encoding</code> fluid.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-_0025default_002dport_002dencoding"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">%default-port-encoding</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025default_002dport_002dencoding"> ¶</a></span></dt>
<dd><p>A fluid containing name of the encoding to be used by default for newly
created ports (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a>).  As a special case,
the value <code class="code">#f</code> is equivalent to <code class="code">"ISO-8859-1"</code>.
</p></dd></dl>

<p>The <code class="code">%default-port-encoding</code> itself defaults to the encoding
appropriate for the current locale, if <code class="code">setlocale</code> has been called.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>, for more on locales and when you might need to call
<code class="code">setlocale</code> explicitly.
</p>
<p>Some port types have other ways of determining their initial locales.
String ports, for example, default to the UTF-8 encoding, in order to be
able to represent all characters regardless of the current locale.  File
ports can optionally sniff their file for a <code class="code">coding:</code> declaration;
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">File Ports</a>.  Binary ports might be initialized to the ISO-8859-1
encoding in which each codepoint between 0 and 255 corresponds to a byte
with that value.
</p>
<p>Currently, the ports only work with <em class="emph">non-modal</em> encodings.  Most
encodings are non-modal, meaning that the conversion of bytes to a
string doesn’t depend on its context: the same byte sequence will always
return the same string.  A couple of modal encodings are in common use,
like ISO-2022-JP and ISO-2022-KR, and they are not yet supported.
</p>
<a class="index-entry-id" id="index-port-conversion-strategy"></a>
<a class="index-entry-id" id="index-conversion-strategy_002c-port"></a>
<a class="index-entry-id" id="index-decoding-error"></a>
<a class="index-entry-id" id="index-encoding-error"></a>
<p>Each port also has an associated conversion strategy, which determines
what to do when a Guile character can’t be converted to the port’s
encoded character representation for output.  There are three possible
strategies: to raise an error, to replace the character with a hex
escape, or to replace the character with a substitute character.  Port
conversion strategies are also used when decoding characters from an
input port.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-port_002dconversion_002dstrategy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-conversion-strategy</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dconversion_002dstrategy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fconversion_005fstrategy"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_conversion_strategy</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fconversion_005fstrategy"> ¶</a></span></dt>
<dd><p>Returns the behavior of the port when outputting a character that is not
representable in the port’s current encoding.
</p>
<p>If <var class="var">port</var> is <code class="code">#f</code>, then the current default behavior will be
returned.  New ports will have this default behavior when they are
created.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dport_002dconversion_002dstrategy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-conversion-strategy!</strong> <var class="def-var-arguments">port sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002dconversion_002dstrategy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005fconversion_005fstrategy_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_conversion_strategy_x</strong> <var class="def-var-arguments">(port, sym)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fconversion_005fstrategy_005fx"> ¶</a></span></dt>
<dd><p>Sets the behavior of Guile when outputting a character that is not
representable in the port’s current encoding, or when Guile encounters a
decoding error when trying to read a character.  <var class="var">sym</var> can be either
<code class="code">error</code>, <code class="code">substitute</code>, or <code class="code">escape</code>.
</p>
<p>If <var class="var">port</var> is an open port, the conversion error behavior is set for
that port.  If it is <code class="code">#f</code>, it is set as the default behavior for
any future ports that get created in this thread.
</p></dd></dl>

<p>As with port encodings, there is a fluid which determines the initial
conversion strategy for a port.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_0025default_002dport_002dconversion_002dstrategy"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">%default-port-conversion-strategy</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025default_002dport_002dconversion_002dstrategy"> ¶</a></span></dt>
<dd><p>The fluid that defines the conversion strategy for newly created ports,
and also for other conversion routines such as <code class="code">scm_to_stringn</code>,
<code class="code">scm_from_stringn</code>, <code class="code">string-&gt;pointer</code>, and
<code class="code">pointer-&gt;string</code>.
</p>
<p>Its value must be one of the symbols described above, with the same
semantics: <code class="code">error</code>, <code class="code">substitute</code>, or <code class="code">escape</code>.
</p>
<p>When Guile starts, its value is <code class="code">substitute</code>.
</p>
<p>Note that <code class="code">(set-port-conversion-strategy! #f <var class="var">sym</var>)</code> is
equivalent to <code class="code">(fluid-set! %default-port-conversion-strategy
<var class="var">sym</var>)</code>.
</p></dd></dl>

<p>As mentioned above, for an output port there are three possible port
conversion strategies.  The <code class="code">error</code> strategy will throw an error
when a nonconvertible character is encountered.  The <code class="code">substitute</code>
strategy will replace nonconvertible characters with a question mark
(‘<samp class="samp">?</samp>’).  Finally the <code class="code">escape</code> strategy will print
nonconvertible characters as a hex escape, using the escaping that is
recognized by Guile’s string syntax.  Note that if the port’s encoding
is a Unicode encoding, like <code class="code">UTF-8</code>, then encoding errors are
impossible.
</p>
<p>For an input port, the <code class="code">error</code> strategy will cause Guile to throw
an error if it encounters an invalid encoding, such as might happen if
you tried to read <code class="code">ISO-8859-1</code> as <code class="code">UTF-8</code>.  The error is
thrown before advancing the read position.  The <code class="code">substitute</code>
strategy will replace the bad bytes with a U+FFFD replacement character,
in accordance with Unicode recommendations.  When reading from an input
port, the <code class="code">escape</code> strategy is treated as if it were <code class="code">error</code>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Textual-I_002fO">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output" accesskey="n" rel="next">Simple Textual Output</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Encoding" accesskey="p" rel="prev">Encoding</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Textual-I_002fO-1">6.12.4 Textual I/O</h4>
<a class="index-entry-id" id="index-textual-input"></a>
<a class="index-entry-id" id="index-textual-output"></a>

<p>This section describes Guile’s core textual I/O operations on characters
and strings.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO">Binary I/O</a>, for input and output of bytes and
bytevectors.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Encoding">Encoding</a>, for more on how characters relate to
bytes.  To read general S-expressions from ports, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write">Writing Scheme Values</a>, for interfaces that write generic Scheme datums.
</p>
<p>To use these routines, first include the textual I/O module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 textual-ports))
</pre></div>

<p>Note that although this module’s name suggests that textual ports are
some different kind of port, that’s not the case: all ports in Guile are
both binary and textual ports.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-get_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-char</strong> <var class="def-var-arguments">input-port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dchar"> ¶</a></span></dt>
<dd><p>Reads from <var class="var">input-port</var>, blocking as necessary, until a
complete character is available from <var class="var">input-port</var>,
or until an end of file is reached.
</p>
<p>If a complete character is available before the next end of file,
<code class="code">get-char</code> returns that character and updates the input port to
point past the character. If an end of file is reached before any
character is read, <code class="code">get-char</code> returns the end-of-file object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lookahead_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lookahead-char</strong> <var class="def-var-arguments">input-port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lookahead_002dchar"> ¶</a></span></dt>
<dd><p>The <code class="code">lookahead-char</code> procedure is like <code class="code">get-char</code>, but it does
not update <var class="var">input-port</var> to point past the character.
</p></dd></dl>

<p>In the same way that it’s possible to "unget" a byte or bytes, it’s
possible to "unget" the bytes corresponding to an encoded character.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-unget_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unget-char</strong> <var class="def-var-arguments">port char</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unget_002dchar"> ¶</a></span></dt>
<dd><p>Place character <var class="var">char</var> in <var class="var">port</var> so that it will be read by the
next read operation.  If called multiple times, the unread characters
will be read again in last-in first-out order.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unget_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unget-string</strong> <var class="def-var-arguments">port str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unget_002dstring"> ¶</a></span></dt>
<dd><p>Place the string <var class="var">str</var> in <var class="var">port</var> so that its characters will
be read from left-to-right as the next characters from <var class="var">port</var>
during subsequent read operations.  If called multiple times, the
unread characters will be read again in last-in first-out order.
</p></dd></dl>

<p>Reading in a character at a time can be inefficient.  If it’s possible
to perform I/O over multiple characters at a time, via strings, that
might be faster.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-get_002dstring_002dn"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-string-n</strong> <var class="def-var-arguments">input-port count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dstring_002dn"> ¶</a></span></dt>
<dd><p>The <code class="code">get-string-n</code> procedure reads from <var class="var">input-port</var>, blocking
as necessary, until <var class="var">count</var> characters are available, or until an
end of file is reached.  <var class="var">count</var> must be an exact, non-negative
integer, representing the number of characters to be read.
</p>
<p>If <var class="var">count</var> characters are available before end of file,
<code class="code">get-string-n</code> returns a string consisting of those <var class="var">count</var>
characters. If fewer characters are available before an end of file, but
one or more characters can be read, <code class="code">get-string-n</code> returns a string
containing those characters. In either case, the input port is updated
to point just past the characters read. If no characters can be read
before an end of file, the end-of-file object is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dstring_002dn_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-string-n!</strong> <var class="def-var-arguments">input-port string start count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dstring_002dn_0021"> ¶</a></span></dt>
<dd><p>The <code class="code">get-string-n!</code> procedure reads from <var class="var">input-port</var> in the
same manner as <code class="code">get-string-n</code>.  <var class="var">start</var> and <var class="var">count</var> must be
exact, non-negative integer objects, with <var class="var">count</var> representing the
number of characters to be read.  <var class="var">string</var> must be a string with at
least $<var class="var">start</var> + <var class="var">count</var>$ characters.
</p>
<p>If <var class="var">count</var> characters are available before an end of file, they are
written into <var class="var">string</var> starting at index <var class="var">start</var>, and <var class="var">count</var>
is returned. If fewer characters are available before an end of file,
but one or more can be read, those characters are written into
<var class="var">string</var> starting at index <var class="var">start</var> and the number of characters
actually read is returned as an exact integer object. If no characters
can be read before an end of file, the end-of-file object is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dstring_002dall"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-string-all</strong> <var class="def-var-arguments">input-port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dstring_002dall"> ¶</a></span></dt>
<dd><p>Reads from <var class="var">input-port</var> until an end of file, decoding characters in
the same manner as <code class="code">get-string-n</code> and <code class="code">get-string-n!</code>.
</p>
<p>If characters are available before the end of file, a string containing
all the characters decoded from that data are returned. If no character
precedes the end of file, the end-of-file object is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-line</strong> <var class="def-var-arguments">input-port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dline"> ¶</a></span></dt>
<dd><p>Reads from <var class="var">input-port</var> up to and including the linefeed
character or end of file, decoding characters in the same manner as
<code class="code">get-string-n</code> and <code class="code">get-string-n!</code>.
</p>
<p>If a linefeed character is read, a string containing all of the text up
to (but not including) the linefeed character is returned, and the port
is updated to point just past the linefeed character. If an end of file
is encountered before any linefeed character is read, but some
characters have been read and decoded as characters, a string containing
those characters is returned. If an end of file is encountered before
any characters are read, the end-of-file object is returned.
</p></dd></dl>

<p>Finally, there are just two core procedures to write characters to a
port.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-put_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-char</strong> <var class="def-var-arguments">port char</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002dchar"> ¶</a></span></dt>
<dd><p>Writes <var class="var">char</var> to the port. The <code class="code">put-char</code> procedure returns
an unspecified value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-put_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-string</strong> <var class="def-var-arguments">port string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-put_002dstring-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-string</strong> <var class="def-var-arguments">port string start</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002dstring-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-put_002dstring-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">put-string</strong> <var class="def-var-arguments">port string start count</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-put_002dstring-2"> ¶</a></span></dt>
<dd><p>Write the <var class="var">count</var> characters of <var class="var">string</var> starting at index
<var class="var">start</var> to the port.
</p>
<p><var class="var">start</var> and <var class="var">count</var> must be non-negative exact integer objects.
<var class="var">string</var> must have a length of at least <em class="math"><var class="var">start</var> +
<var class="var">count</var></em>.  <var class="var">start</var> defaults to 0.  <var class="var">count</var> defaults to
<em class="math"><code class="code">(string-length <var class="var">string</var>)</code> - <var class="var">start</var></em>$.
</p>
<p>Calling <code class="code">put-string</code> is equivalent in all respects to calling
<code class="code">put-char</code> on the relevant sequence of characters, except that it
will attempt to write multiple characters to the port at a time, even if
the port is unbuffered.
</p>
<p>The <code class="code">put-string</code> procedure returns an unspecified value.
</p></dd></dl>

<p>Textual ports have a textual position associated with them: a line and a
column.  Reading in characters or writing them out advances the line and
the column appropriately.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-port_002dcolumn"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-column</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dcolumn"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-port_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-line</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dline"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fcolumn"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_column</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fcolumn"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fline"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_line</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fline"> ¶</a></span></dt>
<dd><p>Return the current column number or line number of <var class="var">port</var>.
</p></dd></dl>

<p>Port lines and positions are represented as 0-origin integers, which is
to say that the the first character of the first line is line 0, column
0.  However, when you display a line number, for example in an error
message, we recommend you add 1 to get 1-origin integers.  This is
because lines numbers traditionally start with 1, and that is what
non-programmers will find most natural.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002dport_002dcolumn_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-column!</strong> <var class="def-var-arguments">port column</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002dcolumn_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dport_002dline_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-line!</strong> <var class="def-var-arguments">port line</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002dline_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005fcolumn_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_column_x</strong> <var class="def-var-arguments">(port, column)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fcolumn_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005fline_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_line_x</strong> <var class="def-var-arguments">(port, line)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fline_005fx"> ¶</a></span></dt>
<dd><p>Set the current column or line number of <var class="var">port</var>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Simple-Output">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Buffering" accesskey="n" rel="next">Buffering</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO" accesskey="p" rel="prev">Textual I/O</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Simple-Textual-Output">6.12.5 Simple Textual Output</h4>

<p>Guile exports a simple formatted output function, <code class="code">simple-format</code>.
For a more capable formatted output facility, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Formatted-Output">Formatted Output</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-simple_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">simple-format</strong> <var class="def-var-arguments">destination message . args</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-simple_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsimple_005fformat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_simple_format</strong> <var class="def-var-arguments">(destination, message, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsimple_005fformat"> ¶</a></span></dt>
<dd><p>Write <var class="var">message</var> to <var class="var">destination</var>, defaulting to the current
output port.  <var class="var">message</var> can contain <code class="code">~A</code> and <code class="code">~S</code> escapes.
When printed, the escapes are replaced with corresponding members of
<var class="var">args</var>: <code class="code">~A</code> formats using <code class="code">display</code> and <code class="code">~S</code> formats
using <code class="code">write</code>.  If <var class="var">destination</var> is <code class="code">#t</code>, then use the
current output port, if <var class="var">destination</var> is <code class="code">#f</code>, then return a
string containing the formatted text.  Does not add a trailing newline.
</p></dd></dl>

<p>Somewhat confusingly, Guile binds the <code class="code">format</code> identifier to
<code class="code">simple-format</code> at startup.  Once <code class="code">(ice-9 format)</code> loads, it
actually replaces the core <code class="code">format</code> binding, so depending on
whether you or a module you use has loaded <code class="code">(ice-9 format)</code>, you
may be using the simple or the more capable version.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Buffering">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Random-Access" accesskey="n" rel="next">Random Access</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output" accesskey="p" rel="prev">Simple Textual Output</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Buffering-1">6.12.6 Buffering</h4>
<a class="index-entry-id" id="index-Port_002c-buffering"></a>

<p>Every port has associated input and output buffers.  You can think of
ports as being backed by some mutable store, and that store might be far
away.  For example, ports backed by file descriptors have to go all the
way to the kernel to read and write their data.  To avoid this
round-trip cost, Guile usually reads in data from the mutable store in
chunks, and then services small requests like <code class="code">get-char</code> out of
that intermediate buffer.  Similarly, small writes like
<code class="code">write-char</code> first go to a buffer, and are sent to the store when
the buffer is full (or when port is flushed).  Buffered ports speed up
your program by reducing the number of round-trips to the mutable store,
and they do so in a way that is mostly transparent to the user.
</p>
<p>There are two major ways, however, in which buffering affects program
semantics.  Building correct, performant programs requires understanding
these situations.
</p>
<p>The first case is in random-access read/write ports (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Random-Access">Random Access</a>).  These ports, usually backed by a file, logically operate over
the same mutable store when both reading and writing.  So, if you read a
character, causing the buffer to fill, then write a character, the bytes
you filled in your read buffer are now invalid.  Every time you switch
between reading and writing, Guile has to flush any pending buffer.  If
this happens frequently, the cost can be high.  In that case you should
reduce the amount that you buffer, in both directions.  Similarly, Guile
has to flush buffers before seeking.  None of these considerations apply
to sockets, which don’t logically read from and write to the same
mutable store, and are not seekable.  Note also that sockets are
unbuffered by default.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">Network Sockets and Communication</a>.
</p>
<p>The second case is the more pernicious one.  If you write data to a
buffered port, it probably doesn’t go out to the mutable store directly.
(This “probably” introduces some indeterminism in your program: what
goes to the store, and when, depends on how full the buffer is.  It is
something that the user needs to explicitly be aware of.)  The data is
written to the store later – when the buffer fills up due to another
write, or when <code class="code">force-output</code> is called, or when <code class="code">close-port</code>
is called, or when the program exits, or even when the garbage collector
runs.  The salient point is, <em class="emph">the errors are signalled then too</em>.
Buffered writes defer error detection (and defer the side effects to the
mutable store), perhaps indefinitely if the port type does not need to
be closed at GC.
</p>
<p>One common heuristic that works well for textual ports is to flush
output when a newline (<code class="code">\n</code>) is written.  This <em class="dfn">line buffering</em>
mode is on by default for TTY ports.  Most other ports are <em class="dfn">block
buffered</em>, meaning that once the output buffer reaches the block size,
which depends on the port and its configuration, the output is flushed
as a block, without regard to what is in the block.  Likewise reads are
read in at the block size, though if there are fewer bytes available to
read, the buffer may not be entirely filled.
</p>
<p>Note that binary reads or writes that are larger than the buffer size go
directly to the mutable store without passing through the buffers.  If
your access pattern involves many big reads or writes, buffering might
not matter so much to you.
</p>
<p>To control the buffering behavior of a port, use <code class="code">setvbuf</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-setvbuf"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setvbuf</strong> <var class="def-var-arguments">port mode [size]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setvbuf"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetvbuf"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setvbuf</strong> <var class="def-var-arguments">(port, mode, size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetvbuf"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-port-buffering"></a>
<p>Set the buffering mode for <var class="var">port</var>.  <var class="var">mode</var> can be one of the
following symbols:
</p>
<dl class="table">
<dt><code class="code">none</code></dt>
<dd><p>non-buffered
</p></dd>
<dt><code class="code">line</code></dt>
<dd><p>line buffered
</p></dd>
<dt><code class="code">block</code></dt>
<dd><p>block buffered, using a newly allocated buffer of <var class="var">size</var> bytes.
If <var class="var">size</var> is omitted, a default size will be used.
</p></dd>
</dl>
</dd></dl>

<p>Another way to set the buffering, for file ports, is to open the file
with <code class="code">0</code> or <code class="code">l</code> as part of the mode string, for unbuffered or
line-buffered ports, respectively.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">File Ports</a>, for more.
</p>
<p>Any buffered output data will be written out when the port is closed.
To make sure to flush it at specific points in your program, use
<code class="code">force-otput</code>.
</p>
<a class="index-entry-id" id="index-fflush"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-force_002doutput"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">force-output</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-force_002doutput"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fforce_005foutput"><span class="category-def">C Function: </span><span><strong class="def-name">scm_force_output</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforce_005foutput"> ¶</a></span></dt>
<dd><p>Flush the specified output port, or the current output port if
<var class="var">port</var> is omitted.  The current output buffer contents, if any, are
passed to the underlying port implementation.
</p>
<p>The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-flush_002dall_002dports"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">flush-all-ports</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-flush_002dall_002dports"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fflush_005fall_005fports"><span class="category-def">C Function: </span><span><strong class="def-name">scm_flush_all_ports</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fflush_005fall_005fports"> ¶</a></span></dt>
<dd><p>Equivalent to calling <code class="code">force-output</code> on all open output ports.  The
return value is unspecified.
</p></dd></dl>

<p>Similarly, sometimes you might want to switch from using Guile’s ports
to working directly on file descriptors.  In that case, for input ports
use <code class="code">drain-input</code> to get any buffered input from that port.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-drain_002dinput"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">drain-input</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-drain_002dinput"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdrain_005finput"><span class="category-def">C Function: </span><span><strong class="def-name">scm_drain_input</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdrain_005finput"> ¶</a></span></dt>
<dd><p>This procedure clears a port’s input buffers, similar
to the way that force-output clears the output buffer.  The
contents of the buffers are returned as a single string, e.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define p (open-input-file ...))
(drain-input p) =&gt; empty string, nothing buffered yet.
(unread-char (read-char p) p)
(drain-input p) =&gt; initial chars from p, up to the buffer size.
</pre></div>
</dd></dl>

<p>All of these considerations are very similar to those of streams in the
C library, although Guile’s ports are not built on top of C streams.
Still, it is useful to read what other systems do.
See <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Streams">Streams</a> in <cite class="cite">The GNU C Library Reference Manual</cite>, for more
discussion on C streams.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Random-Access">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Line_002fDelimited" accesskey="n" rel="next">Line Oriented and Delimited Text</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Buffering" accesskey="p" rel="prev">Buffering</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Random-Access-1">6.12.7 Random Access</h4>
<a class="index-entry-id" id="index-Random-access_002c-ports"></a>
<a class="index-entry-id" id="index-Port_002c-random-access"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-seek"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">seek</strong> <var class="def-var-arguments">fd_port offset whence</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-seek"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fseek"><span class="category-def">C Function: </span><span><strong class="def-name">scm_seek</strong> <var class="def-var-arguments">(fd_port, offset, whence)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fseek"> ¶</a></span></dt>
<dd><p>Sets the current position of <var class="var">fd_port</var> to the integer
<var class="var">offset</var>.  For a file port, <var class="var">offset</var> is expressed
as a number of bytes; for other types of ports, such as string
ports, <var class="var">offset</var> is an abstract representation of the
position within the port’s data, not necessarily expressed
as a number of bytes.  <var class="var">offset</var> is interpreted according to
the value of <var class="var">whence</var>.
</p>
<p>One of the following variables should be supplied for
<var class="var">whence</var>:
</p><dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SEEK_005fSET"><span class="category-def">Variable: </span><span><strong class="def-name">SEEK_SET</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SEEK_005fSET"> ¶</a></span></dt>
<dd><p>Seek from the beginning of the file.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SEEK_005fCUR"><span class="category-def">Variable: </span><span><strong class="def-name">SEEK_CUR</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SEEK_005fCUR"> ¶</a></span></dt>
<dd><p>Seek from the current position.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SEEK_005fEND"><span class="category-def">Variable: </span><span><strong class="def-name">SEEK_END</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SEEK_005fEND"> ¶</a></span></dt>
<dd><p>Seek from the end of the file.
</p></dd></dl>
<p>If <var class="var">fd_port</var> is a file descriptor, the underlying system
call is <code class="code">lseek</code>.  <var class="var">port</var> may be a string port.
</p>
<p>The value returned is the new position in <var class="var">fd_port</var>.  This means
that the current position of a port can be obtained using:
</p><div class="example lisp">
<pre class="lisp-preformatted">(seek port 0 SEEK_CUR)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ftell"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ftell</strong> <var class="def-var-arguments">fd_port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ftell"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fftell"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ftell</strong> <var class="def-var-arguments">(fd_port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fftell"> ¶</a></span></dt>
<dd><p>Return an integer representing the current position of
<var class="var">fd_port</var>, measured from the beginning.  Equivalent to:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(seek port 0 SEEK_CUR)
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-truncate-1"></a>
<a class="index-entry-id" id="index-ftruncate"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-truncate_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">truncate-file</strong> <var class="def-var-arguments">file [length]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-truncate_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftruncate_005ffile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_truncate_file</strong> <var class="def-var-arguments">(file, length)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftruncate_005ffile"> ¶</a></span></dt>
<dd><p>Truncate <var class="var">file</var> to <var class="var">length</var> bytes.  <var class="var">file</var> can be a
filename string, a port object, or an integer file descriptor.  The
return value is unspecified.
</p>
<p>For a port or file descriptor <var class="var">length</var> can be omitted, in which
case the file is truncated at the current position (per <code class="code">ftell</code>
above).
</p>
<p>On most systems a file can be extended by giving a length greater than
the current size, but this is not mandatory in the POSIX standard.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Line_002fDelimited">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Default-Ports" accesskey="n" rel="next">Default Ports for Input, Output and Errors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Random-Access" accesskey="p" rel="prev">Random Access</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Line-Oriented-and-Delimited-Text">6.12.8 Line Oriented and Delimited Text</h4>
<a class="index-entry-id" id="index-Line-input_002foutput"></a>
<a class="index-entry-id" id="index-Port_002c-line-input_002foutput"></a>

<p>The delimited-I/O module can be accessed with:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 rdelim))
</pre></div>

<p>It can be used to read or write lines of text, or read text delimited by
a specified set of characters.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-line</strong> <var class="def-var-arguments">[port] [handle-delim]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dline"> ¶</a></span></dt>
<dd><p>Return a line of text from <var class="var">port</var> if specified, otherwise from the
value returned by <code class="code">(current-input-port)</code>.  Under Unix, a line of text
is terminated by the first end-of-line character or by end-of-file.
</p>
<p>If <var class="var">handle-delim</var> is specified, it should be one of the following
symbols:
</p><dl class="table">
<dt><code class="code">trim</code></dt>
<dd><p>Discard the terminating delimiter.  This is the default, but it will
be impossible to tell whether the read terminated with a delimiter or
end-of-file.
</p></dd>
<dt><code class="code">concat</code></dt>
<dd><p>Append the terminating delimiter (if any) to the returned string.
</p></dd>
<dt><code class="code">peek</code></dt>
<dd><p>Push the terminating delimiter (if any) back on to the port.
</p></dd>
<dt><code class="code">split</code></dt>
<dd><p>Return a pair containing the string read from the port and the
terminating delimiter or end-of-file object.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dline_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-line!</strong> <var class="def-var-arguments">buf [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dline_0021"> ¶</a></span></dt>
<dd><p>Read a line of text into the supplied string <var class="var">buf</var> and return the
number of characters added to <var class="var">buf</var>.  If <var class="var">buf</var> is filled, then
<code class="code">#f</code> is returned.  Read from <var class="var">port</var> if specified, otherwise
from the value returned by <code class="code">(current-input-port)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002ddelimited"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-delimited</strong> <var class="def-var-arguments">delims [port] [handle-delim]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002ddelimited"> ¶</a></span></dt>
<dd><p>Read text until one of the characters in the string <var class="var">delims</var> is
found or end-of-file is reached.  Read from <var class="var">port</var> if supplied,
otherwise from the value returned by <code class="code">(current-input-port)</code>.
<var class="var">handle-delim</var> takes the same values as described for
<code class="code">read-line</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002ddelimited_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-delimited!</strong> <var class="def-var-arguments">delims buf [port] [handle-delim] [start] [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002ddelimited_0021"> ¶</a></span></dt>
<dd><p>Read text into the supplied string <var class="var">buf</var>.
</p>
<p>If a delimiter was found, return the number of characters written,
except if <var class="var">handle-delim</var> is <code class="code">split</code>, in which case the return
value is a pair, as noted above.
</p>
<p>As a special case, if <var class="var">port</var> was already at end-of-stream, the EOF
object is returned. Also, if no characters were written because the
buffer was full, <code class="code">#f</code> is returned.
</p>
<p>It’s something of a wacky interface, to be honest.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025read_002ddelimited_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%read-delimited!</strong> <var class="def-var-arguments">delims str gobble [port [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025read_002ddelimited_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fread_005fdelimited_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_read_delimited_x</strong> <var class="def-var-arguments">(delims, str, gobble, port, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fread_005fdelimited_005fx"> ¶</a></span></dt>
<dd><p>Read characters from <var class="var">port</var> into <var class="var">str</var> until one of the
characters in the <var class="var">delims</var> string is encountered.  If
<var class="var">gobble</var> is true, discard the delimiter character;
otherwise, leave it in the input stream for the next read.  If
<var class="var">port</var> is not specified, use the value of
<code class="code">(current-input-port)</code>.  If <var class="var">start</var> or <var class="var">end</var> are
specified, store data only into the substring of <var class="var">str</var>
bounded by <var class="var">start</var> and <var class="var">end</var> (which default to the
beginning and end of the string, respectively).
</p>
<p>Return a pair consisting of the delimiter that terminated the
string and the number of characters read.  If reading stopped
at the end of file, the delimiter returned is the
<var class="var">eof-object</var>; if the string was filled without encountering
a delimiter, this value is <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025read_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%read-line</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025read_002dline"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fread_005fline"><span class="category-def">C Function: </span><span><strong class="def-name">scm_read_line</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fread_005fline"> ¶</a></span></dt>
<dd><p>Read a newline-terminated line from <var class="var">port</var>, allocating storage as
necessary.  The newline terminator (if any) is removed from the string,
and a pair consisting of the line and its delimiter is returned.  The
delimiter may be either a newline or the <var class="var">eof-object</var>; if
<code class="code">%read-line</code> is called at the end of file, it returns the pair
<code class="code">(#&lt;eof&gt; . #&lt;eof&gt;)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-line</strong> <var class="def-var-arguments">obj [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dline"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwrite_005fline"><span class="category-def">C Function: </span><span><strong class="def-name">scm_write_line</strong> <var class="def-var-arguments">(obj, port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwrite_005fline"> ¶</a></span></dt>
<dd><p>Display <var class="var">obj</var> and a newline character to <var class="var">port</var>.  If
<var class="var">port</var> is not specified, <code class="code">(current-output-port)</code> is
used.  This procedure is equivalent to:
</p><div class="example lisp">
<pre class="lisp-preformatted">(display obj [port])
(newline [port])
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Default-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="n" rel="next">Types of Port</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Line_002fDelimited" accesskey="p" rel="prev">Line Oriented and Delimited Text</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Default-Ports-for-Input_002c-Output-and-Errors">6.12.9 Default Ports for Input, Output and Errors</h4>
<a class="index-entry-id" id="index-Default-ports"></a>
<a class="index-entry-id" id="index-Port_002c-default"></a>

<a class="index-entry-id" id="index-current_002dinput_002dport-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-current_002dinput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-input-port</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dinput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005finput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_input_port</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005finput_005fport"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-standard-input"></a>
<p>Return the current input port.  This is the default port used
by many input procedures.
</p>
<p>Initially this is the <em class="dfn">standard input</em> in Unix and C terminology.
When the standard input is a tty the port is unbuffered, otherwise
it’s fully buffered.
</p>
<p>Unbuffered input is good if an application runs an interactive
subprocess, since any type-ahead input won’t go into Guile’s buffer
and be unavailable to the subprocess.
</p>
<p>Note that Guile buffering is completely separate from the tty “line
discipline”.  In the usual cooked mode on a tty Guile only sees a
line of input once the user presses <kbd class="key">Return</kbd>.
</p></dd></dl>

<a class="index-entry-id" id="index-current_002doutput_002dport-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-current_002doutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-output-port</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002doutput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005foutput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_output_port</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005foutput_005fport"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-standard-output"></a>
<p>Return the current output port.  This is the default port used
by many output procedures.
</p>
<p>Initially this is the <em class="dfn">standard output</em> in Unix and C terminology.
When the standard output is a tty this port is unbuffered, otherwise
it’s fully buffered.
</p>
<p>Unbuffered output to a tty is good for ensuring progress output or a
prompt is seen.  But an application which always prints whole lines
could change to line buffered, or an application with a lot of output
could go fully buffered and perhaps make explicit <code class="code">force-output</code>
calls (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>) at selected points.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002derror_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-error-port</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002derror_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005ferror_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_error_port</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005ferror_005fport"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-standard-error-output"></a>
<p>Return the port to which errors and warnings should be sent.
</p>
<p>Initially this is the <em class="dfn">standard error</em> in Unix and C terminology.
When the standard error is a tty this port is unbuffered, otherwise
it’s fully buffered.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dcurrent_002dinput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-current-input-port</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcurrent_002dinput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dcurrent_002doutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-current-output-port</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcurrent_002doutput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dcurrent_002derror_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-current-error-port</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcurrent_002derror_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcurrent_005finput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_current_input_port</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcurrent_005finput_005fport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcurrent_005foutput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_current_output_port</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcurrent_005foutput_005fport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcurrent_005ferror_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_current_error_port</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcurrent_005ferror_005fport"> ¶</a></span></dt>
<dd><p>Change the ports returned by <code class="code">current-input-port</code>,
<code class="code">current-output-port</code> and <code class="code">current-error-port</code>, respectively,
so that they use the supplied <var class="var">port</var> for input or output.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002dinput_002dfrom_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-input-from-port</strong> <var class="def-var-arguments">port thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dinput_002dfrom_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-with_002doutput_002dto_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-output-to-port</strong> <var class="def-var-arguments">port thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002doutput_002dto_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-with_002derror_002dto_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-error-to-port</strong> <var class="def-var-arguments">port thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002derror_002dto_002dport"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var> in a dynamic environment in which
<code class="code">current-input-port</code>, <code class="code">current-output-port</code> or
<code class="code">current-error-port</code> is rebound to the given <var class="var">port</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005fcurrent_005finput_005fport"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_current_input_port</strong> <code class="def-code-arguments">(SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fcurrent_005finput_005fport"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fdynwind_005fcurrent_005foutput_005fport"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_current_output_port</strong> <code class="def-code-arguments">(SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fcurrent_005foutput_005fport"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fdynwind_005fcurrent_005ferror_005fport"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_current_error_port</strong> <code class="def-code-arguments">(SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fcurrent_005ferror_005fport"> ¶</a></span></dt>
<dd><p>These functions must be used inside a pair of calls to
<code class="code">scm_dynwind_begin</code> and <code class="code">scm_dynwind_end</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).  During the dynwind context, the indicated port is set to
<var class="var">port</var>.
</p>
<p>More precisely, the current port is swapped with a ‘backup’ value
whenever the dynwind context is entered or left.  The backup value is
initialized with the <var class="var">port</var> argument.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Port-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Venerable-Port-Interfaces" accesskey="n" rel="next">Venerable Port Interfaces</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Default-Ports" accesskey="p" rel="prev">Default Ports for Input, Output and Errors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Types-of-Port">6.12.10 Types of Port</h4>
<a class="index-entry-id" id="index-Types-of-ports"></a>
<a class="index-entry-id" id="index-Port_002c-types"></a>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports" accesskey="1">File Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Ports" accesskey="2">Bytevector Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#String-Ports" accesskey="3">String Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ports" accesskey="4">Custom Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports" accesskey="5">Soft Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Void-Ports" accesskey="6">Void Ports</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="File-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Ports" accesskey="n" rel="next">Bytevector Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="File-Ports-1">6.12.10.1 File Ports</h4>
<a class="index-entry-id" id="index-File-port"></a>
<a class="index-entry-id" id="index-Port_002c-file"></a>

<p>The following procedures are used to open file ports.
See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors">open</a>, for an interface
to the Unix <code class="code">open</code> system call.
</p>
<p>All file access uses the “LFS” large file support functions when
available, so files bigger than 2 Gbytes (<em class="math">2^31</em> bytes) can be
read and written on a 32-bit system.
</p>
<p>Most systems have limits on how many files can be open, so it’s
strongly recommended that file ports be closed explicitly when no
longer required (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-open_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-file</strong> <var class="def-var-arguments">filename mode                           [#:guess-encoding=#f] [#:encoding=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005ffile_005fwith_005fencoding"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_file_with_encoding</strong> <var class="def-var-arguments">(filename, mode, guess_encoding, encoding)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005ffile_005fwith_005fencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005ffile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_file</strong> <var class="def-var-arguments">(filename, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005ffile"> ¶</a></span></dt>
<dd><p>Open the file whose name is <var class="var">filename</var>, and return a port
representing that file.  The attributes of the port are
determined by the <var class="var">mode</var> string.  The way in which this is
interpreted is similar to C stdio.  The first character must be
one of the following:
</p>
<dl class="table">
<dt>‘<samp class="samp">r</samp>’</dt>
<dd><p>Open an existing file for input.
</p></dd>
<dt>‘<samp class="samp">w</samp>’</dt>
<dd><p>Open a file for output, creating it if it doesn’t already exist
or removing its contents if it does.
</p></dd>
<dt>‘<samp class="samp">a</samp>’</dt>
<dd><p>Open a file for output, creating it if it doesn’t already
exist.  All writes to the port will go to the end of the file.
The "append mode" can be turned off while the port is in use
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors">fcntl</a>
</p></dd>
</dl>

<p>The following additional characters can be appended:
</p>
<dl class="table">
<dt>‘<samp class="samp">b</samp>’</dt>
<dd><p>Open the underlying file in binary mode, if supported by the system.
Also, open the file using the binary-compatible character encoding
"ISO-8859-1", ignoring the default port encoding.
</p></dd>
<dt>‘<samp class="samp">+</samp>’</dt>
<dd><p>Open the port for both input and output.  E.g., <code class="code">r+</code>: open
an existing file for both input and output.
</p></dd>
<dt>‘<samp class="samp">e</samp>’</dt>
<dd><p>Mark the underlying file descriptor as close-on-exec, as per the
<code class="code">O_CLOEXEC</code> flag.
</p></dd>
<dt>‘<samp class="samp">0</samp>’</dt>
<dd><p>Create an "unbuffered" port.  In this case input and output
operations are passed directly to the underlying port
implementation without additional buffering.  This is likely to
slow down I/O operations.  The buffering mode can be changed
while a port is in use (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>).
</p></dd>
<dt>‘<samp class="samp">l</samp>’</dt>
<dd><p>Add line-buffering to the port.  The port output buffer will be
automatically flushed whenever a newline character is written.
</p></dd>
<dt>‘<samp class="samp">b</samp>’</dt>
<dd><p>Use binary mode, ensuring that each byte in the file will be read as one
Scheme character.
</p>
<p>To provide this property, the file will be opened with the 8-bit
character encoding "ISO-8859-1", ignoring the default port encoding.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more information on port encodings.
</p>
<p>Note that while it is possible to read and write binary data as
characters or strings, it is usually better to treat bytes as octets,
and byte sequences as bytevectors.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO">Binary I/O</a>, for more.
</p>
<p>This option had another historical meaning, for DOS compatibility: in
the default (textual) mode, DOS reads a CR-LF sequence as one LF byte.
The <code class="code">b</code> flag prevents this from happening, adding <code class="code">O_BINARY</code>
to the underlying <code class="code">open</code> call.  Still, the flag is generally useful
because of its port encoding ramifications.
</p></dd>
</dl>

<p>Unless binary mode is requested, the character encoding of the new port
is determined as follows: First, if <var class="var">guess-encoding</var> is true, the
<code class="code">file-encoding</code> procedure is used to guess the encoding of the file
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files">Character Encoding of Source Files</a>).  If <var class="var">guess-encoding</var>
is false or if <code class="code">file-encoding</code> fails, <var class="var">encoding</var> is used unless
it is also false.  As a last resort, the default port encoding is used.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>, for more information on port encodings.  It is an error to
pass a non-false <var class="var">guess-encoding</var> or <var class="var">encoding</var> if binary mode
is requested.
</p>
<p>If a file cannot be opened with the access requested, <code class="code">open-file</code>
throws an exception.
</p></dd></dl>

<a class="index-entry-id" id="index-open_002dinput_002dfile-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-open_002dinput_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-input-file</strong> <var class="def-var-arguments">filename        [#:guess-encoding=#f] [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dinput_002dfile"> ¶</a></span></dt>
<dd>
<p>Open <var class="var">filename</var> for input.  If <var class="var">binary</var> is true, open the port
in binary mode, otherwise use text mode.  <var class="var">encoding</var> and
<var class="var">guess-encoding</var> determine the character encoding as described above
for <code class="code">open-file</code>.  Equivalent to
</p><div class="example lisp">
<pre class="lisp-preformatted">(open-file <var class="var">filename</var>
           (if <var class="var">binary</var> "rb" "r")
           #:guess-encoding <var class="var">guess-encoding</var>
           #:encoding <var class="var">encoding</var>)
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-open_002doutput_002dfile-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-open_002doutput_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-output-file</strong> <var class="def-var-arguments">filename        [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002doutput_002dfile"> ¶</a></span></dt>
<dd>
<p>Open <var class="var">filename</var> for output.  If <var class="var">binary</var> is true, open the port
in binary mode, otherwise use text mode.  <var class="var">encoding</var> specifies the
character encoding as described above for <code class="code">open-file</code>.  Equivalent
to
</p><div class="example lisp">
<pre class="lisp-preformatted">(open-file <var class="var">filename</var>
           (if <var class="var">binary</var> "wb" "w")
           #:encoding <var class="var">encoding</var>)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dinput_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-input-file</strong> <var class="def-var-arguments">filename proc         [#:guess-encoding=#f] [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dinput_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-call_002dwith_002doutput_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-output-file</strong> <var class="def-var-arguments">filename proc         [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002doutput_002dfile"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-call_002dwith_002dinput_002dfile-2"></a>
<a class="index-entry-id" id="index-call_002dwith_002doutput_002dfile-2"></a>
<p>Open <var class="var">filename</var> for input or output, and call <code class="code">(<var class="var">proc</var>
port)</code> with the resulting port.  Return the value returned by
<var class="var">proc</var>.  <var class="var">filename</var> is opened as per <code class="code">open-input-file</code> or
<code class="code">open-output-file</code> respectively, and an error is signaled if it
cannot be opened.
</p>
<p>When <var class="var">proc</var> returns, the port is closed.  If <var class="var">proc</var> does not
return (e.g. if it throws an error), then the port might not be
closed automatically, though it will be garbage collected in the usual
way if not otherwise referenced.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002dinput_002dfrom_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-input-from-file</strong> <var class="def-var-arguments">filename thunk         [#:guess-encoding=#f] [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dinput_002dfrom_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-with_002doutput_002dto_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-output-to-file</strong> <var class="def-var-arguments">filename thunk         [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002doutput_002dto_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-with_002derror_002dto_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-error-to-file</strong> <var class="def-var-arguments">filename thunk         [#:encoding=#f] [#:binary=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002derror_002dto_002dfile"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-with_002dinput_002dfrom_002dfile-2"></a>
<a class="index-entry-id" id="index-with_002doutput_002dto_002dfile-2"></a>
<p>Open <var class="var">filename</var> and call <code class="code">(<var class="var">thunk</var>)</code> with the new port
setup as respectively the <code class="code">current-input-port</code>,
<code class="code">current-output-port</code>, or <code class="code">current-error-port</code>.  Return the
value returned by <var class="var">thunk</var>.  <var class="var">filename</var> is opened as per
<code class="code">open-input-file</code> or <code class="code">open-output-file</code> respectively, and an
error is signaled if it cannot be opened.
</p>
<p>When <var class="var">thunk</var> returns, the port is closed and the previous setting
of the respective current port is restored.
</p>
<p>The current port setting is managed with <code class="code">dynamic-wind</code>, so the
previous value is restored no matter how <var class="var">thunk</var> exits (eg. an
exception), and if <var class="var">thunk</var> is re-entered (via a captured
continuation) then it’s set again to the <var class="var">filename</var> port.
</p>
<p>The port is closed when <var class="var">thunk</var> returns normally, but not when
exited via an exception or new continuation.  This ensures it’s still
ready for use if <var class="var">thunk</var> is re-entered by a captured continuation.
Of course the port is always garbage collected and closed in the usual
way when no longer referenced anywhere.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-port_002dmode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-mode</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dmode"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005fmode"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_mode</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005fmode"> ¶</a></span></dt>
<dd><p>Return the port modes associated with the open port <var class="var">port</var>.
These will not necessarily be identical to the modes used when
the port was opened, since modes such as "append" which are
used only during port creation are not retained.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-port_002dfilename"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-filename</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dfilename"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005ffilename"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_filename</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005ffilename"> ¶</a></span></dt>
<dd><p>Return the filename associated with <var class="var">port</var>, or <code class="code">#f</code> if no
filename is associated with the port.
</p>
<p><var class="var">port</var> must be open; <code class="code">port-filename</code> cannot be used once the
port is closed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dport_002dfilename_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-filename!</strong> <var class="def-var-arguments">port filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002dfilename_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005ffilename_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_filename_x</strong> <var class="def-var-arguments">(port, filename)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005ffilename_005fx"> ¶</a></span></dt>
<dd><p>Change the filename associated with <var class="var">port</var>, using the current input
port if none is specified.  Note that this does not change the port’s
source of data, but only the value that is returned by
<code class="code">port-filename</code> and reported in diagnostic output.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-file_002dport_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">file-port?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-file_002dport_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffile_005fport_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_file_port_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffile_005fport_005fp"> ¶</a></span></dt>
<dd><p>Determine whether <var class="var">obj</var> is a port that is related to a file.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Bytevector-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Ports" accesskey="n" rel="next">String Ports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports" accesskey="p" rel="prev">File Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Bytevector-Ports-1">6.12.10.2 Bytevector Ports</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dbytevector_002dinput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-bytevector-input-port</strong> <var class="def-var-arguments">bv [transcoder]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dbytevector_002dinput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005fbytevector_005finput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_bytevector_input_port</strong> <var class="def-var-arguments">(bv, transcoder)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005fbytevector_005finput_005fport"> ¶</a></span></dt>
<dd><p>Return an input port whose contents are drawn from bytevector <var class="var">bv</var>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>).
</p>
<p>The <var class="var">transcoder</var> argument is currently not supported.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dbytevector_002doutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-bytevector-output-port</strong> <var class="def-var-arguments">[transcoder]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dbytevector_002doutput_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005fbytevector_005foutput_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_bytevector_output_port</strong> <var class="def-var-arguments">(transcoder)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005fbytevector_005foutput_005fport"> ¶</a></span></dt>
<dd><p>Return two values: a binary output port and a procedure.  The latter
should be called with zero arguments to obtain a bytevector containing
the data accumulated by the port, as illustrated below.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(call-with-values
  (lambda ()
    (open-bytevector-output-port))
  (lambda (port get-bytevector)
    (display "hello" port)
    (get-bytevector)))

⇒ #vu8(104 101 108 108 111)
</pre></div>

<p>The <var class="var">transcoder</var> argument is currently not supported.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002doutput_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-output-bytevector</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002doutput_002dbytevector"> ¶</a></span></dt>
<dd><p>Call the one-argument procedure <var class="var">proc</var> with a newly created
bytevector output port.  When the function returns, the bytevector
composed of the characters written into the port is returned.
<var class="var">proc</var> should not close the port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dinput_002dbytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-input-bytevector</strong> <var class="def-var-arguments">bytevector proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dinput_002dbytevector"> ¶</a></span></dt>
<dd><p>Call the one-argument procedure <var class="var">proc</var> with a newly created input
port from which <var class="var">bytevector</var>’s contents may be read.  The values
yielded by the <var class="var">proc</var> is returned.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="String-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ports" accesskey="n" rel="next">Custom Ports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Ports" accesskey="p" rel="prev">Bytevector Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="String-Ports-1">6.12.10.3 String Ports</h4>
<a class="index-entry-id" id="index-String-port"></a>
<a class="index-entry-id" id="index-Port_002c-string"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002doutput_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-output-string</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002doutput_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005fwith_005foutput_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_with_output_string</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005fwith_005foutput_005fstring"> ¶</a></span></dt>
<dd><p>Calls the one-argument procedure <var class="var">proc</var> with a newly created output
port.  When the function returns, the string composed of the characters
written into the port is returned.  <var class="var">proc</var> should not close the port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dinput_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-input-string</strong> <var class="def-var-arguments">string proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dinput_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005fwith_005finput_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_with_input_string</strong> <var class="def-var-arguments">(string, proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005fwith_005finput_005fstring"> ¶</a></span></dt>
<dd><p>Calls the one-argument procedure <var class="var">proc</var> with a newly
created input port from which <var class="var">string</var>’s contents may be
read.  The value yielded by the <var class="var">proc</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002doutput_002dto_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-output-to-string</strong> <var class="def-var-arguments">thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002doutput_002dto_002dstring"> ¶</a></span></dt>
<dd><p>Calls the zero-argument procedure <var class="var">thunk</var> with the current output
port set temporarily to a new string port.  It returns a string
composed of the characters written to the current output.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002dinput_002dfrom_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-input-from-string</strong> <var class="def-var-arguments">string thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dinput_002dfrom_002dstring"> ¶</a></span></dt>
<dd><p>Calls the zero-argument procedure <var class="var">thunk</var> with the current input
port set temporarily to a string port opened on the specified
<var class="var">string</var>.  The value yielded by <var class="var">thunk</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dinput_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-input-string</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dinput_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005finput_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_input_string</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005finput_005fstring"> ¶</a></span></dt>
<dd><p>Take a string and return an input port that delivers characters
from the string. The port can be closed by
<code class="code">close-input-port</code>, though its storage will be reclaimed
by the garbage collector if it becomes inaccessible.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002doutput_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-output-string</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002doutput_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005foutput_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_output_string</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005foutput_005fstring"> ¶</a></span></dt>
<dd><p>Return an output port that will accumulate characters for
retrieval by <code class="code">get-output-string</code>. The port can be closed
by the procedure <code class="code">close-output-port</code>, though its storage
will be reclaimed by the garbage collector if it becomes
inaccessible.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002doutput_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-output-string</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002doutput_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005foutput_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_output_string</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005foutput_005fstring"> ¶</a></span></dt>
<dd><p>Given an output port created by <code class="code">open-output-string</code>,
return a string consisting of the characters that have been
output to the port so far.
</p>
<p><code class="code">get-output-string</code> must be used before closing <var class="var">port</var>, once
closed the string cannot be obtained.
</p></dd></dl>

<p>With string ports, the port-encoding is treated differently than other
types of ports.  When string ports are created, they do not inherit a
character encoding from the current locale.  They are given a
default locale that allows them to handle all valid string characters.
Typically one should not modify a string port’s character encoding
away from its default.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Encoding">Encoding</a>.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Custom-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports" accesskey="n" rel="next">Soft Ports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#String-Ports" accesskey="p" rel="prev">String Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Custom-Ports-1">6.12.10.4 Custom Ports</h4>

<p>Custom ports allow the user to provide input and handle output via
user-supplied procedures.  Guile currently only provides custom binary
ports, not textual ports; for custom textual ports, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports">Soft Ports</a>.
We should add the R6RS custom textual port interfaces though.
Contributions are appreciated.
</p>
<a class="index-entry-id" id="index-custom-binary-input-ports"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcustom_002dbinary_002dinput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-custom-binary-input-port</strong> <var class="def-var-arguments">id read! get-position set-position! close</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcustom_002dbinary_002dinput_002dport"> ¶</a></span></dt>
<dd><p>Return a new custom binary input port<a class="footnote" id="DOCF16" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT16"><sup>16</sup></a> named <var class="var">id</var> (a
string) whose input is drained by invoking <var class="var">read!</var> and passing it a
bytevector, an index where bytes should be written, and the number of
bytes to read.  The <code class="code">read!</code>  procedure must return an integer
indicating the number of bytes read, or <code class="code">0</code> to indicate the
end-of-file.
</p>
<p>Optionally, if <var class="var">get-position</var> is not <code class="code">#f</code>, it must be a thunk
that will be called when <code class="code">port-position</code> is invoked on the custom
binary port and should return an integer indicating the position within
the underlying data stream; if <var class="var">get-position</var> was not supplied, the
returned port does not support <code class="code">port-position</code>.
</p>
<p>Likewise, if <var class="var">set-position!</var> is not <code class="code">#f</code>, it should be a
one-argument procedure.  When <code class="code">set-port-position!</code> is invoked on the
custom binary input port, <var class="var">set-position!</var> is passed an integer
indicating the position of the next byte is to read.
</p>
<p>Finally, if <var class="var">close</var> is not <code class="code">#f</code>, it must be a thunk.  It is
invoked when the custom binary input port is closed.
</p>
<p>The returned port is fully buffered by default, but its buffering mode
can be changed using <code class="code">setvbuf</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>).
</p>
<p>Using a custom binary input port, the <code class="code">open-bytevector-input-port</code>
procedure (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevector-Ports">Bytevector Ports</a>) could be implemented as follows:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (open-bytevector-input-port source)
  (define position 0)
  (define length (bytevector-length source))

  (define (read! bv start count)
    (let ((count (min count (- length position))))
      (bytevector-copy! source position
                        bv start count)
      (set! position (+ position count))
      count))

  (define (get-position) position)

  (define (set-position! new-position)
    (set! position new-position))

  (make-custom-binary-input-port "the port" read!
                                  get-position set-position!
                                  #f))

(read (open-bytevector-input-port (string-&gt;utf8 "hello")))
⇒ hello
</pre></div>
</dd></dl>

<a class="index-entry-id" id="index-custom-binary-output-ports"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcustom_002dbinary_002doutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-custom-binary-output-port</strong> <var class="def-var-arguments">id write! get-position set-position! close</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcustom_002dbinary_002doutput_002dport"> ¶</a></span></dt>
<dd><p>Return a new custom binary output port named <var class="var">id</var> (a string) whose
output is sunk by invoking <var class="var">write!</var> and passing it a bytevector, an
index where bytes should be read from this bytevector, and the number of
bytes to be “written”.  The <code class="code">write!</code>  procedure must return an
integer indicating the number of bytes actually written; when it is
passed <code class="code">0</code> as the number of bytes to write, it should behave as
though an end-of-file was sent to the byte sink.
</p>
<p>The other arguments are as for <code class="code">make-custom-binary-input-port</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-custom-binary-input_002foutput-ports"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcustom_002dbinary_002dinput_002foutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-custom-binary-input/output-port</strong> <var class="def-var-arguments">id read! write! get-position set-position! close</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcustom_002dbinary_002dinput_002foutput_002dport"> ¶</a></span></dt>
<dd><p>Return a new custom binary input/output port named <var class="var">id</var> (a string).
The various arguments are the same as for The other arguments are as for
<code class="code">make-custom-binary-input-port</code> and
<code class="code">make-custom-binary-output-port</code>.  If buffering is enabled on the
port, as is the case by default, input will be buffered in both
directions; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>.  If the <var class="var">set-position!</var> function is
provided and not <code class="code">#f</code>, then the port will also be marked as
random-access, causing the buffer to be flushed between reads and
writes.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Soft-Ports">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Void-Ports" accesskey="n" rel="next">Void Ports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Custom-Ports" accesskey="p" rel="prev">Custom Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Soft-Ports-1">6.12.10.5 Soft Ports</h4>
<a class="index-entry-id" id="index-Soft-port"></a>
<a class="index-entry-id" id="index-Port_002c-soft"></a>

<p>A <em class="dfn">soft port</em> is a port based on a vector of procedures capable of
accepting or delivering characters.  It allows emulation of I/O ports.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsoft_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-soft-port</strong> <var class="def-var-arguments">pv modes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsoft_002dport"> ¶</a></span></dt>
<dd><p>Return a port capable of receiving or delivering characters as
specified by the <var class="var">modes</var> string (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">open-file</a>).  <var class="var">pv</var> must be a vector of length 5 or 6.  Its
components are as follows:
</p>
<ol class="enumerate" start="0">
<li> procedure accepting one character for output
</li><li> procedure accepting a string for output
</li><li> thunk for flushing output
</li><li> thunk for getting one character
</li><li> thunk for closing port (not by garbage collection)
</li><li> (if present and not <code class="code">#f</code>) thunk for computing the number of
characters that can be read from the port without blocking.
</li></ol>

<p>For an output-only port only elements 0, 1, 2, and 4 need be
procedures.  For an input-only port only elements 3 and 4 need
be procedures.  Thunks 2 and 4 can instead be <code class="code">#f</code> if
there is no useful operation for them to perform.
</p>
<p>If thunk 3 returns <code class="code">#f</code> or an <code class="code">eof-object</code>
(see <a data-manual="r5rs" href="https://www.gnu.org/software/guile/manual/r5rs.html#Input">eof-object?</a> in <cite class="cite">The Revised^5 Report on
Scheme</cite>) it indicates that the port has reached end-of-file.
For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define stdout (current-output-port))
(define p (make-soft-port
           (vector
            (lambda (c) (write c stdout))
            (lambda (s) (display s stdout))
            (lambda () (display "." stdout))
            (lambda () (char-upcase (read-char)))
            (lambda () (display "@" stdout)))
           "rw"))

(write p p) ⇒ #&lt;input-output: soft 8081e20&gt;
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Void-Ports">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports" accesskey="p" rel="prev">Soft Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="u" rel="up">Types of Port</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Void-Ports-1">6.12.10.6 Void Ports</h4>
<a class="index-entry-id" id="index-Void-port"></a>
<a class="index-entry-id" id="index-Port_002c-void"></a>

<p>This kind of port causes any data to be discarded when written to, and
always returns the end-of-file object when read from.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-_0025make_002dvoid_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%make-void-port</strong> <var class="def-var-arguments">mode</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025make_002dvoid_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fmake_005fvoid_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_make_void_port</strong> <var class="def-var-arguments">(mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fmake_005fvoid_005fport"> ¶</a></span></dt>
<dd><p>Create and return a new void port.  A void port acts like
<samp class="file">/dev/null</samp>.  The <var class="var">mode</var> argument
specifies the input/output modes for this port: see the
documentation for <code class="code">open-file</code> in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">File Ports</a>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Venerable-Port-Interfaces">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Ports-from-C" accesskey="n" rel="next">Using Ports from C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Port-Types" accesskey="p" rel="prev">Types of Port</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Venerable-Port-Interfaces-1">6.12.11 Venerable Port Interfaces</h4>

<p>Over the 25 years or so that Guile has been around, its port system has
evolved, adding many useful features.  At the same time there have been
four major Scheme standards released in those 25 years, which also
evolve the common Scheme understanding of what a port interface should
be.  Alas, it would be too much to ask for all of these evolutionary
branches to be consistent.  Some of Guile’s original interfaces don’t
mesh with the later Scheme standards, and yet Guile can’t just drop old
interfaces.  Sadly as well, the R6RS and R7RS standards both part from a
base of R5RS, but end up in different and somewhat incompatible designs.
</p>
<p>Guile’s approach is to pick a set of port primitives that make sense
together.  We document that set of primitives, design our internal
interfaces around them, and recommend them to users.  As the R6RS I/O
system is the most capable standard that Scheme has yet produced in this
domain, we mostly recommend that; <code class="code">(ice-9 binary-ports)</code> and
<code class="code">(ice-9 textual-ports)</code> are wholly modelled on <code class="code">(rnrs io
ports)</code>.  Guile does not wholly copy R6RS, however; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Incompatibilities">Incompatibilities with the R6RS</a>.
</p>
<p>At the same time, we have many venerable port interfaces, lore handed
down to us from our hacker ancestors.  Most of these interfaces even
predate the expectation that Scheme should have modules, so they are
present in the default environment.  In Guile we support them as well
and we have no plans to remove them, but again we don’t recommend them
for new users.
</p>
<a class="index-entry-id" id="index-char_002dready_003f-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dready_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-ready?</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dready_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if a character is ready on input <var class="var">port</var>
and return <code class="code">#f</code> otherwise.  If <code class="code">char-ready?</code> returns
<code class="code">#t</code> then the next <code class="code">read-char</code> operation on
<var class="var">port</var> is guaranteed not to hang.  If <var class="var">port</var> is a file
port at end of file then <code class="code">char-ready?</code> returns <code class="code">#t</code>.
</p>
<p><code class="code">char-ready?</code> exists to make it possible for a
program to accept characters from interactive ports without
getting stuck waiting for input.  Any input editors associated
with such ports must make sure that characters whose existence
has been asserted by <code class="code">char-ready?</code> cannot be rubbed out.
If <code class="code">char-ready?</code> were to return <code class="code">#f</code> at end of file,
a port at end of file would be indistinguishable from an
interactive port that has no ready characters.
</p>
<p>Note that <code class="code">char-ready?</code> only works reliably for terminals and
sockets with one-byte encodings.  Under the hood it will return
<code class="code">#t</code> if the port has any input buffered, or if the file descriptor
that backs the port polls as readable, indicating that Guile can fetch
more bytes from the kernel.  However being able to fetch one byte
doesn’t mean that a full character is available; See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Encoding">Encoding</a>.  Also,
on many systems it’s possible for a file descriptor to poll as readable,
but then block when it comes time to read bytes.  Note also that on
Linux kernels, all file ports backed by files always poll as readable.
For non-file ports, this procedure always returns <code class="code">#t</code>, except for
soft ports, which have a <code class="code">char-ready?</code> handler.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Soft-Ports">Soft Ports</a>.
</p>
<p>In short, this is a legacy procedure whose semantics are hard to
provide.  However it is a useful check to see if any input is buffered.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO">Non-Blocking I/O</a>.
</p></dd></dl>

<a class="index-entry-id" id="index-read_002dchar-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-char</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dchar"> ¶</a></span></dt>
<dd><p>The same as <code class="code">get-char</code>, except that <var class="var">port</var> defaults to the
current input port.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<a class="index-entry-id" id="index-peek_002dchar-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-peek_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peek-char</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peek_002dchar"> ¶</a></span></dt>
<dd><p>The same as <code class="code">lookahead-char</code>, except that <var class="var">port</var> defaults to
the current input port.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unread_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unread-char</strong> <var class="def-var-arguments">cobj [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unread_002dchar"> ¶</a></span></dt>
<dd><p>The same as <code class="code">unget-char</code>, except that <var class="var">port</var> defaults to the
current input port, and the arguments are swapped.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unread_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unread-string</strong> <var class="def-var-arguments">str port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unread_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005funread_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_unread_string</strong> <var class="def-var-arguments">(str, port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funread_005fstring"> ¶</a></span></dt>
<dd><p>The same as <code class="code">unget-string</code>, except that <var class="var">port</var> defaults to the
current input port, and the arguments are swapped.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<a class="index-entry-id" id="index-newline-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-newline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">newline</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-newline"> ¶</a></span></dt>
<dd><p>Send a newline to <var class="var">port</var>.  If <var class="var">port</var> is omitted, send to the
current output port.  Equivalent to <code class="code">(put-char port #\newline)</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-write_002dchar-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-write_002dchar"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-char</strong> <var class="def-var-arguments">chr [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dchar"> ¶</a></span></dt>
<dd><p>The same as <code class="code">put-char</code>, except that <var class="var">port</var> defaults to the
current input port, and the arguments are swapped.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Using-Ports-from-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#I_002fO-Extensions" accesskey="n" rel="next">Implementing New Port Types in C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Venerable-Port-Interfaces" accesskey="p" rel="prev">Venerable Port Interfaces</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Using-Ports-from-C-1">6.12.12 Using Ports from C</h4>

<p>Guile’s C interfaces provides some niceties for sending and receiving
bytes and characters in a way that works better with C.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fread"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_read</strong> <code class="def-code-arguments">(SCM port, void *buffer, size_t size)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fread"> ¶</a></span></dt>
<dd><p>Read up to <var class="var">size</var> bytes from <var class="var">port</var> and store them in
<var class="var">buffer</var>.  The return value is the number of bytes actually read,
which can be less than <var class="var">size</var> if end-of-file has been reached.
</p>
<p>Note that as this is a binary input procedure, this function does not
update <code class="code">port-line</code> and <code class="code">port-column</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwrite"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_write</strong> <code class="def-code-arguments">(SCM port, const void *buffer, size_t size)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwrite"> ¶</a></span></dt>
<dd><p>Write <var class="var">size</var> bytes at <var class="var">buffer</var> to <var class="var">port</var>.
</p>
<p>Note that as this is a binary output procedure, this function does not
update <code class="code">port-line</code> and <code class="code">port-column</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fread_005fbytes"><span class="category-def">C Function: </span><span><code class="def-type">size_t</code> <strong class="def-name">scm_c_read_bytes</strong> <code class="def-code-arguments">(SCM port, SCM bv, size_t start, size_t count)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fread_005fbytes"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fwrite_005fbytes"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_write_bytes</strong> <code class="def-code-arguments">(SCM port, SCM bv, size_t start, size_t count)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwrite_005fbytes"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_c_read</code> and <code class="code">scm_c_write</code>, but reading into or
writing from the bytevector <var class="var">bv</var>.  <var class="var">count</var> indicates the byte
index at which to start in the bytevector, and the read or write will
continue for <var class="var">count</var> bytes.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005funget_005fbytes"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_unget_bytes</strong> <code class="def-code-arguments">(const unsigned char *buf, size_t len, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funget_005fbytes"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005funget_005fbyte"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_unget_byte</strong> <code class="def-code-arguments">(int c, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funget_005fbyte"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fungetc"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_ungetc</strong> <code class="def-code-arguments">(scm_t_wchar c, SCM port)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fungetc"> ¶</a></span></dt>
<dd><p>Like <code class="code">unget-bytevector</code>, <code class="code">unget-byte</code>, and <code class="code">unget-char</code>,
respectively.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Textual-I_002fO">Textual I/O</a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fput_005flatin1_005fchars"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_put_latin1_chars</strong> <code class="def-code-arguments">(SCM port, const scm_t_uint8 *buf, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fput_005flatin1_005fchars"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fput_005futf32_005fchars"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_put_utf32_chars</strong> <code class="def-code-arguments">(SCM port, const scm_t_uint32 *buf, size_t len);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fput_005futf32_005fchars"> ¶</a></span></dt>
<dd><p>Write a string to <var class="var">port</var>.  In the first case, the
<code class="code">scm_t_uint8*</code> buffer is a string in the latin-1 encoding.  In the
second, the <code class="code">scm_t_uint32*</code> buffer is a string in the UTF-32
encoding.  These routines will update the port’s line and column.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="I_002fO-Extensions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO" accesskey="n" rel="next">Non-Blocking I/O</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Ports-from-C" accesskey="p" rel="prev">Using Ports from C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Implementing-New-Port-Types-in-C">6.12.13 Implementing New Port Types in C</h4>

<p>This section describes how to implement a new port type in C.  Although
ports support many operations, as a data structure they present an
opaque interface to the user.  To the port implementor, you have two
pieces of information to work with: the port type, and the port’s
“stream”.  The port type is an opaque pointer allocated when defining
your port type.  It is your key into the port API, and it helps you
identify which ports are actually yours.  The “stream” is a pointer
you control, and which you set when you create a port.  Get a stream
from a port using the <code class="code">SCM_STREAM</code> macro.  Note that your port
methods are only ever called with ports of your type.
</p>
<p>A port type is created by calling <code class="code">scm_make_port_type</code>.  Once you
have your port type, you can create ports with <code class="code">scm_c_make_port</code>,
or <code class="code">scm_c_make_port_with_encoding</code>.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fmake_005fport_005ftype"><span class="category-def">Function: </span><span><code class="def-type">scm_t_port_type*</code> <strong class="def-name">scm_make_port_type</strong> <code class="def-code-arguments">(char *name, size_t (*read) (SCM port, SCM dst, size_t start, size_t count), size_t (*write) (SCM port, SCM src, size_t start, size_t count))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fport_005ftype"> ¶</a></span></dt>
<dd><p>Define a new port type.  The <var class="var">name</var>, <var class="var">read</var> and <var class="var">write</var>
parameters are initial values for those port type fields, as described
below.  The other fields are initialized with default values and can be
changed later.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fc_005fmake_005fport_005fwith_005fencoding"><span class="category-def">Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_port_with_encoding</strong> <code class="def-code-arguments">(scm_t_port_type *type, unsigned long mode_bits, SCM encoding, SCM conversion_strategy, scm_t_bits stream)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fport_005fwith_005fencoding"> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fmake_005fport"><span class="category-def">Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_make_port</strong> <code class="def-code-arguments">(scm_t_port_type *type, unsigned long mode_bits, scm_t_bits stream)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fport"> ¶</a></span></dt>
<dd><p>Make a port with the given <var class="var">type</var>.  The <var class="var">stream</var> indicates the
private data associated with the port, which your port implementation
may later retrieve with <code class="code">SCM_STREAM</code>.  The mode bits should include
one or more of the flags <code class="code">SCM_RDNG</code> or <code class="code">SCM_WRTNG</code>, indicating
that the port is an input and/or an output port, respectively.  The mode
bits may also include <code class="code">SCM_BUF0</code> or <code class="code">SCM_BUFLINE</code>, indicating
that the port should be unbuffered or line-buffered, respectively.  The
default is that the port will be block-buffered.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>.
</p>
<p>As you would imagine, <var class="var">encoding</var> and <var class="var">conversion_strategy</var>
specify the port’s initial textual encoding and conversion strategy.
Both are symbols.  <code class="code">scm_c_make_port</code> is the same as
<code class="code">scm_c_make_port_with_encoding</code>, except it uses the default port
encoding and conversion strategy.
</p></dd></dl>

<p>The port type has a number of associate procedures and properties which
collectively implement the port’s behavior.  Creating a new port type
mostly involves writing these procedures.
</p>
<dl class="table">
<dt><code class="code">name</code></dt>
<dd><p>A pointer to a NUL terminated string: the name of the port type.  This
property is initialized via the first argument to
<code class="code">scm_make_port_type</code>.
</p>
</dd>
<dt><code class="code">read</code></dt>
<dd><p>A port’s <code class="code">read</code> implementation fills read buffers.  It should copy
bytes to the supplied bytevector <code class="code">dst</code>, starting at offset
<code class="code">start</code> and continuing for <code class="code">count</code> bytes, returning the number
of bytes read.
</p>
</dd>
<dt><code class="code">write</code></dt>
<dd><p>A port’s <code class="code">write</code> implementation flushes write buffers to the
mutable store.
It should write out bytes from the supplied bytevector <code class="code">src</code>,
starting at offset <code class="code">start</code> and continuing for <code class="code">count</code> bytes,
and return the number of bytes that were written.
</p>
</dd>
<dt><code class="code">read_wait_fd</code></dt>
<dt><code class="code">write_wait_fd</code></dt>
<dd><p>If a port’s <code class="code">read</code> or <code class="code">write</code> function returns <code class="code">(size_t)
-1</code>, that indicates that reading or writing would block.  In that case
to preserve the illusion of a blocking read or write operation, Guile’s
C port run-time will <code class="code">poll</code> on the file descriptor returned by
either the port’s <code class="code">read_wait_fd</code> or <code class="code">write_wait_fd</code> function.
Set using
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fread_005fwait_005ffd"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_read_wait_fd</strong> <code class="def-code-arguments">(scm_t_port_type *type, int (*wait_fd) (SCM port))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fread_005fwait_005ffd"> ¶</a></span></dt>
<dt class="deftypefnx deftypefunx-alias-deftypefnx def-cmd-deftypefn" id="index-scm_005fset_005fport_005fwrite_005fwait_005ffd"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_write_wait_fd</strong> <code class="def-code-arguments">(scm_t_port_type *type, int (*wait_fd) (SCM port))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fwrite_005fwait_005ffd"> ¶</a></span></dt>
</dl>

<p>Only a port type which implements the <code class="code">read_wait_fd</code> or
<code class="code">write_wait_fd</code> port methods can usefully return <code class="code">(size_t) -1</code>
from a read or write function.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO">Non-Blocking I/O</a>, for more on
non-blocking I/O in Guile.
</p>
</dd>
<dt><code class="code">print</code></dt>
<dd><p>Called when <code class="code">write</code> is called on the port, to print a port
description.  For example, for a file port it may produce something
like: <code class="code">#&lt;input: /etc/passwd 3&gt;</code>.  Set using
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fprint"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_print</strong> <code class="def-code-arguments">(scm_t_port_type *type, int (*print) (SCM port, SCM dest_port, scm_print_state *pstate))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fprint"> ¶</a></span></dt>
<dd><p>The first argument <var class="var">port</var> is the port being printed, the second
argument <var class="var">dest_port</var> is where its description should go.
</p></dd></dl>

</dd>
<dt><code class="code">close</code></dt>
<dd><p>Called when the port is closed.  It should free any resources used by
the port.  Set using
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fclose"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_close</strong> <code class="def-code-arguments">(scm_t_port_type *type, void (*close) (SCM port))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fclose"> ¶</a></span></dt>
</dl>

<p>By default, ports that are garbage collected just go away without
closing.  If your port type needs to release some external resource like
a file descriptor, or needs to make sure that its internal buffers are
flushed even if the port is collected while it was open, then mark the
port type as needing a close on GC.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fneeds_005fclose_005fon_005fgc"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_needs_close_on_gc</strong> <code class="def-code-arguments">(scm_t_port_type *type, int needs_close_p)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fneeds_005fclose_005fon_005fgc"> ¶</a></span></dt>
</dl>

</dd>
<dt><code class="code">seek</code></dt>
<dd><p>Set the current position of the port.  Guile will flush read and/or
write buffers before seeking, as appropriate.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fseek"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_seek</strong> <code class="def-code-arguments">(scm_t_port_type *type, scm_t_off (*seek) (SCM port, scm_t_off offset, int whence))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fseek"> ¶</a></span></dt>
</dl>

</dd>
<dt><code class="code">truncate</code></dt>
<dd><p>Truncate the port data to be specified length.  Guile will flush buffers
before hand, as appropriate.  Set using
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005ftruncate"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_truncate</strong> <code class="def-code-arguments">(scm_t_port_type *type, void (*truncate) (SCM port, scm_t_off length))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005ftruncate"> ¶</a></span></dt>
</dl>

</dd>
<dt><code class="code">random_access_p</code></dt>
<dd><p>Determine whether this port is a random-access port.
</p>
<a class="index-entry-id" id="index-random-access"></a>
<p>Seeking on a random-access port with buffered input, or switching to
writing after reading, will cause the buffered input to be discarded and
Guile will seek the port back the buffered number of bytes.  Likewise
seeking on a random-access port with buffered output, or switching to
reading after writing, will flush pending bytes with a call to the
<code class="code">write</code> procedure.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>.
</p>
<p>Indicate to Guile that your port needs this behavior by returning a
nonzero value from your <code class="code">random_access_p</code> function.  The default
implementation of this function returns nonzero if the port type
supplies a seek implementation.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005frandom_005faccess_005fp"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_random_access_p</strong> <code class="def-code-arguments">(scm_t_port_type *type, int (*random_access_p) (SCM port));</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005frandom_005faccess_005fp"> ¶</a></span></dt>
</dl>

</dd>
<dt><code class="code">get_natural_buffer_sizes</code></dt>
<dd><p>Guile will internally attach buffers to ports.  An input port always has
a read buffer and an output port always has a write buffer.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>.  A port buffer consists of a bytevector, along with
some cursors into that bytevector denoting where to get and put data.
</p>
<p>Port implementations generally don’t have to be concerned with
buffering: a port type’s <code class="code">read</code> or <code class="code">write</code> function will
receive the buffer’s bytevector as an argument, along with an offset and
a length into that bytevector, and should then either fill or empty that
bytevector.  However in some cases, port implementations may be able to
provide an appropriate default buffer size to Guile.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fset_005fport_005fget_005fnatural_005fbuffer_005fsizes"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_port_get_natural_buffer_sizes</strong> <code class="def-code-arguments">(scm_t_port_type *type, void (*get_natural_buffer_sizes) (SCM, size_t *read_buf_size, size_t *write_buf_size))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005fget_005fnatural_005fbuffer_005fsizes"> ¶</a></span></dt>
<dd><p>Fill in <var class="var">read_buf_size</var> and <var class="var">write_buf_size</var> with an appropriate buffer size for this port, if one is known.
</p></dd></dl>

<p>File ports implement a <code class="code">get_natural_buffer_sizes</code> to let the
operating system inform Guile about the appropriate buffer sizes for the
particular file opened by the port.
</p></dd>
</dl>

<p>Note that calls to all of these methods can proceed in parallel and
concurrently and from any thread up until the point that the port is
closed.  The call to <code class="code">close</code> will happen when no other method is
running, and no method will be called after the <code class="code">close</code> method is
called.  If your port implementation needs mutual exclusion to prevent
concurrency, it is responsible for locking appropriately.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Non_002dBlocking-I_002fO">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#BOM-Handling" accesskey="n" rel="next">Handling of Unicode Byte Order Marks</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#I_002fO-Extensions" accesskey="p" rel="prev">Implementing New Port Types in C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Non_002dBlocking-I_002fO-1">6.12.14 Non-Blocking I/O</h4>

<p>Most ports in Guile are <em class="dfn">blocking</em>: when you try to read a character
from a port, Guile will block on the read until a character is ready, or
end-of-stream is detected.  Likewise whenever Guile goes to write
(possibly buffered) data to an output port, Guile will block until all
the data is written.
</p>
<p>Interacting with ports in blocking mode is very convenient: you can
write straightforward, sequential algorithms whose code flow reflects
the flow of data.  However, blocking I/O has two main limitations.
</p>
<p>The first is that it’s easy to get into a situation where code is
waiting on data.  Time spent waiting on data when code could be doing
something else is wasteful and prevents your program from reaching its
peak throughput.  If you implement a web server that sequentially
handles requests from clients, it’s very easy for the server to end up
waiting on a client to finish its HTTP request, or waiting on it to
consume the response.  The end result is that you are able to serve
fewer requests per second than you’d like to serve.
</p>
<p>The second limitation is related: a blocking parser over user-controlled
input is a denial-of-service vulnerability.  Indeed the so-called “slow
loris” attack of the early 2010s was just that: an attack on common web
servers that drip-fed HTTP requests, one character at a time.  All it
took was a handful of slow loris connections to occupy an entire web
server.
</p>
<p>In Guile we would like to preserve the ability to write straightforward
blocking networking processes of all kinds, but under the hood to allow
those processes to suspend their requests if they would block.
</p>
<p>To do this, the first piece is to allow Guile ports to declare
themselves as being nonblocking.  This is currently supported only for
file ports, which also includes sockets, terminals, or any other port
that is backed by a file descriptor.  To do that, we use an arcane UNIX
incantation:
</p>
<div class="example">
<pre class="example-preformatted">(let ((flags (fcntl socket F_GETFL)))
  (fcntl socket F_SETFL (logior O_NONBLOCK flags)))
</pre></div>

<p>Now the file descriptor is open in non-blocking mode.  If Guile tries to
read or write from this file and the read or write returns a result
indicating that more data can only be had by doing a blocking read or
write, Guile will block by polling on the socket’s <code class="code">read-wait-fd</code>
or <code class="code">write-wait-fd</code>, to preserve the illusion of a blocking read or
write.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#I_002fO-Extensions">Implementing New Port Types in C</a> for more on those internal interfaces.
</p>
<p>So far we have just reproduced the status quo: the file descriptor is
non-blocking, but the operations on the port do block.  To go farther,
it would be nice if we could suspend the “thread” using delimited
continuations, and only resume the thread once the file descriptor is
readable or writable.  (See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">Prompts</a>).
</p>
<p>But here we run into a difficulty.  The ports code is implemented in C,
which means that although we can suspend the computation to some outer
prompt, we can’t resume it because Guile can’t resume delimited
continuations that capture the C stack.
</p>
<p>To overcome this difficulty we have created a compatible but entirely
parallel implementation of port operations.  To use this implementation,
do the following:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 suspendable-ports))
(install-suspendable-ports!)
</pre></div>

<p>This will replace the core I/O primitives like <code class="code">get-char</code> and
<code class="code">put-bytevector</code> with new versions that are exactly the same as the
ones in the standard library, but with two differences.  One is that
when a read or a write would block, the suspendable port operations call
out the value of the <code class="code">current-read-waiter</code> or
<code class="code">current-write-waiter</code> parameter, as appropriate.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>.  The default read and write waiters do the same thing
that the C read and write waiters do, which is to poll.  User code can
parameterize the waiters, though, enabling the computation to suspend
and allow the program to process other I/O operations.  Because the new
suspendable ports implementation is written in Scheme, that suspended
computation can resume again later when it is able to make progress.
Success!
</p>
<p>The other main difference is that because the new ports implementation
is written in Scheme, it is slower than C, currently by a factor of 3 or
4, though it depends on many factors.  For this reason we have to keep
the C implementations as the default ones.  One day when Guile’s
compiler is better, we can close this gap and have only one port
operation implementation again.
</p>
<p>Note that Guile does not currently include an implementation of the
facility to suspend the current thread and schedule other threads in the
meantime.  Before adding such a thing, we want to make sure that we’re
providing the right primitives that can be used to build schedulers and
other user-space concurrency patterns, and that the patterns that we
settle on are the right patterns.  In the meantime, have a look at 8sync
(<a class="url" href="https://gnu.org/software/8sync">https://gnu.org/software/8sync</a>) for a prototype of an
asynchronous I/O and concurrency facility.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-install_002dsuspendable_002dports_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">install-suspendable-ports!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-install_002dsuspendable_002dports_0021"> ¶</a></span></dt>
<dd><p>Replace the core ports implementation with suspendable ports, as
described above.  This will mutate the values of the bindings like
<code class="code">get-char</code>, <code class="code">put-u8</code>, and so on in place.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-uninstall_002dsuspendable_002dports_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uninstall-suspendable-ports!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uninstall_002dsuspendable_002dports_0021"> ¶</a></span></dt>
<dd><p>Restore the original core ports implementation, un-doing the effect of
<code class="code">install-suspendable-ports!</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dread_002dwaiter"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">current-read-waiter</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dread_002dwaiter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-current_002dwrite_002dwaiter"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">current-write-waiter</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dwrite_002dwaiter"> ¶</a></span></dt>
<dd><p>Parameters whose values are procedures of one argument, called when a
suspendable port operation would block on a port while reading or
writing, respectively.  The default values of these parameters do a
blocking <code class="code">poll</code> on the port’s file descriptor.  The procedures are
passed the port in question as their one argument.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="BOM-Handling">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Non_002dBlocking-I_002fO" accesskey="p" rel="prev">Non-Blocking I/O</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="u" rel="up">Input and Output</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Handling-of-Unicode-Byte-Order-Marks">6.12.15 Handling of Unicode Byte Order Marks</h4>
<a class="index-entry-id" id="index-BOM"></a>
<a class="index-entry-id" id="index-byte-order-mark"></a>

<p>This section documents the finer points of Guile’s handling of Unicode
byte order marks (BOMs).  A byte order mark (U+FEFF) is typically found
at the start of a UTF-16 or UTF-32 stream, to allow readers to reliably
determine the byte order.  Occasionally, a BOM is found at the start of
a UTF-8 stream, but this is much less common and not generally
recommended.
</p>
<p>Guile attempts to handle BOMs automatically, and in accordance with the
recommendations of the Unicode Standard, when the port encoding is set
to <code class="code">UTF-8</code>, <code class="code">UTF-16</code>, or <code class="code">UTF-32</code>.  In brief, Guile
automatically writes a BOM at the start of a UTF-16 or UTF-32 stream,
and automatically consumes one from the start of a UTF-8, UTF-16, or
UTF-32 stream.
</p>
<p>As specified in the Unicode Standard, a BOM is only handled specially at
the start of a stream, and only if the port encoding is set to
<code class="code">UTF-8</code>, <code class="code">UTF-16</code> or <code class="code">UTF-32</code>.  If the port encoding is
set to <code class="code">UTF-16BE</code>, <code class="code">UTF-16LE</code>, <code class="code">UTF-32BE</code>, or
<code class="code">UTF-32LE</code>, then BOMs are <em class="emph">not</em> handled specially, and none of
the special handling described in this section applies.
</p>
<ul class="itemize mark-bullet">
<li>To ensure that Guile will properly detect the byte order of a UTF-16 or
UTF-32 stream, you must perform a textual read before any writes, seeks,
or binary I/O.  Guile will not attempt to read a BOM unless a read is
explicitly requested at the start of the stream.

</li><li>If a textual write is performed before the first read, then an arbitrary
byte order will be chosen.  Currently, big endian is the default on all
platforms, but that may change in the future.  If you wish to explicitly
control the byte order of an output stream, set the port encoding to
<code class="code">UTF-16BE</code>, <code class="code">UTF-16LE</code>, <code class="code">UTF-32BE</code>, or <code class="code">UTF-32LE</code>,
and explicitly write a BOM (<code class="code">#\xFEFF</code>) if desired.

</li><li>If <code class="code">set-port-encoding!</code> is called in the middle of a stream, Guile
treats this as a new logical “start of stream” for purposes of BOM
handling, and will forget about any BOMs that had previously been seen.
Therefore, it may choose a different byte order than had been used
previously.  This is intended to support multiple logical text streams
embedded within a larger binary stream.

</li><li>Binary I/O operations are not guaranteed to update Guile’s notion of
whether the port is at the “start of the stream”, nor are they
guaranteed to produce or consume BOMs.

</li><li>For ports that support seeking (e.g. normal files), the input and output
streams are considered linked: if the user reads first, then a BOM will
be consumed (if appropriate), but later writes will <em class="emph">not</em> produce a
BOM.  Similarly, if the user writes first, then later reads will
<em class="emph">not</em> consume a BOM.

</li><li>For ports that are not random access (e.g. pipes, sockets, and
terminals), the input and output streams are considered
<em class="emph">independent</em> for purposes of BOM handling: the first read will
consume a BOM (if appropriate), and the first write will <em class="emph">also</em>
produce a BOM (if appropriate).  However, the input and output streams
will always use the same byte order.

</li><li>Seeks to the beginning of a file will set the “start of stream” flags.
Therefore, a subsequent textual read or write will consume or produce a
BOM.  However, unlike <code class="code">set-port-encoding!</code>, if a byte order had
already been chosen for the port, it will remain in effect after a seek,
and cannot be changed by the presence of a BOM.  Seeks anywhere other
than the beginning of a file clear the “start of stream” flags.
</li></ul>


<hr>
</div>
</div>
<div class="section-level-extent" id="Regular-Expressions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#LALR_00281_0029-Parsing" accesskey="n" rel="next">LALR(1) Parsing</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Input-and-Output" accesskey="p" rel="prev">Input and Output</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Regular-Expressions-1">6.13 Regular Expressions</h3>
<a class="index-entry-id" id="index-Regular-expressions"></a>

<a class="index-entry-id" id="index-regular-expressions"></a>
<a class="index-entry-id" id="index-regex"></a>
<a class="index-entry-id" id="index-emacs-regexp"></a>

<p>A <em class="dfn">regular expression</em> (or <em class="dfn">regexp</em>) is a pattern that
describes a whole class of strings.  A full description of regular
expressions and their syntax is beyond the scope of this manual.
</p>
<p>If your system does not include a POSIX regular expression library,
and you have not linked Guile with a third-party regexp library such
as Rx, these functions will not be available.  You can tell whether
your Guile installation includes regular expression support by
checking whether <code class="code">(provided? 'regex)</code> returns true.
</p>
<p>The following regexp and string matching features are provided by the
<code class="code">(ice-9 regex)</code> module.  Before using the described functions,
you should load this module by executing <code class="code">(use-modules (ice-9
regex))</code>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions" accesskey="1">Regexp Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures" accesskey="2">Match Structures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes" accesskey="3">Backslash Escapes</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Regexp-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures" accesskey="n" rel="next">Match Structures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" accesskey="u" rel="up">Regular Expressions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Regexp-Functions-1">6.13.1 Regexp Functions</h4>

<p>By default, Guile supports POSIX extended regular expressions.  That
means that the characters ‘<samp class="samp">(</samp>’, ‘<samp class="samp">)</samp>’, ‘<samp class="samp">+</samp>’ and ‘<samp class="samp">?</samp>’ are
special, and must be escaped if you wish to match the literal characters
and there is no support for “non-greedy” variants of ‘<samp class="samp">*</samp>’,
‘<samp class="samp">+</samp>’ or ‘<samp class="samp">?</samp>’.
</p>
<p>This regular expression interface was modeled after that
implemented by SCSH, the Scheme Shell.  It is intended to be
upwardly compatible with SCSH regular expressions.
</p>
<p>Zero bytes (<code class="code">#\nul</code>) cannot be used in regex patterns or input
strings, since the underlying C functions treat that as the end of
string.  If there’s a zero byte an error is thrown.
</p>
<p>Internally, patterns and input strings are converted to the current
locale’s encoding, and then passed to the C library’s regular expression
routines (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Regular-Expressions">Regular Expressions</a> in <cite class="cite">The GNU C Library
Reference Manual</cite>).  The returned match structures always point to
characters in the strings, not to individual bytes, even in the case of
multi-byte encodings.  This ensures that the match structures are
correct when performing matching with characters that have a multi-byte
representation in the locale encoding.  Note, however, that using
characters which cannot be represented in the locale encoding can
lead to surprising results.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dmatch"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-match</strong> <var class="def-var-arguments">pattern str [start]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dmatch"> ¶</a></span></dt>
<dd><p>Compile the string <var class="var">pattern</var> into a regular expression and compare
it with <var class="var">str</var>.  The optional numeric argument <var class="var">start</var> specifies
the position of <var class="var">str</var> at which to begin matching.
</p>
<p><code class="code">string-match</code> returns a <em class="dfn">match structure</em> which
describes what, if anything, was matched by the regular
expression.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures">Match Structures</a>.  If <var class="var">str</var> does not match
<var class="var">pattern</var> at all, <code class="code">string-match</code> returns <code class="code">#f</code>.
</p></dd></dl>

<p>Two examples of a match follow.  In the first example, the pattern
matches the four digits in the match string.  In the second, the pattern
matches nothing.
</p>
<div class="example">
<pre class="example-preformatted">(string-match "[0-9][0-9][0-9][0-9]" "blah2002")
⇒ #("blah2002" (4 . 8))

(string-match "[A-Za-z]" "123456")
⇒ #f
</pre></div>

<p>Each time <code class="code">string-match</code> is called, it must compile its
<var class="var">pattern</var> argument into a regular expression structure.  This
operation is expensive, which makes <code class="code">string-match</code> inefficient if
the same regular expression is used several times (for example, in a
loop).  For better performance, you can compile a regular expression in
advance and then match strings against the compiled regexp.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dregexp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-regexp</strong> <var class="def-var-arguments">pat flag…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dregexp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fregexp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_regexp</strong> <var class="def-var-arguments">(pat, flaglst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fregexp"> ¶</a></span></dt>
<dd><p>Compile the regular expression described by <var class="var">pat</var>, and
return the compiled regexp structure.  If <var class="var">pat</var> does not
describe a legal regular expression, <code class="code">make-regexp</code> throws
a <code class="code">regular-expression-syntax</code> error.
</p>
<p>The <var class="var">flag</var> arguments change the behavior of the compiled
regular expression.  The following values may be supplied:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002ficase"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/icase</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002ficase"> ¶</a></span></dt>
<dd><p>Consider uppercase and lowercase letters to be the same when
matching.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002fnewline"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/newline</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002fnewline"> ¶</a></span></dt>
<dd><p>If a newline appears in the target string, then permit the
‘<samp class="samp">^</samp>’ and ‘<samp class="samp">$</samp>’ operators to match immediately after or
immediately before the newline, respectively.  Also, the
‘<samp class="samp">.</samp>’ and ‘<samp class="samp">[^...]</samp>’ operators will never match a newline
character.  The intent of this flag is to treat the target
string as a buffer containing many lines of text, and the
regular expression as a pattern that may match a single one of
those lines.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002fbasic"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/basic</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002fbasic"> ¶</a></span></dt>
<dd><p>Compile a basic (“obsolete”) regexp instead of the extended
(“modern”) regexps that are the default.  Basic regexps do
not consider ‘<samp class="samp">|</samp>’, ‘<samp class="samp">+</samp>’ or ‘<samp class="samp">?</samp>’ to be special
characters, and require the ‘<samp class="samp">{...}</samp>’ and ‘<samp class="samp">(...)</samp>’
metacharacters to be backslash-escaped (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes">Backslash Escapes</a>).  There are several other differences between basic
and extended regular expressions, but these are the most
significant.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002fextended"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/extended</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002fextended"> ¶</a></span></dt>
<dd><p>Compile an extended regular expression rather than a basic
regexp.  This is the default behavior; this flag will not
usually be needed.  If a call to <code class="code">make-regexp</code> includes
both <code class="code">regexp/basic</code> and <code class="code">regexp/extended</code> flags, the
one which comes last will override the earlier one.
</p></dd></dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-regexp_002dexec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp-exec</strong> <var class="def-var-arguments">rx str [start [flags]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dexec"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fregexp_005fexec"><span class="category-def">C Function: </span><span><strong class="def-name">scm_regexp_exec</strong> <var class="def-var-arguments">(rx, str, start, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fregexp_005fexec"> ¶</a></span></dt>
<dd><p>Match the compiled regular expression <var class="var">rx</var> against
<code class="code">str</code>.  If the optional integer <var class="var">start</var> argument is
provided, begin matching from that position in the string.
Return a match structure describing the results of the match,
or <code class="code">#f</code> if no match could be found.
</p>
<p>The <var class="var">flags</var> argument changes the matching behavior.  The following
flag values may be supplied, use <code class="code">logior</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</a>) to combine them,
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002fnotbol"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/notbol</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002fnotbol"> ¶</a></span></dt>
<dd><p>Consider that the <var class="var">start</var> offset into <var class="var">str</var> is not the
beginning of a line and should not match operator ‘<samp class="samp">^</samp>’.
</p>
<p>If <var class="var">rx</var> was created with the <code class="code">regexp/newline</code> option above,
‘<samp class="samp">^</samp>’ will still match after a newline in <var class="var">str</var>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-regexp_002fnoteol"><span class="category-def">Variable: </span><span><strong class="def-name">regexp/noteol</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002fnoteol"> ¶</a></span></dt>
<dd><p>Consider that the end of <var class="var">str</var> is not the end of a line and should
not match operator ‘<samp class="samp">$</samp>’.
</p>
<p>If <var class="var">rx</var> was created with the <code class="code">regexp/newline</code> option above,
‘<samp class="samp">$</samp>’ will still match before a newline in <var class="var">str</var>.
</p></dd></dl>
</dd></dl>

<div class="example lisp">
<pre class="lisp-preformatted">;; Regexp to match uppercase letters
(define r (make-regexp "[A-Z]*"))

;; Regexp to match letters, ignoring case
(define ri (make-regexp "[A-Z]*" regexp/icase))

;; Search for bob using regexp r
(match:substring (regexp-exec r "bob"))
⇒ ""                  ; no match

;; Search for bob using regexp ri
(match:substring (regexp-exec ri "Bob"))
⇒ "Bob"               ; matched case insensitive
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-regexp_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fregexp_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_regexp_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fregexp_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a compiled regular expression,
or <code class="code">#f</code> otherwise.
</p></dd></dl>

<br>
<dl class="first-deffn">
<dt class="deffn" id="index-list_002dmatches"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-matches</strong> <var class="def-var-arguments">regexp str [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dmatches"> ¶</a></span></dt>
<dd><p>Return a list of match structures which are the non-overlapping
matches of <var class="var">regexp</var> in <var class="var">str</var>.  <var class="var">regexp</var> can be either a
pattern string or a compiled regexp.  The <var class="var">flags</var> argument is as
per <code class="code">regexp-exec</code> above.
</p>
<div class="example">
<pre class="example-preformatted">(map match:substring (list-matches "[a-z]+" "abc 42 def 78"))
⇒ ("abc" "def")
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fold_002dmatches"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fold-matches</strong> <var class="def-var-arguments">regexp str init proc [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fold_002dmatches"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to the non-overlapping matches of <var class="var">regexp</var> in
<var class="var">str</var>, to build a result.  <var class="var">regexp</var> can be either a pattern
string or a compiled regexp.  The <var class="var">flags</var> argument is as per
<code class="code">regexp-exec</code> above.
</p>
<p><var class="var">proc</var> is called as <code class="code">(<var class="var">proc</var> match prev)</code> where
<var class="var">match</var> is a match structure and <var class="var">prev</var> is the previous return
from <var class="var">proc</var>.  For the first call <var class="var">prev</var> is the given
<var class="var">init</var> parameter.  <code class="code">fold-matches</code> returns the final value
from <var class="var">proc</var>.
</p>
<p>For example to count matches,
</p>
<div class="example">
<pre class="example-preformatted">(fold-matches "[a-z][0-9]" "abc x1 def y2" 0
              (lambda (match count)
                (1+ count)))
⇒ 2
</pre></div>
</dd></dl>

<br>
<p>Regular expressions are commonly used to find patterns in one string
and replace them with the contents of another string.  The following
functions are convenient ways to do this.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-regexp_002dsubstitute"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp-substitute</strong> <var class="def-var-arguments">port match item …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dsubstitute"> ¶</a></span></dt>
<dd><p>Write to <var class="var">port</var> selected parts of the match structure <var class="var">match</var>.
Or if <var class="var">port</var> is <code class="code">#f</code> then form a string from those parts and
return that.
</p>
<p>Each <var class="var">item</var> specifies a part to be written, and may be one of the
following,
</p>
<ul class="itemize mark-bullet">
<li>A string.  String arguments are written out verbatim.

</li><li>An integer.  The submatch with that number is written
(<code class="code">match:substring</code>).  Zero is the entire match.

</li><li>The symbol ‘<samp class="samp">pre</samp>’.  The portion of the matched string preceding
the regexp match is written (<code class="code">match:prefix</code>).

</li><li>The symbol ‘<samp class="samp">post</samp>’.  The portion of the matched string following
the regexp match is written (<code class="code">match:suffix</code>).
</li></ul>

<p>For example, changing a match and retaining the text before and after,
</p>
<div class="example">
<pre class="example-preformatted">(regexp-substitute #f (string-match "[0-9]+" "number 25 is good")
                   'pre "37" 'post)
⇒ "number 37 is good"
</pre></div>

<p>Or matching a <small class="sc">YYYYMMDD</small> format date such as ‘<samp class="samp">20020828</samp>’ and
re-ordering and hyphenating the fields.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define date-regex
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute #f (string-match date-regex s)
                   'pre 2 "-" 3 "-" 1 'post " (" 0 ")")
⇒ "Date 04-29-2002 12am. (20020429)"
</pre></div>
</dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-regexp_002dsubstitute_002fglobal"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp-substitute/global</strong> <var class="def-var-arguments">port regexp target item…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dsubstitute_002fglobal"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-search-and-replace"></a>
<p>Write to <var class="var">port</var> selected parts of matches of <var class="var">regexp</var> in
<var class="var">target</var>.  If <var class="var">port</var> is <code class="code">#f</code> then form a string from
those parts and return that.  <var class="var">regexp</var> can be a string or a
compiled regex.
</p>
<p>This is similar to <code class="code">regexp-substitute</code>, but allows global
substitutions on <var class="var">target</var>.  Each <var class="var">item</var> behaves as per
<code class="code">regexp-substitute</code>, with the following differences,
</p>
<ul class="itemize mark-bullet">
<li>A function.  Called as <code class="code">(<var class="var">item</var> match)</code> with the match
structure for the <var class="var">regexp</var> match, it should return a string to be
written to <var class="var">port</var>.

</li><li>The symbol ‘<samp class="samp">post</samp>’.  This doesn’t output anything, but instead
causes <code class="code">regexp-substitute/global</code> to recurse on the unmatched
portion of <var class="var">target</var>.

<p>This <em class="emph">must</em> be supplied to perform a global search and replace on
<var class="var">target</var>; without it <code class="code">regexp-substitute/global</code> returns after
a single match and output.
</p></li></ul>

<p>For example, to collapse runs of tabs and spaces to a single hyphen
each,
</p>
<div class="example">
<pre class="example-preformatted">(regexp-substitute/global #f "[ \t]+"  "this   is   the text"
                          'pre "-" 'post)
⇒ "this-is-the-text"
</pre></div>

<p>Or using a function to reverse the letters in each word,
</p>
<div class="example">
<pre class="example-preformatted">(regexp-substitute/global #f "[a-z]+"  "to do and not-do"
  'pre (lambda (m) (string-reverse (match:substring m))) 'post)
⇒ "ot od dna ton-od"
</pre></div>

<p>Without the <code class="code">post</code> symbol, just one regexp match is made.  For
example the following is the date example from
<code class="code">regexp-substitute</code> above, without the need for the separate
<code class="code">string-match</code> call.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define date-regex
   "([0-9][0-9][0-9][0-9])([0-9][0-9])([0-9][0-9])")
(define s "Date 20020429 12am.")
(regexp-substitute/global #f date-regex s
                          'pre 2 "-" 3 "-" 1 'post " (" 0 ")")

⇒ "Date 04-29-2002 12am. (20020429)"
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Match-Structures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Backslash-Escapes" accesskey="n" rel="next">Backslash Escapes</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions" accesskey="p" rel="prev">Regexp Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" accesskey="u" rel="up">Regular Expressions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Match-Structures-1">6.13.2 Match Structures</h4>

<a class="index-entry-id" id="index-match-structures"></a>

<p>A <em class="dfn">match structure</em> is the object returned by <code class="code">string-match</code> and
<code class="code">regexp-exec</code>.  It describes which portion of a string, if any,
matched the given regular expression.  Match structures include: a
reference to the string that was checked for matches; the starting and
ending positions of the regexp match; and, if the regexp included any
parenthesized subexpressions, the starting and ending positions of each
submatch.
</p>
<p>In each of the regexp match functions described below, the <code class="code">match</code>
argument must be a match structure returned by a previous call to
<code class="code">string-match</code> or <code class="code">regexp-exec</code>.  Most of these functions
return some information about the original target string that was
matched against a regular expression; we will call that string
<var class="var">target</var> for easy reference.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-regexp_002dmatch_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp-match?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dmatch_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a match structure returned by a
previous call to <code class="code">regexp-exec</code>, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003asubstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:substring</strong> <var class="def-var-arguments">match [n]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003asubstring"> ¶</a></span></dt>
<dd><p>Return the portion of <var class="var">target</var> matched by subexpression number
<var class="var">n</var>.  Submatch 0 (the default) represents the entire regexp match.
If the regular expression as a whole matched, but the subexpression
number <var class="var">n</var> did not match, return <code class="code">#f</code>.
</p></dd></dl>

<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:substring s)
⇒ "2002"

;; match starting at offset 6 in the string
(match:substring
  (string-match "[0-9][0-9][0-9][0-9]" "blah987654" 6))
⇒ "7654"
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003astart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:start</strong> <var class="def-var-arguments">match [n]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003astart"> ¶</a></span></dt>
<dd><p>Return the starting position of submatch number <var class="var">n</var>.
</p></dd></dl>

<p>In the following example, the result is 4, since the match starts at
character index 4:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:start s)
⇒ 4
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003aend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:end</strong> <var class="def-var-arguments">match [n]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003aend"> ¶</a></span></dt>
<dd><p>Return the ending position of submatch number <var class="var">n</var>.
</p></dd></dl>

<p>In the following example, the result is 8, since the match runs between
characters 4 and 8 (i.e. the “2002”).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:end s)
⇒ 8
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003aprefix"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:prefix</strong> <var class="def-var-arguments">match</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003aprefix"> ¶</a></span></dt>
<dd><p>Return the unmatched portion of <var class="var">target</var> preceding the regexp match.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:prefix s)
⇒ "blah"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003asuffix"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:suffix</strong> <var class="def-var-arguments">match</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003asuffix"> ¶</a></span></dt>
<dd><p>Return the unmatched portion of <var class="var">target</var> following the regexp match.
</p></dd></dl>

<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:suffix s)
⇒ "foo"
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003acount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:count</strong> <var class="def-var-arguments">match</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003acount"> ¶</a></span></dt>
<dd><p>Return the number of parenthesized subexpressions from <var class="var">match</var>.
Note that the entire regular expression match itself counts as a
subexpression, and failed submatches are included in the count.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-match_003astring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match:string</strong> <var class="def-var-arguments">match</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_003astring"> ¶</a></span></dt>
<dd><p>Return the original <var class="var">target</var> string.
</p></dd></dl>

<div class="example lisp">
<pre class="lisp-preformatted">(define s (string-match "[0-9][0-9][0-9][0-9]" "blah2002foo"))
(match:string s)
⇒ "blah2002foo"
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="Backslash-Escapes">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Match-Structures" accesskey="p" rel="prev">Match Structures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" accesskey="u" rel="up">Regular Expressions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Backslash-Escapes-1">6.13.3 Backslash Escapes</h4>

<p>Sometimes you will want a regexp to match characters like ‘<samp class="samp">*</samp>’ or
‘<samp class="samp">$</samp>’ exactly.  For example, to check whether a particular string
represents a menu entry from an Info node, it would be useful to match
it against a regexp like ‘<samp class="samp">^* [^:]*::</samp>’.  However, this won’t work;
because the asterisk is a metacharacter, it won’t match the ‘<samp class="samp">*</samp>’ at
the beginning of the string.  In this case, we want to make the first
asterisk un-magic.
</p>
<p>You can do this by preceding the metacharacter with a backslash
character ‘<samp class="samp">\</samp>’.  (This is also called <em class="dfn">quoting</em> the
metacharacter, and is known as a <em class="dfn">backslash escape</em>.)  When Guile
sees a backslash in a regular expression, it considers the following
glyph to be an ordinary character, no matter what special meaning it
would ordinarily have.  Therefore, we can make the above example work by
changing the regexp to ‘<samp class="samp">^\* [^:]*::</samp>’.  The ‘<samp class="samp">\*</samp>’ sequence tells
the regular expression engine to match only a single asterisk in the
target string.
</p>
<p>Since the backslash is itself a metacharacter, you may force a regexp to
match a backslash in the target string by preceding the backslash with
itself.  For example, to find variable references in a TeX program,
you might want to find occurrences of the string ‘<samp class="samp">\let\</samp>’ followed
by any number of alphabetic characters.  The regular expression
‘<samp class="samp">\\let\\[A-Za-z]*</samp>’ would do this: the double backslashes in the
regexp each match a single backslash in the target string.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-regexp_002dquote"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">regexp-quote</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dquote"> ¶</a></span></dt>
<dd><p>Quote each special character found in <var class="var">str</var> with a backslash, and
return the resulting string.
</p></dd></dl>

<p><strong class="strong">Very important:</strong> Using backslash escapes in Guile source code
(as in Emacs Lisp or C) can be tricky, because the backslash character
has special meaning for the Guile reader.  For example, if Guile
encounters the character sequence ‘<samp class="samp">\n</samp>’ in the middle of a string
while processing Scheme code, it replaces those characters with a
newline character.  Similarly, the character sequence ‘<samp class="samp">\t</samp>’ is
replaced by a horizontal tab.  Several of these <em class="dfn">escape sequences</em>
are processed by the Guile reader before your code is executed.
Unrecognized escape sequences are ignored: if the characters ‘<samp class="samp">\*</samp>’
appear in a string, they will be translated to the single character
‘<samp class="samp">*</samp>’.
</p>
<p>This translation is obviously undesirable for regular expressions, since
we want to be able to include backslashes in a string in order to
escape regexp metacharacters.  Therefore, to make sure that a backslash
is preserved in a string in your Guile program, you must use <em class="emph">two</em>
consecutive backslashes:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define Info-menu-entry-pattern (make-regexp "^\\* [^:]*"))
</pre></div>

<p>The string in this example is preprocessed by the Guile reader before
any code is executed.  The resulting argument to <code class="code">make-regexp</code> is
the string ‘<samp class="samp">^\* [^:]*</samp>’, which is what we really want.
</p>
<p>This also means that in order to write a regular expression that matches
a single backslash character, the regular expression string in the
source code must include <em class="emph">four</em> backslashes.  Each consecutive pair
of backslashes gets translated by the Guile reader to a single
backslash, and the resulting double-backslash is interpreted by the
regexp engine as matching a single backslash character.  Hence:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define tex-variable-pattern (make-regexp "\\\\let\\\\=[A-Za-z]*"))
</pre></div>

<p>The reason for the unwieldiness of this syntax is historical.  Both
regular expression pattern matchers and Unix string processing systems
have traditionally used backslashes with the special meanings
described above.  The POSIX regular expression specification and ANSI C
standard both require these semantics.  Attempting to abandon either
convention would cause other kinds of compatibility problems, possibly
more severe ones.  Therefore, without extending the Scheme reader to
support strings with different quoting conventions (an ungainly and
confusing extension when implemented in other languages), we must adhere
to this cumbersome escape syntax.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="LALR_00281_0029-Parsing">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="n" rel="next">PEG Parsing</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Regular-Expressions" accesskey="p" rel="prev">Regular Expressions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="LALR_00281_0029-Parsing-1">6.14 LALR(1) Parsing</h3>

<p>The <code class="code">(system base lalr)</code> module provides the
<a class="uref" href="https://github.com/schemeway/lalr-scm/"><code class="code">lalr-scm</code> LALR(1) parser
generator by Dominique Boucher</a>.  <code class="code">lalr-scm</code> uses the same algorithm as GNU
Bison (see <a data-manual="bison" href="http://www.gnu.org/software/bison/manual/bison.html#Introduction">Introduction to Bison</a> in <cite class="cite">Bison, The
Yacc-compatible Parser Generator</cite>).  Parsers are defined using the
<code class="code">lalr-parser</code> macro.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-lalr_002dparser"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">lalr-parser</strong> <var class="def-var-arguments">[<var class="var">options</var>] <var class="var">tokens</var> <var class="var">rules</var>...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lalr_002dparser"> ¶</a></span></dt>
<dd><p>Generate an LALR(1) syntax analyzer.  <var class="var">tokens</var> is a list of symbols
representing the terminal symbols of the grammar.  <var class="var">rules</var> are the grammar
production rules.
</p>
<p>Each rule has the form <code class="code">(<var class="var">non-terminal</var> (<var class="var">rhs</var> ...) : <var class="var">action</var>
...)</code>, where <var class="var">non-terminal</var> is the name of the rule, <var class="var">rhs</var> are the
right-hand sides, i.e., the production rule, and <var class="var">action</var> is a semantic
action associated with the rule.
</p>
<p>The generated parser is a two-argument procedure that takes a
<em class="dfn">tokenizer</em> and a <em class="dfn">syntax error procedure</em>.  The tokenizer
should be a thunk that returns lexical tokens as produced by
<code class="code">make-lexical-token</code>.  The syntax error procedure may be called
with at least an error message (a string), and optionally the lexical
token that caused the error.
</p></dd></dl>

<p>Please refer to the <code class="code">lalr-scm</code> documentation for details.
</p>
<hr>
</div>
<div class="section-level-extent" id="PEG-Parsing">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="n" rel="next">Reading and Evaluating Scheme Code</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#LALR_00281_0029-Parsing" accesskey="p" rel="prev">LALR(1) Parsing</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="PEG-Parsing-1">6.15 PEG Parsing</h3>

<p>Parsing Expression Grammars (PEGs) are a way of specifying formal
languages for text processing.  They can be used either for matching
(like regular expressions) or for building recursive descent parsers
(like lex/yacc).  Guile uses a superset of PEG syntax that allows more
control over what information is preserved during parsing.
</p>
<p>Wikipedia has a clear and concise introduction to PEGs if you want to
familiarize yourself with the syntax:
<a class="url" href="http://en.wikipedia.org/wiki/Parsing_expression_grammar">http://en.wikipedia.org/wiki/Parsing_expression_grammar</a>.
</p>
<p>The <code class="code">(ice-9 peg)</code> module works by compiling PEGs down to lambda
expressions.  These can either be stored in variables at compile-time by
the define macros (<code class="code">define-peg-pattern</code> and
<code class="code">define-peg-string-patterns</code>) or calculated explicitly at runtime
with the compile functions (<code class="code">compile-peg-pattern</code> and
<code class="code">peg-string-compile</code>).
</p>
<p>They can then be used for either parsing (<code class="code">match-pattern</code>) or searching
(<code class="code">search-for-pattern</code>).  For convenience, <code class="code">search-for-pattern</code>
also takes pattern literals in case you want to inline a simple search
(people often use regular expressions this way).
</p>
<p>The rest of this documentation consists of a syntax reference, an API
reference, and a tutorial.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Syntax-Reference" accesskey="1">PEG Syntax Reference</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-API-Reference" accesskey="2">PEG API Reference</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Tutorial" accesskey="3">PEG Tutorial</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Internals" accesskey="4">PEG Internals</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="PEG-Syntax-Reference">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-API-Reference" accesskey="n" rel="next">PEG API Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="u" rel="up">PEG Parsing</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="PEG-Syntax-Reference-1">6.15.1 PEG Syntax Reference</h4>

<h4 class="subsubheading" id="Normal-PEG-Syntax_003a">Normal PEG Syntax:</h4>

<dl class="first-deftp">
<dt class="deftp" id="index-sequence"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">sequence</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sequence"> ¶</a></span></dt>
<dd><p>Parses <var class="var">a</var>.  If this succeeds, continues to parse <var class="var">b</var> from the
end of the text parsed as <var class="var">a</var>.  Succeeds if both <var class="var">a</var> and
<var class="var">b</var> succeed.
</p>
<p><code class="code">"a b"</code>
</p>
<p><code class="code">(and a b)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-ordered-choice"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">ordered choice</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ordered-choice"> ¶</a></span></dt>
<dd><p>Parses <var class="var">a</var>.  If this fails, backtracks and parses <var class="var">b</var>.
Succeeds if either <var class="var">a</var> or <var class="var">b</var> succeeds.
</p>
<p><code class="code">"a/b"</code>
</p>
<p><code class="code">(or a b)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-zero-or-more"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">zero or more</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-zero-or-more"> ¶</a></span></dt>
<dd><p>Parses <var class="var">a</var> as many times in a row as it can, starting each <var class="var">a</var>
at the end of the text parsed by the previous <var class="var">a</var>.  Always
succeeds.
</p>
<p><code class="code">"a*"</code>
</p>
<p><code class="code">(* a)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-one-or-more"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">one or more</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-one-or-more"> ¶</a></span></dt>
<dd><p>Parses <var class="var">a</var> as many times in a row as it can, starting each <var class="var">a</var>
at the end of the text parsed by the previous <var class="var">a</var>.  Succeeds if at
least one <var class="var">a</var> was parsed.
</p>
<p><code class="code">"a+"</code>
</p>
<p><code class="code">(+ a)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-optional"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">optional</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-optional"> ¶</a></span></dt>
<dd><p>Tries to parse <var class="var">a</var>.  Succeeds if <var class="var">a</var> succeeds.
</p>
<p><code class="code">"a?"</code>
</p>
<p><code class="code">(? a)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-followed-by"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">followed by</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-followed-by"> ¶</a></span></dt>
<dd><p>Makes sure it is possible to parse <var class="var">a</var>, but does not actually parse
it.  Succeeds if <var class="var">a</var> would succeed.
</p>
<p><code class="code">"&amp;a"</code>
</p>
<p><code class="code">(followed-by a)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-not-followed-by"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">not followed by</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-not-followed-by"> ¶</a></span></dt>
<dd><p>Makes sure it is impossible to parse <var class="var">a</var>, but does not actually
parse it.  Succeeds if <var class="var">a</var> would fail.
</p>
<p><code class="code">"!a"</code>
</p>
<p><code class="code">(not-followed-by a)</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-string-literal"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">string literal</strong> <var class="def-var-arguments">“abc”</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string-literal"> ¶</a></span></dt>
<dd><p>Parses the string <var class="var">"abc"</var>.  Succeeds if that parsing succeeds.
</p>
<p><code class="code">"'abc'"</code>
</p>
<p><code class="code">"abc"</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-any-character"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">any character</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any-character"> ¶</a></span></dt>
<dd><p>Parses any single character.  Succeeds unless there is no more text to
be parsed.
</p>
<p><code class="code">"."</code>
</p>
<p><code class="code">peg-any</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-character-class"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">character class</strong> <var class="def-var-arguments">a b</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-character-class"> ¶</a></span></dt>
<dd><p>Alternative syntax for “Ordered Choice <var class="var">a</var> <var class="var">b</var>” if <var class="var">a</var> and
<var class="var">b</var> are characters.
</p>
<p><code class="code">"[ab]"</code>
</p>
<p><code class="code">(or "a" "b")</code>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-range-of-characters"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">range of characters</strong> <var class="def-var-arguments">a z</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-range-of-characters"> ¶</a></span></dt>
<dd><p>Parses any character falling between <var class="var">a</var> and <var class="var">z</var>.
</p>
<p><code class="code">"[a-z]"</code>
</p>
<p><code class="code">(range #\a #\z)</code>
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<pre class="example-preformatted">"(a !b / c &amp;d*) 'e'+"
</pre></div>

<p>Would be:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(and
 (or
  (and a (not-followed-by b))
  (and c (followed-by (* d))))
 (+ "e"))
</pre></div>

<h4 class="subsubheading" id="Extended-Syntax">Extended Syntax</h4>

<p>There is some extra syntax for S-expressions.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-ignore"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">ignore</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ignore"> ¶</a></span></dt>
<dd><p>Ignore the text matching <var class="var">a</var>
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-capture"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">capture</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-capture"> ¶</a></span></dt>
<dd><p>Capture the text matching <var class="var">a</var>.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-peg"><span class="category-def">PEG Pattern: </span><span><strong class="def-name">peg</strong> <var class="def-var-arguments">a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg"> ¶</a></span></dt>
<dd><p>Embed the PEG pattern <var class="var">a</var> using string syntax.
</p></dd></dl>

<p>Example:
</p>
<div class="example">
<pre class="example-preformatted">"!a / 'b'"
</pre></div>

<p>Is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(or (peg "!a") "b")
</pre></div>

<p>and
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(or (not-followed-by a) "b")
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="PEG-API-Reference">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Tutorial" accesskey="n" rel="next">PEG Tutorial</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Syntax-Reference" accesskey="p" rel="prev">PEG Syntax Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="u" rel="up">PEG Parsing</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="PEG-API-Reference-1">6.15.2 PEG API Reference</h4>

<h4 class="subsubheading" id="Define-Macros">Define Macros</h4>

<p>The most straightforward way to define a PEG is by using one of the
define macros (both of these macroexpand into <code class="code">define</code>
expressions).  These macros bind parsing functions to variables.  These
parsing functions may be invoked by <code class="code">match-pattern</code> or
<code class="code">search-for-pattern</code>, which return a PEG match record.  Raw data can be
retrieved from this record with the PEG match deconstructor functions.
More complicated (and perhaps enlightening) examples can be found in the
tutorial.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dpeg_002dstring_002dpatterns"><span class="category-def">Scheme Macro: </span><span><strong class="def-name">define-peg-string-patterns</strong> <var class="def-var-arguments">peg-string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dpeg_002dstring_002dpatterns"> ¶</a></span></dt>
<dd><p>Defines all the nonterminals in the PEG <var class="var">peg-string</var>.  More
precisely, <code class="code">define-peg-string-patterns</code> takes a superset of PEGs.  A normal PEG
has a <code class="code">&lt;-</code> between the nonterminal and the pattern.
<code class="code">define-peg-string-patterns</code> uses this symbol to determine what information it
should propagate up the parse tree.  The normal <code class="code">&lt;-</code> propagates the
matched text up the parse tree, <code class="code">&lt;--</code> propagates the matched text
up the parse tree tagged with the name of the nonterminal, and <code class="code">&lt;</code>
discards that matched text and propagates nothing up the parse tree.
Also, nonterminals may consist of any alphanumeric character or a “-”
character (in normal PEGs nonterminals can only be alphabetic).
</p>
<p>For example, if we:
</p><div class="example lisp">
<pre class="lisp-preformatted">(define-peg-string-patterns 
  "as &lt;- 'a'+
bs &lt;- 'b'+
as-or-bs &lt;- as/bs")
(define-peg-string-patterns 
  "as-tag &lt;-- 'a'+
bs-tag &lt;-- 'b'+
as-or-bs-tag &lt;-- as-tag/bs-tag")
</pre></div>
<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(match-pattern as-or-bs "aabbcc") ⇒
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;
(match-pattern as-or-bs-tag "aabbcc") ⇒
#&lt;peg start: 0 end: 2 string: aabbcc tree: (as-or-bs-tag (as-tag aa))&gt;
</pre></div>

<p>Note that in doing this, we have bound 6 variables at the toplevel
(<var class="var">as</var>, <var class="var">bs</var>, <var class="var">as-or-bs</var>, <var class="var">as-tag</var>, <var class="var">bs-tag</var>, and
<var class="var">as-or-bs-tag</var>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002dpeg_002dpattern"><span class="category-def">Scheme Macro: </span><span><strong class="def-name">define-peg-pattern</strong> <var class="def-var-arguments">name capture-type peg-sexp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dpeg_002dpattern"> ¶</a></span></dt>
<dd><p>Defines a single nonterminal <var class="var">name</var>.  <var class="var">capture-type</var> determines
how much information is passed up the parse tree.  <var class="var">peg-sexp</var> is a
PEG in S-expression form.
</p>
<p>Possible values for capture-type:
</p>
<dl class="table">
<dt><code class="code">all</code></dt>
<dd><p>passes the matched text up the parse tree tagged with the name of the
nonterminal.
</p></dd>
<dt><code class="code">body</code></dt>
<dd><p>passes the matched text up the parse tree.
</p></dd>
<dt><code class="code">none</code></dt>
<dd><p>passes nothing up the parse tree.
</p></dd>
</dl>

<p>For Example, if we:
</p><div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern as body (+ "a"))
(define-peg-pattern bs body (+ "b"))
(define-peg-pattern as-or-bs body (or as bs))
(define-peg-pattern as-tag all (+ "a"))
(define-peg-pattern bs-tag all (+ "b"))
(define-peg-pattern as-or-bs-tag all (or as-tag bs-tag))
</pre></div>
<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(match-pattern as-or-bs "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;
(match-pattern as-or-bs-tag "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: (as-or-bs-tag (as-tag aa))&gt;
</pre></div>

<p>Note that in doing this, we have bound 6 variables at the toplevel
(<var class="var">as</var>, <var class="var">bs</var>, <var class="var">as-or-bs</var>, <var class="var">as-tag</var>, <var class="var">bs-tag</var>, and
<var class="var">as-or-bs-tag</var>).
</p></dd></dl>

<h4 class="subsubheading" id="Compile-Functions">Compile Functions</h4>
<p>It is sometimes useful to be able to compile anonymous PEG patterns at
runtime.  These functions let you do that using either syntax.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-peg_002dstring_002dcompile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg-string-compile</strong> <var class="def-var-arguments">peg-string capture-type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_002dstring_002dcompile"> ¶</a></span></dt>
<dd><p>Compiles the PEG pattern in <var class="var">peg-string</var> propagating according to
<var class="var">capture-type</var> (capture-type can be any of the values from
<code class="code">define-peg-pattern</code>).
</p></dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-compile_002dpeg_002dpattern"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">compile-peg-pattern</strong> <var class="def-var-arguments">peg-sexp capture-type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compile_002dpeg_002dpattern"> ¶</a></span></dt>
<dd><p>Compiles the PEG pattern in <var class="var">peg-sexp</var> propagating according to
<var class="var">capture-type</var> (capture-type can be any of the values from
<code class="code">define-peg-pattern</code>).
</p></dd></dl>

<p>The functions return syntax objects, which can be useful if you want to
use them in macros. If all you want is to define a new nonterminal, you
can do the following:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define exp '(+ "a"))
(define as (compile (compile-peg-pattern exp 'body)))
</pre></div>

<p>You can use this nonterminal with all of the regular PEG functions:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(match-pattern as "aaaaa") ⇒
#&lt;peg start: 0 end: 5 string: bbbbb tree: bbbbb&gt;
</pre></div>

<h4 class="subsubheading" id="Parsing-_0026-Matching-Functions">Parsing &amp; Matching Functions</h4>

<p>For our purposes, “parsing” means parsing a string into a tree
starting from the first character, while “matching” means searching
through the string for a substring.  In practice, the only difference
between the two functions is that <code class="code">match-pattern</code> gives up if it can’t
find a valid substring starting at index 0 and <code class="code">search-for-pattern</code> keeps
looking.  They are both equally capable of “parsing” and “matching”
given those constraints.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-match_002dpattern"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">match-pattern</strong> <var class="def-var-arguments">nonterm string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-match_002dpattern"> ¶</a></span></dt>
<dd><p>Parses <var class="var">string</var> using the PEG stored in <var class="var">nonterm</var>.  If no match
was found, <code class="code">match-pattern</code> returns false.  If a match was found, a PEG
match record is returned.
</p>
<p>The <code class="code">capture-type</code> argument to <code class="code">define-peg-pattern</code> allows you to
choose what information to hold on to while parsing.  The options are:
</p>
<dl class="table">
<dt><code class="code">all</code></dt>
<dd><p>tag the matched text with the nonterminal
</p></dd>
<dt><code class="code">body</code></dt>
<dd><p>just the matched text
</p></dd>
<dt><code class="code">none</code></dt>
<dd><p>nothing
</p></dd>
</dl>

<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern as all (+ "a"))
(match-pattern as "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: (as aa)&gt;

(define-peg-pattern as body (+ "a"))
(match-pattern as "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;

(define-peg-pattern as none (+ "a"))
(match-pattern as "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: ()&gt;

(define-peg-pattern bs body (+ "b"))
(match-pattern bs "aabbcc") ⇒ 
#f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-search_002dfor_002dpattern"><span class="category-def">Scheme Macro: </span><span><strong class="def-name">search-for-pattern</strong> <var class="def-var-arguments">nonterm-or-peg string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-search_002dfor_002dpattern"> ¶</a></span></dt>
<dd><p>Searches through <var class="var">string</var> looking for a matching subexpression.
<var class="var">nonterm-or-peg</var> can either be a nonterminal or a literal PEG
pattern.  When a literal PEG pattern is provided, <code class="code">search-for-pattern</code> works
very similarly to the regular expression searches many hackers are used
to.  If no match was found, <code class="code">search-for-pattern</code> returns false.  If a match
was found, a PEG match record is returned.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern as body (+ "a"))
(search-for-pattern as "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;
(search-for-pattern (+ "a") "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;
(search-for-pattern "'a'+" "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: aa&gt;

(define-peg-pattern as all (+ "a"))
(search-for-pattern as "aabbcc") ⇒ 
#&lt;peg start: 0 end: 2 string: aabbcc tree: (as aa)&gt;

(define-peg-pattern bs body (+ "b"))
(search-for-pattern bs "aabbcc") ⇒ 
#&lt;peg start: 2 end: 4 string: aabbcc tree: bb&gt;
(search-for-pattern (+ "b") "aabbcc") ⇒ 
#&lt;peg start: 2 end: 4 string: aabbcc tree: bb&gt;
(search-for-pattern "'b'+" "aabbcc") ⇒ 
#&lt;peg start: 2 end: 4 string: aabbcc tree: bb&gt;

(define-peg-pattern zs body (+ "z"))
(search-for-pattern zs "aabbcc") ⇒ 
#f
(search-for-pattern (+ "z") "aabbcc") ⇒ 
#f
(search-for-pattern "'z'+" "aabbcc") ⇒ 
#f
</pre></div>
</dd></dl>

<h4 class="subsubheading" id="PEG-Match-Records">PEG Match Records</h4>
<p>The <code class="code">match-pattern</code> and <code class="code">search-for-pattern</code> functions both return PEG
match records.  Actual information can be extracted from these with the
following functions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-peg_003astring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg:string</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_003astring"> ¶</a></span></dt>
<dd><p>Returns the original string that was parsed in the creation of
<code class="code">match-record</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peg_003astart"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg:start</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_003astart"> ¶</a></span></dt>
<dd><p>Returns the index of the first parsed character in the original string
(from <code class="code">peg:string</code>).  If this is the same as <code class="code">peg:end</code>,
nothing was parsed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peg_003aend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg:end</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_003aend"> ¶</a></span></dt>
<dd><p>Returns one more than the index of the last parsed character in the
original string (from <code class="code">peg:string</code>).  If this is the same as
<code class="code">peg:start</code>, nothing was parsed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peg_003asubstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg:substring</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_003asubstring"> ¶</a></span></dt>
<dd><p>Returns the substring parsed by <code class="code">match-record</code>.  This is equivalent to
<code class="code">(substring (peg:string match-record) (peg:start match-record) (peg:end
match-record))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peg_003atree"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg:tree</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_003atree"> ¶</a></span></dt>
<dd><p>Returns the tree parsed by <code class="code">match-record</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-peg_002drecord_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">peg-record?</strong> <var class="def-var-arguments">match-record</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-peg_002drecord_003f"> ¶</a></span></dt>
<dd><p>Returns true if <code class="code">match-record</code> is a PEG match record, or false
otherwise.
</p></dd></dl>

<p>Example:
</p><div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern bs all (peg "'b'+"))

(search-for-pattern bs "aabbcc") ⇒
#&lt;peg start: 2 end: 4 string: aabbcc tree: (bs bb)&gt;

(let ((pm (search-for-pattern bs "aabbcc")))
   `((string ,(peg:string pm))
     (start ,(peg:start pm))
     (end ,(peg:end pm))
     (substring ,(peg:substring pm))
     (tree ,(peg:tree pm))
     (record? ,(peg-record? pm)))) ⇒
((string "aabbcc")
 (start 2)
 (end 4)
 (substring "bb")
 (tree (bs "bb"))
 (record? #t))
</pre></div>

<h4 class="subsubheading" id="Miscellaneous">Miscellaneous</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-context_002dflatten"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">context-flatten</strong> <var class="def-var-arguments">tst lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-context_002dflatten"> ¶</a></span></dt>
<dd><p>Takes a predicate <var class="var">tst</var> and a list <var class="var">lst</var>.  Flattens <var class="var">lst</var>
until all elements are either atoms or satisfy <var class="var">tst</var>.  If <var class="var">lst</var>
itself satisfies <var class="var">tst</var>, <code class="code">(list lst)</code> is returned (this is a
flat list whose only element satisfies <var class="var">tst</var>).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(context-flatten (lambda (x) (and (number? (car x)) (= (car x) 1))) '(2 2 (1 1 (2 2)) (2 2 (1 1)))) ⇒ 
(2 2 (1 1 (2 2)) 2 2 (1 1))
(context-flatten (lambda (x) (and (number? (car x)) (= (car x) 1))) '(1 1 (1 1 (2 2)) (2 2 (1 1)))) ⇒ 
((1 1 (1 1 (2 2)) (2 2 (1 1))))
</pre></div>

<p>If you’re wondering why this is here, take a look at the tutorial.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-keyword_002dflatten"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">keyword-flatten</strong> <var class="def-var-arguments">terms lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-keyword_002dflatten"> ¶</a></span></dt>
<dd><p>A less general form of <code class="code">context-flatten</code>.  Takes a list of terminal
atoms <code class="code">terms</code> and flattens <var class="var">lst</var> until all elements are either
atoms, or lists which have an atom from <code class="code">terms</code> as their first
element.
</p><div class="example lisp">
<pre class="lisp-preformatted">(keyword-flatten '(a b) '(c a b (a c) (b c) (c (b a) (c a)))) ⇒
(c a b (a c) (b c) c (b a) c a)
</pre></div>

<p>If you’re wondering why this is here, take a look at the tutorial.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="PEG-Tutorial">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Internals" accesskey="n" rel="next">PEG Internals</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-API-Reference" accesskey="p" rel="prev">PEG API Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="u" rel="up">PEG Parsing</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="PEG-Tutorial-1">6.15.3 PEG Tutorial</h4>

<h4 class="subsubheading" id="Parsing-_002fetc_002fpasswd">Parsing /etc/passwd</h4>
<p>This example will show how to parse /etc/passwd using PEGs.
</p>
<p>First we define an example /etc/passwd file:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define *etc-passwd*
  "root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/bin/sh
bin:x:2:2:bin:/bin:/bin/sh
sys:x:3:3:sys:/dev:/bin/sh
nobody:x:65534:65534:nobody:/nonexistent:/bin/sh
messagebus:x:103:107::/var/run/dbus:/bin/false
")
</pre></div>

<p>As a first pass at this, we might want to have all the entries in
/etc/passwd in a list.
</p>
<p>Doing this with string-based PEG syntax would look like this:
</p><div class="example lisp">
<pre class="lisp-preformatted">(define-peg-string-patterns
  "passwd &lt;- entry* !.
entry &lt;-- (! NL .)* NL*
NL &lt; '\n'")
</pre></div>

<p>A <code class="code">passwd</code> file is 0 or more entries (<code class="code">entry*</code>) until the end
of the file (<code class="code">!.</code> (<code class="code">.</code> is any character, so <code class="code">!.</code> means
“not anything”)).  We want to capture the data in the nonterminal
<code class="code">passwd</code>, but not tag it with the name, so we use <code class="code">&lt;-</code>.
</p>
<p>An entry is a series of 0 or more characters that aren’t newlines
(<code class="code">(! NL .)*</code>) followed by 0 or more newlines (<code class="code">NL*</code>).  We want
to tag all the entries with <code class="code">entry</code>, so we use <code class="code">&lt;--</code>.
</p>
<p>A newline is just a literal newline (<code class="code">'\n'</code>).  We don’t want a
bunch of newlines cluttering up the output, so we use <code class="code">&lt;</code> to throw
away the captured data.
</p>
<p>Here is the same PEG defined using S-expressions:
</p><div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern passwd body (and (* entry) (not-followed-by peg-any)))
(define-peg-pattern entry all (and (* (and (not-followed-by NL) peg-any))
			       (* NL)))
(define-peg-pattern NL none "\n")
</pre></div>

<p>Obviously this is much more verbose.  On the other hand, it’s more
explicit, and thus easier to build automatically.  However, there are
some tricks that make S-expressions easier to use in some cases.  One is
the <code class="code">ignore</code> keyword; the string syntax has no way to say “throw
away this text” except breaking it out into a separate nonterminal.
For instance, to throw away the newlines we had to define <code class="code">NL</code>.  In
the S-expression syntax, we could have simply written <code class="code">(ignore
"\n")</code>.  Also, for the cases where string syntax is really much cleaner,
the <code class="code">peg</code> keyword can be used to embed string syntax in
S-expression syntax.  For instance, we could have written:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern passwd body (peg "entry* !."))
</pre></div>

<p>However we define it, parsing <code class="code">*etc-passwd*</code> with the <code class="code">passwd</code>
nonterminal yields the same results:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(peg:tree (match-pattern passwd *etc-passwd*)) ⇒
((entry "root:x:0:0:root:/root:/bin/bash")
 (entry "daemon:x:1:1:daemon:/usr/sbin:/bin/sh")
 (entry "bin:x:2:2:bin:/bin:/bin/sh")
 (entry "sys:x:3:3:sys:/dev:/bin/sh")
 (entry "nobody:x:65534:65534:nobody:/nonexistent:/bin/sh")
 (entry "messagebus:x:103:107::/var/run/dbus:/bin/false"))
</pre></div>

<p>However, here is something to be wary of:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(peg:tree (match-pattern passwd "one entry")) ⇒
(entry "one entry")
</pre></div>

<p>By default, the parse trees generated by PEGs are compressed as much as
possible without losing information.  It may not look like this is what
you want at first, but uncompressed parse trees are an enormous headache
(there’s no easy way to predict how deep particular lists will nest,
there are empty lists littered everywhere, etc. etc.).  One side-effect
of this, however, is that sometimes the compressor is too aggressive.
No information is discarded when <code class="code">((entry "one entry"))</code> is
compressed to <code class="code">(entry "one entry")</code>, but in this particular case it
probably isn’t what we want.
</p>
<p>There are two functions for easily dealing with this:
<code class="code">keyword-flatten</code> and <code class="code">context-flatten</code>.  The
<code class="code">keyword-flatten</code> function takes a list of keywords and a list to
flatten, then tries to coerce the list such that the first element of
all sublists is one of the keywords.  The <code class="code">context-flatten</code>
function is similar, but instead of a list of keywords it takes a
predicate that should indicate whether a given sublist is good enough
(refer to the API reference for more details).
</p>
<p>What we want here is <code class="code">keyword-flatten</code>.
</p><div class="example lisp">
<pre class="lisp-preformatted">(keyword-flatten '(entry) (peg:tree (match-pattern passwd *etc-passwd*))) ⇒
((entry "root:x:0:0:root:/root:/bin/bash")
 (entry "daemon:x:1:1:daemon:/usr/sbin:/bin/sh")
 (entry "bin:x:2:2:bin:/bin:/bin/sh")
 (entry "sys:x:3:3:sys:/dev:/bin/sh")
 (entry "nobody:x:65534:65534:nobody:/nonexistent:/bin/sh")
 (entry "messagebus:x:103:107::/var/run/dbus:/bin/false"))
(keyword-flatten '(entry) (peg:tree (match-pattern passwd "one entry"))) ⇒
((entry "one entry"))
</pre></div>

<p>Of course, this is a somewhat contrived example.  In practice we would
probably just tag the <code class="code">passwd</code> nonterminal to remove the ambiguity
(using either the <code class="code">all</code> keyword for S-expressions or the <code class="code">&lt;--</code>
symbol for strings)..
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-pattern tag-passwd all (peg "entry* !."))
(peg:tree (match-pattern tag-passwd *etc-passwd*)) ⇒
(tag-passwd
  (entry "root:x:0:0:root:/root:/bin/bash")
  (entry "daemon:x:1:1:daemon:/usr/sbin:/bin/sh")
  (entry "bin:x:2:2:bin:/bin:/bin/sh")
  (entry "sys:x:3:3:sys:/dev:/bin/sh")
  (entry "nobody:x:65534:65534:nobody:/nonexistent:/bin/sh")
  (entry "messagebus:x:103:107::/var/run/dbus:/bin/false"))
(peg:tree (match-pattern tag-passwd "one entry"))
(tag-passwd 
  (entry "one entry"))
</pre></div>

<p>If you’re ever uncertain about the potential results of parsing
something, remember the two absolute rules:
</p><ol class="enumerate">
<li> No parsing information will ever be discarded.
</li><li> There will never be any lists with fewer than 2 elements.
</li></ol>

<p>For the purposes of (1), "parsing information" means things tagged with
the <code class="code">any</code> keyword or the <code class="code">&lt;--</code> symbol.  Plain strings will be
concatenated.
</p>
<p>Let’s extend this example a bit more and actually pull some useful
information out of the passwd file:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-string-patterns
  "passwd &lt;-- entry* !.
entry &lt;-- login C pass C uid C gid C nameORcomment C homedir C shell NL*
login &lt;-- text
pass &lt;-- text
uid &lt;-- [0-9]*
gid &lt;-- [0-9]*
nameORcomment &lt;-- text
homedir &lt;-- path
shell &lt;-- path
path &lt;-- (SLASH pathELEMENT)*
pathELEMENT &lt;-- (!NL !C  !'/' .)*
text &lt;- (!NL !C  .)*
C &lt; ':'
NL &lt; '\n'
SLASH &lt; '/'")
</pre></div>

<p>This produces rather pretty parse trees:
</p><div class="example lisp">
<pre class="lisp-preformatted">(passwd
  (entry (login "root")
         (pass "x")
         (uid "0")
         (gid "0")
         (nameORcomment "root")
         (homedir (path (pathELEMENT "root")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "bash"))))
  (entry (login "daemon")
         (pass "x")
         (uid "1")
         (gid "1")
         (nameORcomment "daemon")
         (homedir
           (path (pathELEMENT "usr") (pathELEMENT "sbin")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "sh"))))
  (entry (login "bin")
         (pass "x")
         (uid "2")
         (gid "2")
         (nameORcomment "bin")
         (homedir (path (pathELEMENT "bin")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "sh"))))
  (entry (login "sys")
         (pass "x")
         (uid "3")
         (gid "3")
         (nameORcomment "sys")
         (homedir (path (pathELEMENT "dev")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "sh"))))
  (entry (login "nobody")
         (pass "x")
         (uid "65534")
         (gid "65534")
         (nameORcomment "nobody")
         (homedir (path (pathELEMENT "nonexistent")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "sh"))))
  (entry (login "messagebus")
         (pass "x")
         (uid "103")
         (gid "107")
         nameORcomment
         (homedir
           (path (pathELEMENT "var")
                 (pathELEMENT "run")
                 (pathELEMENT "dbus")))
         (shell (path (pathELEMENT "bin") (pathELEMENT "false")))))
</pre></div>

<p>Notice that when there’s no entry in a field (e.g. <code class="code">nameORcomment</code>
for messagebus) the symbol is inserted.  This is the “don’t throw away
any information” rule—we succesfully matched a <code class="code">nameORcomment</code>
of 0 characters (since we used <code class="code">*</code> when defining it).  This is
usually what you want, because it allows you to e.g. use <code class="code">list-ref</code>
to pull out elements (since they all have known offsets).
</p>
<p>If you’d prefer not to have symbols for empty matches, you can replace
the <code class="code">*</code> with a <code class="code">+</code> and add a <code class="code">?</code> after the
<code class="code">nameORcomment</code> in <code class="code">entry</code>.  Then it will try to parse 1 or
more characters, fail (inserting nothing into the parse tree), but
continue because it didn’t have to match the nameORcomment to continue.
</p>

<h4 class="subsubheading" id="Embedding-Arithmetic-Expressions">Embedding Arithmetic Expressions</h4>

<p>We can parse simple mathematical expressions with the following PEG:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-string-patterns
  "expr &lt;- sum
sum &lt;-- (product ('+' / '-') sum) / product
product &lt;-- (value ('*' / '/') product) / value
value &lt;-- number / '(' expr ')'
number &lt;-- [0-9]+")
</pre></div>

<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(peg:tree (match-pattern expr "1+1/2*3+(1+1)/2")) ⇒
(sum (product (value (number "1")))
     "+"
     (sum (product
            (value (number "1"))
            "/"
            (product
              (value (number "2"))
              "*"
              (product (value (number "3")))))
          "+"
          (sum (product
                 (value "("
                        (sum (product (value (number "1")))
                             "+"
                             (sum (product (value (number "1")))))
                        ")")
                 "/"
                 (product (value (number "2")))))))
</pre></div>

<p>There is very little wasted effort in this PEG.  The <code class="code">number</code>
nonterminal has to be tagged because otherwise the numbers might run
together with the arithmetic expressions during the string concatenation
stage of parse-tree compression (the parser will see “1” followed by
“/” and decide to call it “1/”).  When in doubt, tag.
</p>
<p>It is very easy to turn these parse trees into lisp expressions:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (parse-sum sum left . rest)
  (if (null? rest)
      (apply parse-product left)
      (list (string-&gt;symbol (car rest))
	    (apply parse-product left)
	    (apply parse-sum (cadr rest)))))

(define (parse-product product left . rest)
  (if (null? rest)
      (apply parse-value left)
      (list (string-&gt;symbol (car rest))
	    (apply parse-value left)
	    (apply parse-product (cadr rest)))))

(define (parse-value value first . rest)
  (if (null? rest)
      (string-&gt;number (cadr first))
      (apply parse-sum (car rest))))

(define parse-expr parse-sum)
</pre></div>

<p>(Notice all these functions look very similar; for a more complicated
PEG, it would be worth abstracting.)
</p>
<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(apply parse-expr (peg:tree (match-pattern expr "1+1/2*3+(1+1)/2"))) ⇒
(+ 1 (+ (/ 1 (* 2 3)) (/ (+ 1 1) 2)))
</pre></div>

<p>But wait!  The associativity is wrong!  Where it says <code class="code">(/ 1 (* 2
3))</code>, it should say <code class="code">(* (/ 1 2) 3)</code>.
</p>
<p>It’s tempting to try replacing e.g. <code class="code">"sum &lt;-- (product ('+' / '-')
sum) / product"</code> with <code class="code">"sum &lt;-- (sum ('+' / '-') product) /
product"</code>, but this is a Bad Idea.  PEGs don’t support left recursion.
To see why, imagine what the parser will do here.  When it tries to
parse <code class="code">sum</code>, it first has to try and parse <code class="code">sum</code>.  But to do
that, it first has to try and parse <code class="code">sum</code>.  This will continue
until the stack gets blown off.
</p>
<p>So how does one parse left-associative binary operators with PEGs?
Honestly, this is one of their major shortcomings.  There’s no
general-purpose way of doing this, but here the repetition operators are
a good choice:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-1))

(define-peg-string-patterns
  "expr &lt;- sum
sum &lt;-- (product ('+' / '-'))* product
product &lt;-- (value ('*' / '/'))* value
value &lt;-- number / '(' expr ')'
number &lt;-- [0-9]+")

;; take a deep breath...
(define (make-left-parser next-func)
  (lambda (sum first . rest) ;; general form, comments below assume
    ;; that we're dealing with a sum expression
    (if (null? rest) ;; form (sum (product ...))
      (apply next-func first)
      (if (string? (cadr first));; form (sum ((product ...) "+") (product ...))
	  (list (string-&gt;symbol (cadr first))
		(apply next-func (car first))
		(apply next-func (car rest)))
          ;; form (sum (((product ...) "+") ((product ...) "+")) (product ...))
	  (car 
	   (reduce ;; walk through the list and build a left-associative tree
	    (lambda (l r)
	      (list (list (cadr r) (car r) (apply next-func (car l)))
		    (string-&gt;symbol (cadr l))))
	    'ignore
	    (append ;; make a list of all the products
             ;; the first one should be pre-parsed
	     (list (list (apply next-func (caar first))
			 (string-&gt;symbol (cadar first))))
	     (cdr first)
             ;; the last one has to be added in
	     (list (append rest '("done"))))))))))

(define (parse-value value first . rest)
  (if (null? rest)
      (string-&gt;number (cadr first))
      (apply parse-sum (car rest))))
(define parse-product (make-left-parser parse-value))
(define parse-sum (make-left-parser parse-product))
(define parse-expr parse-sum)
</pre></div>

<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(apply parse-expr (peg:tree (match-pattern expr "1+1/2*3+(1+1)/2"))) ⇒
(+ (+ 1 (* (/ 1 2) 3)) (/ (+ 1 1) 2))
</pre></div>

<p>As you can see, this is much uglier (it could be made prettier by using
<code class="code">context-flatten</code>, but the way it’s written above makes it clear
how we deal with the three ways the zero-or-more <code class="code">*</code> expression can
parse).  Fortunately, most of the time we can get away with only using
right-associativity.
</p>
<h4 class="subsubheading" id="Simplified-Functions">Simplified Functions</h4>

<p>For a more tantalizing example, consider the following grammar that
parses (highly) simplified C functions:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-peg-string-patterns
  "cfunc &lt;-- cSP ctype cSP cname cSP cargs cLB cSP cbody cRB
ctype &lt;-- cidentifier
cname &lt;-- cidentifier
cargs &lt;-- cLP (! (cSP cRP) carg cSP (cCOMMA / cRP) cSP)* cSP
carg &lt;-- cSP ctype cSP cname
cbody &lt;-- cstatement *
cidentifier &lt;- [a-zA-z][a-zA-Z0-9_]*
cstatement &lt;-- (!';'.)*cSC cSP
cSC &lt; ';'
cCOMMA &lt; ','
cLP &lt; '('
cRP &lt; ')'
cLB &lt; '{'
cRB &lt; '}'
cSP &lt; [ \t\n]*")
</pre></div>

<p>Then:
</p><div class="example lisp">
<pre class="lisp-preformatted">(match-pattern cfunc "int square(int a) { return a*a;}") ⇒
(32
 (cfunc (ctype "int")
        (cname "square")
        (cargs (carg (ctype "int") (cname "a")))
        (cbody (cstatement "return a*a"))))
</pre></div>

<p>And:
</p><div class="example lisp">
<pre class="lisp-preformatted">(match-pattern cfunc "int mod(int a, int b) { int c = a/b;return a-b*c; }") ⇒
(52
 (cfunc (ctype "int")
        (cname "mod")
        (cargs (carg (ctype "int") (cname "a"))
               (carg (ctype "int") (cname "b")))
        (cbody (cstatement "int c = a/b")
               (cstatement "return a- b*c"))))
</pre></div>

<p>By wrapping all the <code class="code">carg</code> nonterminals in a <code class="code">cargs</code>
nonterminal, we were able to remove any ambiguity in the parsing
structure and avoid having to call <code class="code">context-flatten</code> on the output
of <code class="code">match-pattern</code>.  We used the same trick with the <code class="code">cstatement</code>
nonterminals, wrapping them in a <code class="code">cbody</code> nonterminal.
</p>
<p>The whitespace nonterminal <code class="code">cSP</code> used here is a (very) useful
instantiation of a common pattern for matching syntactically irrelevant
information.  Since it’s tagged with <code class="code">&lt;</code> and ends with <code class="code">*</code> it
won’t clutter up the parse trees (all the empty lists will be discarded
during the compression step) and it will never cause parsing to fail.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="PEG-Internals">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Tutorial" accesskey="p" rel="prev">PEG Tutorial</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="u" rel="up">PEG Parsing</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="PEG-Internals-1">6.15.4 PEG Internals</h4>

<p>A PEG parser takes a string as input and attempts to parse it as a given
nonterminal. The key idea of the PEG implementation is that every
nonterminal is just a function that takes a string as an argument and
attempts to parse that string as its nonterminal. The functions always
start from the beginning, but a parse is considered successful if there
is material left over at the end.
</p>
<p>This makes it easy to model different PEG parsing operations. For
instance, consider the PEG grammar <code class="code">"ab"</code>, which could also be
written <code class="code">(and "a" "b")</code>. It matches the string “ab”. Here’s how
that might be implemented in the PEG style:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (match-and-a-b str)
  (match-a str)
  (match-b str))
</pre></div>

<p>As you can see, the use of functions provides an easy way to model
sequencing. In a similar way, one could model <code class="code">(or a b)</code> with
something like the following:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (match-or-a-b str)
  (or (match-a str) (match-b str)))
</pre></div>

<p>Here the semantics of a PEG <code class="code">or</code> expression map naturally onto
Scheme’s <code class="code">or</code> operator. This function will attempt to run
<code class="code">(match-a str)</code>, and return its result if it succeeds. Otherwise it
will run <code class="code">(match-b str)</code>.
</p>
<p>Of course, the code above wouldn’t quite work. We need some way for the
parsing functions to communicate. The actual interface used is below.
</p>
<h4 class="subsubheading" id="Parsing-Function-Interface">Parsing Function Interface</h4>

<p>A parsing function takes three arguments - a string, the length of that
string, and the position in that string it should start parsing at. In
effect, the parsing functions pass around substrings in pieces - the
first argument is a buffer of characters, and the second two give a
range within that buffer that the parsing function should look at.
</p>
<p>Parsing functions return either #f, if they failed to match their
nonterminal, or a list whose first element must be an integer
representing the final position in the string they matched and whose cdr
can be any other data the function wishes to return, or ’() if it
doesn’t have any more data.
</p>
<p>The one caveat is that if the extra data it returns is a list, any
adjacent strings in that list will be appended by <code class="code">match-pattern</code>. For
instance, if a parsing function returns <code class="code">(13 ("a" "b" "c"))</code>,
<code class="code">match-pattern</code> will take <code class="code">(13 ("abc"))</code> as its value.
</p>
<p>For example, here is a function to match “ab” using the actual
interface.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (match-a-b str len pos)
   (and (&lt;= (+ pos 2) len)
        (string= str "ab" pos (+ pos 2))
        (list (+ pos 2) '()))) ; we return no extra information
</pre></div>

<p>The above function can be used to match a string by running
<code class="code">(match-pattern match-a-b "ab")</code>.
</p>
<h4 class="subsubheading" id="Code-Generators-and-Extensible-Syntax">Code Generators and Extensible Syntax</h4>

<p>PEG expressions, such as those in a <code class="code">define-peg-pattern</code> form, are
interpreted internally in two steps.
</p>
<p>First, any string PEG is expanded into an s-expression PEG by the code
in the <code class="code">(ice-9 peg string-peg)</code> module.
</p>
<p>Then, the s-expression PEG that results is compiled into a parsing
function by the <code class="code">(ice-9 peg codegen)</code> module. In particular, the
function <code class="code">compile-peg-pattern</code> is called on the s-expression. It then
decides what to do based on the form it is passed.
</p>
<p>The PEG syntax can be expanded by providing <code class="code">compile-peg-pattern</code> more
options for what to do with its forms. The extended syntax will be
associated with a symbol, for instance <code class="code">my-parsing-form</code>, and will
be called on all PEG expressions of the form
</p><div class="example lisp">
<pre class="lisp-preformatted">(my-parsing-form ...)
</pre></div>

<p>The parsing function should take two arguments. The first will be a
syntax object containing a list with all of the arguments to the form
(but not the form’s name), and the second will be the
<code class="code">capture-type</code> argument that is passed to <code class="code">define-peg-pattern</code>.
</p>
<p>New functions can be registered by calling <code class="code">(add-peg-compiler!
symbol function)</code>, where <code class="code">symbol</code> is the symbol that will indicate
a form of this type and <code class="code">function</code> is the code generating function
described above. The function <code class="code">add-peg-compiler!</code> is exported from
the <code class="code">(ice-9 peg codegen)</code> module.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="Read_002fLoad_002fEval_002fCompile">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="n" rel="next">Memory Management and Garbage Collection</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#PEG-Parsing" accesskey="p" rel="prev">PEG Parsing</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Reading-and-Evaluating-Scheme-Code">6.16 Reading and Evaluating Scheme Code</h3>

<p>This chapter describes Guile functions that are concerned with reading,
loading, evaluating, and compiling Scheme code at run time.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="1">Scheme Syntax: Standard and Guile Extensions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read" accesskey="2">Reading Scheme Code</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read" accesskey="3">Reading Scheme Code, For the Compiler</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write" accesskey="4">Writing Scheme Values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation" accesskey="5">Procedures for On the Fly Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Compilation" accesskey="6">Compiling Scheme Code</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Loading" accesskey="7">Loading Scheme Code from File</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths" accesskey="8">Load Paths</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files" accesskey="9">Character Encoding of Source Files</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Delayed-Evaluation">Delayed Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Evaluation">Local Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Inclusion">Local Inclusion</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Sandboxed-Evaluation">Sandboxed Evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Servers">REPL Servers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Cooperative-REPL-Servers">Cooperative REPL Servers</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Scheme-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read" accesskey="n" rel="next">Reading Scheme Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Scheme-Syntax_003a-Standard-and-Guile-Extensions">6.16.1 Scheme Syntax: Standard and Guile Extensions</h4>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Expression-Syntax" accesskey="1">Expression Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Comments" accesskey="2">Comments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Block-Comments" accesskey="3">Block Comments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Case-Sensitivity" accesskey="4">Case Sensitivity</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Syntax" accesskey="5">Keyword Syntax</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Reader-Extensions" accesskey="6">Reader Extensions</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Expression-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Comments" accesskey="n" rel="next">Comments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Expression-Syntax-1">6.16.1.1 Expression Syntax</h4>

<p>An expression to be evaluated takes one of the following forms.
</p>
<dl class="table">
<dt><code class="code"><var class="var">symbol</var></code></dt>
<dd><p>A symbol is evaluated by dereferencing.  A binding of that symbol is
sought and the value there used.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(define x 123)
x ⇒ 123
</pre></div>

</dd>
<dt><code class="code">(<var class="var">proc</var> <var class="var">args</var>…)</code></dt>
<dd><p>A parenthesised expression is a function call.  <var class="var">proc</var> and each
argument are evaluated, then the function (which <var class="var">proc</var> evaluated
to) is called with those arguments.
</p>
<p>The order in which <var class="var">proc</var> and the arguments are evaluated is
unspecified, so be careful when using expressions with side effects.
</p>
<div class="example">
<pre class="example-preformatted">(max 1 2 3) ⇒ 3

(define (get-some-proc)  min)
((get-some-proc) 1 2 3) ⇒ 1
</pre></div>

<p>The same sort of parenthesised form is used for a macro invocation,
but in that case the arguments are not evaluated.  See the
descriptions of macros for more on this (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Macros">Macros</a>, and
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Rules">Syntax-rules Macros</a>).
</p>
</dd>
<dt><code class="code"><var class="var">constant</var></code></dt>
<dd><p>Number, string, character and boolean constants evaluate “to
themselves”, so can appear as literals.
</p>
<div class="example">
<pre class="example-preformatted">123     ⇒ 123
99.9    ⇒ 99.9
"hello" ⇒ "hello"
#\z     ⇒ #\z
#t      ⇒ #t
</pre></div>

<p>Note that an application must not attempt to modify literal strings,
since they may be in read-only memory.
</p>
</dd>
<dt id="index-quote"><span><code class="code">(quote <var class="var">data</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quote"> ¶</a></span></dt>
<dt><code class="code">'<var class="var">data</var></code></dt>
<dd><a class="index-entry-id" id="index-_0027"></a>
<p>Quoting is used to obtain a literal symbol (instead of a variable
reference), a literal list (instead of a function call), or a literal
vector.  <code class="code">'</code> is simply a shorthand for a <code class="code">quote</code> form.
For example,
</p>
<div class="example">
<pre class="example-preformatted">'x                   ⇒ x
'(1 2 3)             ⇒ (1 2 3)
'#(1 (2 3) 4)        ⇒ #(1 (2 3) 4)
(quote x)            ⇒ x
(quote (1 2 3))      ⇒ (1 2 3)
(quote #(1 (2 3) 4)) ⇒ #(1 (2 3) 4)
</pre></div>

<p>Note that an application must not attempt to modify literal lists or
vectors obtained from a <code class="code">quote</code> form, since they may be in
read-only memory.
</p>
</dd>
<dt id="index-quasiquote"><span><code class="code">(quasiquote <var class="var">data</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quasiquote"> ¶</a></span></dt>
<dt><code class="code">`<var class="var">data</var></code></dt>
<dd><a class="index-entry-id" id="index-_0060"></a>
<p>Backquote quasi-quotation is like <code class="code">quote</code>, but selected
sub-expressions are evaluated.  This is a convenient way to construct
a list or vector structure most of which is constant, but at certain
points should have expressions substituted.
</p>
<p>The same effect can always be had with suitable <code class="code">list</code>,
<code class="code">cons</code> or <code class="code">vector</code> calls, but quasi-quoting is often easier.
</p>
<dl class="table">
<dt id="index-unquote"><span><code class="code">(unquote <var class="var">expr</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unquote"> ¶</a></span></dt>
<dt><code class="code">,<var class="var">expr</var></code></dt>
<dd><a class="index-entry-id" id="index-_002c"></a>
<p>Within the quasiquote <var class="var">data</var>, <code class="code">unquote</code> or <code class="code">,</code> indicates
an expression to be evaluated and inserted.  The comma syntax <code class="code">,</code>
is simply a shorthand for an <code class="code">unquote</code> form.  For example,
</p>
<div class="example">
<pre class="example-preformatted">`(1 2 (* 9 9) 3 4)       ⇒ (1 2 (* 9 9) 3 4)
`(1 2 ,(* 9 9) 3 4)      ⇒ (1 2 81 3 4)
`(1 (unquote (+ 1 1)) 3) ⇒ (1 2 3)
`#(1 ,(/ 12 2))          ⇒ #(1 6)
</pre></div>

</dd>
<dt id="index-unquote_002dsplicing"><span><code class="code">(unquote-splicing <var class="var">expr</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unquote_002dsplicing"> ¶</a></span></dt>
<dt><code class="code">,@<var class="var">expr</var></code></dt>
<dd><a class="index-entry-id" id="index-_002c_0040"></a>
<p>Within the quasiquote <var class="var">data</var>, <code class="code">unquote-splicing</code> or
<code class="code">,@</code> indicates an expression to be evaluated and the elements of
the returned list inserted.  <var class="var">expr</var> must evaluate to a list.  The
“comma-at” syntax <code class="code">,@</code> is simply a shorthand for an
<code class="code">unquote-splicing</code> form.
</p>
<div class="example">
<pre class="example-preformatted">(define x '(2 3))
`(1 ,x 4)                           ⇒ (1 (2 3) 4)
`(1 ,@x 4)                         ⇒ (1 2 3 4)
`(1 (unquote-splicing (map 1+ x)))  ⇒ (1 3 4)
`#(9 ,@x 9)                        ⇒ #(9 2 3 9)
</pre></div>

<p>Notice <code class="code">,@</code> differs from plain <code class="code">,</code> in the way one level of
nesting is stripped.  For <code class="code">,@</code> the elements of a returned list
are inserted, whereas with <code class="code">,</code> it would be the list itself
inserted.
</p></dd>
</dl>


</dd>
</dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Comments">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Block-Comments" accesskey="n" rel="next">Block Comments</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Expression-Syntax" accesskey="p" rel="prev">Expression Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Comments-1">6.16.1.2 Comments</h4>


<p>Comments in Scheme source files are written by starting them with a
semicolon character (<code class="code">;</code>).  The comment then reaches up to the end
of the line.  Comments can begin at any column, and the may be inserted
on the same line as Scheme code.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">; Comment
;; Comment too
(define x 1)        ; Comment after expression
(let ((y 1))
  ;; Display something.
  (display y)
;;; Comment at left margin.
  (display (+ y 1)))
</pre></div>

<p>It is common to use a single semicolon for comments following
expressions on a line, to use two semicolons for comments which are
indented like code, and three semicolons for comments which start at
column 0, even if they are inside an indented code block.  This
convention is used when indenting code in Emacs’ Scheme mode.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Block-Comments">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Case-Sensitivity" accesskey="n" rel="next">Case Sensitivity</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Comments" accesskey="p" rel="prev">Comments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Block-Comments-1">6.16.1.3 Block Comments</h4>
<a class="index-entry-id" id="index-multiline-comments"></a>
<a class="index-entry-id" id="index-block-comments"></a>
<a class="index-entry-id" id="index-_0023_0021"></a>
<a class="index-entry-id" id="index-_0021_0023"></a>


<p>In addition to the standard line comments defined by R5RS, Guile has
another comment type for multiline comments, called <em class="dfn">block
comments</em>.  This type of comment begins with the character sequence
<code class="code">#!</code> and ends with the characters <code class="code">!#</code>.
</p>
<p>These comments are compatible with the block
comments in the Scheme Shell <samp class="file">scsh</samp> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-shell-_0028scsh_0029">The Scheme shell (scsh)</a>).  The characters <code class="code">#!</code> were chosen because they are the
magic characters used in shell scripts for indicating that the name of
the program for executing the script follows on the same line.
</p>
<p>Thus a Guile script often starts like this.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#! /usr/local/bin/guile -s
!#
</pre></div>

<p>More details on Guile scripting can be found in the scripting section
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Scripting">Guile Scripting</a>).
</p>
<a class="index-entry-id" id="index-R6RS-block-comments"></a>
<a class="index-entry-id" id="index-SRFI_002d30-block-comments"></a>
<p>Similarly, Guile (starting from version 2.0) supports nested block
comments as specified by R6RS and
<a class="url" href="http://srfi.schemers.org/srfi-30/srfi-30.html">SRFI-30</a>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(+ 1 #| this is a #| nested |# block comment |# 2)
⇒ 3
</pre></div>

<p>For backward compatibility, this syntax can be overridden with
<code class="code">read-hash-extend</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Reader-Extensions"><code class="code">read-hash-extend</code></a>).
</p>
<p>There is one special case where the contents of a comment can actually
affect the interpretation of code.  When a character encoding
declaration, such as <code class="code">coding: utf-8</code> appears in one of the first
few lines of a source file, it indicates to Guile’s default reader
that this source code file is not ASCII.  For details see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files">Character Encoding of Source Files</a>.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Case-Sensitivity">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Syntax" accesskey="n" rel="next">Keyword Syntax</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Block-Comments" accesskey="p" rel="prev">Block Comments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Case-Sensitivity-1">6.16.1.4 Case Sensitivity</h4>
<a class="index-entry-id" id="index-fold_002dcase"></a>
<a class="index-entry-id" id="index-no_002dfold_002dcase"></a>


<p>Scheme as defined in R5RS is not case sensitive when reading symbols.
Guile, on the contrary is case sensitive by default, so the identifiers
</p>
<div class="example lisp">
<pre class="lisp-preformatted">guile-whuzzy
Guile-Whuzzy
</pre></div>

<p>are the same in R5RS Scheme, but are different in Guile.
</p>
<p>It is possible to turn off case sensitivity in Guile by setting the
reader option <code class="code">case-insensitive</code>.  For more information on reader
options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(read-enable 'case-insensitive)
</pre></div>

<p>It is also possible to disable (or enable) case sensitivity within a
single file by placing the reader directives <code class="code">#!fold-case</code> (or
<code class="code">#!no-fold-case</code>) within the file itself.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Keyword-Syntax">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Reader-Extensions" accesskey="n" rel="next">Reader Extensions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Case-Sensitivity" accesskey="p" rel="prev">Case Sensitivity</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Keyword-Syntax-1">6.16.1.5 Keyword Syntax</h4>


<hr>
</div>
<div class="subsubsection-level-extent" id="Reader-Extensions">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Keyword-Syntax" accesskey="p" rel="prev">Keyword Syntax</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="u" rel="up">Scheme Syntax: Standard and Guile Extensions</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Reader-Extensions-1">6.16.1.6 Reader Extensions</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dhash_002dextend"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-hash-extend</strong> <var class="def-var-arguments">chr proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dhash_002dextend"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fread_005fhash_005fextend"><span class="category-def">C Function: </span><span><strong class="def-name">scm_read_hash_extend</strong> <var class="def-var-arguments">(chr, proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fread_005fhash_005fextend"> ¶</a></span></dt>
<dd><p>Install the procedure <var class="var">proc</var> for reading expressions
starting with the character sequence <code class="code">#</code> and <var class="var">chr</var>.
<var class="var">proc</var> will be called with two arguments:  the character
<var class="var">chr</var> and the port to read further data from. The object
returned will be the return value of <code class="code">read</code>. 
Passing <code class="code">#f</code> for <var class="var">proc</var> will remove a previous setting. 
</p>
</dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Scheme-Read">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read" accesskey="n" rel="next">Reading Scheme Code, For the Compiler</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Syntax" accesskey="p" rel="prev">Scheme Syntax: Standard and Guile Extensions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Reading-Scheme-Code">6.16.2 Reading Scheme Code</h4>

<a class="index-entry-id" id="index-read-4"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-read-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_read</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fread"> ¶</a></span></dt>
<dd><p>Read an s-expression from the input port <var class="var">port</var>, or from
the current input port if <var class="var">port</var> is not specified.
Any whitespace before the next token is discarded.
</p></dd></dl>

<p>The behaviour of Guile’s Scheme reader can be modified by manipulating
its read options.
</p>
<a class="index-entry-id" id="index-options-_002d-read"></a>
<a class="index-entry-id" id="index-read-options"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002doptions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-options</strong> <var class="def-var-arguments">[setting]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002doptions"> ¶</a></span></dt>
<dd><p>Display the current settings of the global read options.  If
<var class="var">setting</var> is omitted, only a short form of the current read options
is printed.  Otherwise if <var class="var">setting</var> is the symbol <code class="code">help</code>, a
complete options description is displayed.
</p></dd></dl>

<p>The set of available options, and their default values, may be had by
invoking <code class="code">read-options</code> at the prompt.
</p>
<div class="example smalllisp lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (read-options)
(square-brackets keywords #f positions)
scheme@(guile-user)&gt; (read-options 'help)
positions         yes   Record positions of source code expressions.
case-insensitive  no    Convert symbols to lower case.
keywords          #f    Style of keyword recognition: #f, 'prefix or 'postfix.
r6rs-hex-escapes  no    Use R6RS variable-length character and string hex escapes.
square-brackets   yes   Treat `[' and `]' as parentheses, for R6RS compatibility.
hungry-eol-escapes no   In strings, consume leading whitespace after an
                        escaped end-of-line.
curly-infix       no    Support SRFI-105 curly infix expressions.
r7rs-symbols      no    Support R7RS |...| symbol notation.
</pre></div>

<p>Note that Guile also includes a preliminary mechanism for setting read
options on a per-port basis.  For instance, the <code class="code">case-insensitive</code>
read option is set (or unset) on the port when the reader encounters the
<code class="code">#!fold-case</code> or <code class="code">#!no-fold-case</code> reader directives.
Similarly, the <code class="code">#!curly-infix</code> reader directive sets the
<code class="code">curly-infix</code> read option on the port, and
<code class="code">#!curly-infix-and-bracket-lists</code> sets <code class="code">curly-infix</code> and
unsets <code class="code">square-brackets</code> on the port (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d105">SRFI-105 Curly-infix expressions.</a>).  There is
currently no other way to access or set the per-port read options.
</p>
<p>The boolean options may be toggled with <code class="code">read-enable</code> and
<code class="code">read-disable</code>. The non-boolean <code class="code">keywords</code> option must be set
using <code class="code">read-set!</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002denable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-enable</strong> <var class="def-var-arguments">option-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002denable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-read_002ddisable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-disable</strong> <var class="def-var-arguments">option-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002ddisable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-read_002dset_0021"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">read-set!</strong> <var class="def-var-arguments">option-name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dset_0021"> ¶</a></span></dt>
<dd><p>Modify the read options.  <code class="code">read-enable</code> should be used with boolean
options and switches them on, <code class="code">read-disable</code> switches them off.
</p>
<p><code class="code">read-set!</code> can be used to set an option to a specific value.  Due
to historical oddities, it is a macro that expects an unquoted option
name.
</p></dd></dl>

<p>For example, to make <code class="code">read</code> fold all symbols to their lower case
(perhaps for compatibility with older Scheme code), you can enter:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(read-enable 'case-insensitive)
</pre></div>

<p>For more information on the effect of the <code class="code">r6rs-hex-escapes</code> and
<code class="code">hungry-eol-escapes</code> options, see (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#String-Syntax">String Read Syntax</a>).
</p>
<p>For more information on the <code class="code">r7rs-symbols</code> option, see
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Symbol-Read-Syntax">Extended Read Syntax for Symbols</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Annotated-Scheme-Read">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write" accesskey="n" rel="next">Writing Scheme Values</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read" accesskey="p" rel="prev">Reading Scheme Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Reading-Scheme-Code_002c-For-the-Compiler">6.16.3 Reading Scheme Code, For the Compiler</h4>

<p>When something goes wrong with a Scheme program, the user will want to
know how to fix it.  This starts with identifying where the error
occured: we want to associate a source location with each component part
of source code, and propagate that source location information through
to the compiler or interpreter.
</p>
<p>For that, Guile provides <code class="code">read-syntax</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002dsyntax"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-syntax</strong> <var class="def-var-arguments">[port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dsyntax"> ¶</a></span></dt>
<dd><p>Read an s-expression from the input port <var class="var">port</var>, or from the current
input port if <var class="var">port</var> is not specified.
</p>
<p>If, after skipping white space and comments, no more bytes are available
from <var class="var">port</var>, return the end-of-file object.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Binary-I_002fO">Binary I/O</a>.
Otherwise, return an annotated datum.  An annotated datum is a syntax
object which associates a source location with a datum.  For example:
</p>
<div class="example">
<pre class="example-preformatted">(call-with-input-string "  foo" read-syntax)
; ⇒ #&lt;syntax:unknown file:1:2 foo&gt;
(call-with-input-string "(foo)" read-syntax)
; ⇒
; #&lt;syntax:unknown file:1:0
;   (#&lt;syntax unknown file:1:1 foo&gt;)&gt;
</pre></div>

<p>As the second example shows, all fields of pairs and vectors are also
annotated, recursively.
</p></dd></dl>

<p>Most users are familiar with syntax objects in the context of macros,
which use syntax objects to associate scope information with
identifiers.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Macros">Macros</a>.  Here we use syntax objects to associate
source location information with any datum, but without attaching scope
information.  The Scheme compiler (<code class="code">compile</code>) and the interpreter
(<code class="code">eval</code>) can accept syntax objects directly as input, allowing them
to associate source information with resulting code.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, and See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">Procedures for On the Fly Evaluation</a>.
</p>
<p>Note that there is a legacy interface for getting source locations into
the Scheme compiler or interpreter, which is to use a side table that
associates “source properties” with each subdatum returned by
<code class="code">read</code>, instead of wrapping the datums directly as in
<code class="code">read-syntax</code>.  This has the disadvantage of not being able to
annotate all kinds of datums.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties">Source Properties</a>, for more
information.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Scheme-Write">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation" accesskey="n" rel="next">Procedures for On the Fly Evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read" accesskey="p" rel="prev">Reading Scheme Code, For the Compiler</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Writing-Scheme-Values">6.16.4 Writing Scheme Values</h4>

<p>Any scheme value may be written to a port. Not all values may be read
back in (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>), however.
</p>
<a class="index-entry-id" id="index-write-4"></a>
<a class="index-entry-id" id="index-print"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-write"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write</strong> <var class="def-var-arguments">obj [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write"> ¶</a></span></dt>
<dd><p>Send a representation of <var class="var">obj</var> to <var class="var">port</var> or to the current
output port if not given.
</p>
<p>The output is designed to be machine readable, and can be read back
with <code class="code">read</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>).  Strings are printed in
double quotes, with escapes if necessary, and characters are printed in
‘<samp class="samp">#\</samp>’ notation.
</p></dd></dl>

<a class="index-entry-id" id="index-display-4"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-display"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">display</strong> <var class="def-var-arguments">obj [port]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-display"> ¶</a></span></dt>
<dd><p>Send a representation of <var class="var">obj</var> to <var class="var">port</var> or to the current
output port if not given.
</p>
<p>The output is designed for human readability, it differs from
<code class="code">write</code> in that strings are printed without double quotes and
escapes, and characters are printed as per <code class="code">write-char</code>, not in
‘<samp class="samp">#\</samp>’ form.
</p></dd></dl>

<p>As was the case with the Scheme reader, there are a few options that
affect the behavior of the Scheme printer.
</p>
<a class="index-entry-id" id="index-options-_002d-print"></a>
<a class="index-entry-id" id="index-print-options"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-print_002doptions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">print-options</strong> <var class="def-var-arguments">[setting]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-print_002doptions"> ¶</a></span></dt>
<dd><p>Display the current settings of the read options.  If <var class="var">setting</var> is
omitted, only a short form of the current read options is
printed. Otherwise if <var class="var">setting</var> is the symbol <code class="code">help</code>, a
complete options description is displayed.
</p></dd></dl>

<p>The set of available options, and their default values, may be had by
invoking <code class="code">print-options</code> at the prompt.
</p>
<div class="example smalllisp lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (print-options)
(quote-keywordish-symbols reader highlight-suffix "}" highlight-prefix "{")
scheme@(guile-user)&gt; (print-options 'help)
highlight-prefix          {       The string to print before highlighted values.
highlight-suffix          }       The string to print after highlighted values.
quote-keywordish-symbols  reader  How to print symbols that have a colon
                                  as their first or last character. The
                                  value '#f' does not quote the colons;
                                  '#t' quotes them; 'reader' quotes them
                                  when the reader option 'keywords' is
                                  not '#f'.
escape-newlines           yes     Render newlines as \n when printing
                                  using `write'. 
r7rs-symbols              no      Escape symbols using R7RS |...| symbol
                                  notation.
</pre></div>

<p>These options may be modified with the print-set! syntax.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-print_002dset_0021"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">print-set!</strong> <var class="def-var-arguments">option-name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-print_002dset_0021"> ¶</a></span></dt>
<dd><p>Modify the print options.  Due to historical oddities, <code class="code">print-set!</code>
is a macro that expects an unquoted option name.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Fly-Evaluation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compilation" accesskey="n" rel="next">Compiling Scheme Code</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write" accesskey="p" rel="prev">Writing Scheme Values</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Procedures-for-On-the-Fly-Evaluation">6.16.5 Procedures for On the Fly Evaluation</h4>

<p>Scheme has the lovely property that its expressions may be represented
as data.  The <code class="code">eval</code> procedure takes a Scheme datum and evaluates
it as code.
</p>
<a class="index-entry-id" id="index-eval-2"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-eval"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eval</strong> <var class="def-var-arguments">exp module_or_state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eval"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feval"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eval</strong> <var class="def-var-arguments">(exp, module_or_state)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feval"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">exp</var>, a list representing a Scheme expression,
in the top-level environment specified by <var class="var">module_or_state</var>.
While <var class="var">exp</var> is evaluated (using <code class="code">primitive-eval</code>),
<var class="var">module_or_state</var> is made the current module.  The current module
is reset to its previous value when <code class="code">eval</code> returns.
XXX - dynamic states.
Example: (eval ’(+ 1 2) (interaction-environment))
</p></dd></dl>

<a class="index-entry-id" id="index-interaction_002denvironment-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-interaction_002denvironment"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">interaction-environment</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-interaction_002denvironment"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finteraction_005fenvironment"><span class="category-def">C Function: </span><span><strong class="def-name">scm_interaction_environment</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finteraction_005fenvironment"> ¶</a></span></dt>
<dd><p>Return a specifier for the environment that contains
implementation–defined bindings, typically a superset of those
listed in the report.  The intent is that this procedure will
return the environment in which the implementation would
evaluate expressions dynamically typed by the user.
</p></dd></dl>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Environments">Environments</a>, for other environments.
</p>
<p>One does not always receive code as Scheme data, of course, and this is
especially the case for Guile’s other language implementations
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages">Support for Other Languages</a>).  For the case in which all you have is a
string, we have <code class="code">eval-string</code>.  There is a legacy version of this
procedure in the default environment, but you really want the one from
<code class="code">(ice-9 eval-string)</code>, so load it up:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 eval-string))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-eval_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eval-string</strong> <var class="def-var-arguments">string [#:module=#f] [#:file=#f]                           [#:line=#f] [#:column=#f]                           [#:lang=(current-language)]                           [#:compile?=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eval_002dstring"> ¶</a></span></dt>
<dd><p>Parse <var class="var">string</var> according to the current language, normally Scheme.
Evaluate or compile the expressions it contains, in order, returning the
last expression.
</p>
<p>If the <var class="var">module</var> keyword argument is set, save a module excursion
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Module-System-Reflection">Module System Reflection</a>) and set the current module to
<var class="var">module</var> before evaluation.
</p>
<p>The <var class="var">file</var>, <var class="var">line</var>, and <var class="var">column</var> keyword arguments can be
used to indicate that the source string begins at a particular source
location.
</p>
<p>Finally, <var class="var">lang</var> is a language, defaulting to the current language,
and the expression is compiled if <var class="var">compile?</var> is true or there is no
evaluator for the given language.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-scm_005feval_005fstring"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eval_string</strong> <var class="def-var-arguments">(string)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feval_005fstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feval_005fstring_005fin_005fmodule"><span class="category-def">C Function: </span><span><strong class="def-name">scm_eval_string_in_module</strong> <var class="def-var-arguments">(string, module)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feval_005fstring_005fin_005fmodule"> ¶</a></span></dt>
<dd><p>These C bindings call <code class="code">eval-string</code> from <code class="code">(ice-9
eval-string)</code>, evaluating within <var class="var">module</var> or the current module.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005feval_005fstring"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_eval_string</strong> <code class="def-code-arguments">(const char *string)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005feval_005fstring"> ¶</a></span></dt>
<dd><p><code class="code">scm_eval_string</code>, but taking a C string in locale encoding instead
of an <code class="code">SCM</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-apply"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">apply</strong> <var class="def-var-arguments">proc arg … arglst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-apply"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fapply_005f0"><span class="category-def">C Function: </span><span><strong class="def-name">scm_apply_0</strong> <var class="def-var-arguments">(proc, arglst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fapply_005f0"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fapply_005f1"><span class="category-def">C Function: </span><span><strong class="def-name">scm_apply_1</strong> <var class="def-var-arguments">(proc, arg1, arglst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fapply_005f1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fapply_005f2"><span class="category-def">C Function: </span><span><strong class="def-name">scm_apply_2</strong> <var class="def-var-arguments">(proc, arg1, arg2, arglst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fapply_005f2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fapply_005f3"><span class="category-def">C Function: </span><span><strong class="def-name">scm_apply_3</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arglst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fapply_005f3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fapply"><span class="category-def">C Function: </span><span><strong class="def-name">scm_apply</strong> <var class="def-var-arguments">(proc, arg, rest)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fapply"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-apply-2"></a>
<p>Call <var class="var">proc</var> with arguments <var class="var">arg</var> … and the
elements of the <var class="var">arglst</var> list.
</p>
<p><code class="code">scm_apply</code> takes parameters corresponding to a Scheme level
<code class="code">(lambda (proc arg1 . rest) ...)</code>.  So <var class="var">arg1</var> and all but the
last element of the <var class="var">rest</var> list make up <var class="var">arg</var> …, and the
last element of <var class="var">rest</var> is the <var class="var">arglst</var> list.  Or if <var class="var">rest</var>
is the empty list <code class="code">SCM_EOL</code> then there’s no <var class="var">arg</var> …, and
(<var class="var">arg1</var>) is the <var class="var">arglst</var>.
</p>
<p><var class="var">arglst</var> is not modified, but the <var class="var">rest</var> list passed to
<code class="code">scm_apply</code> is modified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-scm_005fcall_005f0"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_0</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f0"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f1"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_1</strong> <var class="def-var-arguments">(proc, arg1)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f2"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_2</strong> <var class="def-var-arguments">(proc, arg1, arg2)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f3"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_3</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f4"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_4</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f4"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f5"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_5</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4, arg5)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f5"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f6"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_6</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4, arg5, arg6)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f6"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f7"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_7</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4, arg5, arg6, arg7)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f7"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f8"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_8</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f8"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005f9"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_9</strong> <var class="def-var-arguments">(proc, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005f9"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> with the given arguments.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-scm_005fcall"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call</strong> <var class="def-var-arguments">(proc, ...)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> with any number of arguments.  The argument list must be
terminated by <code class="code">SCM_UNDEFINED</code>.  For example:
</p>
<div class="example">
<pre class="example-preformatted">scm_call (scm_c_public_ref ("guile", "+"),
          scm_from_int (1),
          scm_from_int (2),
          SCM_UNDEFINED);
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-scm_005fcall_005fn"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_n</strong> <var class="def-var-arguments">(proc, argv, nargs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005fn"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> with the array of arguments <var class="var">argv</var>, as a
<code class="code">SCM*</code>.  The length of the arguments should be passed in
<var class="var">nargs</var>, as a <code class="code">size_t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002deval"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-eval</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002deval"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005feval"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive_eval</strong> <var class="def-var-arguments">(exp)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005feval"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">exp</var> in the top-level environment specified by
the current module.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Compilation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Loading" accesskey="n" rel="next">Loading Scheme Code from File</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation" accesskey="p" rel="prev">Procedures for On the Fly Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Compiling-Scheme-Code">6.16.6 Compiling Scheme Code</h4>

<p>The <code class="code">eval</code> procedure directly interprets the S-expression
representation of Scheme. An alternate strategy for evaluation is to
determine ahead of time what computations will be necessary to
evaluate the expression, and then use that recipe to produce the
desired results. This is known as <em class="dfn">compilation</em>.
</p>
<p>While it is possible to compile simple Scheme expressions such as
<code class="code">(+ 2 2)</code> or even <code class="code">"Hello world!"</code>, compilation is most
interesting in the context of procedures. Compiling a lambda expression
produces a compiled procedure, which is just like a normal procedure
except typically much faster, because it can bypass the generic
interpreter.
</p>
<p>Functions from system modules in a Guile installation are normally
compiled already, so they load and run quickly.
</p>
<a class="index-entry-id" id="index-automatic-compilation"></a>
<p>Note that well-written Scheme programs will not typically call the
procedures in this section, for the same reason that it is often bad
taste to use <code class="code">eval</code>.  By default, Guile automatically compiles any
files it encounters that have not been compiled yet (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile"><code class="code">--auto-compile</code></a>).  The compiler can also be invoked
explicitly from the shell as <code class="code">guild compile foo.scm</code>.
</p>
<p>(Why are calls to <code class="code">eval</code> and <code class="code">compile</code> usually in bad taste?
Because they are limited, in that they can only really make sense for
top-level expressions. Also, most needs for “compile-time”
computation are fulfilled by macros and closures. Of course one good
counterexample is the REPL itself, or any code that reads expressions
from a port.)
</p>
<p>Automatic compilation generally works transparently, without any need
for user intervention.  However Guile does not yet do proper dependency
tracking, so that if file <samp class="file"><var class="var">a</var>.scm</samp> uses macros from
<samp class="file"><var class="var">b</var>.scm</samp>, and <var class="var"><var class="var">b</var>.scm</var> changes, <code class="code"><var class="var">a</var>.scm</code>
would not be automatically recompiled.  To forcibly invalidate the
auto-compilation cache, pass the <code class="code">--fresh-auto-compile</code> option to
Guile, or set the <code class="code">GUILE_AUTO_COMPILE</code> environment variable to
<code class="code">fresh</code> (instead of to <code class="code">0</code> or <code class="code">1</code>).
</p>
<p>For more information on the compiler itself, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-to-the-Virtual-Machine">Compiling to the Virtual Machine</a>. For information on the virtual machine, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#A-Virtual-Machine-for-Guile">A Virtual Machine for Guile</a>.
</p>
<p>The command-line interface to Guile’s compiler is the <code class="command">guild
compile</code> command:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-guild-compile"><span class="category-def">Command: </span><span><strong class="def-name">guild compile</strong> <var class="def-var-arguments">[<samp class="option">option</samp>...] <var class="var">file</var>...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-guild-compile"> ¶</a></span></dt>
<dd><p>Compile <var class="var">file</var>, a source file, and store bytecode in the compilation cache
or in the file specified by the <samp class="option">-o</samp> option.  The following options are
available:
</p>
<dl class="table">
<dt><samp class="option">-L <var class="var">dir</var></samp></dt>
<dt><samp class="option">--load-path=<var class="var">dir</var></samp></dt>
<dd><p>Add <var class="var">dir</var> to the front of the module load path.
</p>
</dd>
<dt><samp class="option">-o <var class="var">ofile</var></samp></dt>
<dt><samp class="option">--output=<var class="var">ofile</var></samp></dt>
<dd><p>Write output bytecode to <var class="var">ofile</var>.  By convention, bytecode file
names end in <code class="code">.go</code>.  When <samp class="option">-o</samp> is omitted, the output file
name is as for <code class="code">compile-file</code> (see below).
</p>
</dd>
<dt><samp class="option">-x <var class="var">extension</var></samp></dt>
<dd><p>Recognize <var class="var">extension</var> as a valid source file name extension.
</p>
<p>For example, to compile R6RS code, you might want to pass <code class="command">-x
.sls</code> so that files ending in <samp class="file">.sls</samp> can be found.
</p>
</dd>
<dt id="index-warnings_002c-compiler"><span><samp class="option">-W <var class="var">warning</var></samp><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-warnings_002c-compiler"> ¶</a></span></dt>
<dt><samp class="option">--warn=<var class="var">warning</var></samp></dt>
<dd><p>Enable specific warning passes; use <code class="code">-Whelp</code> for a list of
available options.  The default is <code class="code">-W1</code>, which enables a number of
common warnings.  Pass <code class="code">-W0</code> to disable all warnings.
</p>
</dd>
<dt id="index-optimizations_002c-compiler"><span><samp class="option">-O <var class="var">opt</var></samp><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-optimizations_002c-compiler"> ¶</a></span></dt>
<dt><samp class="option">--optimize=<var class="var">opt</var></samp></dt>
<dd><p>Enable or disable specific compiler optimizations; use <code class="code">-Ohelp</code> for
a list of available options.  The default is <code class="code">-O2</code>, which enables
most optimizations.  <code class="code">-O0</code> is recommended if compilation speed is
more important than the speed of the compiled code.  Pass
<code class="code">-Ono-<var class="var">opt</var></code> to disable a specific compiler pass.  Any number
of <code class="code">-O</code> options can be passed to the compiler, with later ones
taking precedence.
</p>
</dd>
<dt><samp class="option">--r6rs</samp></dt>
<dt><samp class="option">--r7rs</samp></dt>
<dd><p>Compile in an environment whose default bindings, reader options, and
load paths are adapted for specific Scheme standards.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support">R6RS Support</a>, and See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support">R7RS Support</a>.
</p>
</dd>
<dt><samp class="option">-f <var class="var">lang</var></samp></dt>
<dt><samp class="option">--from=<var class="var">lang</var></samp></dt>
<dd><p>Use <var class="var">lang</var> as the source language of <var class="var">file</var>.  If this option is omitted,
<code class="code">scheme</code> is assumed.
</p>
</dd>
<dt><samp class="option">-t <var class="var">lang</var></samp></dt>
<dt><samp class="option">--to=<var class="var">lang</var></samp></dt>
<dd><p>Use <var class="var">lang</var> as the target language of <var class="var">file</var>.  If this option is omitted,
<code class="code">rtl</code> is assumed.
</p>
</dd>
<dt><samp class="option">-T <var class="var">target</var></samp></dt>
<dt><samp class="option">--target=<var class="var">target</var></samp></dt>
<dd><p>Produce code for <var class="var">target</var> instead of <var class="var">%host-type</var> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config">%host-type</a>).  Target must be a valid GNU triplet, such as
<code class="code">armv5tel-unknown-linux-gnueabi</code> (see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Specifying-Target-Triplets">Specifying Target
Triplets</a> in <cite class="cite">GNU Autoconf Manual</cite>).
</p>
</dd>
</dl>

<p>Each <var class="var">file</var> is assumed to be UTF-8-encoded, unless it contains a
coding declaration as recognized by <code class="code">file-encoding</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files">Character Encoding of Source Files</a>).
</p></dd></dl>

<p>The compiler can also be invoked directly by Scheme code.  These
interfaces are in their own module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system base compile))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-compile-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">compile</strong> <var class="def-var-arguments">exp [#:env=#f]                           [#:from=(current-language)]                           [#:to=value] [#:opts=’()]                           [#:optimization-level=(default-optimization-level)]                           [#:warning-level=(default-warning-level)]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compile-1"> ¶</a></span></dt>
<dd><p>Compile the expression <var class="var">exp</var> in the environment <var class="var">env</var>. If
<var class="var">exp</var> is a procedure, the result will be a compiled procedure;
otherwise <code class="code">compile</code> is mostly equivalent to <code class="code">eval</code>.
</p>
<p>For a discussion of languages and compiler options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-to-the-Virtual-Machine">Compiling to the Virtual Machine</a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-compile_002dfile-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">compile-file</strong> <var class="def-var-arguments">file [#:output-file=#f]                           [#:from=(current-language)] [#:to=’rtl]                           [#:env=(default-environment from)]                           [#:opts=’()]                           [#:optimization-level=(default-optimization-level)]                           [#:warning-level=(default-warning-level)]                           [#:canonicalization=’relative]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compile_002dfile-1"> ¶</a></span></dt>
<dd><p>Compile the file named <var class="var">file</var>.
</p>
<p>Output will be written to a <var class="var">output-file</var>.   If you do not supply an
output file name, output is written to a file in the cache directory, as
computed by <code class="code">(compiled-file-name <var class="var">file</var>)</code>.
</p>
<p><var class="var">from</var> and <var class="var">to</var> specify the source and target languages.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-to-the-Virtual-Machine">Compiling to the Virtual Machine</a>, for more information on these
options, and on <var class="var">env</var> and <var class="var">opts</var>.
</p>
<p>As with <code class="command">guild compile</code>, <var class="var">file</var> is assumed to be
UTF-8-encoded unless it contains a coding declaration.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-default_002doptimization_002dlevel"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">default-optimization-level</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-default_002doptimization_002dlevel"> ¶</a></span></dt>
<dd><p>The default optimization level, as an integer from 0 to 9.  The default
is 2.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-default_002dwarning_002dlevel"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">default-warning-level</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-default_002dwarning_002dlevel"> ¶</a></span></dt>
<dd><p>The default warning level, as an integer from 0 to 9.  The default is 1.
</p></dd></dl>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>, for more on how to set parameters.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-compiled_002dfile_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">compiled-file-name</strong> <var class="def-var-arguments">file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-compiled_002dfile_002dname"> ¶</a></span></dt>
<dd><p>Compute a cached location for a compiled version of a Scheme file named
<var class="var">file</var>.
</p>
<p>This file will usually be below the <samp class="file">$HOME/.cache/guile/ccache</samp>
directory, depending on the value of the <code class="env">XDG_CACHE_HOME</code>
environment variable.  The intention is that <code class="code">compiled-file-name</code>
provides a fallback location for caching auto-compiled files.  If you
want to place a compile file in the <code class="code">%load-compiled-path</code>, you
should pass the <var class="var">output-file</var> option to <code class="code">compile-file</code>,
explicitly.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-_0025auto_002dcompilation_002doptions"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">%auto-compilation-options</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025auto_002dcompilation_002doptions"> ¶</a></span></dt>
<dd><p>This variable contains the options passed to the <code class="code">compile-file</code>
procedure when auto-compiling source files.  By default, it enables
useful compilation warnings.  It can be customized from <samp class="file">~/.guile</samp>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Loading">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths" accesskey="n" rel="next">Load Paths</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Compilation" accesskey="p" rel="prev">Compiling Scheme Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Loading-Scheme-Code-from-File">6.16.7 Loading Scheme Code from File</h4>

<a class="index-entry-id" id="index-load-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-load-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">load</strong> <var class="def-var-arguments">filename [reader]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load-2"> ¶</a></span></dt>
<dd><p>Load <var class="var">filename</var> and evaluate its contents in the top-level
environment.
</p>
<p><var class="var">reader</var> if provided should be either <code class="code">#f</code>, or a procedure with
the signature <code class="code">(lambda (port) …)</code> which reads the next
expression from <var class="var">port</var>.  If <var class="var">reader</var> is <code class="code">#f</code> or absent,
Guile’s built-in <code class="code">read</code> procedure is used (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>).
</p>
<p>The <var class="var">reader</var> argument takes effect by setting the value of the
<code class="code">current-reader</code> fluid (see below) before loading the file, and
restoring its previous value when loading is complete.  The Scheme code
inside <var class="var">filename</var> can itself change the current reader procedure on
the fly by setting <code class="code">current-reader</code> fluid.
</p>
<p>If the variable <code class="code">%load-hook</code> is defined, it should be bound to a
procedure that will be called before any code is loaded.  See
documentation for <code class="code">%load-hook</code> later in this section.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-load_002dcompiled"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">load-compiled</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load_002dcompiled"> ¶</a></span></dt>
<dd><p>Load the compiled file named <var class="var">filename</var>.
</p>
<p>Compiling a source file (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile">Reading and Evaluating Scheme Code</a>) and then
calling <code class="code">load-compiled</code> on the resulting file is equivalent to
calling <code class="code">load</code> on the source file.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002dload-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-load</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002dload-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005fload"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive_load</strong> <var class="def-var-arguments">(filename)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005fload"> ¶</a></span></dt>
<dd><p>Load the file named <var class="var">filename</var> and evaluate its contents in the
top-level environment.  <var class="var">filename</var> must either be a full pathname or
be a pathname relative to the current directory.  If the variable
<code class="code">%load-hook</code> is defined, it should be bound to a procedure that
will be called before any code is loaded.  See the documentation for
<code class="code">%load-hook</code> later in this section.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fprimitive_005fload"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_primitive_load</strong> <code class="def-code-arguments">(const char *filename)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprimitive_005fload"> ¶</a></span></dt>
<dd><p><code class="code">scm_primitive_load</code>, but taking a C string instead of an
<code class="code">SCM</code>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-current_002dreader"><span class="category-def">Variable: </span><span><strong class="def-name">current-reader</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dreader"> ¶</a></span></dt>
<dd><p><code class="code">current-reader</code> holds the read procedure that is currently being
used by the above loading procedures to read expressions (from the file
that they are loading).  <code class="code">current-reader</code> is a fluid, so it has an
independent value in each dynamic root and should be read and set using
<code class="code">fluid-ref</code> and <code class="code">fluid-set!</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a>).
</p>
<p>Changing <code class="code">current-reader</code> is typically useful to introduce local
syntactic changes, such that code following the <code class="code">fluid-set!</code> call
is read using the newly installed reader.  The <code class="code">current-reader</code>
change should take place at evaluation time when the code is evaluated,
or at compilation time when the code is compiled:
</p>
<a class="index-entry-id" id="index-eval_002dwhen-1"></a>
<div class="example">
<pre class="example-preformatted">(eval-when (compile eval)
  (fluid-set! current-reader my-own-reader))
</pre></div>

<p>The <code class="code">eval-when</code> form above ensures that the <code class="code">current-reader</code>
change occurs at the right time.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025load_002dhook"><span class="category-def">Variable: </span><span><strong class="def-name">%load-hook</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025load_002dhook"> ¶</a></span></dt>
<dd><p>A procedure to be called <code class="code">(%load-hook <var class="var">filename</var>)</code> whenever a
file is loaded, or <code class="code">#f</code> for no such call.  <code class="code">%load-hook</code> is
used by all of the loading functions (<code class="code">load</code> and
<code class="code">primitive-load</code>, and <code class="code">load-from-path</code> and
<code class="code">primitive-load-path</code> documented in the next section).
</p>
<p>For example an application can set this to show what’s loaded,
</p>
<div class="example">
<pre class="example-preformatted">(set! %load-hook (lambda (filename)
                   (format #t "Loading ~a ...\n" filename)))
(load-from-path "foo.scm")
-| Loading /usr/local/share/guile/site/foo.scm ...
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dload_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-load-port</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dload_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005fload_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_load_port</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005fload_005fport"> ¶</a></span></dt>
<dd><p>Return the current-load-port.
The load port is used internally by <code class="code">primitive-load</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Load-Paths">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files" accesskey="n" rel="next">Character Encoding of Source Files</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Loading" accesskey="p" rel="prev">Loading Scheme Code from File</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Load-Paths-1">6.16.8 Load Paths</h4>

<p>The procedure in the previous section look for Scheme code in the file
system at specific location.  Guile also has some procedures to search
the load path for code.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025load_002dpath"><span class="category-def">Variable: </span><span><strong class="def-name">%load-path</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025load_002dpath"> ¶</a></span></dt>
<dd><p>List of directories which should be searched for Scheme modules and
libraries.  When Guile starts up, <code class="code">%load-path</code> is initialized to
the default load path <code class="code">(list (%library-dir) (%site-dir)
(%global-site-dir) (%package-data-dir))</code>.  The <code class="env">GUILE_LOAD_PATH</code>
environment variable can be used to prepend or append additional
directories (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Environment-Variables">Environment Variables</a>).
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config">Configuration, Build and Installation</a>, for more on <code class="code">%site-dir</code> and related
procedures.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-load_002dfrom_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">load-from-path</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load_002dfrom_002dpath"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">load</code>, but searches for <var class="var">filename</var> in the load
paths. Preferentially loads a compiled version of the file, if it is
available and up-to-date.
</p></dd></dl>

<p>A user can extend the load path by calling <code class="code">add-to-load-path</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-add_002dto_002dload_002dpath"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">add-to-load-path</strong> <var class="def-var-arguments">dir</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dto_002dload_002dpath"> ¶</a></span></dt>
<dd><p>Add <var class="var">dir</var> to the load path.
</p></dd></dl>

<p>For example, a script might include this form to add the directory that
it is in to the load path:
</p>
<div class="example">
<pre class="example-preformatted">(add-to-load-path (dirname (current-filename)))
</pre></div>

<p>It’s better to use <code class="code">add-to-load-path</code> than to modify
<code class="code">%load-path</code> directly, because <code class="code">add-to-load-path</code> takes care
of modifying the path both at compile-time and at run-time.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002dload_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-load-path</strong> <var class="def-var-arguments">filename [exception-on-not-found]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002dload_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005fload_005fpath"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive_load_path</strong> <var class="def-var-arguments">(filename)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005fload_005fpath"> ¶</a></span></dt>
<dd><p>Search <code class="code">%load-path</code> for the file named <var class="var">filename</var> and
load it into the top-level environment.  If <var class="var">filename</var> is a
relative pathname and is not found in the list of search paths,
an error is signalled.  Preferentially loads a compiled version of the
file, if it is available and up-to-date.
</p>
<p>If <var class="var">filename</var> is a relative pathname and is not found in the list of
search paths, one of three things may happen, depending on the optional
second argument, <var class="var">exception-on-not-found</var>.  If it is <code class="code">#f</code>,
<code class="code">#f</code> will be returned.  If it is a procedure, it will be called
with no arguments.  (This allows a distinction to be made between
exceptions raised by loading a file, and exceptions related to the
loader itself.)  Otherwise an error is signalled.
</p>
<p>For compatibility with Guile 1.8 and earlier, the C function takes only
one argument, which can be either a string (the file name) or an
argument list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025search_002dload_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%search-load-path</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025search_002dload_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fsearch_005fload_005fpath"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_search_load_path</strong> <var class="def-var-arguments">(filename)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fsearch_005fload_005fpath"> ¶</a></span></dt>
<dd><p>Search <code class="code">%load-path</code> for the file named <var class="var">filename</var>, which must
be readable by the current user.  If <var class="var">filename</var> is found in the list
of paths to search or is an absolute pathname, return its full pathname.
Otherwise, return <code class="code">#f</code>.  Filenames may have any of the optional
extensions in the <code class="code">%load-extensions</code> list; <code class="code">%search-load-path</code>
will try each extension automatically.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025load_002dextensions"><span class="category-def">Variable: </span><span><strong class="def-name">%load-extensions</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025load_002dextensions"> ¶</a></span></dt>
<dd><p>A list of default file extensions for files containing Scheme code.
<code class="code">%search-load-path</code> tries each of these extensions when looking for
a file to load.  By default, <code class="code">%load-extensions</code> is bound to the
list <code class="code">("" ".scm")</code>.
</p></dd></dl>

<p>As mentioned above, when Guile searches the <code class="code">%load-path</code> for a
source file, it will also search the <code class="code">%load-compiled-path</code> for a
corresponding compiled file.  If the compiled file is as new or newer
than the source file, it will be loaded instead of the source file,
using <code class="code">load-compiled</code>.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025load_002dcompiled_002dpath"><span class="category-def">Variable: </span><span><strong class="def-name">%load-compiled-path</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025load_002dcompiled_002dpath"> ¶</a></span></dt>
<dd><p>Like <code class="code">%load-path</code>, but for compiled files.  By default, this path
has two entries: one for compiled files from Guile itself, and one for
site packages.  The <code class="env">GUILE_LOAD_COMPILED_PATH</code> environment variable
can be used to prepend or append additional directories
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Environment-Variables">Environment Variables</a>).
</p></dd></dl>

<p>When <code class="code">primitive-load-path</code> searches the <code class="code">%load-compiled-path</code>
for a corresponding compiled file for a relative path it does so by
appending <code class="code">.go</code> to the relative path.  For example, searching for
<code class="code">ice-9/popen</code> could find
<code class="code">/usr/lib/guile/3.0/ccache/ice-9/popen.go</code>, and use it instead of
<code class="code">/usr/share/guile/3.0/ice-9/popen.scm</code>.
</p>
<p>If <code class="code">primitive-load-path</code> does not find a corresponding <code class="code">.go</code>
file in the <code class="code">%load-compiled-path</code>, or the <code class="code">.go</code> file is out of
date, it will search for a corresponding auto-compiled file in the
fallback path, possibly creating one if one does not exist.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">Installing Site Packages</a>, for more on how to correctly install
site packages.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System">Modules and the File System</a>, for more on the
relationship between load paths and modules.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for
more on the fallback path and auto-compilation.
</p>
<p>Finally, there are a couple of helper procedures for general path
manipulation.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-path</strong> <var class="def-var-arguments">path [tail]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fparse_005fpath"><span class="category-def">C Function: </span><span><strong class="def-name">scm_parse_path</strong> <var class="def-var-arguments">(path, tail)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fparse_005fpath"> ¶</a></span></dt>
<dd><p>Parse <var class="var">path</var>, which is expected to be a colon-separated string, into
a list and return the resulting list with <var class="var">tail</var> appended. If
<var class="var">path</var> is <code class="code">#f</code>, <var class="var">tail</var> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dpath_002dwith_002dellipsis"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-path-with-ellipsis</strong> <var class="def-var-arguments">path base</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dpath_002dwith_002dellipsis"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fparse_005fpath_005fwith_005fellipsis"><span class="category-def">C Function: </span><span><strong class="def-name">scm_parse_path_with_ellipsis</strong> <var class="def-var-arguments">(path, base)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fparse_005fpath_005fwith_005fellipsis"> ¶</a></span></dt>
<dd><p>Parse <var class="var">path</var>, which is expected to be a colon-separated string, into
a list and return the resulting list with <var class="var">base</var> (a list) spliced in
place of the <code class="code">...</code> path component, if present, or else <var class="var">base</var>
is added to the end.  If <var class="var">path</var> is <code class="code">#f</code>, <var class="var">base</var> is
returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-search_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">search-path</strong> <var class="def-var-arguments">path filename [extensions [require-exts?]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-search_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsearch_005fpath"><span class="category-def">C Function: </span><span><strong class="def-name">scm_search_path</strong> <var class="def-var-arguments">(path, filename, rest)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsearch_005fpath"> ¶</a></span></dt>
<dd><p>Search <var class="var">path</var> for a directory containing a file named
<var class="var">filename</var>. The file must be readable, and not a directory.  If we
find one, return its full filename; otherwise, return <code class="code">#f</code>.  If
<var class="var">filename</var> is absolute, return it unchanged.  If given,
<var class="var">extensions</var> is a list of strings; for each directory in <var class="var">path</var>,
we search for <var class="var">filename</var> concatenated with each <var class="var">extension</var>.  If
<var class="var">require-exts?</var>  is true, require that the returned file name have
one of the given extensions; if <var class="var">require-exts?</var> is not given, it
defaults to <code class="code">#f</code>.
</p>
<p>For compatibility with Guile 1.8 and earlier, the C function takes only
three arguments.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Character-Encoding-of-Source-Files">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Delayed-Evaluation" accesskey="n" rel="next">Delayed Evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths" accesskey="p" rel="prev">Load Paths</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Character-Encoding-of-Source-Files-1">6.16.9 Character Encoding of Source Files</h4>

<a class="index-entry-id" id="index-source-file-encoding"></a>
<a class="index-entry-id" id="index-primitive_002dload"></a>
<a class="index-entry-id" id="index-load"></a>
<p>Scheme source code files are usually encoded in ASCII or UTF-8, but the
built-in reader can interpret other character encodings as well.  When
Guile loads Scheme source code, it uses the <code class="code">file-encoding</code>
procedure (described below) to try to guess the encoding of the file.
In the absence of any hints, UTF-8 is assumed.  One way to provide a
hint about the encoding of a source file is to place a coding
declaration in the top 500 characters of the file.
</p>
<p>A coding declaration has the form <code class="code">coding: XXXXXX</code>, where
<code class="code">XXXXXX</code> is the name of a character encoding in which the source
code file has been encoded.  The coding declaration must appear in a
scheme comment.  It can either be a semicolon-initiated comment, or the
first block <code class="code">#!</code> comment in the file.
</p>
<p>The name of the character encoding in the coding declaration is
typically lower case and containing only letters, numbers, and hyphens,
as recognized by <code class="code">set-port-encoding!</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports"><code class="code">set-port-encoding!</code></a>).  Common examples of character encoding
names are <code class="code">utf-8</code> and <code class="code">iso-8859-1</code>,
<a class="url" href="http://www.iana.org/assignments/character-sets">as defined by
IANA</a>.  Thus, the coding declaration is mostly compatible with Emacs.
</p>
<p>However, there are some differences in encoding names recognized by
Emacs and encoding names defined by IANA, the latter being essentially a
subset of the former.  For instance, <code class="code">latin-1</code> is a valid encoding
name for Emacs, but it’s not according to the IANA standard, which Guile
follows; instead, you should use <code class="code">iso-8859-1</code>, which is both
understood by Emacs and dubbed by IANA (IANA writes it uppercase but
Emacs wants it lowercase and Guile is case insensitive.)
</p>
<p>For source code, only a subset of all possible character encodings can
be interpreted by the built-in source code reader.  Only those
character encodings in which ASCII text appears unmodified can be
used.  This includes <code class="code">UTF-8</code> and <code class="code">ISO-8859-1</code> through
<code class="code">ISO-8859-15</code>.  The multi-byte character encodings <code class="code">UTF-16</code>
and <code class="code">UTF-32</code> may not be used because they are not compatible with
ASCII.
</p>
<a class="index-entry-id" id="index-read"></a>
<a class="index-entry-id" id="index-encoding"></a>
<a class="index-entry-id" id="index-port-encoding"></a>
<a class="index-entry-id" id="index-set_002dport_002dencoding_0021-1"></a>
<p>There might be a scenario in which one would want to read non-ASCII
code from a port, such as with the function <code class="code">read</code>, instead of
with <code class="code">load</code>.  If the port’s character encoding is the same as the
encoding of the code to be read by the port, not other special
handling is necessary.  The port will automatically do the character
encoding conversion.  The functions <code class="code">setlocale</code> or by
<code class="code">set-port-encoding!</code> are used to set port encodings
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>).
</p>
<p>If a port is used to read code of unknown character encoding, it can
accomplish this in three steps.  First, the character encoding of the
port should be set to ISO-8859-1 using <code class="code">set-port-encoding!</code>.
Then, the procedure <code class="code">file-encoding</code>, described below, is used to
scan for a coding declaration when reading from the port.  As a side
effect, it rewinds the port after its scan is complete. After that,
the port’s character encoding should be set to the encoding returned
by <code class="code">file-encoding</code>, if any, again by using
<code class="code">set-port-encoding!</code>.  Then the code can be read as normal.
</p>
<p>Alternatively, one can use the <code class="code">#:guess-encoding</code> keyword argument
of <code class="code">open-file</code> and related procedures.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">File Ports</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-file_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">file-encoding</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-file_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffile_005fencoding"><span class="category-def">C Function: </span><span><strong class="def-name">scm_file_encoding</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffile_005fencoding"> ¶</a></span></dt>
<dd><p>Attempt to scan the first few hundred bytes from the <var class="var">port</var> for
hints about its character encoding.  Return a string containing the
encoding name or <code class="code">#f</code> if the encoding cannot be determined.  The
port is rewound.
</p>
<p>Currently, the only supported method is to look for an Emacs-like
character coding declaration (see <a data-manual="emacs" href="http://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Recognize-Coding">how Emacs
recognizes file encoding</a> in <cite class="cite">The GNU Emacs Reference Manual</cite>).  The
coding declaration is of the form <code class="code">coding: XXXXX</code> and must appear
in a Scheme comment.  Additional heuristics may be added in the future.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Delayed-Evaluation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Evaluation" accesskey="n" rel="next">Local Evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Encoding-of-Source-Files" accesskey="p" rel="prev">Character Encoding of Source Files</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Delayed-Evaluation-1">6.16.10 Delayed Evaluation</h4>
<a class="index-entry-id" id="index-delayed-evaluation"></a>
<a class="index-entry-id" id="index-promises"></a>

<p>Promises are a convenient way to defer a calculation until its result
is actually needed, and to run such a calculation only once.  Also
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d45">SRFI-45 - Primitives for Expressing Iterative Lazy Algorithms</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-delay"><span class="category-def">syntax: </span><span><strong class="def-name">delay</strong> <var class="def-var-arguments">expr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delay"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-delay-3"></a>
<p>Return a promise object which holds the given <var class="var">expr</var> expression,
ready to be evaluated by a later <code class="code">force</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-promise_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">promise?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-promise_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpromise_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_promise_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpromise_005fp"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a promise.
</p></dd></dl>

<a class="index-entry-id" id="index-force-3"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-force"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">force</strong> <var class="def-var-arguments">p</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-force"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fforce"><span class="category-def">C Function: </span><span><strong class="def-name">scm_force</strong> <var class="def-var-arguments">(p)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforce"> ¶</a></span></dt>
<dd><p>Return the value obtained from evaluating the <var class="var">expr</var> in the given
promise <var class="var">p</var>.  If <var class="var">p</var> has previously been forced then its
<var class="var">expr</var> is not evaluated again, instead the value obtained at that
time is simply returned.
</p>
<p>During a <code class="code">force</code>, an <var class="var">expr</var> can call <code class="code">force</code> again on
its own promise, resulting in a recursive evaluation of that
<var class="var">expr</var>.  The first evaluation to return gives the value for the
promise.  Higher evaluations run to completion in the normal way, but
their results are ignored, <code class="code">force</code> always returns the first
value.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Local-Evaluation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Inclusion" accesskey="n" rel="next">Local Inclusion</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Delayed-Evaluation" accesskey="p" rel="prev">Delayed Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Local-Evaluation-1">6.16.11 Local Evaluation</h4>

<p>Guile includes a facility to capture a lexical environment, and later
evaluate a new expression within that environment.  This code is
implemented in a module.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 local-eval))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-the_002denvironment"><span class="category-def">syntax: </span><span><strong class="def-name">the-environment</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-the_002denvironment"> ¶</a></span></dt>
<dd><p>Captures and returns a lexical environment for use with
<code class="code">local-eval</code> or <code class="code">local-compile</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-local_002deval"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">local-eval</strong> <var class="def-var-arguments">exp env</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-local_002deval"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flocal_005feval"><span class="category-def">C Function: </span><span><strong class="def-name">scm_local_eval</strong> <var class="def-var-arguments">(exp, env)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flocal_005feval"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-local_002dcompile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">local-compile</strong> <var class="def-var-arguments">exp env [opts=()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-local_002dcompile"> ¶</a></span></dt>
<dd><p>Evaluate or compile the expression <var class="var">exp</var> in the lexical environment
<var class="var">env</var>.
</p></dd></dl>

<p>Here is a simple example, illustrating that it is the variable
that gets captured, not just its value at one point in time.
</p>
<div class="example">
<pre class="example-preformatted">(define e (let ((x 100)) (the-environment)))
(define fetch-x (local-eval '(lambda () x) e))
(fetch-x)
⇒ 100
(local-eval '(set! x 42) e)
(fetch-x)
⇒ 42
</pre></div>

<p>While <var class="var">exp</var> is evaluated within the lexical environment of
<code class="code">(the-environment)</code>, it has the dynamic environment of the call to
<code class="code">local-eval</code>.
</p>
<p><code class="code">local-eval</code> and <code class="code">local-compile</code> can only evaluate
expressions, not definitions.
</p>
<div class="example">
<pre class="example-preformatted">(local-eval '(define foo 42)
            (let ((x 100)) (the-environment)))
⇒ syntax error: definition in expression context
</pre></div>

<p>Note that the current implementation of <code class="code">(the-environment)</code> only
captures “normal” lexical bindings, and pattern variables bound by
<code class="code">syntax-case</code>.  It does not currently capture local syntax
transformers bound by <code class="code">let-syntax</code>, <code class="code">letrec-syntax</code> or
non-top-level <code class="code">define-syntax</code> forms.  Any attempt to reference such
captured syntactic keywords via <code class="code">local-eval</code> or
<code class="code">local-compile</code> produces an error.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Local-Inclusion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sandboxed-Evaluation" accesskey="n" rel="next">Sandboxed Evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Evaluation" accesskey="p" rel="prev">Local Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Local-Inclusion-1">6.16.12 Local Inclusion</h4>

<p>This section has discussed various means of linking Scheme code
together: fundamentally, loading up files at run-time using <code class="code">load</code>
and <code class="code">load-compiled</code>.  Guile provides another option to compose
parts of programs together at expansion-time instead of at run-time.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-include"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">include</strong> <var class="def-var-arguments">file-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-include"> ¶</a></span></dt>
<dd><p>Open <var class="var">file-name</var>, at expansion-time, and read the Scheme forms that
it contains, splicing them into the location of the <code class="code">include</code>,
within a <code class="code">begin</code>.
</p>
<p>If <var class="var">file-name</var> is a relative path, it is searched for relative to
the path that contains the file that the <code class="code">include</code> form appears in.
</p></dd></dl>

<p>If you are a C programmer, if <code class="code">load</code> in Scheme is like
<code class="code">dlopen</code> in C, consider <code class="code">include</code> to be like the C
preprocessor’s <code class="code">#include</code>.  When you use <code class="code">include</code>, it is as
if the contents of the included file were typed in instead of the
<code class="code">include</code> form.
</p>
<p>Because the code is included at compile-time, it is available to the
macroexpander.  Syntax definitions in the included file are available to
later code in the form in which the <code class="code">include</code> appears, without the
need for <code class="code">eval-when</code>.  (See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When">Eval-when</a>.)
</p>
<p>For the same reason, compiling a form that uses <code class="code">include</code> results
in one compilation unit, composed of multiple files.  Loading the
compiled file is one <code class="code">stat</code> operation for the compilation unit,
instead of <code class="code">2*<var class="var">n</var></code> in the case of <code class="code">load</code> (once for each
loaded source file, and once each corresponding compiled file, in the
best case).
</p>
<p>Unlike <code class="code">load</code>, <code class="code">include</code> also works within nested lexical
contexts.  It so happens that the optimizer works best within a lexical
context, because all of the uses of bindings in a lexical context are
visible, so composing files by including them within a <code class="code">(let ()
...)</code> can sometimes lead to important speed improvements.
</p>
<p>On the other hand, <code class="code">include</code> does have all the disadvantages of
early binding: once the code with the <code class="code">include</code> is compiled, no
change to the included file is reflected in the future behavior of the
including form.
</p>
<p>Also, the particular form of <code class="code">include</code>, which requires an absolute
path, or a path relative to the current directory at compile-time, is
not very amenable to compiling the source in one place, but then
installing the source to another place.  For this reason, Guile provides
another form, <code class="code">include-from-path</code>, which looks for the source file
to include within a load path.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-include_002dfrom_002dpath"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">include-from-path</strong> <var class="def-var-arguments">file-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-include_002dfrom_002dpath"> ¶</a></span></dt>
<dd><p>Like <code class="code">include</code>, but instead of expecting <code class="code">file-name</code> to be an
absolute file name, it is expected to be a relative path to search in
the <code class="code">%load-path</code>.
</p></dd></dl>

<p><code class="code">include-from-path</code> is more useful when you want to install all of
the source files for a package (as you should!).  It makes it possible
to evaluate an installed file from source, instead of relying on the
<code class="code">.go</code> file being up to date.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Sandboxed-Evaluation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Servers" accesskey="n" rel="next">REPL Servers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Local-Inclusion" accesskey="p" rel="prev">Local Inclusion</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Sandboxed-Evaluation-1">6.16.13 Sandboxed Evaluation</h4>

<p>Sometimes you would like to evaluate code that comes from an untrusted
party.  The safest way to do this is to buy a new computer, evaluate the
code on that computer, then throw the machine away.  However if you are
unwilling to take this simple approach, Guile does include a limited
“sandbox” facility that can allow untrusted code to be evaluated with
some confidence.
</p>
<p>To use the sandboxed evaluator, load its module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 sandbox))
</pre></div>

<p>Guile’s sandboxing facility starts with the ability to restrict the time
and space used by a piece of code.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dtime_002dlimit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-time-limit</strong> <var class="def-var-arguments">limit thunk limit-reached</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dtime_002dlimit"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var>, but cancel it if <var class="var">limit</var> seconds of wall-clock
time have elapsed.  If the computation is cancelled, call
<var class="var">limit-reached</var> in tail position.  <var class="var">thunk</var> must not disable
interrupts or prevent an abort via a <code class="code">dynamic-wind</code> unwind handler.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dallocation_002dlimit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-allocation-limit</strong> <var class="def-var-arguments">limit thunk limit-reached</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dallocation_002dlimit"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var>, but cancel it if <var class="var">limit</var> bytes have been
allocated.  If the computation is cancelled, call <var class="var">limit-reached</var> in
tail position.  <var class="var">thunk</var> must not disable interrupts or prevent an
abort via a <code class="code">dynamic-wind</code> unwind handler.
</p>
<p>This limit applies to both stack and heap allocation.  The computation
will not be aborted before <var class="var">limit</var> bytes have been allocated, but
for the heap allocation limit, the check may be postponed until the next garbage collection.
</p>
<p>Note that as a current shortcoming, the heap size limit applies to all
threads; concurrent allocation by other unrelated threads counts towards
the allocation limit.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dtime_002dand_002dallocation_002dlimits"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-time-and-allocation-limits</strong> <var class="def-var-arguments">time-limit allocation-limit thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dtime_002dand_002dallocation_002dlimits"> ¶</a></span></dt>
<dd><p>Invoke <var class="var">thunk</var> in a dynamic extent in which its execution is limited
to <var class="var">time-limit</var> seconds of wall-clock time, and its allocation to
<var class="var">allocation-limit</var> bytes.  <var class="var">thunk</var> must not disable interrupts
or prevent an abort via a <code class="code">dynamic-wind</code> unwind handler.
</p>
<p>If successful, return all values produced by invoking <var class="var">thunk</var>.  Any
uncaught exception thrown by the thunk will propagate out.  If the time
or allocation limit is exceeded, an exception will be thrown to the
<code class="code">limit-exceeded</code> key.
</p></dd></dl>

<p>The time limit and stack limit are both very precise, but the heap limit
only gets checked asynchronously, after a garbage collection.  In
particular, if the heap is already very large, the number of allocated
bytes between garbage collections will be large, and therefore the
precision of the check is reduced.
</p>
<p>Additionally, due to the mechanism used by the allocation limit (the
<code class="code">after-gc-hook</code>), large single allocations like <code class="code">(make-vector
#e1e7)</code> are only detected after the allocation completes, even if the
allocation itself causes garbage collection.  It’s possible therefore
for user code to not only exceed the allocation limit set, but also to
exhaust all available memory, causing out-of-memory conditions at any
allocation site.  Failure to allocate memory in Guile itself should be
safe and cause an exception to be thrown, but most systems are not
designed to handle <code class="code">malloc</code> failures.  An allocation failure may
therefore exercise unexpected code paths in your system, so it is a
weakness of the sandbox (and therefore an interesting point of attack).
</p>
<p>The main sandbox interface is <code class="code">eval-in-sandbox</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-eval_002din_002dsandbox"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eval-in-sandbox</strong> <var class="def-var-arguments">exp [#:time-limit 0.1]                           [#:allocation-limit #e10e6]                           [#:bindings all-pure-bindings]                           [#:module (make-sandbox-module bindings)]                           [#:sever-module? #t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eval_002din_002dsandbox"> ¶</a></span></dt>
<dd><p>Evaluate the Scheme expression <var class="var">exp</var> within an isolated
"sandbox".  Limit its execution to <var class="var">time-limit</var> seconds of
wall-clock time, and limit its allocation to <var class="var">allocation-limit</var>
bytes.
</p>
<p>The evaluation will occur in <var class="var">module</var>, which defaults to the result
of calling <code class="code">make-sandbox-module</code> on <var class="var">bindings</var>, which itself
defaults to <code class="code">all-pure-bindings</code>.  This is the core of the
sandbox: creating a scope for the expression that is <em class="dfn">safe</em>.
</p>
<p>A safe sandbox module has two characteristics.  Firstly, it will not
allow the expression being evaluated to avoid being cancelled due to
time or allocation limits.  This ensures that the expression terminates
in a timely fashion.
</p>
<p>Secondly, a safe sandbox module will prevent the evaluation from
receiving information from previous evaluations, or from affecting
future evaluations.  All combinations of binding sets exported by
<code class="code">(ice-9 sandbox)</code> form safe sandbox modules.
</p>
<p>The <var class="var">bindings</var> should be given as a list of import sets.  One import
set is a list whose car names an interface, like <code class="code">(ice-9 q)</code>, and
whose cdr is a list of imports.  An import is either a bare symbol or a
pair of <code class="code">(<var class="var">out</var> . <var class="var">in</var>)</code>, where <var class="var">out</var> and <var class="var">in</var> are
both symbols and denote the name under which a binding is exported from
the module, and the name under which to make the binding available,
respectively.  Note that <var class="var">bindings</var> is only used as an input to the
default initializer for the <var class="var">module</var> argument; if you pass
<code class="code">#:module</code>, <var class="var">bindings</var> is unused.  If <var class="var">sever-module?</var> is
true (the default), the module will be unlinked from the global module
tree after the evaluation returns, to allow <var class="var">mod</var> to be
garbage-collected.
</p>
<p>If successful, return all values produced by <var class="var">exp</var>.  Any uncaught
exception thrown by the expression will propagate out.  If the time or
allocation limit is exceeded, an exception will be thrown to the
<code class="code">limit-exceeded</code> key.
</p></dd></dl>

<p>Constructing a safe sandbox module is tricky in general.  Guile defines
an easy way to construct safe modules from predefined sets of bindings.
Before getting to that interface, here are some general notes on safety.
</p>
<ol class="enumerate">
<li> The time and allocation limits rely on the ability to interrupt
and cancel a computation.  For this reason, no binding included in a
sandbox module should be able to indefinitely postpone interrupt
handling, nor should a binding be able to prevent an abort.  In practice
this second consideration means that <code class="code">dynamic-wind</code> should not be
included in any binding set.
</li><li> The time and allocation limits apply only to the
<code class="code">eval-in-sandbox</code> call.  If the call returns a procedure which is
later called, no limit is “automatically” in place.  Users of
<code class="code">eval-in-sandbox</code> have to be very careful to reimpose limits when
calling procedures that escape from sandboxes.
</li><li> Similarly, the dynamic environment of the <code class="code">eval-in-sandbox</code>
call is not necessarily in place when any procedure that escapes from
the sandbox is later called.

<p>This detail prevents us from exposing <code class="code">primitive-eval</code> to the
sandbox, for two reasons.  The first is that it’s possible for legacy
code to forge references to any binding, if the
<code class="code">allow-legacy-syntax-objects?</code> parameter is true.  The default for
this parameter is true; see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers">Syntax Transformer Helpers</a> for the
details.  The parameter is bound to <code class="code">#f</code> for the duration of the
<code class="code">eval-in-sandbox</code> call itself, but that will not be in place during
calls to escaped procedures.
</p>
<p>The second reason we don’t expose <code class="code">primitive-eval</code> is that
<code class="code">primitive-eval</code> implicitly works in the current module, which for
an escaped procedure will probably be different than the module that is
current for the <code class="code">eval-in-sandbox</code> call itself.
</p>
<p>The common denominator here is that if an interface exposed to the
sandbox relies on dynamic environments, it is easy to mistakenly grant
the sandboxed procedure additional capabilities in the form of bindings
that it should not have access to.  For this reason, the default sets of
predefined bindings do not depend on any dynamically scoped value.
</p></li><li> Mutation may allow a sandboxed evaluation to break some invariant
in users of data supplied to it.  A lot of code culturally doesn’t
expect mutation, but if you hand mutable data to a sandboxed evaluation
and you also grant mutating capabilities to that evaluation, then the
sandboxed code may indeed mutate that data.  The default set of bindings
to the sandbox do not include any mutating primitives.

<p>Relatedly, <code class="code">set!</code> may allow a sandbox to mutate a primitive,
invalidating many system-wide invariants.  Guile is currently quite
permissive when it comes to imported bindings and mutability.  Although
<code class="code">set!</code> to a module-local or lexically bound variable would be fine,
we don’t currently have an easy way to disallow <code class="code">set!</code> to an
imported binding, so currently no binding set includes <code class="code">set!</code>.
</p></li><li> Mutation may allow a sandboxed evaluation to keep state, or
make a communication mechanism with other code.  On the one hand this
sounds cool, but on the other hand maybe this is part of your threat
model.  Again, the default set of bindings doesn’t include mutating
primitives, preventing sandboxed evaluations from keeping state.
</li><li> The sandbox should probably not be able to open a network
connection, or write to a file, or open a file from disk.  The default
binding set includes no interaction with the operating system.
</li></ol>

<p>If you, dear reader, find the above discussion interesting, you will
enjoy Jonathan Rees’ dissertation, “A Security Kernel Based on the
Lambda Calculus”.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-all_002dpure_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">all-pure-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-all_002dpure_002dbindings"> ¶</a></span></dt>
<dd><p>All “pure” bindings that together form a safe subset of those bindings
available by default to Guile user code.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-all_002dpure_002dand_002dimpure_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">all-pure-and-impure-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-all_002dpure_002dand_002dimpure_002dbindings"> ¶</a></span></dt>
<dd><p>Like <code class="code">all-pure-bindings</code>, but additionally including mutating
primitives like <code class="code">vector-set!</code>.  This set is still safe in the sense
mentioned above, with the caveats about mutation.
</p></dd></dl>

<p>The components of these composite sets are as follows:
</p><dl class="first-defvr">
<dt class="defvr" id="index-alist_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">alist-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-array_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">array-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-array_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-bit_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">bit-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bit_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-bitvector_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">bitvector-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bitvector_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-char_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-char_002dset_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">char-set-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dset_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-clock_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">clock-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-clock_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-core_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">core-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-core_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-error_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">error-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-fluid_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">fluid-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-hash_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">hash-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hash_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-iteration_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">iteration-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-iteration_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-keyword_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">keyword-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-keyword_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-list_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">list-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-macro_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">macro-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-macro_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-nil_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">nil-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-nil_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-number_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">number-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-number_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-pair_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">pair-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pair_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-predicate_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">predicate-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-predicate_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-procedure_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">procedure-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-promise_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">promise-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-promise_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-prompt_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">prompt-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-prompt_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-regexp_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">regexp-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-regexp_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-sort_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">sort-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sort_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-srfi_002d4_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">srfi-4-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-srfi_002d4_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-string_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">string-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-symbol_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">symbol-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-unspecified_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">unspecified-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unspecified_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-variable_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">variable-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-vector_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">vector-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vector_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-version_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">version-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-version_002dbindings"> ¶</a></span></dt>
<dd><p>The components of <code class="code">all-pure-bindings</code>.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-mutating_002dalist_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-alist-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dalist_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002darray_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-array-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002darray_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dbitvector_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-bitvector-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dbitvector_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dfluid_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-fluid-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dfluid_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dhash_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-hash-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dhash_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dlist_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-list-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dlist_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dpair_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-pair-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dpair_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dsort_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-sort-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dsort_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dsrfi_002d4_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-srfi-4-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dsrfi_002d4_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dstring_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-string-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dstring_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dvariable_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-variable-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dvariable_002dbindings"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-mutating_002dvector_002dbindings"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">mutating-vector-bindings</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutating_002dvector_002dbindings"> ¶</a></span></dt>
<dd><p>The additional components of <code class="code">all-pure-and-impure-bindings</code>.
</p></dd></dl>

<p>Finally, what do you do with a binding set?  What is a binding set
anyway?  <code class="code">make-sandbox-module</code> is here for you.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsandbox_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-sandbox-module</strong> <var class="def-var-arguments">bindings</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsandbox_002dmodule"> ¶</a></span></dt>
<dd><p>Return a fresh module that only contains <var class="var">bindings</var>.
</p>
<p>The <var class="var">bindings</var> should be given as a list of import sets.  One import
set is a list whose car names an interface, like <code class="code">(ice-9 q)</code>, and
whose cdr is a list of imports.  An import is either a bare symbol or a
pair of <code class="code">(<var class="var">out</var> . <var class="var">in</var>)</code>, where <var class="var">out</var> and <var class="var">in</var> are
both symbols and denote the name under which a binding is exported from
the module, and the name under which to make the binding available,
respectively.
</p></dd></dl>

<p>So you see that binding sets are just lists, and
<code class="code">all-pure-and-impure-bindings</code> is really just the result of
appending all of the component binding sets.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="REPL-Servers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Cooperative-REPL-Servers" accesskey="n" rel="next">Cooperative REPL Servers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Sandboxed-Evaluation" accesskey="p" rel="prev">Sandboxed Evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="REPL-Servers-1">6.16.14 REPL Servers</h4>

<a class="index-entry-id" id="index-REPL-server"></a>

<p>The procedures in this section are provided by
</p><div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system repl server))
</pre></div>

<p>When an application is written in Guile, it is often convenient to
allow the user to be able to interact with it by evaluating Scheme
expressions in a REPL.
</p>
<p>The procedures of this module allow you to spawn a <em class="dfn">REPL server</em>,
which permits interaction over a local or TCP connection.  Guile itself
uses them internally to implement the <samp class="option">--listen</samp> switch,
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Command_002dline-Options">Command-line Options</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dtcp_002dserver_002dsocket"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-tcp-server-socket</strong> <var class="def-var-arguments">[#:host=#f]                           [#:addr] [#:port=37146]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dtcp_002dserver_002dsocket"> ¶</a></span></dt>
<dd><p>Return a stream socket bound to a given address <var class="var">addr</var> and port
number <var class="var">port</var>. If the <var class="var">host</var> is given, and <var class="var">addr</var> is not,
then the <var class="var">host</var> string is converted to an address.  If neither is
given, we use the loopback address.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dunix_002ddomain_002dserver_002dsocket"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-unix-domain-server-socket</strong> <var class="def-var-arguments">[#:path="/tmp/guile-socket"]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dunix_002ddomain_002dserver_002dsocket"> ¶</a></span></dt>
<dd><p>Return a UNIX domain socket, bound to a given <var class="var">path</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-run_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">run-server</strong> <var class="def-var-arguments">[server-socket]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-run_002dserver"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-spawn_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">spawn-server</strong> <var class="def-var-arguments">[server-socket]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-spawn_002dserver"> ¶</a></span></dt>
<dd><p>Create and run a REPL, making it available over the given
<var class="var">server-socket</var>.  If <var class="var">server-socket</var> is not provided, it
defaults to the socket created by calling <code class="code">make-tcp-server-socket</code>
with no arguments.
</p>
<p><code class="code">run-server</code> runs the server in the current thread, whereas
<code class="code">spawn-server</code> runs the server in a new thread.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stop_002dserver_002dand_002dclients_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stop-server-and-clients!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stop_002dserver_002dand_002dclients_0021"> ¶</a></span></dt>
<dd><p>Closes the connection on all running server sockets.
</p>
<p>Please note that in the current implementation, the REPL threads are
cancelled without unwinding their stacks.  If any of them are holding
mutexes or are within a critical section, the results are unspecified.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Cooperative-REPL-Servers">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Servers" accesskey="p" rel="prev">REPL Servers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="u" rel="up">Reading and Evaluating Scheme Code</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Cooperative-REPL-Servers-1">6.16.15 Cooperative REPL Servers</h4>

<a class="index-entry-id" id="index-Cooperative-REPL-server"></a>

<p>The procedures in this section are provided by
</p><div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system repl coop-server))
</pre></div>

<p>Whereas ordinary REPL servers run in their own threads (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#REPL-Servers">REPL Servers</a>), sometimes it is more convenient to provide REPLs that run at
specified times within an existing thread, for example in programs
utilizing an event loop or in single-threaded programs.  This allows for
safe access and mutation of a program’s data structures from the REPL,
without concern for thread synchronization.
</p>
<p>Although the REPLs are run in the thread that calls
<code class="code">spawn-coop-repl-server</code> and <code class="code">poll-coop-repl-server</code>,
dedicated threads are spawned so that the calling thread is not blocked.
The spawned threads read input for the REPLs and to listen for new
connections.
</p>
<p>Cooperative REPL servers must be polled periodically to evaluate any
pending expressions by calling <code class="code">poll-coop-repl-server</code> with the
object returned from <code class="code">spawn-coop-repl-server</code>.  The thread that
calls <code class="code">poll-coop-repl-server</code> will be blocked for as long as the
expression takes to be evaluated or if the debugger is entered.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-spawn_002dcoop_002drepl_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">spawn-coop-repl-server</strong> <var class="def-var-arguments">[server-socket]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-spawn_002dcoop_002drepl_002dserver"> ¶</a></span></dt>
<dd><p>Create and return a new cooperative REPL server object, and spawn a new
thread to listen for connections on <var class="var">server-socket</var>.  Proper
functioning of the REPL server requires that
<code class="code">poll-coop-repl-server</code> be called periodically on the returned
server object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-poll_002dcoop_002drepl_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">poll-coop-repl-server</strong> <var class="def-var-arguments">coop-server</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-poll_002dcoop_002drepl_002dserver"> ¶</a></span></dt>
<dd><p>Poll the cooperative REPL server <var class="var">coop-server</var> and apply a pending
operation if there is one, such as evaluating an expression typed at the
REPL prompt.  This procedure must be called from the same thread that
called <code class="code">spawn-coop-repl-server</code>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="section-level-extent" id="Memory-Management">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="n" rel="next">Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Read_002fLoad_002fEval_002fCompile" accesskey="p" rel="prev">Reading and Evaluating Scheme Code</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Memory-Management-and-Garbage-Collection">6.17 Memory Management and Garbage Collection</h3>

<p>Guile uses a <em class="emph">garbage collector</em> to manage most of its objects.
While the garbage collector is designed to be mostly invisible, you 
sometimes need to interact with it explicitly.
</p>
<p>See <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection">Garbage Collection</a> for a general discussion of how garbage
collection relates to using Guile from C.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection-Functions" accesskey="1">Function related to Garbage Collection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Blocks" accesskey="2">Memory Blocks</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References" accesskey="3">Weak References</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Guardians" accesskey="4">Guardians</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Garbage-Collection-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Blocks" accesskey="n" rel="next">Memory Blocks</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="u" rel="up">Memory Management and Garbage Collection</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Function-related-to-Garbage-Collection">6.17.1 Function related to Garbage Collection</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-gc-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gc</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gc-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgc"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gc</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc"> ¶</a></span></dt>
<dd><p>Finds all of the “live” <code class="code">SCM</code> objects and reclaims for further
use those that are no longer accessible.  You normally don’t need to
call this function explicitly.  Its functionality is invoked
automatically as needed.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fgc_005fprotect_005fobject"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_gc_protect_object</strong> <code class="def-code-arguments">(SCM <var class="var">obj</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fprotect_005fobject"> ¶</a></span></dt>
<dd><p>Protects <var class="var">obj</var> from being freed by the garbage collector, when it
otherwise might be.  When you are done with the object, call
<code class="code">scm_gc_unprotect_object</code> on the object. Calls to
<code class="code">scm_gc_protect_object</code>/<code class="code">scm_gc_unprotect_object</code> can be nested, and
the object remains protected until it has been unprotected as many times
as it was protected. It is an error to unprotect an object more times
than it has been protected. Returns the SCM object it was passed.
</p>
<p>Note that storing <var class="var">obj</var> in a C global variable has the same
effect<a class="footnote" id="DOCF17" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT17"><sup>17</sup></a>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fgc_005funprotect_005fobject"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_gc_unprotect_object</strong> <code class="def-code-arguments">(SCM <var class="var">obj</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005funprotect_005fobject"> ¶</a></span></dt>
<dd>
<p>Unprotects an object from the garbage collector which was protected by
<code class="code">scm_gc_unprotect_object</code>. Returns the SCM object it was passed.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpermanent_005fobject"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_permanent_object</strong> <code class="def-code-arguments">(SCM <var class="var">obj</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpermanent_005fobject"> ¶</a></span></dt>
<dd>
<p>Similar to <code class="code">scm_gc_protect_object</code> in that it causes the
collector to always mark the object, except that it should not be
nested (only call <code class="code">scm_permanent_object</code> on an object once), and
it has no corresponding unpermanent function. Once an object is
declared permanent, it will never be freed. Returns the SCM object it
was passed.
</p></dd></dl>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fremember_005fupto_005fhere_005f1"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">scm_remember_upto_here_1</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fremember_005fupto_005fhere_005f1"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fremember_005fupto_005fhere_005f2"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">scm_remember_upto_here_2</strong> <code class="def-code-arguments">(SCM obj1, SCM obj2)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fremember_005fupto_005fhere_005f2"> ¶</a></span></dt>
<dd><p>Create a reference to the given object or objects, so they’re certain
to be present on the stack or in a register and hence will not be
freed by the garbage collector before this point.
</p>
<p>Note that these functions can only be applied to ordinary C local
variables (ie. “automatics”).  Objects held in global or static
variables or some malloced block or the like cannot be protected with
this mechanism.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gc_002dstats"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gc-stats</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gc_002dstats"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgc_005fstats"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gc_stats</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fstats"> ¶</a></span></dt>
<dd><p>Return an association list of statistics about Guile’s current
use of storage.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gc_002dlive_002dobject_002dstats"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gc-live-object-stats</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gc_002dlive_002dobject_002dstats"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgc_005flive_005fobject_005fstats"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gc_live_object_stats</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005flive_005fobject_005fstats"> ¶</a></span></dt>
<dd><p>Return an alist of statistics of the current live objects. 
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fgc_005fmark"><span class="category-def">Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_gc_mark</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fmark"> ¶</a></span></dt>
<dd><p>Mark the object <var class="var">x</var>, and recurse on any objects <var class="var">x</var> refers to.
If <var class="var">x</var>’s mark bit is already set, return immediately.  This function
must only be called during the mark-phase of garbage collection,
typically from a smob <em class="emph">mark</em> function.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Memory-Blocks">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References" accesskey="n" rel="next">Weak References</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Garbage-Collection-Functions" accesskey="p" rel="prev">Function related to Garbage Collection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="u" rel="up">Memory Management and Garbage Collection</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Memory-Blocks-1">6.17.2 Memory Blocks</h4>

<a class="index-entry-id" id="index-automatically_002dmanaged-memory"></a>
<a class="index-entry-id" id="index-GC_002dmanaged-memory"></a>
<a class="index-entry-id" id="index-conservative-garbage-collection"></a>

<p>In C programs, dynamic management of memory blocks is normally done
with the functions malloc, realloc, and free.  Guile has additional
functions for dynamic memory allocation that are integrated into the
garbage collector and the error reporting system.
</p>
<p>Memory blocks that are associated with Scheme objects (for example a
foreign object) should be allocated with <code class="code">scm_gc_malloc</code> or
<code class="code">scm_gc_malloc_pointerless</code>.  These two functions will either
return a valid pointer or signal an error.  Memory blocks allocated this
way may be released explicitly; however, this is not strictly needed,
and we recommend <em class="emph">not</em> calling <code class="code">scm_gc_free</code>.  All memory
allocated with <code class="code">scm_gc_malloc</code> or <code class="code">scm_gc_malloc_pointerless</code>
is automatically reclaimed when the garbage collector no longer sees any
live reference to it<a class="footnote" id="DOCF18" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT18"><sup>18</sup></a>.
</p>
<p>When garbage collection occurs, Guile will visit the words in memory
allocated with <code class="code">scm_gc_malloc</code>, looking for live pointers.  This
means that if <code class="code">scm_gc_malloc</code>-allocated memory contains a pointer
to some other part of the memory, the garbage collector notices it and
prevents it from being reclaimed<a class="footnote" id="DOCF19" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT19"><sup>19</sup></a>.  Conversely, memory allocated with
<code class="code">scm_gc_malloc_pointerless</code> is assumed to be “pointer-less” and
is not scanned for pointers.
</p>
<p>For memory that is not associated with a Scheme object, you can use
<code class="code">scm_malloc</code> instead of <code class="code">malloc</code>.  Like
<code class="code">scm_gc_malloc</code>, it will either return a valid pointer or signal
an error.  However, it will not assume that the new memory block can
be freed by a garbage collection.  The memory must be explicitly freed
with <code class="code">free</code>.
</p>
<p>There is also <code class="code">scm_gc_realloc</code> and <code class="code">scm_realloc</code>, to be used
in place of <code class="code">realloc</code> when appropriate, and <code class="code">scm_gc_calloc</code>
and <code class="code">scm_calloc</code>, to be used in place of <code class="code">calloc</code> when
appropriate.
</p>
<p>The function <code class="code">scm_dynwind_free</code> can be useful when memory should be
freed with libc’s <code class="code">free</code> when leaving a dynwind context,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmalloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_malloc</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmalloc"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fcalloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_calloc</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcalloc"> ¶</a></span></dt>
<dd><p>Allocate <var class="var">size</var> bytes of memory and return a pointer to it.  When
<var class="var">size</var> is 0, return <code class="code">NULL</code>.  When not enough memory is
available, signal an error.  This function runs the GC to free up some
memory when it deems it appropriate.
</p>
<p>The memory is allocated by the libc <code class="code">malloc</code> function and can be
freed with <code class="code">free</code>.  There is no <code class="code">scm_free</code> function to go
with <code class="code">scm_malloc</code> to make it easier to pass memory back and forth
between different modules.  
</p>
<p>The function <code class="code">scm_calloc</code> is similar to <code class="code">scm_malloc</code>, but
initializes the block of memory to zero as well.
</p>
<p>These functions will (indirectly) call
<code class="code">scm_gc_register_allocation</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005frealloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_realloc</strong> <code class="def-code-arguments">(void *<var class="var">mem</var>, size_t <var class="var">new_size</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frealloc"> ¶</a></span></dt>
<dd><p>Change the size of the memory block at <var class="var">mem</var> to <var class="var">new_size</var> and
return its new location.  When <var class="var">new_size</var> is 0, this is the same
as calling <code class="code">free</code> on <var class="var">mem</var> and <code class="code">NULL</code> is returned.  When
<var class="var">mem</var> is <code class="code">NULL</code>, this function behaves like <code class="code">scm_malloc</code>
and allocates a new block of size <var class="var">new_size</var>.
</p>
<p>When not enough memory is available, signal an error.  This function
runs the GC to free up some memory when it deems it appropriate.
</p>
<p>This function will call <code class="code">scm_gc_register_allocation</code>.
</p></dd></dl>




<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fgc_005fmalloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_gc_malloc</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>, const char *<var class="var">what</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fmalloc"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fgc_005fmalloc_005fpointerless"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_gc_malloc_pointerless</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>, const char *<var class="var">what</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fmalloc_005fpointerless"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fgc_005frealloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_gc_realloc</strong> <code class="def-code-arguments">(void *<var class="var">mem</var>, size_t <var class="var">old_size</var>, size_t <var class="var">new_size</var>, const char *<var class="var">what</var>);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005frealloc"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fgc_005fcalloc"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_gc_calloc</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>, const char *<var class="var">what</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fcalloc"> ¶</a></span></dt>
<dd><p>Allocate <var class="var">size</var> bytes of automatically-managed memory.  The memory
is automatically freed when no longer referenced from any live memory
block.
</p>
<p>When garbage collection occurs, Guile will visit the words in memory
allocated with <code class="code">scm_gc_malloc</code> or <code class="code">scm_gc_calloc</code>, looking for
pointers to other memory allocations that are managed by the GC.  In
contrast, memory allocated by <code class="code">scm_gc_malloc_pointerless</code> is not
scanned for pointers.
</p>
<p>The <code class="code">scm_gc_realloc</code> call preserves the “pointerlessness” of the
memory area pointed to by <var class="var">mem</var>.  Note that you need to pass the old
size of a reallocated memory block as well.  See below for a motivation.
</p></dd></dl>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fgc_005ffree"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_gc_free</strong> <code class="def-code-arguments">(void *<var class="var">mem</var>, size_t <var class="var">size</var>, const char *<var class="var">what</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005ffree"> ¶</a></span></dt>
<dd><p>Explicitly free the memory block pointed to by <var class="var">mem</var>, which was
previously allocated by one of the above <code class="code">scm_gc</code> functions.  This
function is almost always unnecessary, except for codebases that still
need to compile on Guile 1.8.
</p>
<p>Note that you need to explicitly pass the <var class="var">size</var> parameter.  This
is done since it should normally be easy to provide this parameter
(for memory that is associated with GC controlled objects) and help keep
the memory management overhead very low.  However, in Guile 2.x,
<var class="var">size</var> is always ignored.
</p></dd></dl>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fgc_005fregister_005fallocation"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_gc_register_allocation</strong> <code class="def-code-arguments">(size_t <var class="var">size</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgc_005fregister_005fallocation"> ¶</a></span></dt>
<dd><p>Informs the garbage collector that <var class="var">size</var> bytes have been allocated,
which the collector would otherwise not have known about.
</p>
<p>In general, Scheme will decide to collect garbage only after some amount
of memory has been allocated.  Calling this function will make the
Scheme garbage collector know about more allocation, and thus run more
often (as appropriate).
</p>
<p>It is especially important to call this function when large unmanaged
allocations, like images, may be freed by small Scheme allocations, like
foreign objects.
</p></dd></dl>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005ffree-1"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_free</strong> <code class="def-code-arguments">(void *mem)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005ffree-1"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">scm_dynwind_unwind_handler (free, <var class="var">mem</var>,
SCM_F_WIND_EXPLICITLY)</code>.  That is, the memory block at <var class="var">mem</var> will be
freed (using <code class="code">free</code> from the C library) when the current dynwind is
left.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-malloc_002dstats"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">malloc-stats</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-malloc_002dstats"> ¶</a></span></dt>
<dd><p>Return an alist ((<var class="var">what</var> . <var class="var">n</var>) ...) describing number
of malloced objects.
<var class="var">what</var> is the second argument to <code class="code">scm_gc_malloc</code>,
<var class="var">n</var> is the number of objects of that type currently
allocated.
</p>
<p>This function is only available if the <code class="code">GUILE_DEBUG_MALLOC</code>
preprocessor macro was defined when Guile was compiled.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Weak-References">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guardians" accesskey="n" rel="next">Guardians</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Blocks" accesskey="p" rel="prev">Memory Blocks</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="u" rel="up">Memory Management and Garbage Collection</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Weak-References-1">6.17.3 Weak References</h4>

<p>[FIXME: This chapter is based on Mikael Djurfeldt’s answer to a
question by Michael Livshin. Any mistakes are not theirs, of course. ]
</p>
<p>Weak references let you attach bookkeeping information to data so that
the additional information automatically disappears when the original
data is no longer in use and gets garbage collected. In a weak key hash,
the hash entry for that key disappears as soon as the key is no longer
referenced from anywhere else. For weak value hashes, the same happens
as soon as the value is no longer in use. Entries in a doubly weak hash
disappear when either the key or the value are not used anywhere else
anymore.
</p>
<p>Object properties offer the same kind of functionality as weak key
hashes in many situations. (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Object-Properties">Object Properties</a>)
</p>
<p>Here’s an example (a little bit strained perhaps, but one of the
examples is actually used in Guile):
</p>
<p>Assume that you’re implementing a debugging system where you want to
associate information about filename and position of source code
expressions with the expressions themselves.
</p>
<p>Hashtables can be used for that, but if you use ordinary hash tables
it will be impossible for the scheme interpreter to "forget" old
source when, for example, a file is reloaded.
</p>
<p>To implement the mapping from source code expressions to positional
information it is necessary to use weak-key tables since we don’t want
the expressions to be remembered just because they are in our table.
</p>
<p>To implement a mapping from source file line numbers to source code
expressions you would use a weak-value table.
</p>
<p>To implement a mapping from source code expressions to the procedures
they constitute a doubly-weak table has to be used.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-hash-tables" accesskey="1">Weak hash tables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-vectors" accesskey="2">Weak vectors</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Weak-hash-tables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-vectors" accesskey="n" rel="next">Weak vectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References" accesskey="u" rel="up">Weak References</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Weak-hash-tables-1">6.17.3.1 Weak hash tables</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dweak_002dkey_002dhash_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-weak-key-hash-table</strong> <var class="def-var-arguments">[size]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dweak_002dkey_002dhash_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dweak_002dvalue_002dhash_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-weak-value-hash-table</strong> <var class="def-var-arguments">[size]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dweak_002dvalue_002dhash_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002ddoubly_002dweak_002dhash_002dtable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-doubly-weak-hash-table</strong> <var class="def-var-arguments">[size]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ddoubly_002dweak_002dhash_002dtable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fweak_005fkey_005fhash_005ftable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_weak_key_hash_table</strong> <var class="def-var-arguments">(size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fweak_005fkey_005fhash_005ftable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fweak_005fvalue_005fhash_005ftable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_weak_value_hash_table</strong> <var class="def-var-arguments">(size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fweak_005fvalue_005fhash_005ftable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fdoubly_005fweak_005fhash_005ftable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_doubly_weak_hash_table</strong> <var class="def-var-arguments">(size)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fdoubly_005fweak_005fhash_005ftable"> ¶</a></span></dt>
<dd><p>Return a weak hash table with <var class="var">size</var> buckets. As with any
hash table, choosing a good size for the table requires some
caution.
</p>
<p>You can modify weak hash tables in exactly the same way you would modify
regular hash tables, with the exception of the routines that act on
handles.  Weak tables have a different implementation behind the scenes
that doesn’t have handles.  see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">Hash Tables</a>, for more on
<code class="code">hashq-ref</code> et al.
</p></dd></dl>

<p>Note that in a weak-key hash table, the reference to the value is
strong.  This means that if the value references the key, even
indirectly, the key will never be collected, which can lead to a memory
leak.  The reverse is true for weak value tables.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-weak_002dkey_002dhash_002dtable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-key-hash-table?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dkey_002dhash_002dtable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-weak_002dvalue_002dhash_002dtable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-value-hash-table?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dvalue_002dhash_002dtable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-doubly_002dweak_002dhash_002dtable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">doubly-weak-hash-table?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-doubly_002dweak_002dhash_002dtable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fkey_005fhash_005ftable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_key_hash_table_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fkey_005fhash_005ftable_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fvalue_005fhash_005ftable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_value_hash_table_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fvalue_005fhash_005ftable_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdoubly_005fweak_005fhash_005ftable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_doubly_weak_hash_table_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdoubly_005fweak_005fhash_005ftable_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is the specified weak hash
table. Note that a doubly weak hash table is neither a weak key
nor a weak value hash table.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Weak-vectors">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-hash-tables" accesskey="p" rel="prev">Weak hash tables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References" accesskey="u" rel="up">Weak References</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Weak-vectors-1">6.17.3.2 Weak vectors</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dweak_002dvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-weak-vector</strong> <var class="def-var-arguments">size [fill]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dweak_002dvector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fweak_005fvector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_weak_vector</strong> <var class="def-var-arguments">(size, fill)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fweak_005fvector"> ¶</a></span></dt>
<dd><p>Return a weak vector with <var class="var">size</var> elements. If the optional
argument <var class="var">fill</var> is given, all entries in the vector will be
set to <var class="var">fill</var>. The default value for <var class="var">fill</var> is the
empty list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-weak_002dvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-vector</strong> <var class="def-var-arguments">elem …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dvector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003eweak_002dvector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;weak-vector</strong> <var class="def-var-arguments">l</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003eweak_002dvector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fvector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_vector</strong> <var class="def-var-arguments">(l)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fvector"> ¶</a></span></dt>
<dd><p>Construct a weak vector from a list: <code class="code">weak-vector</code> uses
the list of its arguments while <code class="code">list-&gt;weak-vector</code> uses
its only argument <var class="var">l</var> (a list) to construct a weak vector
the same way <code class="code">list-&gt;vector</code> would.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-weak_002dvector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dvector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fvector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fvector_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a weak vector.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-weak_002dvector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-vector-ref</strong> <var class="def-var-arguments">wvect k</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dvector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fvector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_vector_ref</strong> <var class="def-var-arguments">(wvect, k)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fvector_005fref"> ¶</a></span></dt>
<dd><p>Return the <var class="var">k</var>th element of the weak vector <var class="var">wvect</var>, or
<code class="code">#f</code> if that element has been collected.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-weak_002dvector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">weak-vector-set!</strong> <var class="def-var-arguments">wvect k elt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-weak_002dvector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fweak_005fvector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_weak_vector_set_x</strong> <var class="def-var-arguments">(wvect, k, elt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fweak_005fvector_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the <var class="var">k</var>th element of the weak vector <var class="var">wvect</var> to <var class="var">elt</var>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Guardians">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Weak-References" accesskey="p" rel="prev">Weak References</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="u" rel="up">Memory Management and Garbage Collection</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Guardians-1">6.17.4 Guardians</h4>

<p>Guardians provide a way to be notified about objects that would
otherwise be collected as garbage.  Guarding them prevents the objects
from being collected and cleanup actions can be performed on them, for
example.
</p>
<p>See R. Kent Dybvig, Carl Bruggeman, and David Eby (1993) "Guardians in
a Generation-Based Garbage Collector".  ACM SIGPLAN Conference on
Programming Language Design and Implementation, June 1993.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dguardian"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-guardian</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dguardian"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fguardian"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_guardian</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fguardian"> ¶</a></span></dt>
<dd><p>Create a new guardian.  A guardian protects a set of objects from
garbage collection, allowing a program to apply cleanup or other
actions.
</p>
<p><code class="code">make-guardian</code> returns a procedure representing the guardian.
Calling the guardian procedure with an argument adds the argument to
the guardian’s set of protected objects.  Calling the guardian
procedure without an argument returns one of the protected objects
which are ready for garbage collection, or <code class="code">#f</code> if no such object
is available.  Objects which are returned in this way are removed from
the guardian.
</p>
<p>You can put a single object into a guardian more than once and you can
put a single object into more than one guardian.  The object will then
be returned multiple times by the guardian procedures.
</p>
<p>An object is eligible to be returned from a guardian when it is no
longer referenced from outside any guardian.
</p>
<p>There is no guarantee about the order in which objects are returned
from a guardian.  If you want to impose an order on finalization
actions, for example, you can do that by keeping objects alive in some
global data structure until they are no longer needed for finalizing
other objects.
</p>
<p>Being an element in a weak vector, a key in a hash table with weak
keys, or a value in a hash table with weak values does not prevent an
object from being returned by a guardian.  But as long as an object
can be returned from a guardian it will not be removed from such a
weak vector or hash table.  In other words, a weak link does not
prevent an object from being considered collectable, but being inside
a guardian prevents a weak link from being broken.
</p>
<p>A key in a weak key hash table can be thought of as having a strong
reference to its associated value as long as the key is accessible.
Consequently, when the key is only accessible from within a guardian,
the reference from the key to the value is also considered to be
coming from within a guardian.  Thus, if there is no other reference
to the value, it is eligible to be returned from a guardian.
</p></dd></dl>



<hr>
</div>
</div>
<div class="section-level-extent" id="Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="n" rel="next">Foreign Function Interface</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Management" accesskey="p" rel="prev">Memory Management and Garbage Collection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Modules-1">6.18 Modules</h3>
<a class="index-entry-id" id="index-modules"></a>

<p>When programs become large, naming conflicts can occur when a function
or global variable defined in one file has the same name as a function
or global variable in another file.  Even just a <em class="emph">similarity</em>
between function names can cause hard-to-find bugs, since a programmer
might type the wrong function name.
</p>
<p>The approach used to tackle this problem is called <em class="emph">information
encapsulation</em>, which consists of packaging functional units into a
given name space that is clearly separated from other name spaces.
<a class="index-entry-id" id="index-encapsulation"></a>
<a class="index-entry-id" id="index-information-encapsulation"></a>
<a class="index-entry-id" id="index-name-space"></a>
</p>
<p>The language features that allow this are usually called <em class="emph">the
module system</em> because programs are broken up into modules that are
compiled separately (or loaded separately in an interpreter).
</p>
<p>Older languages, like C, have limited support for name space
manipulation and protection.  In C a variable or function is public by
default, and can be made local to a module with the <code class="code">static</code>
keyword.  But you cannot reference public variables and functions from
another module with different names.
</p>
<p>More advanced module systems have become a common feature in recently
designed languages: ML, Python, Perl, and Modula 3 all allow the
<em class="emph">renaming</em> of objects from a foreign module, so they will not
clutter the global name space.
<a class="index-entry-id" id="index-name-space-_002d-private"></a>
</p>
<p>In addition, Guile offers variables as first-class objects.  They can
be used for interacting with the module system.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#General-Information-about-Modules" accesskey="1">General Information about Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules" accesskey="2">Using Guile Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules" accesskey="3">Creating Guile Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System" accesskey="4">Modules and the File System</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References" accesskey="5">R6RS Version References</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Libraries" accesskey="6">R6RS Libraries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Variables" accesskey="7">Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Module-System-Reflection" accesskey="8">Module System Reflection</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Declarative-Modules" accesskey="9">Declarative Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Modules-from-C">Accessing Modules from C</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#provide-and-require">provide and require</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Environments">Environments</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="General-Information-about-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules" accesskey="n" rel="next">Using Guile Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="General-Information-about-Modules-1">6.18.1 General Information about Modules</h4>

<p>A Guile module can be thought of as a collection of named procedures,
variables and macros.  More precisely, it is a set of <em class="dfn">bindings</em>
of symbols (names) to Scheme objects.
</p>
<p>Within a module, all bindings are visible.  Certain bindings
can be declared <em class="dfn">public</em>, in which case they are added to the
module’s so-called <em class="dfn">export list</em>; this set of public bindings is
called the module’s <em class="dfn">public interface</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules">Creating Guile Modules</a>).
</p>
<p>A client module <em class="dfn">uses</em> a providing module’s bindings by either
accessing the providing module’s public interface, or by building a
custom interface (and then accessing that).  In a custom interface, the
client module can <em class="dfn">select</em> which bindings to access and can also
algorithmically <em class="dfn">rename</em> bindings.  In contrast, when using the
providing module’s public interface, the entire export list is available
without renaming (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules">Using Guile Modules</a>).
</p>
<p>All Guile modules have a unique <em class="dfn">module name</em>, for example
<code class="code">(ice-9 popen)</code> or <code class="code">(srfi srfi-11)</code>.  Module names are lists
of one or more symbols.
</p>
<p>When Guile goes to use an interface from a module, for example
<code class="code">(ice-9 popen)</code>, Guile first looks to see if it has loaded
<code class="code">(ice-9 popen)</code> for any reason.  If the module has not been loaded
yet, Guile searches a <em class="dfn">load path</em> for a file that might define it,
and loads that file.
</p>
<p>The following subsections go into more detail on using, creating,
installing, and otherwise manipulating modules and the module system.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Using-Guile-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules" accesskey="n" rel="next">Creating Guile Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#General-Information-about-Modules" accesskey="p" rel="prev">General Information about Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Using-Guile-Modules-1">6.18.2 Using Guile Modules</h4>

<p>To use a Guile module is to access either its public interface or a
custom interface (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#General-Information-about-Modules">General Information about Modules</a>).  Both
types of access are handled by the syntactic form <code class="code">use-modules</code>,
which accepts one or more interface specifications and, upon evaluation,
arranges for those interfaces to be available to the current module.
This process may include locating and loading code for a given module if
that code has not yet been loaded, following <code class="code">%load-path</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System">Modules and the File System</a>).
</p>
<p>An <em class="dfn">interface specification</em> has one of two forms.  The first
variation is simply to name the module, in which case its public
interface is the one accessed.  For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 popen))
</pre></div>

<p>Here, the interface specification is <code class="code">(ice-9 popen)</code>, and the
result is that the current module now has access to <code class="code">open-pipe</code>,
<code class="code">close-pipe</code>, <code class="code">open-input-pipe</code>, and so on (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Pipes">Pipes</a>).
</p>
<p>Note in the previous example that if the current module had already
defined <code class="code">open-pipe</code>, that definition would be overwritten by the
definition in <code class="code">(ice-9 popen)</code>.  For this reason (and others), there
is a second variation of interface specification that not only names a
module to be accessed, but also selects bindings from it and renames
them to suit the current module’s needs.  For example:
</p>
<a class="index-entry-id" id="index-binding-renamer"></a>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules ((ice-9 popen)
              #:select ((open-pipe . pipe-open) close-pipe)
              #:renamer (symbol-prefix-proc 'unixy:)))
</pre></div>

<p>or more simply:
</p>
<a class="index-entry-id" id="index-prefix"></a>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules ((ice-9 popen)
              #:select ((open-pipe . pipe-open) close-pipe)
              #:prefix unixy:))
</pre></div>

<p>Here, the interface specification is more complex than before, and the
result is that a custom interface with only two bindings is created and
subsequently accessed by the current module.  The mapping of old to new
names is as follows:
</p>
<div class="example smallexample">
<pre class="example-preformatted">(ice-9 popen) sees:             current module sees:
open-pipe                       unixy:pipe-open
close-pipe                      unixy:close-pipe
</pre></div>

<p>This example also shows how to use the convenience procedure
<code class="code">symbol-prefix-proc</code>.
</p>
<p>You can also directly refer to bindings in a module by using the
<code class="code">@</code> syntax.  For example, instead of using the
<code class="code">use-modules</code> statement from above and writing
<code class="code">unixy:pipe-open</code> to refer to the <code class="code">pipe-open</code> from the
<code class="code">(ice-9 popen)</code>, you could also write <code class="code">(@ (ice-9 popen)
open-pipe)</code>.  Thus an alternative to the complete <code class="code">use-modules</code>
statement would be
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define unixy:pipe-open (@ (ice-9 popen) open-pipe))
(define unixy:close-pipe (@ (ice-9 popen) close-pipe))
</pre></div>

<p>There is also <code class="code">@@</code>, which can be used like <code class="code">@</code>, but does
not check whether the variable that is being accessed is actually
exported.  Thus, <code class="code">@@</code> can be thought of as the impolite version
of <code class="code">@</code> and should only be used as a last resort or for
debugging, for example.
</p>
<p>Note that just as with a <code class="code">use-modules</code> statement, any module that
has not yet been loaded will be loaded when referenced by a <code class="code">@</code> or
<code class="code">@@</code> form.
</p>
<p>You can also use the <code class="code">@</code> and <code class="code">@@</code> syntaxes as the target
of a <code class="code">set!</code> when the binding refers to a variable.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-symbol_002dprefix_002dproc"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symbol-prefix-proc</strong> <var class="def-var-arguments">prefix-sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symbol_002dprefix_002dproc"> ¶</a></span></dt>
<dd><p>Return a procedure that prefixes its arg (a symbol) with
<var class="var">prefix-sym</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-use_002dmodules"><span class="category-def">syntax: </span><span><strong class="def-name">use-modules</strong> <var class="def-var-arguments">spec …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-use_002dmodules"> ¶</a></span></dt>
<dd><p>Resolve each interface specification <var class="var">spec</var> into an interface and
arrange for these to be accessible by the current module.  The return
value is unspecified.
</p>
<p><var class="var">spec</var> can be a list of symbols, in which case it names a module
whose public interface is found and used.
</p>
<p><var class="var">spec</var> can also be of the form:
</p>
<a class="index-entry-id" id="index-binding-renamer-1"></a>
<div class="example lisp">
<pre class="lisp-preformatted"> (MODULE-NAME [#:select SELECTION]
              [#:prefix PREFIX]
              [#:renamer RENAMER])
</pre></div>

<p>in which case a custom interface is newly created and used.
<var class="var">module-name</var> is a list of symbols, as above; <var class="var">selection</var> is a
list of selection-specs; <var class="var">prefix</var> is a symbol that is prepended to
imported names; and <var class="var">renamer</var> is a procedure that takes a symbol and
returns its new name.  A selection-spec is either a symbol or a pair of
symbols <code class="code">(ORIG . SEEN)</code>, where <var class="var">orig</var> is the name in the used
module and <var class="var">seen</var> is the name in the using module.  Note that
<var class="var">seen</var> is also modified by <var class="var">prefix</var> and <var class="var">renamer</var>.
</p>
<p>The <code class="code">#:select</code>, <code class="code">#:prefix</code>, and <code class="code">#:renamer</code> clauses are
optional.  If all are omitted, the returned interface has no bindings.
If the <code class="code">#:select</code> clause is omitted, <var class="var">prefix</var> and <var class="var">renamer</var>
operate on the used module’s public interface.
</p>
<p>In addition to the above, <var class="var">spec</var> can also include a <code class="code">#:version</code> 
clause, of the form:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"> #:version VERSION-SPEC
</pre></div>

<p>where <var class="var">version-spec</var> is an R6RS-compatible version reference.  An
error will be signaled in the case in which a module with the same name
has already been loaded, if that module specifies a version and that
version is not compatible with <var class="var">version-spec</var>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References">R6RS Version References</a>, for more on version references.
</p>
<p>If the module name is not resolvable, <code class="code">use-modules</code> will signal an
error.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0040"><span class="category-def">syntax: </span><span><strong class="def-name">@</strong> <var class="def-var-arguments">module-name binding-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0040"> ¶</a></span></dt>
<dd><p>Refer to the binding named <var class="var">binding-name</var> in module
<var class="var">module-name</var>.  The binding must have been exported by the module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0040_0040"><span class="category-def">syntax: </span><span><strong class="def-name">@@</strong> <var class="def-var-arguments">module-name binding-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0040_0040"> ¶</a></span></dt>
<dd><p>Refer to the binding named <var class="var">binding-name</var> in module
<var class="var">module-name</var>.  The binding must not have been exported by the
module.  This syntax is only intended for debugging purposes or as a
last resort.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Declarative-Modules">Declarative Modules</a>, for some limitations on the
use of <code class="code">@@</code>.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Creating-Guile-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System" accesskey="n" rel="next">Modules and the File System</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules" accesskey="p" rel="prev">Using Guile Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Creating-Guile-Modules-1">6.18.3 Creating Guile Modules</h4>

<p>When you want to create your own modules, you have to take the following
steps:
</p>
<ul class="itemize mark-bullet">
<li>Create a Scheme source file and add all variables and procedures you wish
to export, or which are required by the exported procedures.

</li><li>Add a <code class="code">define-module</code> form at the beginning.

</li><li>Export all bindings which should be in the public interface, either
by using <code class="code">define-public</code> or <code class="code">export</code> (both documented below).
</li></ul>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002dmodule"><span class="category-def">syntax: </span><span><strong class="def-name">define-module</strong> <var class="def-var-arguments">module-name option …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dmodule"> ¶</a></span></dt>
<dd><p><var class="var">module-name</var> is a list of one or more symbols.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-module (ice-9 popen))
</pre></div>

<p><code class="code">define-module</code> makes this module available to Guile programs under
the given <var class="var">module-name</var>.
</p>
<p><var class="var">option</var> … are keyword/value pairs which specify more about the
defined module.  The recognized options and their meaning are shown in
the following table.
</p>
<dl class="table">
<dt><code class="code">#:use-module <var class="var">interface-specification</var></code></dt>
<dd><p>Equivalent to a <code class="code">(use-modules <var class="var">interface-specification</var>)</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Modules">Using Guile Modules</a>).
</p>
</dd>
<dt id="index-autoload"><span><code class="code">#:autoload <var class="var">module</var> <var class="var">symbol-list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-autoload"> ¶</a></span></dt>
<dd><p>Load <var class="var">module</var> when any of <var class="var">symbol-list</var> are accessed.  For
example,
</p>
<div class="example">
<pre class="example-preformatted">(define-module (my mod)
  #:autoload (srfi srfi-1) (partition delete-duplicates))
...
(when something
  (set! foo (delete-duplicates ...)))
</pre></div>

<p>When a module is autoloaded, only the bindings in <var class="var">symbol-list</var>
become available<a class="footnote" id="DOCF20" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT20"><sup>20</sup></a>.
</p>
<p>An autoload is a good way to put off loading a big module until it’s
really needed, for instance for faster startup or if it will only be
needed in certain circumstances.
</p>
</dd>
<dt id="index-export"><span><code class="code">#:export <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-export"> ¶</a></span></dt>
<dd><p>Export all identifiers in <var class="var">list</var> which must be a list of symbols
or pairs of symbols.  This is equivalent to <code class="code">(export <var class="var">list</var>)</code> 
in the module body.
</p>
</dd>
<dt id="index-re_002dexport"><span><code class="code">#:re-export <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-re_002dexport"> ¶</a></span></dt>
<dd><p>Re-export all identifiers in <var class="var">list</var> which must be a list of
symbols or pairs of symbols.  The symbols in <var class="var">list</var> must be 
imported by the current module from other modules.  This is equivalent
to <code class="code">re-export</code> below.
</p>
</dd>
<dt id="index-replace"><span><code class="code">#:replace <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-replace"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-replacing-binding"></a>
<a class="index-entry-id" id="index-overriding-binding"></a>
<a class="index-entry-id" id="index-duplicate-binding"></a>
<p>Export all identifiers in <var class="var">list</var> (a list of symbols or pairs of
symbols) and mark them as <em class="dfn">replacing bindings</em>.  In the module 
user’s name space, this will have the effect of replacing any binding 
with the same name that is not also “replacing”.  Normally a 
replacement results in an “override” warning message, 
<code class="code">#:replace</code> avoids that.
</p>
<p>In general, a module that exports a binding for which the <code class="code">(guile)</code>
module already has a definition should use <code class="code">#:replace</code> instead of
<code class="code">#:export</code>.  <code class="code">#:replace</code>, in a sense, lets Guile know that the
module <em class="emph">purposefully</em> replaces a core binding.  It is important to
note, however, that this binding replacement is confined to the name
space of the module user.  In other words, the value of the core binding
in question remains unchanged for other modules.
</p>
<p>Note that although it is often a good idea for the replaced binding to
remain compatible with a binding in <code class="code">(guile)</code>, to avoid surprising
the user, sometimes the bindings will be incompatible.  For example,
SRFI-19 exports its own version of <code class="code">current-time</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time">SRFI-19 Time</a>) which is not compatible with the core <code class="code">current-time</code>
function (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>).  Guile assumes that a user importing a module
knows what she is doing, and uses <code class="code">#:replace</code> for this binding
rather than <code class="code">#:export</code>.
</p>
<p>A <code class="code">#:replace</code> clause is equivalent to <code class="code">(export! <var class="var">list</var>)</code>
in the module body.
</p>
<p>The <code class="code">#:duplicates</code> (see below) provides fine-grain control about
duplicate binding handling on the module-user side.
</p>
</dd>
<dt id="index-re_002dexport_002dand_002dreplace"><span><code class="code">#:re-export-and-replace <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-re_002dexport_002dand_002dreplace"> ¶</a></span></dt>
<dd><p>Like <code class="code">#:re-export</code>, but also marking the bindings as replacements
in the sense of <code class="code">#:replace</code>.
</p>
</dd>
<dt id="index-module-version"><span><code class="code">#:version <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module-version"> ¶</a></span></dt>
<dd><p>Specify a version for the module in the form of <var class="var">list</var>, a list of
zero or more exact, nonnegative integers.  The corresponding 
<code class="code">#:version</code> option in the <code class="code">use-modules</code> form allows callers
to restrict the value of this option in various ways.
</p>
</dd>
<dt id="index-duplicate-binding-handlers"><span><code class="code">#:duplicates <var class="var">list</var></code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-duplicate-binding-handlers"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-duplicate-binding-1"></a>
<a class="index-entry-id" id="index-overriding-binding-1"></a>
<p>Tell Guile to handle duplicate bindings for the bindings imported by
the current module according to the policy defined by <var class="var">list</var>, a
list of symbols.  <var class="var">list</var> must contain symbols representing a
duplicate binding handling policy chosen among the following:
</p>
<dl class="table">
<dt><code class="code">check</code></dt>
<dd><p>Raises an error when a binding is imported from more than one place.
</p></dd>
<dt><code class="code">warn</code></dt>
<dd><p>Issue a warning when a binding is imported from more than one place
and leave the responsibility of actually handling the duplication to
the next duplicate binding handler.
</p></dd>
<dt><code class="code">replace</code></dt>
<dd><p>When a new binding is imported that has the same name as a previously
imported binding, then do the following:
</p>
<ol class="enumerate">
<li> <a class="index-entry-id" id="index-replacing-binding-1"></a>
If the old binding was said to be <em class="dfn">replacing</em> (via the
<code class="code">#:replace</code> option above) and the new binding is not replacing,
the keep the old binding.
</li><li> If the old binding was not said to be replacing and the new binding is
replacing, then replace the old binding with the new one.
</li><li> If neither the old nor the new binding is replacing, then keep the old
one.
</li></ol>

</dd>
<dt><code class="code">warn-override-core</code></dt>
<dd><p>Issue a warning when a core binding is being overwritten and actually
override the core binding with the new one.
</p></dd>
<dt><code class="code">first</code></dt>
<dd><p>In case of duplicate bindings, the firstly imported binding is always
the one which is kept.
</p></dd>
<dt><code class="code">last</code></dt>
<dd><p>In case of duplicate bindings, the lastly imported binding is always
the one which is kept.
</p></dd>
<dt><code class="code">noop</code></dt>
<dd><p>In case of duplicate bindings, leave the responsibility to the next
duplicate handler.
</p></dd>
</dl>

<p>If <var class="var">list</var> contains more than one symbol, then the duplicate
binding handlers which appear first will be used first when resolving
a duplicate binding situation.  As mentioned above, some resolution
policies may explicitly leave the responsibility of handling the
duplication to the next handler in <var class="var">list</var>.
</p>
<p>If GOOPS has been loaded before the <code class="code">#:duplicates</code> clause is
processed, there are additional strategies available for dealing with
generic functions.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Merging-Generics">Merging Generics</a>, for more information.
</p>
<a class="index-entry-id" id="index-default_002dduplicate_002dbinding_002dhandler"></a>
<p>The default duplicate binding resolution policy is given by the
<code class="code">default-duplicate-binding-handler</code> procedure, and is
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(replace warn-override-core warn last)
</pre></div>

</dd>
<dt id="index-pure-module"><span><code class="code">#:pure</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pure-module"> ¶</a></span></dt>
<dd><p>Create a <em class="dfn">pure</em> module, that is a module which does not contain any
of the standard procedure bindings except for the syntax forms.  This is
useful if you want to create <em class="dfn">safe</em> modules, that is modules which
do not know anything about dangerous procedures.
</p></dd>
</dl>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-export-1"><span class="category-def">syntax: </span><span><strong class="def-name">export</strong> <var class="def-var-arguments">variable …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-export-1"> ¶</a></span></dt>
<dd><p>Add all <var class="var">variable</var>s (which must be symbols or pairs of symbols) to 
the list of exported bindings of the current module.  If <var class="var">variable</var>
is a pair, its <code class="code">car</code> gives the name of the variable as seen by the
current module and its <code class="code">cdr</code> specifies a name for the binding in
the current module’s public interface.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002dpublic"><span class="category-def">syntax: </span><span><strong class="def-name">define-public</strong> <var class="def-var-arguments">…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dpublic"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">(begin (define foo ...) (export foo))</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-re_002dexport-1"><span class="category-def">syntax: </span><span><strong class="def-name">re-export</strong> <var class="def-var-arguments">variable …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-re_002dexport-1"> ¶</a></span></dt>
<dd><p>Add all <var class="var">variable</var>s (which must be symbols or pairs of symbols) to 
the list of re-exported bindings of the current module.  Pairs of 
symbols are handled as in <code class="code">export</code>.  Re-exported bindings must be
imported by the current module from some other module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-export_0021"><span class="category-def">syntax: </span><span><strong class="def-name">export!</strong> <var class="def-var-arguments">variable …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-export_0021"> ¶</a></span></dt>
<dd><p>Like <code class="code">export</code>, but marking the exported variables as replacing.
Using a module with replacing bindings will cause any existing bindings
to be replaced without issuing any warnings.  See the discussion of
<code class="code">#:replace</code> above.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Modules-and-the-File-System">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References" accesskey="n" rel="next">R6RS Version References</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules" accesskey="p" rel="prev">Creating Guile Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Modules-and-the-File-System-1">6.18.4 Modules and the File System</h4>

<p>Typical programs only use a small subset of modules installed on a Guile
system.  In order to keep startup time down, Guile only loads modules
when a program uses them, on demand.
</p>
<p>When a program evaluates <code class="code">(use-modules (ice-9 popen))</code>, and the
module is not loaded, Guile searches for a conventionally-named file
from in the <em class="dfn">load path</em>.
</p>
<p>In this case, loading <code class="code">(ice-9 popen)</code> will eventually cause Guile
to run <code class="code">(primitive-load-path "ice-9/popen")</code>.
<code class="code">primitive-load-path</code> will search for a file <samp class="file">ice-9/popen</samp> in
the <code class="code">%load-path</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>).  For each directory in
<code class="code">%load-path</code>, Guile will try to find the file name, concatenated
with the extensions from <code class="code">%load-extensions</code>.  By default, this will
cause Guile to <code class="code">stat</code> <samp class="file">ice-9/popen.scm</samp>, and then
<samp class="file">ice-9/popen</samp>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Load-Paths">Load Paths</a>, for more on
<code class="code">primitive-load-path</code>.
</p>
<p>If a corresponding compiled <samp class="file">.go</samp> file is found in the
<code class="code">%load-compiled-path</code> or in the fallback path, and is as fresh as
the source file, it will be loaded instead of the source file.  If no
compiled file is found, Guile may try to compile the source file and
cache away the resulting <samp class="file">.go</samp> file.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for more
on compilation.
</p>
<p>Once Guile finds a suitable source or compiled file is found, the file
will be loaded.  If, after loading the file, the module under
consideration is still not defined, Guile will signal an error.
</p>
<p>For more information on where and how to install Scheme modules,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Installing-Site-Packages">Installing Site Packages</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="R6RS-Version-References">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Libraries" accesskey="n" rel="next">R6RS Libraries</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules-and-the-File-System" accesskey="p" rel="prev">Modules and the File System</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="R6RS-Version-References-1">6.18.5 R6RS Version References</h4>

<p>Guile’s module system includes support for locating modules based on
a declared version specifier of the same form as the one described in
R6RS (see <a data-manual="r6rs" href="https://www.gnu.org/software/guile/manual/r6rs.html#Library-form">R6RS Library Form</a> in <cite class="cite">The Revised^6 
Report on the Algorithmic Language Scheme</cite>).  By using the 
<code class="code">#:version</code> keyword in a <code class="code">define-module</code> form, a module may
specify a version as a list of zero or more exact, nonnegative integers.
</p>
<p>This version can then be used to locate the module during the module
search process.  Client modules and callers of the <code class="code">use-modules</code> 
function may specify constraints on the versions of target modules by
providing a <em class="dfn">version reference</em>, which has one of the following
forms:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"> (<var class="var">sub-version-reference</var> ...)
 (and <var class="var">version-reference</var> ...)
 (or <var class="var">version-reference</var> ...)
 (not <var class="var">version-reference</var>)
</pre></div>

<p>in which <var class="var">sub-version-reference</var> is in turn one of:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"> (<var class="var">sub-version</var>)
 (&gt;= <var class="var">sub-version</var>)
 (&lt;= <var class="var">sub-version</var>)
 (and <var class="var">sub-version-reference</var> ...)
 (or <var class="var">sub-version-reference</var> ...)
 (not <var class="var">sub-version-reference</var>)
</pre></div>

<p>in which <var class="var">sub-version</var> is an exact, nonnegative integer as above. A
version reference matches a declared module version if each element of
the version reference matches a corresponding element of the module 
version, according to the following rules:
</p>
<ul class="itemize mark-bullet">
<li>The <code class="code">and</code> sub-form matches a version or version element if every 
element in the tail of the sub-form matches the specified version or 
version element.

</li><li>The <code class="code">or</code> sub-form matches a version or version element if any 
element in the tail of the sub-form matches the specified version or
version element.

</li><li>The <code class="code">not</code> sub-form matches a version or version element if the tail
of the sub-form does not match the version or version element.  

</li><li>The <code class="code">&gt;=</code> sub-form matches a version element if the element is 
greater than or equal to the <var class="var">sub-version</var> in the tail of the 
sub-form.

</li><li>The <code class="code">&lt;=</code> sub-form matches a version element if the version is less
than or equal to the <var class="var">sub-version</var> in the tail of the sub-form.

</li><li>A <var class="var">sub-version</var> matches a version element if one is <var class="var">eqv?</var> to
the other.
</li></ul>

<p>For example, a module declared as:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"> (define-module (mylib mymodule) #:version (1 2 0))
</pre></div>

<p>would be successfully loaded by any of the following <code class="code">use-modules</code>
expressions:
</p>
<div class="example lisp">
<pre class="lisp-preformatted"> (use-modules ((mylib mymodule) #:version (1 2 (&gt;= 0))))
 (use-modules ((mylib mymodule) #:version (or (1 2 0) (1 2 1))))
 (use-modules ((mylib mymodule) #:version ((and (&gt;= 1) (not 2)) 2 0)))
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="R6RS-Libraries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Variables" accesskey="n" rel="next">Variables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References" accesskey="p" rel="prev">R6RS Version References</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="R6RS-Libraries-1">6.18.6 R6RS Libraries</h4>

<p>In addition to the API described in the previous sections, you also
have the option to create modules using the portable <code class="code">library</code> form
described in R6RS (see <a data-manual="r6rs" href="https://www.gnu.org/software/guile/manual/r6rs.html#Library-form">R6RS Library Form</a> in <cite class="cite">The
Revised^6 Report on the Algorithmic Language Scheme</cite>), and to import 
libraries created in this format by other programmers.  Guile’s R6RS 
library implementation takes advantage of the flexibility built into the
module system by expanding the R6RS library form into a corresponding 
Guile <code class="code">define-module</code> form that specifies equivalent import and 
export requirements and includes the same body expressions.  The library
expression:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  (library (mylib (1 2))
    (export mybinding)
    (import (otherlib (3))))
</pre></div>

<p>is equivalent to the module definition:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  (define-module (mylib)
    #:version (1 2)
    #:use-module ((otherlib) #:version (3))
    #:export (mybinding))
</pre></div>

<p>Central to the mechanics of R6RS libraries is the concept of import
and export <em class="dfn">levels</em>, which control the visibility of bindings at
various phases of a library’s lifecycle — macros necessary to 
expand forms in the library’s body need to be available at expand 
time; variables used in the body of a procedure exported by the
library must be available at runtime.  R6RS specifies the optional
<code class="code">for</code> sub-form of an <em class="emph">import set</em> specification (see below)
as a mechanism by which a library author can indicate that a
particular library import should take place at a particular phase 
with respect to the lifecycle of the importing library.  
</p>
<p>Guile’s library implementation uses a technique called 
<em class="dfn">implicit phasing</em> (first described by Abdulaziz Ghuloum and R. 
Kent Dybvig), which allows the expander and compiler to automatically 
determine the necessary visibility of a binding imported from another 
library.  As such, the <code class="code">for</code> sub-form described below is ignored by
Guile (but may be required by Schemes in which phasing is explicit).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-library"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">library</strong> <var class="def-var-arguments">name (export export-spec ...) (import import-spec ...) body ...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-library"> ¶</a></span></dt>
<dd><p>Defines a new library with the specified name, exports, and imports,
and evaluates the specified body expressions in this library’s 
environment.
</p>
<p>The library <var class="var">name</var> is a non-empty list of identifiers, optionally
ending with a version specification of the form described above
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Creating-Guile-Modules">Creating Guile Modules</a>).
</p>
<p>Each <var class="var">export-spec</var> is the name of a variable defined or imported
by the library, or must take the form 
<code class="code">(rename (internal-name external-name) ...)</code>, where the 
identifier <var class="var">internal-name</var> names a variable defined or imported 
by the library and <var class="var">external-name</var> is the name by which the
variable is seen by importing libraries.
</p>
<p>Each <var class="var">import-spec</var> must be either an <em class="dfn">import set</em> (see below)
or must be of the form <code class="code">(for import-set import-level ...)</code>, 
where each <var class="var">import-level</var> is one of:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  run
  expand
  (meta <var class="var">level</var>)
</pre></div>

<p>where <var class="var">level</var> is an integer.  Note that since Guile does not
require explicit phase specification, any <var class="var">import-set</var>s found 
inside of <code class="code">for</code> sub-forms will be “unwrapped” during 
expansion and processed as if they had been specified directly.
</p>
<p>Import sets in turn take one of the following forms:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  <var class="var">library-reference</var>
  (library <var class="var">library-reference</var>)
  (only <var class="var">import-set</var> <var class="var">identifier</var> ...)
  (except <var class="var">import-set</var> <var class="var">identifier</var> ...)
  (prefix <var class="var">import-set</var> <var class="var">identifier</var>)
  (rename <var class="var">import-set</var> (<var class="var">internal-identifier</var> <var class="var">external-identifier</var>) ...)
</pre></div>

<p>where <var class="var">library-reference</var> is a non-empty list of identifiers
ending with an optional version reference (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References">R6RS Version References</a>), and the other sub-forms have the following semantics,
defined recursively on nested <var class="var">import-set</var>s:
</p>
<ul class="itemize mark-bullet">
<li>The <code class="code">library</code> sub-form is used to specify libraries for import
whose names begin with the identifier “library.”

</li><li>The <code class="code">only</code> sub-form imports only the specified <var class="var">identifier</var>s
from the given <var class="var">import-set</var>.

</li><li>The <code class="code">except</code> sub-form imports all of the bindings exported by 
<var class="var">import-set</var> except for those that appear in the specified list
of <var class="var">identifier</var>s.

</li><li>The <code class="code">prefix</code> sub-form imports all of the bindings exported
by <var class="var">import-set</var>, first prefixing them with the specified
<var class="var">identifier</var>.

</li><li>The <code class="code">rename</code> sub-form imports all of the identifiers exported
by <var class="var">import-set</var>.  The binding for each <var class="var">internal-identifier</var>
among these identifiers is made visible to the importing library as
the corresponding <var class="var">external-identifier</var>; all other bindings are
imported using the names provided by <var class="var">import-set</var>.

</li></ul>

<p>Note that because Guile translates R6RS libraries into module 
definitions, an import specification may be used to declare a
dependency on a native Guile module — although doing so may make 
your libraries less portable to other Schemes.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-import-1"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">import</strong> <var class="def-var-arguments">import-spec ...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-import-1"> ¶</a></span></dt>
<dd><p>Import into the current environment the libraries specified by the
given import specifications, where each <var class="var">import-spec</var> takes the
same form as in the <code class="code">library</code> form described above.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Module-System-Reflection" accesskey="n" rel="next">Module System Reflection</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Libraries" accesskey="p" rel="prev">R6RS Libraries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Variables-1">6.18.7 Variables</h4>
<a class="index-entry-id" id="index-Variables"></a>

<p>Each module has its own hash table, sometimes known as an <em class="dfn">obarray</em>,
that maps the names defined in that module to their corresponding
variable objects.
</p>
<p>A variable is a box-like object that can hold any Scheme value.  It is
said to be <em class="dfn">undefined</em> if its box holds a special Scheme value that
denotes undefined-ness (which is different from all other Scheme values,
including for example <code class="code">#f</code>); otherwise the variable is
<em class="dfn">defined</em>.
</p>
<p>On its own, a variable object is anonymous.  A variable is said to be
<em class="dfn">bound</em> when it is associated with a name in some way, usually a
symbol in a module obarray.  When this happens, the name is said to be
bound to the variable, in that module.
</p>
<p>(That’s the theory, anyway.  In practice, defined-ness and bound-ness
sometimes get confused, because Lisp and Scheme implementations have
often conflated — or deliberately drawn no distinction between — a
name that is unbound and a name that is bound to a variable whose value
is undefined.  We will try to be clear about the difference and explain
any confusion where it is unavoidable.)
</p>
<p>Variables do not have a read syntax.  Most commonly they are created and
bound implicitly by <code class="code">define</code> expressions: a top-level <code class="code">define</code>
expression of the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define <var class="var">name</var> <var class="var">value</var>)
</pre></div>

<p>creates a variable with initial value <var class="var">value</var> and binds it to the
name <var class="var">name</var> in the current module.  But they can also be created
dynamically by calling one of the constructor procedures
<code class="code">make-variable</code> and <code class="code">make-undefined-variable</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dundefined_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-undefined-variable</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dundefined_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fundefined_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_undefined_variable</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fundefined_005fvariable"> ¶</a></span></dt>
<dd><p>Return a variable that is initially unbound.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-variable</strong> <var class="def-var-arguments">init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_variable</strong> <var class="def-var-arguments">(init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fvariable"> ¶</a></span></dt>
<dd><p>Return a variable initialized to value <var class="var">init</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-variable_002dbound_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">variable-bound?</strong> <var class="def-var-arguments">var</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_002dbound_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvariable_005fbound_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_variable_bound_p</strong> <var class="def-var-arguments">(var)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvariable_005fbound_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">var</var> is bound to a value, or <code class="code">#f</code>
otherwise.  Throws an error if <var class="var">var</var> is not a variable object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-variable_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">variable-ref</strong> <var class="def-var-arguments">var</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvariable_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_variable_ref</strong> <var class="def-var-arguments">(var)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvariable_005fref"> ¶</a></span></dt>
<dd><p>Dereference <var class="var">var</var> and return its value.
<var class="var">var</var> must be a variable object; see <code class="code">make-variable</code>
and <code class="code">make-undefined-variable</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-variable_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">variable-set!</strong> <var class="def-var-arguments">var val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvariable_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_variable_set_x</strong> <var class="def-var-arguments">(var, val)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvariable_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the value of the variable <var class="var">var</var> to <var class="var">val</var>.
<var class="var">var</var> must be a variable object, <var class="var">val</var> can be any
value. Return an unspecified value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-variable_002dunset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">variable-unset!</strong> <var class="def-var-arguments">var</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_002dunset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvariable_005funset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_variable_unset_x</strong> <var class="def-var-arguments">(var)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvariable_005funset_005fx"> ¶</a></span></dt>
<dd><p>Unset the value of the variable <var class="var">var</var>, leaving <var class="var">var</var> unbound.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-variable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">variable?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-variable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fvariable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_variable_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fvariable_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a variable object, else return
<code class="code">#f</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Module-System-Reflection">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Declarative-Modules" accesskey="n" rel="next">Declarative Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Variables" accesskey="p" rel="prev">Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Module-System-Reflection-1">6.18.8 Module System Reflection</h4>

<p>The previous sections have described a declarative view of the module
system.  You can also work with it programmatically by accessing and
modifying various parts of the Scheme objects that Guile uses to
implement the module system.
</p>
<p>At any time, there is a <em class="dfn">current module</em>.  This module is the one
where a top-level <code class="code">define</code> and similar syntax will add new
bindings.  You can find other module objects with <code class="code">resolve-module</code>,
for example.
</p>
<p>These module objects can be used as the second argument to <code class="code">eval</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-current_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-module</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dmodule"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005fmodule"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_module</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005fmodule"> ¶</a></span></dt>
<dd><p>Return the current module object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dcurrent_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-current-module</strong> <var class="def-var-arguments">module</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dcurrent_002dmodule"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fcurrent_005fmodule"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_current_module</strong> <var class="def-var-arguments">(module)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fcurrent_005fmodule"> ¶</a></span></dt>
<dd><p>Set the current module to <var class="var">module</var> and return
the previous current module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-save_002dmodule_002dexcursion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">save-module-excursion</strong> <var class="def-var-arguments">thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-save_002dmodule_002dexcursion"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var> within a <code class="code">dynamic-wind</code> such that the module that
is current at invocation time is restored when <var class="var">thunk</var>’s dynamic
extent is left (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).
</p>
<p>More precisely, if <var class="var">thunk</var> escapes non-locally, the current module
(at the time of escape) is saved, and the original current module (at
the time <var class="var">thunk</var>’s dynamic extent was last entered) is restored.  If
<var class="var">thunk</var>’s dynamic extent is re-entered, then the current module is
saved, and the previously saved inner module is set current again.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-resolve_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">resolve-module</strong> <var class="def-var-arguments">name [autoload=#t] [version=#f]                           [#:ensure=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-resolve_002dmodule"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fresolve_005fmodule"><span class="category-def">C Function: </span><span><strong class="def-name">scm_resolve_module</strong> <var class="def-var-arguments">(name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fresolve_005fmodule"> ¶</a></span></dt>
<dd><p>Find the module named <var class="var">name</var> and return it.  When it has not already
been defined and <var class="var">autoload</var> is true, try to auto-load it.  When it
can’t be found that way either, create an empty module if <var class="var">ensure</var>
is true, otherwise return <code class="code">#f</code>.  If <var class="var">version</var> is true, ensure
that the resulting module is compatible with the given version reference
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Version-References">R6RS Version References</a>).  The name is a list of symbols.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-resolve_002dinterface"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">resolve-interface</strong> <var class="def-var-arguments">name [#:select=#f]                           [#:hide=’()] [#:prefix=#f]                           [#:renamer=#f] [#:version=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-resolve_002dinterface"> ¶</a></span></dt>
<dd><p>Find the module named <var class="var">name</var> as with <code class="code">resolve-module</code> and
return its interface.  The interface of a module is also a module
object, but it contains only the exported bindings.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002duses"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-uses</strong> <var class="def-var-arguments">module</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002duses"> ¶</a></span></dt>
<dd><p>Return a list of the interfaces used by <var class="var">module</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002duse_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-use!</strong> <var class="def-var-arguments">module interface</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002duse_0021"> ¶</a></span></dt>
<dd><p>Add <var class="var">interface</var> to the front of the use-list of <var class="var">module</var>.  Both
arguments should be module objects, and <var class="var">interface</var> should very
likely be a module returned by <code class="code">resolve-interface</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-reload_002dmodule"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reload-module</strong> <var class="def-var-arguments">module</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reload_002dmodule"> ¶</a></span></dt>
<dd><p>Revisit the source file that corresponds to <var class="var">module</var>.  Raises an
error if no source file is associated with the given module.
</p></dd></dl>

<p>As mentioned in the previous section, modules contain a mapping between
identifiers (as symbols) and storage locations (as variables).  Guile
defines a number of procedures to allow access to this mapping.  If you
are programming in C, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Modules-from-C">Accessing Modules from C</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-module_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-variable</strong> <var class="def-var-arguments">module name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002dvariable"> ¶</a></span></dt>
<dd><p>Return the variable bound to <var class="var">name</var> (a symbol) in <var class="var">module</var>, or
<code class="code">#f</code> if <var class="var">name</var> is unbound.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002dadd_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-add!</strong> <var class="def-var-arguments">module name var</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002dadd_0021"> ¶</a></span></dt>
<dd><p>Define a new binding between <var class="var">name</var> (a symbol) and <var class="var">var</var> (a
variable) in <var class="var">module</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-ref</strong> <var class="def-var-arguments">module name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002dref"> ¶</a></span></dt>
<dd><p>Look up the value bound to <var class="var">name</var> in <var class="var">module</var>.  Like
<code class="code">module-variable</code>, but also does a <code class="code">variable-ref</code> on the
resulting variable, raising an error if <var class="var">name</var> is unbound.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002ddefine_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-define!</strong> <var class="def-var-arguments">module name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002ddefine_0021"> ¶</a></span></dt>
<dd><p>Locally bind <var class="var">name</var> to <var class="var">value</var> in <var class="var">module</var>.  If <var class="var">name</var>
was already locally bound in <var class="var">module</var>, i.e., defined locally and not
by an imported module, the value stored in the existing variable will be
updated.  Otherwise, a new variable will be added to the module, via
<code class="code">module-add!</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-module_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">module-set!</strong> <var class="def-var-arguments">module name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-module_002dset_0021"> ¶</a></span></dt>
<dd><p>Update the binding of <var class="var">name</var> in <var class="var">module</var> to <var class="var">value</var>, raising
an error if <var class="var">name</var> is not already bound in <var class="var">module</var>.
</p></dd></dl>

<p>There are many other reflective procedures available in the default
environment.  If you find yourself using one of them, please contact the
Guile developers so that we can commit to stability for that interface.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Declarative-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Modules-from-C" accesskey="n" rel="next">Accessing Modules from C</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Module-System-Reflection" accesskey="p" rel="prev">Module System Reflection</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Declarative-Modules-1">6.18.9 Declarative Modules</h4>

<p>The first-class access to modules and module variables described in the
previous subsection is very powerful and allows Guile users to build
many tools to dynamically learn things about their Guile systems.
However, as Scheme godparent Mathias Felleisen wrote in “On the
Expressive Power of Programming Languages”, a more expressive language
is necessarily harder to reason about.  There are transformations that
Guile’s compiler would like to make which can’t be done if every
top-level definition is subject to mutation at any time.
</p>
<p>Consider this module:
</p>
<div class="example">
<pre class="example-preformatted">(define-module (boxes)
  #:export (make-box box-ref box-set! box-swap!))

(define (make-box x) (list x))
(define (box-ref box) (car box))
(define (box-set! box x) (set-car! box x))
(define (box-swap! box x)
  (let ((y (box-ref box)))
    (box-set! box x)
    y))
</pre></div>

<p>Ideally you’d like for the <code class="code">box-ref</code> in <code class="code">box-swap!</code> to be
inlined to <code class="code">car</code>.  Guile’s compiler can do this, but only if it
knows that <code class="code">box-ref</code>’s definition is what it appears to be in the
text.  However, in the general case it could be that a programmer could
reach into the <code class="code">(boxes)</code> module at any time and change the value of
<code class="code">box-ref</code>.
</p>
<a class="index-entry-id" id="index-declarative"></a>
<a class="index-entry-id" id="index-modules_002c-declarative"></a>
<a class="index-entry-id" id="index-definitions_002c-declarative"></a>
<p>To allow Guile to reason about the values of top-levels from a module, a
module can be marked as <em class="dfn">declarative</em>.  This flag applies only to
the subset of top-level definitions that are themselves declarative:
those that are defined within the compilation unit, and not assigned
(<code class="code">set!</code>) or redefined within the compilation unit.
</p>
<p>To explicitly mark a module as being declarative, pass the
<code class="code">#:declarative?</code> keyword argument when declaring a module:
</p>
<div class="example">
<pre class="example-preformatted">(define-module (boxes)
  #:export (make-box box-ref box-set! box-swap!)
  #:declarative? #t)
</pre></div>

<p>By default, modules are compiled declaratively if the
<code class="code">user-modules-declarative?</code> parameter is true when the
module is compiled.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-user_002dmodules_002ddeclarative_003f"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">user-modules-declarative?</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-user_002dmodules_002ddeclarative_003f"> ¶</a></span></dt>
<dd><p>A boolean indicating whether definitions in modules created by
<code class="code">define-module</code> or implicitly as part of a compilation unit without
an explicit module can be treated as declarative.
</p></dd></dl>

<p>Because it’s usually what you want, the default value of
<code class="code">user-modules-declarative?</code> is <code class="code">#t</code>.
</p>
<h4 class="subsubheading" id="Should-I-Mark-My-Module-As-Declarative_003f">Should I Mark My Module As Declarative?</h4>

<p>In the vast majority of use cases, declarative modules are what you
want.  However, there are exceptions.
</p>
<p>Consider the <code class="code">(boxes)</code> module above.  Let’s say you want to be able
to go in and change the definition of <code class="code">box-set!</code> at run-time:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; (use-modules (boxes))
scheme@(guile-user)&gt; ,module boxes
scheme@(boxes)&gt; (define (box-set! x y) (set-car! x (pk y)))
</pre></div>

<p>However, considering that <code class="code">(boxes)</code> is a declarative module, it
could be that <code class="code">box-swap!</code> inlined the call to <code class="code">box-set!</code> – so
it may be that you are surprised if you call <code class="code">(box-swap! x y)</code> and
you don’t see the new definition being used.  (Note, however, that Guile
has no guarantees about what definitions its compiler will or will not
inline.)
</p>
<p>If you want to allow the definition of <code class="code">box-set!</code> to be changed and
to have all of its uses updated, then probably the best option is to
edit the module and reload the whole thing:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; ,reload (boxes)
</pre></div>

<p>The advantage of the reloading approach is that you maintain the
optimizations that declarative modules enable, while also being able to
live-update the code.  If the module keeps precious program state, those
definitions can be marked as <code class="code">define-once</code> to prevent reloads from
overwriting them.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Top-Level">Top Level Variable Definitions</a>, for more on <code class="code">define-once</code>.
Incidentally, <code class="code">define-once</code> also prevents declarative-definition
optimizations, so if there’s a limited subset of redefinable bindings,
<code class="code">define-once</code> could be an interesting tool to mark those
definitions as works-in-progress for interactive program development.
</p>
<p>To users, whether a module is declarative or not is mostly immaterial:
besides normal use via <code class="code">use-modules</code>, users can reference and
redefine public or private bindings programmatically or interactively.
The only difference is that changing a declarative definition may not
change all of its uses.  If this use-case is important to you, and if
reloading whole modules is insufficient, then you can mark all
definitions in a module as non-declarative by adding
<code class="code">#:declarative? #f</code> to the module definition.
</p>
<p>The default of whether modules are declarative or not can be controlled
via the <code class="code">(user-modules-declarative?)</code> parameter mentioned above,
but care should be taken to set this parameter when the modules are
compiled, e.g. via <code class="code">(eval-when (expand) (user-modules-declarative?
#f))</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When">Eval-when</a>.
</p>
<p>Alternately you can prevent declarative-definition optimizations by
compiling at the <code class="code">-O1</code> optimization level instead of the default
<code class="code">-O2</code>, or via explicitly passing <code class="code">-Ono-letrectify</code> to the
<code class="code">guild compile</code> invocation.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for more on
compiler options.
</p>
<a class="index-entry-id" id="index-inlining-1"></a>
<p>One final note.  Currently, definitions from declarative modules can
only be inlined within the module they are defined in, and within a
compilation unit.  This may change in the future to allow Guile to
inline imported declarative definitions as well (cross-module inlining).
To Guile, whether a definition is inlinable or not is a property of the
definition, not its use.  We hope to improve compiler tooling in the
future to allow the user to identify definitions that are out of date
when a declarative binding is redefined.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Accessing-Modules-from-C">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#provide-and-require" accesskey="n" rel="next">provide and require</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Declarative-Modules" accesskey="p" rel="prev">Declarative Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Accessing-Modules-from-C-1">6.18.10 Accessing Modules from C</h4>

<p>The last sections have described how modules are used in Scheme code,
which is the recommended way of creating and accessing modules.  You
can also work with modules from C, but it is more cumbersome.
</p>
<p>The following procedures are available.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fcall_005fwith_005fcurrent_005fmodule"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_call_with_current_module</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM (*<var class="var">func</var>)(void *), void *<var class="var">data</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fcall_005fwith_005fcurrent_005fmodule"> ¶</a></span></dt>
<dd><p>Call <var class="var">func</var> and make <var class="var">module</var> the current module during the
call.  The argument <var class="var">data</var> is passed to <var class="var">func</var>.  The return
value of <code class="code">scm_c_call_with_current_module</code> is the return value of
<var class="var">func</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpublic_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_public_variable</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpublic_005fvariable"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fpublic_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_public_variable</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fpublic_005fvariable"> ¶</a></span></dt>
<dd><p>Find a the variable bound to the symbol <var class="var">name</var> in the public
interface of the module named <var class="var">module_name</var>.
</p>
<p><var class="var">module_name</var> should be a list of symbols, when represented as a
Scheme object, or a space-separated string, in the <code class="code">const char *</code>
case.  See <code class="code">scm_c_define_module</code> below, for more examples.
</p>
<p>Signals an error if no module was found with the given name.  If
<var class="var">name</var> is not bound in the module, just returns <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fprivate_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_private_variable</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprivate_005fvariable"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fprivate_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_private_variable</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprivate_005fvariable"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_public_variable</code>, but looks in the internals of the
module named <var class="var">module_name</var> instead of the public interface.
Logically, these procedures should only be called on modules you write.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpublic_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_public_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpublic_005flookup"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fpublic_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_public_lookup</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fpublic_005flookup"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fprivate_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_private_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprivate_005flookup"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fprivate_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_private_lookup</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprivate_005flookup"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_public_variable</code> or <code class="code">scm_private_variable</code>, but if
the <var class="var">name</var> is not bound in the module, signals an error.  Returns a
variable, always.
</p>
<div class="example">
<pre class="example-preformatted">static SCM eval_string_var;

/* NOTE: It is important that the call to 'my_init'
   happens-before all calls to 'my_eval_string'. */
void my_init (void)
{
  eval_string_var = scm_c_public_lookup ("ice-9 eval-string",
                                         "eval-string");
}

SCM my_eval_string (SCM str)
{
  return scm_call_1 (scm_variable_ref (eval_string_var), str);
}
</pre></div>
</dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpublic_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_public_ref</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpublic_005fref"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fpublic_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_public_ref</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fpublic_005fref"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fprivate_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_private_ref</strong> <code class="def-code-arguments">(SCM <var class="var">module_name</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprivate_005fref"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc_005fprivate_005fref"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_private_ref</strong> <code class="def-code-arguments">(const char *<var class="var">module_name</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprivate_005fref"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_public_lookup</code> or <code class="code">scm_private_lookup</code>, but
additionally dereferences the variable.  If the variable object is
unbound, signals an error.  Returns the value bound to <var class="var">name</var> in
<var class="var">module_name</var>.
</p></dd></dl>

<p>In addition, there are a number of other lookup-related procedures.  We
suggest that you use the <code class="code">scm_public_</code> and <code class="code">scm_private_</code>
family of procedures instead, if possible.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_lookup</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005flookup"> ¶</a></span></dt>
<dd><p>Return the variable bound to the symbol indicated by <var class="var">name</var> in the
current module.  If there is no such binding or the symbol is not
bound to a variable, signal an error.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flookup"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_c_lookup</code>, but the symbol is specified directly.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmodule_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_module_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmodule_005flookup"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmodule_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_module_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodule_005flookup"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_c_lookup</code> and <code class="code">scm_lookup</code>, but the specified
module is used instead of the current one.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmodule_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_module_variable</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM <var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodule_005fvariable"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_module_lookup</code>, but if the binding does not exist, just
returns <code class="code">#f</code> instead of raising an error.
</p></dd></dl>

<p>To define a value, use <code class="code">scm_define</code>:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fdefine-1"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_define</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>, SCM <var class="var">val</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fdefine-1"> ¶</a></span></dt>
<dd><p>Bind the symbol indicated by <var class="var">name</var> to a variable in the current
module and set that variable to <var class="var">val</var>.  When <var class="var">name</var> is already
bound to a variable, use that.  Else create a new variable.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdefine-1"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_define</strong> <code class="def-code-arguments">(SCM <var class="var">name</var>, SCM <var class="var">val</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdefine-1"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_c_define</code>, but the symbol is specified directly.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmodule_005fdefine"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_module_define</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, const char *<var class="var">name</var>, SCM <var class="var">val</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmodule_005fdefine"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmodule_005fdefine"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_module_define</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM <var class="var">name</var>, SCM <var class="var">val</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodule_005fdefine"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_c_define</code> and <code class="code">scm_define</code>, but the specified
module is used instead of the current one.
</p></dd></dl>

<p>In some rare cases, you may need to access the variable that
<code class="code">scm_module_define</code> would have accessed, without changing the
binding of the existing variable, if one is present.  In that case, use
<code class="code">scm_module_ensure_local_variable</code>:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmodule_005fensure_005flocal_005fvariable"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_module_ensure_local_variable</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM <var class="var">sym</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodule_005fensure_005flocal_005fvariable"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_module_define</code>, but if the <var class="var">sym</var> is already locally
bound in that module, the variable’s existing binding is not reset.
Returns a variable.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmodule_005freverse_005flookup"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_module_reverse_lookup</strong> <code class="def-code-arguments">(SCM <var class="var">module</var>, SCM <var class="var">variable</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmodule_005freverse_005flookup"> ¶</a></span></dt>
<dd><p>Find the symbol that is bound to <var class="var">variable</var> in <var class="var">module</var>.  When no such binding is found, return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fdefine_005fmodule"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_define_module</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>, void (*<var class="var">init</var>)(void *), void *<var class="var">data</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fdefine_005fmodule"> ¶</a></span></dt>
<dd><p>Define a new module named <var class="var">name</var> and make it current while
<var class="var">init</var> is called, passing it <var class="var">data</var>.  Return the module.
</p>
<p>The parameter <var class="var">name</var> is a string with the symbols that make up
the module name, separated by spaces.  For example, ‘<samp class="samp">"foo bar"</samp>’ names
the module ‘<samp class="samp">(foo bar)</samp>’.
</p>
<p>When there already exists a module named <var class="var">name</var>, it is used
unchanged, otherwise, an empty module is created.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fresolve_005fmodule"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_resolve_module</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fresolve_005fmodule"> ¶</a></span></dt>
<dd><p>Find the module name <var class="var">name</var> and return it.  When it has not
already been defined, try to auto-load it.  When it can’t be found
that way either, create an empty module.  The name is interpreted as
for <code class="code">scm_c_define_module</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fuse_005fmodule"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_c_use_module</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fuse_005fmodule"> ¶</a></span></dt>
<dd><p>Add the module named <var class="var">name</var> to the uses list of the current
module, as with <code class="code">(use-modules <var class="var">name</var>)</code>.  The name is
interpreted as for <code class="code">scm_c_define_module</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fexport"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_export</strong> <code class="def-code-arguments">(const char *<var class="var">name</var>, ...)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fexport"> ¶</a></span></dt>
<dd><p>Add the bindings designated by <var class="var">name</var>, ... to the public interface
of the current module.  The list of names is terminated by
<code class="code">NULL</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="provide-and-require">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Environments" accesskey="n" rel="next">Environments</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Modules-from-C" accesskey="p" rel="prev">Accessing Modules from C</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="provide-and-require-1">6.18.11 provide and require</h4>

<p>Aubrey Jaffer, mostly to support his portable Scheme library SLIB,
implemented a provide/require mechanism for many Scheme implementations.
Library files in SLIB <em class="emph">provide</em> a feature, and when user programs
<em class="emph">require</em> that feature, the library file is loaded in.
</p>
<p>For example, the file <samp class="file">random.scm</samp> in the SLIB package contains the
line
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(provide 'random)
</pre></div>

<p>so to use its procedures, a user would type
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(require 'random)
</pre></div>

<p>and they would magically become available, <em class="emph">but still have the same
names!</em>  So this method is nice, but not as good as a full-featured
module system.
</p>
<p>When SLIB is used with Guile, provide and require can be used to access
its facilities.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Environments">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#provide-and-require" accesskey="p" rel="prev">provide and require</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="u" rel="up">Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Environments-1">6.18.12 Environments</h4>
<a class="index-entry-id" id="index-environment-1"></a>

<p>Scheme, as defined in R5RS, does <em class="emph">not</em> have a full module system.
However it does define the concept of a top-level <em class="dfn">environment</em>.
Such an environment maps identifiers (symbols) to Scheme objects such
as procedures and lists: <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#About-Closure">The Concept of Closure</a>.  In other words, it
implements a set of <em class="dfn">bindings</em>.
</p>
<p>Environments in R5RS can be passed as the second argument to
<code class="code">eval</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">Procedures for On the Fly Evaluation</a>).  Three procedures are defined to
return environments: <code class="code">scheme-report-environment</code>,
<code class="code">null-environment</code> and <code class="code">interaction-environment</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Fly-Evaluation">Procedures for On the Fly Evaluation</a>).
</p>
<p>In addition, in Guile any module can be used as an R5RS environment,
i.e., passed as the second argument to <code class="code">eval</code>.
</p>
<p>Note: the following two procedures are available only when the 
<code class="code">(ice-9 r5rs)</code> module is loaded:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 r5rs))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-scheme_002dreport_002denvironment"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">scheme-report-environment</strong> <var class="def-var-arguments">version</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scheme_002dreport_002denvironment"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-null_002denvironment"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">null-environment</strong> <var class="def-var-arguments">version</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-null_002denvironment"> ¶</a></span></dt>
<dd><p><var class="var">version</var> must be the exact integer ‘5’, corresponding to revision
5 of the Scheme report (the Revised^5 Report on Scheme).
<code class="code">scheme-report-environment</code> returns a specifier for an
environment that is empty except for all bindings defined in the
report that are either required or both optional and supported by the
implementation. <code class="code">null-environment</code> returns a specifier for an
environment that is empty except for the (syntactic) bindings for all
syntactic keywords defined in the report that are either required or
both optional and supported by the implementation.
</p>
<p>Currently Guile does not support values of <var class="var">version</var> for other
revisions of the report.
</p>
<p>The effect of assigning (through the use of <code class="code">eval</code>) a variable
bound in a <code class="code">scheme-report-environment</code> (for example <code class="code">car</code>)
is unspecified.  Currently the environments specified by
<code class="code">scheme-report-environment</code> are not immutable in Guile.
</p></dd></dl>




<hr>
</div>
</div>
<div class="section-level-extent" id="Foreign-Function-Interface">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects" accesskey="n" rel="next">Foreign Objects</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Modules" accesskey="p" rel="prev">Modules</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Foreign-Function-Interface-1">6.19 Foreign Function Interface</h3>
<a class="index-entry-id" id="index-foreign-function-interface"></a>
<a class="index-entry-id" id="index-ffi"></a>

<p>Sometimes you need to use libraries written in C or Rust or some other
non-Scheme language.  More rarely, you might need to write some C to
extend Guile.  This section describes how to load these “foreign
libraries”, look up data and functions inside them, and so on.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Libraries" accesskey="1">Foreign Libraries</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions" accesskey="2">Foreign Extensions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Pointers" accesskey="3">Foreign Pointers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Types" accesskey="4">Foreign Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Functions" accesskey="5">Foreign Functions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Void-Pointers-and-Byte-Access" accesskey="6">Void Pointers and Byte Access</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Structs" accesskey="7">Foreign Structs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#More-Foreign-Functions" accesskey="8">More Foreign Functions</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Foreign-Libraries">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions" accesskey="n" rel="next">Foreign Extensions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Libraries-1">6.19.1 Foreign Libraries</h4>

<p>Just as Guile can load up Scheme libraries at run-time, Guile can also
load some system libraries written in C or other low-level languages.
We refer to these as dynamically-loadable modules as <em class="dfn">foreign
libraries</em>, to distinguish them from native libraries written in Scheme
or other languages implemented by Guile.
<a class="index-entry-id" id="index-foreign-libraries"></a>
<a class="index-entry-id" id="index-libraries_002c-foreign"></a>
</p>
<p>Foreign libraries usually come in two forms.  Some foreign libraries are
part of the operating system, such as the compression library
<code class="code">libz</code>.  These shared libraries are built in such a way that many
programs can use their functionality without duplicating their code.
When a program written in C is built, it can declare that it uses a
specific set of shared libraries.
<a class="index-entry-id" id="index-shared-libraries"></a>
<a class="index-entry-id" id="index-libraries_002c-shared"></a>
When the program is run, the operating system takes care of locating and
loading the shared libraries.
</p>
<p>The operating system components that can dynamically load and link
shared libraries when a program is run are also available
programmatically during a program’s execution.  This is the interface
that’s most useful for Guile, and this is what we mean in Guile when we
refer to <em class="dfn">dynamic linking</em>.  Dynamic linking at run-time is
sometimes called <em class="dfn">dlopening</em>, to distinguish it from the dynamic
linking that happens at program start-up.
<a class="index-entry-id" id="index-dynamic-linking"></a>
<a class="index-entry-id" id="index-dlopening"></a>
</p>
<p>The other kind of foreign library is sometimes known as a module,
plug-in, bundle, or an extension.  These foreign libraries aren’t meant
to be linked to by C programs, but rather only to be dynamically loaded
at run-time – they extend some main program with functionality, but
don’t stand on their own.  Sometimes a Guile library will implement some
of its functionality in a loadable module.
</p>
<p>In either case, the interface on the Guile side is the same.  You load
the interface using <code class="code">load-foreign-library</code>.  The resulting foreign
library object implements a simple lookup interface whereby the user can
get addresses of data or code exported by the library.  There is no
facility to inspect foreign libraries; you have to know what’s in there
already before you look.
</p>
<p>Routines for loading foreign libraries and accessing their contents are
implemented in the <code class="code">(system foreign-library)</code> module.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign-library))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-load_002dforeign_002dlibrary"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">load-foreign-library</strong> <var class="def-var-arguments">[library]        [#:extensions=system-library-extensions]        [#:search-ltdl-library-path?=#t]        [#:search-path=search-path]        [#:search-system-paths?=#t] [#:lazy?=#t] [#:global=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load_002dforeign_002dlibrary"> ¶</a></span></dt>
<dd><p>[#:rename-on-cygwin?=#t]
Find the shared library denoted by <var class="var">library</var> (a string or <code class="code">#f</code>)
and link it into the running Guile application.  When everything works
out, return a Scheme object suitable for representing the linked object
file.  Otherwise an error is thrown.
</p>
<p>If <var class="var">library</var> argument is omitted, it defaults to <code class="code">#f</code>.  If
<code class="code">library</code> is false, the resulting foreign library gives access to
all symbols available for dynamic linking in the main binary.
</p>
<p>It is not necessary to include any extension such as <code class="code">.so</code> in
<var class="var">library</var>.  For each system, Guile has a default set of extensions
that it will try.  On GNU systems, the default extension set is just
<code class="code">.so</code>; on Windows, just <code class="code">.dll</code>; and on Darwin (Mac OS), it is
<code class="code">.bundle</code>, <code class="code">.so</code>, and <code class="code">.dylib</code>.  Pass <code class="code">#:extensions
<var class="var">extensions</var></code> to override the default extensions list.  If
<var class="var">library</var> contains one of the extensions, no extensions are tried,
so it is possible to specify the extension if you know exactly what file
to load.
</p>
<p>Unless <var class="var">library</var> denotes an absolute file name or otherwise contains
a directory separator (<code class="code">/</code>, and also <code class="code">\</code> on Windows), Guile
will search for the library in the directories listed in
<var class="var">search-paths</var>.  The default search path has three components, which
can all be overriden by colon-delimited (semicolon on Windows)
environment variables:
</p>
<dl class="table">
<dt><code class="env">GUILE_EXTENSIONS_PATH</code></dt>
<dd><p>This is the main environment variable for users to add directories
containing Guile extensions.  The default value has no entries.  This
environment variable was added in Guile 3.0.6.
</p></dd>
<dt><code class="env">LTDL_LIBRARY_PATH</code></dt>
<dd><p>Before Guile 3.0.6, Guile loaded foreign libraries using <code class="code">libltdl</code>,
the dynamic library loader provided by libtool.  This loader used
<code class="env">LTDL_LIBRARY_PATH</code>, and for backwards compatibility we still
support that path.
</p>
<p>However, <code class="code">libltdl</code> would not only open <code class="code">.so</code> (or <code class="code">.dll</code>
and so on) files, but also the <code class="code">.la</code> files created by libtool.  In
installed libraries – libraries that are in the target directories of
<code class="code">make install</code> – <code class="code">.la</code> files are never needed, to the extent
that most GNU/Linux distributions remove them entirely.  It is
sufficient to just load the <code class="code">.so</code> (or <code class="code">.dll</code> and so on) files,
which are always located in the same directory as the <code class="code">.la</code> files.
</p>
<p>But for uninstalled dynamic libraries, like those in a build tree, the
situation is a bit of a mess.  If you have a project that uses libtool
to build libraries – which is the case for Guile, and for most projects
using autotools – and you build <samp class="file">foo.so</samp> in directory <samp class="file">D</samp>,
libtool will put <samp class="file">foo.la</samp> in <samp class="file">D</samp>, but <samp class="file">foo.so</samp> gets put
into <samp class="file">D/.libs</samp>.
</p>
<p>Users were mostly oblivious to this situation, as <code class="code">libltdl</code> had
special logic to be able to read the <code class="code">.la</code> file to know where to
find the <code class="code">.so</code>, even from an uninstalled build tree, preventing the
existence of <samp class="file">.libs</samp> from leaking out to the user.
</p>
<p>We don’t use libltdl now, essentially for flexibility and
error-reporting reasons.  But, to keep this old use-case working, if
<var class="var">search-ltdl-library-path?</var> is true, we add each entry of
<code class="code">LTDL_LIBRARY_PATH</code> to the default extensions load path,
additionally adding the <samp class="file">.libs</samp> subdirextories for each entry, in
case there are <samp class="file">.so</samp> files there instead of alongside the
<samp class="file">.la</samp> files.
</p></dd>
<dt><code class="env">GUILE_SYSTEM_EXTENSIONS_PATH</code></dt>
<dd><p>The last path in Guile’s search path belongs to Guile itself, and
defaults to the libdir and the extensiondir, in that order.  For
example, if you install to <samp class="file">/opt/guile</samp>, these would probably be
<samp class="file">/opt/guile/lib</samp> and
<code class="code">/opt/guile/lib/guile/3.0/extensions</code>,
respectively.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Installations">Parallel Installations</a>, for more details on
<code class="code">extensionsdir</code>.
</p></dd>
</dl>

<p>Finally, if no library is found in the search path, and if <var class="var">library</var>
is not absolute and does not include directory separators, and if
<var class="var">search-system-paths?</var> is true, the operating system may have its
own logic for where to locate <var class="var">library</var>.  For example, on GNU, there
will be a default set of paths (often <samp class="file">/usr/lib</samp> and <samp class="file">/lib</samp>,
though it depends on the system), and the <code class="code">LD_LIBRARY_PATH</code>
environment variable can add additional paths.  Other operating systems
have other conventions.
</p>
<p>Falling back to the operating system for search is usually not a great
thing; it is a recipe for making programs that work on one machine but
not on others.  Still, when wrapping system libraries, it can be the
only way to get things working at all.
</p>
<p>If <var class="var">lazy?</var> is true (the default), Guile will request the operating
system to resolve symbols used by the loaded library as they are first
used.  If <var class="var">global?</var> is true, symbols defined by the loaded library
will be available when other modules need to resolve symbols; the
default is <code class="code">#f</code>, which keeps symbols local.
</p>
<p>If <var class="var">rename-on-cygwin?</var> is true (the default) – on Cygwin hosts only
– the search behavior is modified such that a filename that starts with
“lib” will be searched for under the name “cyg”, as is customary for
Cygwin.
</p></dd></dl>

<p>The environment variables mentioned above are parsed when the
foreign-library module is first loaded and bound to parameters.  Null
path components, for example the three components of
<code class="env">GUILE_SYSTEM_EXTENSIONS_PATH="::"</code>, are ignored.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-guile_002dextensions_002dpath"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">guile-extensions-path</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-guile_002dextensions_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-ltdl_002dlibrary_002dpath"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">ltdl-library-path</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ltdl_002dlibrary_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-guile_002dsystem_002dextensions_002dpath"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">guile-system-extensions-path</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-guile_002dsystem_002dextensions_002dpath"> ¶</a></span></dt>
<dd><p>Parameters whose initial values are taken from
<code class="env">GUILE_EXTENSIONS_PATH</code>, <code class="env">LTDL_LIBRARY_PATH</code>, and
<code class="env">GUILE_SYSTEM_EXTENSIONS_PATH</code>, respectively.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>.
The current values of these parameters are used when building the search
path when <code class="code">load-foreign-library</code> is called, unless the caller
explicitly passes a <code class="code">#:search-path</code> argument.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-foreign_002dlibrary_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">foreign-library?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-foreign_002dlibrary_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a foreign library, or <code class="code">#f</code>
otherwise.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Extensions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Pointers" accesskey="n" rel="next">Foreign Pointers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Libraries" accesskey="p" rel="prev">Foreign Libraries</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Extensions-1">6.19.2 Foreign Extensions</h4>

<p>One way to use shared libraries is to extend Guile.  Such loadable
modules generally define one distinguished initialization function that,
when called, will use the <code class="code">libguile</code> API to define procedures in
the current module.
</p>
<p>Concretely, you might extend Guile with an implementation of the Bessel
function, <code class="code">j0</code>:
</p>
<div class="example smallexample">
<pre class="example-preformatted">#include &lt;math.h&gt;
#include &lt;libguile.h&gt;

SCM
j0_wrapper (SCM x)
{
  return scm_from_double (j0 (scm_to_double (x, "j0")));
}

void
init_math_bessel (void)
{
  scm_c_define_gsubr ("j0", 1, 0, 0, j0_wrapper);
}
</pre></div>

<p>The C source file would then need to be compiled into a shared library.
On GNU/Linux, the compiler invocation might look like this:
</p>
<div class="example smallexample">
<pre class="example-preformatted">gcc -shared -o bessel.so -fPIC bessel.c
</pre></div>

<p>A good default place to put shared libraries that extend Guile is into
the extensions dir.  From the command line or a build script, invoke
<code class="code">pkg-config --variable=extensionsdir
guile-3.0</code> to print the extensions dir.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Installations">Parallel Installations</a>, for more details.
</p>
<p>Guile can load up <code class="code">bessel.so</code> via <code class="code">load-extension</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-load_002dextension"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">load-extension</strong> <var class="def-var-arguments">lib init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-load_002dextension"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fload_005fextension"><span class="category-def">C Function: </span><span><strong class="def-name">scm_load_extension</strong> <var class="def-var-arguments">(lib, init)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fload_005fextension"> ¶</a></span></dt>
<dd><p>Load and initialize the extension designated by LIB and INIT.
</p></dd></dl>

<p>The normal way for a extension to be used is to write a small Scheme
file that defines a module, and to load the extension into this
module.  When the module is auto-loaded, the extension is loaded as
well.  For example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-module (math bessel)
  #:export (j0))

(load-extension "bessel" "init_math_bessel")
</pre></div>

<p>This <code class="code">load-extension</code> invocation loads the <code class="code">bessel</code> library
via <code class="code">(load-foreign-library "bessel")</code>, then looks up the
<code class="code">init_math_bessel</code> symbol in the library, treating it as a function
of no arguments, and calls that function.
</p>
<p>If you decide to put your extension outside the default search path for
<code class="code">load-foreign-library</code>, probably you should adapt the Scheme module
to specify its absolute path.  For example, if you use <code class="code">automake</code>
to build your extension and place it in <code class="code">$(pkglibdir)</code>, you might
define a build-parameters module that gets created by the build system:
</p>
<div class="example">
<pre class="example-preformatted">(define-module (math config)
  #:export (extensiondir))
(define extensiondir "PKGLIBDIR")
</pre></div>

<p>This file would be <code class="code">config.scm.in</code>.  You would define a <code class="code">make</code>
rule to substitute in the absolute installed file name:
</p>
<div class="example">
<pre class="example-preformatted">config.scm: config.scm.in
        sed 's|PKGLIBDIR|$(pkglibdir)|' &lt;$&lt; &gt;$&nbsp;</pre></div>

<p>Then your <code class="code">(math bessel)</code> would import <code class="code">(math config)</code>, then
<code class="code">(load-extension (in-vicinity extensiondir "bessel")
"init_math_bessel")</code>.
</p>
<p>An alternate approach would be to rebind the
<code class="code">guile-extensions-path</code> parameter, or its corresponding environment
variable, but note that changing those parameters applies to other users
of <code class="code">load-foreign-library</code> as well.
</p>
<p>Note that the new primitives that the extension adds to Guile with
<code class="code">scm_c_define_gsubr</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Primitive-Procedures">Primitive Procedures</a>) or with any of
the other mechanisms are placed into the module that is current when the
<code class="code">scm_c_define_gsubr</code> is executed, so to be clear about what goes
vwhere it’s best to include the <code class="code">load-extension</code> in a module, as
above.  Alternately, the C code can use <code class="code">scm_c_define_module</code> to
specify which module is being created:
</p>
<div class="example smallexample">
<pre class="example-preformatted">static void
do_init (void *unused)
{
  scm_c_define_gsubr ("j0", 1, 0, 0, j0_wrapper);
  scm_c_export ("j0", NULL);
}

void
init_math_bessel ()
{
  scm_c_define_module ("math bessel", do_init, NULL);
}
</pre></div>

<p>And yet... if what we want is just the <code class="code">j0</code> function, it seems like
a lot of ceremony to have to compile a Guile-specific wrapper library
complete with an initialization function and wraper module to allow
Guile users to call it.  There is another way, but to get there, we have
to talk about function pointers and function types first.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Functions">Foreign Functions</a>, to skip to the good parts.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Pointers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Types" accesskey="n" rel="next">Foreign Types</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Extensions" accesskey="p" rel="prev">Foreign Extensions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Pointers-1">6.19.3 Foreign Pointers</h4>

<p>Foreign libraries are essentially key-value mappings, where the keys are
names of definitions and the values are the addresses of those
definitions.  To look up the address of a definition, use
<code class="code">foreign-library-pointer</code> from the <code class="code">(system foreign-library)</code>
module.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-foreign_002dlibrary_002dpointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">foreign-library-pointer</strong> <var class="def-var-arguments">lib name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-foreign_002dlibrary_002dpointer"> ¶</a></span></dt>
<dd><p>Return a “wrapped pointer” for the symbol <var class="var">name</var> in the shared
object referred to by <var class="var">lib</var>.  The returned pointer points to a C
object.
</p>
<p>As a convenience, if <var class="var">lib</var> is not a foreign library, it will be
passed to <code class="code">load-foreign-library</code>.
</p></dd></dl>

<p>If we continue with the <code class="code">bessel.so</code> example from before, we can get
the address of the <code class="code">init_math_bessel</code> function via:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign-library))
(define init (foreign-library-pointer "bessel" "init_math_bessel"))
init
⇒ #&lt;pointer 0x7fb35b1b4688&gt;
</pre></div>

<p>A value returned by <code class="code">foreign-library-pointer</code> is a Scheme wrapper
for a C pointer.  Pointers are a data type in Guile that is disjoint
from all other types.  The next section discusses ways to dereference
pointers, but before then we describe the usual type predicates and so
on.
</p>
<p>Note that the rest of the interfaces in this section are part of the
<code class="code">(system foreign)</code> library:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_002daddress"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer-address</strong> <var class="def-var-arguments">pointer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_002daddress"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpointer_005faddress"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pointer_address</strong> <var class="def-var-arguments">(pointer)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpointer_005faddress"> ¶</a></span></dt>
<dd><p>Return the numerical value of <var class="var">pointer</var>.
</p>
<div class="example">
<pre class="example-preformatted">(pointer-address init)
⇒ 139984413364296 ; YMMV
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dpointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-pointer</strong> <var class="def-var-arguments">address [finalizer]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dpointer"> ¶</a></span></dt>
<dd><p>Return a foreign pointer object pointing to <var class="var">address</var>.  If
<var class="var">finalizer</var> is passed, it should be a pointer to a one-argument C
function that will be called when the pointer object becomes
unreachable.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a pointer object, or <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-_0025null_002dpointer"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">%null-pointer</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025null_002dpointer"> ¶</a></span></dt>
<dd><p>A foreign pointer whose value is 0.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-null_002dpointer_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">null-pointer?</strong> <var class="def-var-arguments">pointer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-null_002dpointer_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">pointer</var> is the null pointer, <code class="code">#f</code> otherwise.
</p></dd></dl>

<p>For the purpose of passing SCM values directly to foreign functions, and
allowing them to return SCM values, Guile also supports some unsafe
casting operators.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-scm_002d_003epointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">scm-&gt;pointer</strong> <var class="def-var-arguments">scm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_002d_003epointer"> ¶</a></span></dt>
<dd><p>Return a foreign pointer object with the <code class="code">object-address</code>
of <var class="var">scm</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_002d_003escm"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer-&gt;scm</strong> <var class="def-var-arguments">pointer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_002d_003escm"> ¶</a></span></dt>
<dd><p>Unsafely cast <var class="var">pointer</var> to a Scheme object.
Cross your fingers!
</p></dd></dl>

<p>Sometimes you want to give C extensions access to the dynamic FFI.  At
that point, the names get confusing, because “pointer” can refer to a
<code class="code">SCM</code> object that wraps a pointer, or to a <code class="code">void*</code> value.  We
will try to use “pointer object” to refer to Scheme objects, and
“pointer value” to refer to <code class="code">void *</code> values.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fpointer"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_pointer</strong> <code class="def-code-arguments">(void *ptr, void (*finalizer) (void*))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fpointer"> ¶</a></span></dt>
<dd><p>Create a pointer object from a pointer value.
</p>
<p>If <var class="var">finalizer</var> is non-null, Guile arranges to call it on the pointer
value at some point after the pointer object becomes collectable.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fpointer"><span class="category-def">C Function: </span><span><code class="def-type">void*</code> <strong class="def-name">scm_to_pointer</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fpointer"> ¶</a></span></dt>
<dd><p>Unpack the pointer value from a pointer object.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Types">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Functions" accesskey="n" rel="next">Foreign Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Pointers" accesskey="p" rel="prev">Foreign Pointers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Types-1">6.19.4 Foreign Types</h4>

<p>From Scheme’s perspective, foreign pointers are shards of chaos.  The
user can create a foreign pointer for any address, and do with it what
they will.  The only thing that lends a sense of order to the whole is a
shared hallucination that certain storage locations have certain types.
When making Scheme wrappers for foreign interfaces, we hide the madness
by explicitly representing the the data types of parameters and fields.
</p>
<p>These “foreign type values” may be constructed using the constants and
procedures from the <code class="code">(system foreign)</code> module, which may be loaded
like this:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
</pre></div>

<p><code class="code">(system foreign)</code> exports a number of values expressing the basic
C types.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-int8"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">int8</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-int8"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-uint8"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">uint8</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uint8"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-uint16"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">uint16</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uint16"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-int16"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">int16</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-int16"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-uint32"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">uint32</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uint32"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-int32"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">int32</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-int32"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-uint64"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">uint64</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uint64"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-int64"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">int64</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-int64"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-float"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">float</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-float"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-double"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">double</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-double"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-complex_002ddouble"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">complex-double</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-complex_002ddouble"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-complex_002dfloat"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">complex-float</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-complex_002dfloat"> ¶</a></span></dt>
<dd><p>These values represent the C numeric types of the specified sizes and
signednesses. <code class="code">complex-float</code> and <code class="code">complex-double</code> stand for
C99 <code class="code">float _Complex</code> and <code class="code">double _Complex</code> respecively.
</p></dd></dl>

<p>In addition there are some convenience bindings for indicating types of
platform-dependent size.
</p>
<dl class="first-defvr">
<dt class="defvr" id="index-int"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">int</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-int"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-unsigned_002dint"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">unsigned-int</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unsigned_002dint"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-long"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">long</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-long"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-unsigned_002dlong"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">unsigned-long</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unsigned_002dlong"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-short"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">short</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-short"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-unsigned_002dshort"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">unsigned-short</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unsigned_002dshort"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-size_005ft-1"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">size_t</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-size_005ft-1"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-ssize_005ft"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">ssize_t</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ssize_005ft"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-ptrdiff_005ft"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">ptrdiff_t</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ptrdiff_005ft"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-intptr_005ft"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">intptr_t</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-intptr_005ft"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-uintptr_005ft"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">uintptr_t</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uintptr_005ft"> ¶</a></span></dt>
<dd><p>Values exported by the <code class="code">(system foreign)</code> module, representing C
numeric types. For example, <code class="code">long</code> may be <code class="code">equal?</code> to
<code class="code">int64</code> on a 64-bit platform.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-void"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">void</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-void"> ¶</a></span></dt>
<dd><p>The <code class="code">void</code> type.  It can be used as the first argument to
<code class="code">pointer-&gt;procedure</code> to wrap a C function that returns nothing.
</p></dd></dl>

<p>In addition, the symbol <code class="code">*</code> is used by convention to denote pointer
types.  Procedures detailed in the following sections, such as
<code class="code">pointer-&gt;procedure</code>, accept it as a type descriptor.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Functions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Void-Pointers-and-Byte-Access" accesskey="n" rel="next">Void Pointers and Byte Access</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Types" accesskey="p" rel="prev">Foreign Types</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Functions-1">6.19.5 Foreign Functions</h4>

<p>The most natural thing to do with a dynamic library is to grovel around
in it for a function pointer: a <em class="dfn">foreign function</em>.  Load the
<code class="code">(system foreign)</code> module to use these Scheme interfaces.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_002d_003eprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer-&gt;procedure</strong> <var class="def-var-arguments">return_type func_ptr arg_types                                              [#:return-errno?=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_002d_003eprocedure"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpointer_005fto_005fprocedure"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pointer_to_procedure</strong> <var class="def-var-arguments">(return_type, func_ptr, arg_types)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpointer_005fto_005fprocedure"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpointer_005fto_005fprocedure_005fwith_005ferrno"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pointer_to_procedure_with_errno</strong> <var class="def-var-arguments">(return_type, func_ptr, arg_types)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpointer_005fto_005fprocedure_005fwith_005ferrno"> ¶</a></span></dt>
<dd>
<p>Make a foreign function.
</p>
<p>Given the foreign void pointer <var class="var">func_ptr</var>, its argument and
return types <var class="var">arg_types</var> and <var class="var">return_type</var>, return a
procedure that will pass arguments to the foreign function
and return appropriate values.
</p>
<p><var class="var">arg_types</var> should be a list of foreign types.
<code class="code">return_type</code> should be a foreign type. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Types">Foreign Types</a>, for
more information on foreign types.
</p>
<p>If <var class="var">return-errno?</var> is true, or when calling
<code class="code">scm_pointer_to_procedure_with_errno</code>, the returned procedure will
return two values, with <code class="code">errno</code> as the second value.
</p></dd></dl>

<p>Finally, in <code class="code">(system foreign-library)</code> there is a convenient
wrapper function, joining together <code class="code">foreign-libary-pointer</code> and
<code class="code">procedure-&gt;pointer</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-foreign_002dlibrary_002dfunction"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">foreign-library-function</strong> <var class="def-var-arguments">lib name        [#:return-type=void] [#:arg-types=’()] [#:return-errno?=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-foreign_002dlibrary_002dfunction"> ¶</a></span></dt>
<dd><p>Load the address of <var class="var">name</var> from <var class="var">lib</var>, and treat it as a
function taking arguments <var class="var">arg-types</var> and returning
<var class="var">return-type</var>, optionally also with errno.
</p>
<p>An invocation of <code class="code">foreign-library-function</code> is entirely equivalent
to:
</p><div class="example">
<pre class="example-preformatted">(pointer-&gt;procedure <var class="var">return-type</var>
                    (foreign-library-pointer <var class="var">lib</var> <var class="var">name</var>)
                    <var class="var">arg-types</var>
                    #:return-errno? <var class="var">return-errno?</var>).
</pre></div>
</dd></dl>

<p>Pulling all this together, here is a better definition of <code class="code">(math
bessel)</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define-module (math bessel)
  #:use-module (system foreign)
  #:use-module (system foreign-library)
  #:export (j0))

(define j0
  (foreign-library-function "libm" "j0"
                            #:return-type double
                            #:arg-types (list double)))
</pre></div>

<p>That’s it! No C at all.
</p>
<p>Before going on to more detailed examples, the next two sections discuss
how to deal with data that is more complex than, say, <code class="code">int8</code>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#More-Foreign-Functions">More Foreign Functions</a>, to continue with foreign function examples.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Void-Pointers-and-Byte-Access">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Structs" accesskey="n" rel="next">Foreign Structs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Functions" accesskey="p" rel="prev">Foreign Functions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Void-Pointers-and-Byte-Access-1">6.19.6 Void Pointers and Byte Access</h4>

<p>Wrapped pointers are untyped, so they are essentially equivalent to C
<code class="code">void</code> pointers.  As in C, the memory region pointed to by a
pointer can be accessed at the byte level.  This is achieved using
<em class="emph">bytevectors</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>).  The <code class="code">(rnrs bytevectors)</code>
module contains procedures that can be used to convert byte sequences to
Scheme objects such as strings, floating point numbers, or integers.
</p>
<p>Load the <code class="code">(system foreign)</code> module to use these Scheme interfaces.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_002d_003ebytevector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer-&gt;bytevector</strong> <var class="def-var-arguments">pointer len [offset [uvec_type]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_002d_003ebytevector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpointer_005fto_005fbytevector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pointer_to_bytevector</strong> <var class="def-var-arguments">(pointer, len, offset, uvec_type)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpointer_005fto_005fbytevector"> ¶</a></span></dt>
<dd><p>Return a bytevector aliasing the <var class="var">len</var> bytes pointed to by
<var class="var">pointer</var>.
</p>
<p>The user may specify an alternate default interpretation for the memory
by passing the <var class="var">uvec_type</var> argument, to indicate that the memory is
an array of elements of that type.  <var class="var">uvec_type</var> should be something
that <code class="code">array-type</code> would return, like <code class="code">f32</code> or <code class="code">s16</code>.
</p>
<p>When <var class="var">offset</var> is passed, it specifies the offset in bytes relative
to <var class="var">pointer</var> of the memory region aliased by the returned
bytevector.
</p>
<p>Mutating the returned bytevector mutates the memory pointed to by
<var class="var">pointer</var>, so buckle your seatbelts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bytevector_002d_003epointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bytevector-&gt;pointer</strong> <var class="def-var-arguments">bv [offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bytevector_002d_003epointer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbytevector_005fto_005fpointer"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bytevector_to_pointer</strong> <var class="def-var-arguments">(bv, offset)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbytevector_005fto_005fpointer"> ¶</a></span></dt>
<dd><p>Return a pointer aliasing the memory pointed to by <var class="var">bv</var> or
<var class="var">offset</var> bytes after <var class="var">bv</var> when <var class="var">offset</var> is passed.
</p></dd></dl>

<p>In addition to these primitives, convenience procedures are available:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-dereference_002dpointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dereference-pointer</strong> <var class="def-var-arguments">pointer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dereference_002dpointer"> ¶</a></span></dt>
<dd><p>Assuming <var class="var">pointer</var> points to a memory region that holds a pointer,
return this pointer.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003epointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;pointer</strong> <var class="def-var-arguments">string [encoding]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003epointer"> ¶</a></span></dt>
<dd><p>Return a foreign pointer to a nul-terminated copy of <var class="var">string</var> in the
given <var class="var">encoding</var>, defaulting to the current locale encoding.  The C
string is freed when the returned foreign pointer becomes unreachable.
</p>
<p>This is the Scheme equivalent of <code class="code">scm_to_stringn</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pointer_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pointer-&gt;string</strong> <var class="def-var-arguments">pointer [length] [encoding]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pointer_002d_003estring"> ¶</a></span></dt>
<dd><p>Return the string representing the C string pointed to by <var class="var">pointer</var>.
If <var class="var">length</var> is omitted or <code class="code">-1</code>, the string is assumed to be
nul-terminated.  Otherwise <var class="var">length</var> is the number of bytes in memory
pointed to by <var class="var">pointer</var>.  The C string is assumed to be in the given
<var class="var">encoding</var>, defaulting to the current locale encoding.
</p>
<p>This is the Scheme equivalent of <code class="code">scm_from_stringn</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-wrapped-pointer-types"></a>
<p>Most object-oriented C libraries use pointers to specific data
structures to identify objects.  It is useful in such cases to reify the
different pointer types as disjoint Scheme types.  The
<code class="code">define-wrapped-pointer-type</code> macro simplifies this.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dwrapped_002dpointer_002dtype"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-wrapped-pointer-type</strong> <var class="def-var-arguments">type-name pred wrap unwrap print</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dwrapped_002dpointer_002dtype"> ¶</a></span></dt>
<dd><p>Define helper procedures to wrap pointer objects into Scheme objects
with a disjoint type.  Specifically, this macro defines:
</p>
<ul class="itemize mark-bullet">
<li><var class="var">pred</var>, a predicate for the new Scheme type;
</li><li><var class="var">wrap</var>, a procedure that takes a pointer object and returns an
object that satisfies <var class="var">pred</var>;
</li><li><var class="var">unwrap</var>, which does the reverse.
</li></ul>

<p><var class="var">wrap</var> preserves pointer identity, for two pointer objects <var class="var">p1</var>
and <var class="var">p2</var> that are <code class="code">equal?</code>, <code class="code">(eq? (<var class="var">wrap</var> <var class="var">p1</var>)
(<var class="var">wrap</var> <var class="var">p2</var>)) ⇒ #t</code>.
</p>
<p>Finally, <var class="var">print</var> should name a user-defined procedure to print such
objects.  The procedure is passed the wrapped object and a port to write
to.
</p>
<p>For example, assume we are wrapping a C library that defines a type,
<code class="code">bottle_t</code>, and functions that can be passed <code class="code">bottle_t *</code>
pointers to manipulate them.  We could write:
</p>
<div class="example">
<pre class="example-preformatted">(define-wrapped-pointer-type bottle
  bottle?
  wrap-bottle unwrap-bottle
  (lambda (b p)
    (format p "#&lt;bottle of ~a ~x&gt;"
            (bottle-contents b)
            (pointer-address (unwrap-bottle b)))))

(define grab-bottle
  ;; Wrapper for `bottle_t *grab (void)'.
  (let ((grab (foreign-library-function libbottle "grab_bottle"
                                        #:return-type '*)))
    (lambda ()
      "Return a new bottle."
      (wrap-bottle (grab)))))

(define bottle-contents
  ;; Wrapper for `const char *bottle_contents (bottle_t *)'.
  (let ((contents (foreign-library-function libbottle "bottle_contents"
                                            #:return-type '*
                                            #:arg-types  '(*))))
    (lambda (b)
      "Return the contents of B."
      (pointer-&gt;string (contents (unwrap-bottle b))))))

(write (grab-bottle))
⇒ #&lt;bottle of Château Haut-Brion 803d36&gt;
</pre></div>

<p>In this example, <code class="code">grab-bottle</code> is guaranteed to return a genuine
<code class="code">bottle</code> object satisfying <code class="code">bottle?</code>.  Likewise,
<code class="code">bottle-contents</code> errors out when its argument is not a genuine
<code class="code">bottle</code> object.
</p></dd></dl>

<p>As another example, currently Guile has a variable, <code class="code">scm_numptob</code>,
as part of its API. It is declared as a C <code class="code">long</code>. So, to read its
value, we can do:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
(use-modules (rnrs bytevectors))
(define numptob
  (foreign-library-pointer #f "scm_numptob"))
numptob
(bytevector-uint-ref (pointer-&gt;bytevector numptob (sizeof long))
                     0 (native-endianness)
                     (sizeof long))
⇒ 8
</pre></div>

<p>If we wanted to corrupt Guile’s internal state, we could set
<code class="code">scm_numptob</code> to another value; but we shouldn’t, because that
variable is not meant to be set.  Indeed this point applies more widely:
the C API is a dangerous place to be.  Not only might setting a value
crash your program, simply accessing the data pointed to by a dangling
pointer or similar can prove equally disastrous.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Foreign-Structs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#More-Foreign-Functions" accesskey="n" rel="next">More Foreign Functions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Void-Pointers-and-Byte-Access" accesskey="p" rel="prev">Void Pointers and Byte Access</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Foreign-Structs-1">6.19.7 Foreign Structs</h4>

<p>Finally, one last note on foreign values before moving on to actually
calling foreign functions. Sometimes you need to deal with C structs,
which requires interpreting each element of the struct according to the
its type, offset, and alignment. The <code class="code">(system foreign)</code> module has
some primitives to support this.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-sizeof"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sizeof</strong> <var class="def-var-arguments">type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sizeof"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsizeof"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sizeof</strong> <var class="def-var-arguments">(type)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsizeof"> ¶</a></span></dt>
<dd><p>Return the size of <var class="var">type</var>, in bytes.
</p>
<p><var class="var">type</var> should be a valid C type, like <code class="code">int</code>.
Alternately <var class="var">type</var> may be the symbol <code class="code">*</code>, in which
case the size of a pointer is returned. <var class="var">type</var> may
also be a list of types, in which case the size of a
<code class="code">struct</code> with ABI-conventional packing is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alignof"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alignof</strong> <var class="def-var-arguments">type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alignof"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005falignof"><span class="category-def">C Function: </span><span><strong class="def-name">scm_alignof</strong> <var class="def-var-arguments">(type)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005falignof"> ¶</a></span></dt>
<dd><p>Return the alignment of <var class="var">type</var>, in bytes.
</p>
<p><var class="var">type</var> should be a valid C type, like <code class="code">int</code>.
Alternately <var class="var">type</var> may be the symbol <code class="code">*</code>, in which
case the alignment of a pointer is returned. <var class="var">type</var> may
also be a list of types, in which case the alignment of a
<code class="code">struct</code> with ABI-conventional packing is returned.
</p></dd></dl>

<p>Guile also provides some convenience methods to pack and unpack foreign
pointers wrapping C structs.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dc_002dstruct"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-c-struct</strong> <var class="def-var-arguments">types vals</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dc_002dstruct"> ¶</a></span></dt>
<dd><p>Create a foreign pointer to a C struct containing <var class="var">vals</var> with types
<code class="code">types</code>.
</p>
<p><var class="var">vals</var> and <code class="code">types</code> should be lists of the same length.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dc_002dstruct"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-c-struct</strong> <var class="def-var-arguments">foreign types</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dc_002dstruct"> ¶</a></span></dt>
<dd><p>Parse a foreign pointer to a C struct, returning a list of values.
</p>
<p><code class="code">types</code> should be a list of C types.
</p></dd></dl>

<p>For example, to create and parse the equivalent of a <code class="code">struct {
int64_t a; uint8_t b; }</code>:
</p>
<div class="example">
<pre class="example-preformatted">(parse-c-struct (make-c-struct (list int64 uint8)
                               (list 300 43))
                (list int64 uint8))
⇒ (300 43)
</pre></div>

<p>As yet, Guile only has convenience routines to support
conventionally-packed structs. But given the <code class="code">bytevector-&gt;pointer</code>
and <code class="code">pointer-&gt;bytevector</code> routines, one can create and parse
tightly packed structs and unions by hand. See the code for
<code class="code">(system foreign)</code> for details.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="More-Foreign-Functions">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Structs" accesskey="p" rel="prev">Foreign Structs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="u" rel="up">Foreign Function Interface</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="More-Foreign-Functions-1">6.19.8 More Foreign Functions</h4>

<p>It is possible to pass pointers to foreign functions, and to return them
as well.  In that case the type of the argument or return value should
be the symbol <code class="code">*</code>, indicating a pointer. For example, the following
code makes <code class="code">memcpy</code> available to Scheme:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign))
(define memcpy
  (foreign-library-function #f "memcpy"
                            #:return-type '*
                            #:arg-types (list '* '* size_t)))
</pre></div>

<p>To invoke <code class="code">memcpy</code>, one must pass it foreign pointers:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (rnrs bytevectors))

(define src-bits
  (u8-list-&gt;bytevector '(0 1 2 3 4 5 6 7)))
(define src
  (bytevector-&gt;pointer src-bits))
(define dest
  (bytevector-&gt;pointer (make-bytevector 16 0)))

(memcpy dest src (bytevector-length src-bits))

(bytevector-&gt;u8-list (pointer-&gt;bytevector dest 16))
⇒ (0 1 2 3 4 5 6 7 0 0 0 0 0 0 0 0)
</pre></div>

<p>One may also pass structs as values, passing structs as foreign
pointers. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Structs">Foreign Structs</a>, for more information on how to express
struct types and struct values.
</p>
<p>“Out” arguments are passed as foreign pointers. The memory pointed to
by the foreign pointer is mutated in place.
</p>
<div class="example">
<pre class="example-preformatted">;; struct timeval {
;;      time_t      tv_sec;     /* seconds */
;;      suseconds_t tv_usec;    /* microseconds */
;; };
;; assuming fields are of type "long"

(define gettimeofday
  (let ((f (foreign-library-function #f "gettimeofday"
                                     #:return-type int
                                     #:arg-types (list '* '*)))
        (tv-type (list long long)))
    (lambda ()
      (let* ((timeval (make-c-struct tv-type (list 0 0)))
             (ret (f timeval %null-pointer)))
        (if (zero? ret)
            (apply values (parse-c-struct timeval tv-type))
            (error "gettimeofday returned an error" ret))))))

(gettimeofday)    
⇒ 1270587589
⇒ 499553
</pre></div>

<p>As you can see, this interface to foreign functions is at a very low,
somewhat dangerous level<a class="footnote" id="DOCF21" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT21"><sup>21</sup></a>.
</p>
<a class="index-entry-id" id="index-callbacks"></a>
<p>The FFI can also work in the opposite direction: making Scheme
procedures callable from C.  This makes it possible to use Scheme
procedures as “callbacks” expected by C function.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002d_003epointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">procedure-&gt;pointer</strong> <var class="def-var-arguments">return-type proc arg-types</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002d_003epointer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprocedure_005fto_005fpointer"><span class="category-def">C Function: </span><span><strong class="def-name">scm_procedure_to_pointer</strong> <var class="def-var-arguments">(return_type, proc, arg_types)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprocedure_005fto_005fpointer"> ¶</a></span></dt>
<dd><p>Return a pointer to a C function of type <var class="var">return-type</var>
taking arguments of types <var class="var">arg-types</var> (a list) and
behaving as a proxy to procedure <var class="var">proc</var>.  Thus
<var class="var">proc</var>’s arity, supported argument types, and return
type should match <var class="var">return-type</var> and <var class="var">arg-types</var>.
</p></dd></dl>

<p>As an example, here’s how the C library’s <code class="code">qsort</code> array sorting
function can be made accessible to Scheme (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Array-Sort-Function"><code class="code">qsort</code></a> in <cite class="cite">The GNU C Library Reference Manual</cite>):
</p>
<div class="example">
<pre class="example-preformatted">(define qsort!
  (let ((qsort (foreign-library-function
                #f "qsort" #:arg-types (list '* size_t size_t '*))))
    (lambda (bv compare)
      ;; Sort bytevector BV in-place according to comparison
      ;; procedure COMPARE.
      (let ((ptr (procedure-&gt;pointer int
                                     (lambda (x y)
                                       ;; X and Y are pointers so,
                                       ;; for convenience, dereference
                                       ;; them before calling COMPARE.
                                       (compare (dereference-uint8* x)
                                                (dereference-uint8* y)))
                                     (list '* '*))))
        (qsort (bytevector-&gt;pointer bv)
               (bytevector-length bv) 1 ;; we're sorting bytes
               ptr)))))

(define (dereference-uint8* ptr)
  ;; Helper function: dereference the byte pointed to by PTR.
  (let ((b (pointer-&gt;bytevector ptr 1)))
    (bytevector-u8-ref b 0)))

(define bv
  ;; An unsorted array of bytes.
  (u8-list-&gt;bytevector '(7 1 127 3 5 4 77 2 9 0)))

;; Sort BV.
(qsort! bv (lambda (x y) (- x y)))

;; Let's see what the sorted array looks like:
(bytevector-&gt;u8-list bv)
⇒ (0 1 2 3 4 5 7 9 77 127)
</pre></div>

<p>And voilà!
</p>
<p>Note that <code class="code">procedure-&gt;pointer</code> is not supported (and not defined)
on a few exotic architectures.  Thus, user code may need to check
<code class="code">(defined? 'procedure-&gt;pointer)</code>.  Nevertheless, it is available on
many architectures, including (as of libffi 3.0.9) x86, ia64, SPARC,
PowerPC, ARM, and MIPS, to name a few.
</p>

<hr>
</div>
</div>
<div class="section-level-extent" id="Foreign-Objects">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Smobs" accesskey="n" rel="next">Smobs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Function-Interface" accesskey="p" rel="prev">Foreign Function Interface</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Foreign-Objects-1">6.20 Foreign Objects</h3>

<a class="index-entry-id" id="index-foreign-object"></a>

<p>This chapter contains reference information related to defining and
working with foreign objects.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Defining-New-Foreign-Object-Types">Defining New Foreign Object Types</a>,
for a tutorial-like introduction to foreign objects.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-scm_005ft_005fstruct_005ffinalize"><span class="category-def">C Type: </span><span><strong class="def-name">scm_t_struct_finalize</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ft_005fstruct_005ffinalize"> ¶</a></span></dt>
<dd><p>This function type returns <code class="code">void</code> and takes one <code class="code">SCM</code>
argument.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005ftype"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_type</strong> <code class="def-code-arguments">(SCM name, SCM slots, scm_t_struct_finalize finalizer)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005ftype"> ¶</a></span></dt>
<dd><p>Create a fresh foreign object type.  <var class="var">name</var> is a symbol naming the
type.  <var class="var">slots</var> is a list of symbols, each one naming a field in the
foreign object type.  <var class="var">finalizer</var> indicates the finalizer, and may
be <code class="code">NULL</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-finalizer-1"></a>
<a class="index-entry-id" id="index-finalization-1"></a>

<p>We recommend that finalizers be avoided if possible.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>.  Finalizers must be async-safe and
thread-safe.  Again, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>.  If you
are embedding Guile in an application that is not thread-safe, and you
define foreign object types that need finalization, you might want to
disable automatic finalization, and arrange to call
<code class="code">scm_manually_run_finalizers ()</code> yourself.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fautomatic_005ffinalization_005fenabled"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_set_automatic_finalization_enabled</strong> <code class="def-code-arguments">(int enabled_p)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fautomatic_005ffinalization_005fenabled"> ¶</a></span></dt>
<dd><p>Enable or disable automatic finalization.  By default, Guile arranges to
invoke object finalizers automatically, in a separate thread if
possible.  Passing a zero value for <var class="var">enabled_p</var> will disable
automatic finalization for Guile as a whole.  If you disable automatic
finalization, you will have to call <code class="code">scm_run_finalizers ()</code>
periodically.
</p>
<p>Unlike most other Guile functions, you can call
<code class="code">scm_set_automatic_finalization_enabled</code> before Guile has been
initialized.
</p>
<p>Return the previous status of automatic finalization.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005frun_005ffinalizers"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_run_finalizers</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frun_005ffinalizers"> ¶</a></span></dt>
<dd><p>Invoke any pending finalizers.  Returns the number of finalizers that
were invoked.  This function should be called when automatic
finalization is disabled, though it may be called if it is enabled as
well.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fassert_005fforeign_005fobject_005ftype"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_assert_foreign_object_type</strong> <code class="def-code-arguments">(SCM type, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassert_005fforeign_005fobject_005ftype"> ¶</a></span></dt>
<dd><p>When <var class="var">val</var> is a foreign object of the given <var class="var">type</var>, do nothing.
Otherwise, signal an error.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005f0"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_0</strong> <code class="def-code-arguments">(SCM type)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005f0"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005f1"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_1</strong> <code class="def-code-arguments">(SCM type, void *val0)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005f1"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005f2"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_2</strong> <code class="def-code-arguments">(SCM type, void *val0, void *val1)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005f2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005f3"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_3</strong> <code class="def-code-arguments">(SCM type, void *val0, void *val1, void *val2)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005f3"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fmake_005fforeign_005fobject_005fn"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_make_foreign_object_n</strong> <code class="def-code-arguments">(SCM type, size_t n, void *vals[])</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fforeign_005fobject_005fn"> ¶</a></span></dt>
<dd><p>Make a new foreign object of the type with type <var class="var">type</var> and
initialize the first <var class="var">n</var> fields to the given values, as appropriate.
</p>
<p>The number of fields for objects of a given type is fixed when the type
is created.  It is an error to give more initializers than there are
fields in the value.  It is perfectly fine to give fewer initializers
than needed; this is convenient when some fields are of non-pointer
types, and would be easier to initialize with the setters described
below.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fforeign_005fobject_005fref"><span class="category-def">C Function: </span><span><code class="def-type">void*</code> <strong class="def-name">scm_foreign_object_ref</strong> <code class="def-code-arguments">(SCM obj, size_t n);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005fref"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fforeign_005fobject_005funsigned_005fref"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">scm_foreign_object_unsigned_ref</strong> <code class="def-code-arguments">(SCM obj, size_t n);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005funsigned_005fref"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fforeign_005fobject_005fsigned_005fref"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_signed_bits</code> <strong class="def-name">scm_foreign_object_signed_ref</strong> <code class="def-code-arguments">(SCM obj, size_t n);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005fsigned_005fref"> ¶</a></span></dt>
<dd><p>Return the value of the <var class="var">n</var>th field of the foreign object <var class="var">obj</var>.
The backing store for the fields is as wide as a <code class="code">scm_t_bits</code>
value, which is at least as wide as a pointer.  The different variants
handle casting in a portable way.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fforeign_005fobject_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_foreign_object_set_x</strong> <code class="def-code-arguments">(SCM obj, size_t n, void *val);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005fset_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fforeign_005fobject_005funsigned_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_foreign_object_unsigned_set_x</strong> <code class="def-code-arguments">(SCM obj, size_t n, scm_t_bits val);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005funsigned_005fset_005fx"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fforeign_005fobject_005fsigned_005fset_005fx"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_foreign_object_signed_set_x</strong> <code class="def-code-arguments">(SCM obj, size_t n, scm_t_signed_bits val);</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fforeign_005fobject_005fsigned_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the value of the <var class="var">n</var>th field of the foreign object <var class="var">obj</var> to
<var class="var">val</var>, after portably converting to a <code class="code">scm_t_bits</code> value, if
needed.
</p></dd></dl>

<p>One can also access foreign objects from Scheme.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects-and-Scheme">Foreign Objects and Scheme</a>, for some examples.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system foreign-object))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dforeign_002dobject_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-foreign-object-type</strong> <var class="def-var-arguments">name slots [#:finalizer=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dforeign_002dobject_002dtype"> ¶</a></span></dt>
<dd><p>Make a new foreign object type.  See the above documentation for
<code class="code">scm_make_foreign_object_type</code>; these functions are exactly
equivalent, except for the way in which the finalizer gets attached to
instances (an internal detail).
</p>
<p>The resulting value is a GOOPS class.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS">GOOPS</a>, for more on classes
in Guile.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-define_002dforeign_002dobject_002dtype"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-foreign-object-type</strong> <var class="def-var-arguments">name constructor (slot ...) [#:finalizer=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dforeign_002dobject_002dtype"> ¶</a></span></dt>
<dd><p>A convenience macro to define a type, using
<code class="code">make-foreign-object-type</code>, and bind it to <var class="var">name</var>.  A
constructor will be bound to <var class="var">constructor</var>, and getters will be
bound to each of <var class="var">slot...</var>.
</p></dd></dl>


<hr>
</div>
<div class="section-level-extent" id="Smobs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="n" rel="next">Threads, Mutexes, Asyncs and Dynamic Roots</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects" accesskey="p" rel="prev">Foreign Objects</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Smobs-1">6.21 Smobs</h3>

<a class="index-entry-id" id="index-smob"></a>

<p>A <em class="dfn">smob</em> is a “small object”.  Before foreign objects were
introduced in Guile 2.0.12 (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a>), smobs were the
preferred way to for C code to define new kinds of Scheme objects.  With
the exception of the so-called “applicable SMOBs” discussed below,
smobs are now a legacy interface and are headed for eventual
deprecation.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Deprecation">Deprecation</a>.  New code should use the foreign
object interface.
</p>
<p>This section contains reference information related to defining and
working with smobs.  For a tutorial-like introduction to smobs, see
“Defining New Types (Smobs)” in previous versions of this manual.
</p>
<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fmake_005fsmob_005ftype"><span class="category-def">Function: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">scm_make_smob_type</strong> <code class="def-code-arguments">(const char *name, size_t size)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fsmob_005ftype"> ¶</a></span></dt>
<dd><p>This function adds a new smob type, named <var class="var">name</var>, with instance size
<var class="var">size</var>, to the system.  The return value is a tag that is used in
creating instances of the type.
</p>
<p>If <var class="var">size</var> is 0, the default <em class="emph">free</em> function will do nothing.
</p>
<p>If <var class="var">size</var> is not 0, the default <em class="emph">free</em> function will
deallocate the memory block pointed to by <code class="code">SCM_SMOB_DATA</code> with
<code class="code">scm_gc_free</code>.  The <var class="var">what</var> parameter in the call to
<code class="code">scm_gc_free</code> will be <var class="var">name</var>.
</p>
<p>Default values are provided for the <em class="emph">mark</em>, <em class="emph">free</em>,
<em class="emph">print</em>, and <em class="emph">equalp</em> functions.  If you want to customize any
of these functions, the call to <code class="code">scm_make_smob_type</code> should be
immediately followed by calls to one or several of
<code class="code">scm_set_smob_mark</code>, <code class="code">scm_set_smob_free</code>,
<code class="code">scm_set_smob_print</code>, and/or <code class="code">scm_set_smob_equalp</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-finalizer-2"></a>
<a class="index-entry-id" id="index-finalization-2"></a>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fsmob_005ffree"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_smob_free</strong> <code class="def-code-arguments">(scm_t_bits tc, size_t (*free) (SCM obj))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsmob_005ffree"> ¶</a></span></dt>
<dd><p>This function sets the smob freeing procedure (sometimes referred to as
a <em class="dfn">finalizer</em>) for the smob type specified by the tag
<var class="var">tc</var>. <var class="var">tc</var> is the tag returned by <code class="code">scm_make_smob_type</code>.
</p>
<p>The <var class="var">free</var> procedure must deallocate all resources that are
directly associated with the smob instance <var class="var">obj</var>.  It must assume
that all <code class="code">SCM</code> values that it references have already been freed
and are thus invalid.
</p>
<p>It must also not call any libguile function or macro except
<code class="code">scm_gc_free</code>, <code class="code">SCM_SMOB_FLAGS</code>, <code class="code">SCM_SMOB_DATA</code>,
<code class="code">SCM_SMOB_DATA_2</code>, and <code class="code">SCM_SMOB_DATA_3</code>.
</p>
<p>The <var class="var">free</var> procedure must return 0.
</p>
<p>Note that defining a freeing procedure is not necessary if the resources
associated with <var class="var">obj</var> consists only of memory allocated with
<code class="code">scm_gc_malloc</code> or <code class="code">scm_gc_malloc_pointerless</code> because this
memory is automatically reclaimed by the garbage collector when it is no
longer needed (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Memory-Blocks"><code class="code">scm_gc_malloc</code></a>).
</p></dd></dl>

<p>Smob free functions must be thread-safe.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>, for a discussion on finalizers and concurrency.  If you are
embedding Guile in an application that is not thread-safe, and you
define smob types that need finalization, you might want to disable
automatic finalization, and arrange to call
<code class="code">scm_manually_run_finalizers ()</code> yourself.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Objects">Foreign Objects</a>.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fsmob_005fmark"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_smob_mark</strong> <code class="def-code-arguments">(scm_t_bits tc, SCM (*mark) (SCM obj))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsmob_005fmark"> ¶</a></span></dt>
<dd><p>This function sets the smob marking procedure for the smob type specified by
the tag <var class="var">tc</var>. <var class="var">tc</var> is the tag returned by <code class="code">scm_make_smob_type</code>.
</p>
<p>Defining a marking procedure is almost always the wrong thing to do.  It
is much, much preferable to allocate smob data with the
<code class="code">scm_gc_malloc</code> and <code class="code">scm_gc_malloc_pointerless</code> functions, and
allow the GC to trace pointers automatically.
</p>
<p>Any mark procedures you see currently almost surely date from the time
of Guile 1.8, before the switch to the Boehm-Demers-Weiser collector.
Such smob implementations should be changed to just use
<code class="code">scm_gc_malloc</code> and friends, and to lose their mark function.
</p>
<p>If you decide to keep the mark function, note that it may be called on
objects that are on the free list.  Please read and digest the comments
from the BDW GC’s <code class="code">gc/gc_mark.h</code> header.
</p>
<p>The <var class="var">mark</var> procedure must cause <code class="code">scm_gc_mark</code> to be called
for every <code class="code">SCM</code> value that is directly referenced by the smob
instance <var class="var">obj</var>.  One of these <code class="code">SCM</code> values can be returned
from the procedure and Guile will call <code class="code">scm_gc_mark</code> for it.
This can be used to avoid deep recursions for smob instances that form
a list.
</p>
<p>It must not call any libguile function or macro except
<code class="code">scm_gc_mark</code>, <code class="code">SCM_SMOB_FLAGS</code>, <code class="code">SCM_SMOB_DATA</code>,
<code class="code">SCM_SMOB_DATA_2</code>, and <code class="code">SCM_SMOB_DATA_3</code>.
</p></dd></dl>


<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fsmob_005fprint"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_smob_print</strong> <code class="def-code-arguments">(scm_t_bits tc, int (*print) (SCM obj, SCM port, scm_print_state* pstate))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsmob_005fprint"> ¶</a></span></dt>
<dd><p>This function sets the smob printing procedure for the smob type
specified by the tag <var class="var">tc</var>. <var class="var">tc</var> is the tag returned by
<code class="code">scm_make_smob_type</code>.
</p>
<p>The <var class="var">print</var> procedure should output a textual representation of
the smob instance <var class="var">obj</var> to <var class="var">port</var>, using information in
<var class="var">pstate</var>.
</p>
<p>The textual representation should be of the form <code class="code">#&lt;name ...&gt;</code>.
This ensures that <code class="code">read</code> will not interpret it as some other
Scheme value.
</p>
<p>It is often best to ignore <var class="var">pstate</var> and just print to <var class="var">port</var>
with <code class="code">scm_display</code>, <code class="code">scm_write</code>, <code class="code">scm_simple_format</code>,
and <code class="code">scm_puts</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fsmob_005fequalp"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_smob_equalp</strong> <code class="def-code-arguments">(scm_t_bits tc, SCM (*equalp) (SCM obj1, SCM obj2))</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsmob_005fequalp"> ¶</a></span></dt>
<dd><p>This function sets the smob equality-testing predicate for the smob
type specified by the tag <var class="var">tc</var>. <var class="var">tc</var> is the tag returned by
<code class="code">scm_make_smob_type</code>.
</p>
<p>The <var class="var">equalp</var> procedure should return <code class="code">SCM_BOOL_T</code> when
<var class="var">obj1</var> is <code class="code">equal?</code> to <var class="var">obj2</var>.  Else it should return
<code class="code">SCM_BOOL_F</code>.  Both <var class="var">obj1</var> and <var class="var">obj2</var> are instances of the
smob type <var class="var">tc</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fassert_005fsmob_005ftype"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_assert_smob_type</strong> <code class="def-code-arguments">(scm_t_bits tag, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fassert_005fsmob_005ftype"> ¶</a></span></dt>
<dd><p>When <var class="var">val</var> is a smob of the type indicated by <var class="var">tag</var>, do nothing.
Else, signal an error.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSMOB_005fPREDICATE"><span class="category-def">C Macro: </span><span><code class="def-type">int</code> <strong class="def-name">SCM_SMOB_PREDICATE</strong> <code class="def-code-arguments">(scm_t_bits tag, SCM exp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fPREDICATE"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">exp</var> is a smob instance of the type indicated by
<var class="var">tag</var>, or false otherwise.  The expression <var class="var">exp</var> can be
evaluated more than once, so it shouldn’t contain any side effects.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fnew_005fsmob"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_new_smob</strong> <code class="def-code-arguments">(scm_t_bits tag, void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnew_005fsmob"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fnew_005fdouble_005fsmob"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_new_double_smob</strong> <code class="def-code-arguments">(scm_t_bits tag, void *data, void *data2, void *data3)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnew_005fdouble_005fsmob"> ¶</a></span></dt>
<dd><p>Make a new smob of the type with tag <var class="var">tag</var> and smob data <var class="var">data</var>,
<var class="var">data2</var>, and <var class="var">data3</var>, as appropriate.
</p>
<p>The <var class="var">tag</var> is what has been returned by <code class="code">scm_make_smob_type</code>.
The initial values <var class="var">data</var>, <var class="var">data2</var>, and <var class="var">data3</var> are of
type <code class="code">scm_t_bits</code>; when you want to use them for <code class="code">SCM</code>
values, these values need to be converted to a <code class="code">scm_t_bits</code> first
by using <code class="code">SCM_UNPACK</code>.
</p>
<p>The flags of the smob instance start out as zero.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSMOB_005fFLAGS"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_SMOB_FLAGS</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fFLAGS"> ¶</a></span></dt>
<dd><p>Return the 16 extra bits of the smob <var class="var">obj</var>.  No meaning is
predefined for these bits, you can use them freely.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSET_005fSMOB_005fFLAGS"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_SET_SMOB_FLAGS</strong> <code class="def-code-arguments">(SCM obj, scm_t_bits flags)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fFLAGS"> ¶</a></span></dt>
<dd><p>Set the 16 extra bits of the smob <var class="var">obj</var> to <var class="var">flags</var>.  No
meaning is predefined for these bits, you can use them freely.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSMOB_005fDATA"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_SMOB_DATA</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fDATA"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fDATA_005f2"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_SMOB_DATA_2</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fDATA_005f2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fDATA_005f3"><span class="category-def">C Macro: </span><span><code class="def-type">scm_t_bits</code> <strong class="def-name">SCM_SMOB_DATA_3</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fDATA_005f3"> ¶</a></span></dt>
<dd><p>Return the first (second, third) immediate word of the smob <var class="var">obj</var>
as a <code class="code">scm_t_bits</code> value.  When the word contains a <code class="code">SCM</code>
value, use <code class="code">SCM_SMOB_OBJECT</code> (etc.) instead.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSET_005fSMOB_005fDATA"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_DATA</strong> <code class="def-code-arguments">(SCM obj, scm_t_bits val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fDATA"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSET_005fSMOB_005fDATA_005f2"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_DATA_2</strong> <code class="def-code-arguments">(SCM obj, scm_t_bits val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fDATA_005f2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSET_005fSMOB_005fDATA_005f3"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_DATA_3</strong> <code class="def-code-arguments">(SCM obj, scm_t_bits val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fDATA_005f3"> ¶</a></span></dt>
<dd><p>Set the first (second, third) immediate word of the smob <var class="var">obj</var> to
<var class="var">val</var>.  When the word should be set to a <code class="code">SCM</code> value, use
<code class="code">SCM_SMOB_SET_OBJECT</code> (etc.) instead.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSMOB_005fOBJECT"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_SMOB_OBJECT</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fOBJECT_005f2"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_SMOB_OBJECT_2</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT_005f2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fOBJECT_005f3"><span class="category-def">C Macro: </span><span><code class="def-type">SCM</code> <strong class="def-name">SCM_SMOB_OBJECT_3</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT_005f3"> ¶</a></span></dt>
<dd><p>Return the first (second, third) immediate word of the smob <var class="var">obj</var>
as a <code class="code">SCM</code> value.  When the word contains a <code class="code">scm_t_bits</code>
value, use <code class="code">SCM_SMOB_DATA</code> (etc.) instead.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSET_005fSMOB_005fOBJECT"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_OBJECT</strong> <code class="def-code-arguments">(SCM obj, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fOBJECT"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSET_005fSMOB_005fOBJECT_005f2"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_OBJECT_2</strong> <code class="def-code-arguments">(SCM obj, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fOBJECT_005f2"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSET_005fSMOB_005fOBJECT_005f3"><span class="category-def">C Macro: </span><span><code class="def-type">void</code> <strong class="def-name">SCM_SET_SMOB_OBJECT_3</strong> <code class="def-code-arguments">(SCM obj, SCM val)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSET_005fSMOB_005fOBJECT_005f3"> ¶</a></span></dt>
<dd><p>Set the first (second, third) immediate word of the smob <var class="var">obj</var> to
<var class="var">val</var>.  When the word should be set to a <code class="code">scm_t_bits</code> value, use
<code class="code">SCM_SMOB_SET_DATA</code> (etc.) instead.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-SCM_005fSMOB_005fOBJECT_005fLOC"><span class="category-def">C Macro: </span><span><code class="def-type">SCM *</code> <strong class="def-name">SCM_SMOB_OBJECT_LOC</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT_005fLOC"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fOBJECT_005f2_005fLOC"><span class="category-def">C Macro: </span><span><code class="def-type">SCM *</code> <strong class="def-name">SCM_SMOB_OBJECT_2_LOC</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT_005f2_005fLOC"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-SCM_005fSMOB_005fOBJECT_005f3_005fLOC"><span class="category-def">C Macro: </span><span><code class="def-type">SCM *</code> <strong class="def-name">SCM_SMOB_OBJECT_3_LOC</strong> <code class="def-code-arguments">(SCM obj)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SCM_005fSMOB_005fOBJECT_005f3_005fLOC"> ¶</a></span></dt>
<dd><p>Return a pointer to the first (second, third) immediate word of the
smob <var class="var">obj</var>.  Note that this is a pointer to <code class="code">SCM</code>.  If you
need to work with <code class="code">scm_t_bits</code> values, use <code class="code">SCM_PACK</code> and
<code class="code">SCM_UNPACK</code>, as appropriate.
</p></dd></dl>

<dl class="first-deftypefn first-deftypefun-alias-first-deftypefn">
<dt class="deftypefn deftypefun-alias-deftypefn" id="index-scm_005fmarkcdr"><span class="category-def">Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_markcdr</strong> <code class="def-code-arguments">(SCM <var class="var">x</var>)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmarkcdr"> ¶</a></span></dt>
<dd><p>Mark the references in the smob <var class="var">x</var>, assuming that <var class="var">x</var>’s first
data word contains an ordinary Scheme object, and <var class="var">x</var> refers to no
other objects.  This function simply returns <var class="var">x</var>’s first data word.
</p></dd></dl>


<hr>
</div>
<div class="section-level-extent" id="Scheduling">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config" accesskey="n" rel="next">Configuration, Features and Runtime Options</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Smobs" accesskey="p" rel="prev">Smobs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Threads_002c-Mutexes_002c-Asyncs-and-Dynamic-Roots">6.22 Threads, Mutexes, Asyncs and Dynamic Roots</h3>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Threads" accesskey="1">Threads</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Thread-Local-Variables" accesskey="2">Thread-Local Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs" accesskey="3">Asynchronous Interrupts</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Atomics" accesskey="4">Atomics</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables" accesskey="5">Mutexes and Condition Variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Blocking" accesskey="6">Blocking in Guile Mode</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Futures" accesskey="7">Futures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Forms" accesskey="8">Parallel forms</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Threads">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Thread-Local-Variables" accesskey="n" rel="next">Thread-Local Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Threads-1">6.22.1 Threads</h4>
<a class="index-entry-id" id="index-threads"></a>
<a class="index-entry-id" id="index-Guile-threads"></a>
<a class="index-entry-id" id="index-POSIX-threads"></a>

<p>Guile supports POSIX threads, unless it was configured with
<code class="code">--without-threads</code> or the host lacks POSIX thread support.  When
thread support is available, the <code class="code">threads</code> feature is provided
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Manipulation"><code class="code">provided?</code></a>).
</p>
<p>The procedures below manipulate Guile threads, which are wrappers around
the system’s POSIX threads.  For application-level parallelism, using
higher-level constructs, such as futures, is recommended
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Futures">Futures</a>).
</p>
<p>To use these facilities, load the <code class="code">(ice-9 threads)</code> module.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 threads))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-all_002dthreads"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">all-threads</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-all_002dthreads"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fall_005fthreads"><span class="category-def">C Function: </span><span><strong class="def-name">scm_all_threads</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fall_005fthreads"> ¶</a></span></dt>
<dd><p>Return a list of all threads.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dthread"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-thread</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dthread"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005fthread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_thread</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005fthread"> ¶</a></span></dt>
<dd><p>Return the thread that called this function.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dnew_002dthread"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-new-thread</strong> <var class="def-var-arguments">thunk [handler]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dnew_002dthread"> ¶</a></span></dt>
<dd><p>Call <code class="code">thunk</code> in a new thread and with a new dynamic state,
returning the new thread.  The procedure <var class="var">thunk</var> is called via
<code class="code">with-continuation-barrier</code>.
</p>
<p>When <var class="var">handler</var> is specified, then <var class="var">thunk</var> is called from
within a <code class="code">catch</code> with tag <code class="code">#t</code> that has <var class="var">handler</var> as its
handler.  This catch is established inside the continuation barrier.
</p>
<p>Once <var class="var">thunk</var> or <var class="var">handler</var> returns, the return value is made
the <em class="emph">exit value</em> of the thread and the thread is terminated.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fspawn_005fthread"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_spawn_thread</strong> <code class="def-code-arguments">(scm_t_catch_body body, void *body_data, scm_t_catch_handler handler, void *handler_data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fspawn_005fthread"> ¶</a></span></dt>
<dd><p>Call <var class="var">body</var> in a new thread, passing it <var class="var">body_data</var>, returning
the new thread.  The function <var class="var">body</var> is called via
<code class="code">scm_c_with_continuation_barrier</code>.
</p>
<p>When <var class="var">handler</var> is non-<code class="code">NULL</code>, <var class="var">body</var> is called via
<code class="code">scm_internal_catch</code> with tag <code class="code">SCM_BOOL_T</code> that has
<var class="var">handler</var> and <var class="var">handler_data</var> as the handler and its data.  This
catch is established inside the continuation barrier.
</p>
<p>Once <var class="var">body</var> or <var class="var">handler</var> returns, the return value is made the
<em class="emph">exit value</em> of the thread and the thread is terminated.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-thread_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">thread?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fthread_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_thread_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fthread_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> ff <var class="var">obj</var> is a thread; otherwise, return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-join_002dthread"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">join-thread</strong> <var class="def-var-arguments">thread [timeout [timeoutval]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-join_002dthread"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fjoin_005fthread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_join_thread</strong> <var class="def-var-arguments">(thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fjoin_005fthread"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fjoin_005fthread_005ftimed"><span class="category-def">C Function: </span><span><strong class="def-name">scm_join_thread_timed</strong> <var class="def-var-arguments">(thread, timeout, timeoutval)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fjoin_005fthread_005ftimed"> ¶</a></span></dt>
<dd><p>Wait for <var class="var">thread</var> to terminate and return its exit value.  Only
threads that were created with <code class="code">call-with-new-thread</code> or
<code class="code">scm_spawn_thread</code> can be joinable; attempting to join a foreign
thread will raise an error.
</p>
<p>When <var class="var">timeout</var> is given, it specifies a point in time where the
waiting should be aborted.  It can be either an integer as returned by
<code class="code">current-time</code> or a pair as returned by <code class="code">gettimeofday</code>.  When
the waiting is aborted, <var class="var">timeoutval</var> is returned (if it is
specified; <code class="code">#f</code> is returned otherwise).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-thread_002dexited_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">thread-exited?</strong> <var class="def-var-arguments">thread</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dexited_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fthread_005fexited_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_thread_exited_p</strong> <var class="def-var-arguments">(thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fthread_005fexited_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">thread</var> has exited, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-yield"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">yield</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-yield"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fyield"><span class="category-def">C Function: </span><span><strong class="def-name">scm_yield</strong> <var class="def-var-arguments">(thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fyield"> ¶</a></span></dt>
<dd><p>If one or more threads are waiting to execute, calling yield forces an
immediate context switch to one of them. Otherwise, yield has no effect.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-cancel_002dthread"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cancel-thread</strong> <var class="def-var-arguments">thread . values</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cancel_002dthread"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcancel_005fthread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cancel_thread</strong> <var class="def-var-arguments">(thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcancel_005fthread"> ¶</a></span></dt>
<dd><p>Asynchronously interrupt <var class="var">thread</var> and ask it to terminate.
<code class="code">dynamic-wind</code> post thunks will run, but throw handlers will not.
If <var class="var">thread</var> has already terminated or been signaled to terminate,
this function is a no-op.  Calling <code class="code">join-thread</code> on the thread will
return the given <var class="var">values</var>, if the cancel succeeded.
</p>
<p>Under the hood, thread cancellation uses <code class="code">system-async-mark</code> and
<code class="code">abort-to-prompt</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a> for more on asynchronous
interrupts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dthread"><span class="category-def">macro: </span><span><strong class="def-name">make-thread</strong> <var class="def-var-arguments">proc arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dthread"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to <var class="var">arg</var> … in a new thread formed by
<code class="code">call-with-new-thread</code> using a default error handler that displays
the error to the current error port.  The <var class="var">arg</var> …
expressions are evaluated in the new thread.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-begin_002dthread"><span class="category-def">macro: </span><span><strong class="def-name">begin-thread</strong> <var class="def-var-arguments">expr1 expr2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-begin_002dthread"> ¶</a></span></dt>
<dd><p>Evaluate forms <var class="var">expr1</var> <var class="var">expr2</var> … in a new thread formed by
<code class="code">call-with-new-thread</code> using a default error handler that displays
the error to the current error port.
</p></dd></dl>

<p>One often wants to limit the number of threads running to be
proportional to the number of available processors.  These interfaces
are therefore exported by (ice-9 threads) as well.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-total_002dprocessor_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">total-processor-count</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-total_002dprocessor_002dcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftotal_005fprocessor_005fcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_total_processor_count</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftotal_005fprocessor_005fcount"> ¶</a></span></dt>
<dd><p>Return the total number of processors of the machine, which
is guaranteed to be at least 1.  A “processor” here is a
thread execution unit, which can be either:
</p>
<ul class="itemize mark-bullet">
<li>an execution core in a (possibly multi-core) chip, in a
  (possibly multi- chip) module, in a single computer, or
</li><li>a thread execution unit inside a core in the case of
  <em class="dfn">hyper-threaded</em> CPUs.
</li></ul>

<p>Which of the two definitions is used, is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dprocessor_002dcount"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-processor-count</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dprocessor_002dcount"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005fprocessor_005fcount"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_processor_count</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005fprocessor_005fcount"> ¶</a></span></dt>
<dd><p>Like <code class="code">total-processor-count</code>, but return the number of
processors available to the current process.  See
<code class="code">setaffinity</code> and <code class="code">getaffinity</code> for more
information.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Thread-Local-Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs" accesskey="n" rel="next">Asynchronous Interrupts</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Threads" accesskey="p" rel="prev">Threads</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Thread_002dLocal-Variables">6.22.2 Thread-Local Variables</h4>

<p>Sometimes you want to establish a variable binding that is only valid
for a given thread: a “thread-local variable”.
</p>
<p>You would think that fluids or parameters would be Guile’s answer for
thread-local variables, since establishing a new fluid binding doesn’t
affect bindings in other threads.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a>, or
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Parameters">Parameters</a>.  However, new threads inherit the fluid bindings that
were in place in their creator threads.  In this way, a binding
established using a fluid (or a parameter) in a thread can escape to
other threads, which might not be what you want.  Or, it might escape
via explicit reification via <code class="code">current-dynamic-state</code>.
</p>
<p>Of course, this dynamic scoping might be exactly what you want; that’s
why fluids and parameters work this way, and is what you want for for
many common parameters such as the current input and output ports, the
current locale conversion parameters, and the like.  Perhaps this is the
case for most parameters, even.  If your use case for thread-local
bindings comes from a desire to isolate a binding from its setting in
unrelated threads, then fluids and parameters apply nicely.
</p>
<p>On the other hand, if your use case is to prevent concurrent access to a
value from multiple threads, then using vanilla fluids or parameters is
not appropriate.  For this purpose, Guile has <em class="dfn">thread-local fluids</em>.
A fluid created with <code class="code">make-thread-local-fluid</code> won’t be captured by
<code class="code">current-dynamic-state</code> and won’t be propagated to new threads.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dthread_002dlocal_002dfluid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-thread-local-fluid</strong> <var class="def-var-arguments">[dflt]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dthread_002dlocal_002dfluid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fthread_005flocal_005ffluid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_thread_local_fluid</strong> <var class="def-var-arguments">(dflt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fthread_005flocal_005ffluid"> ¶</a></span></dt>
<dd><p>Return a newly created fluid, whose initial value is <var class="var">dflt</var>, or
<code class="code">#f</code> if <var class="var">dflt</var> is not given.  Unlike fluids made with
<code class="code">make-fluid</code>, thread local fluids are not captured by
<code class="code">make-dynamic-state</code>.  Similarly, a newly spawned child thread does
not inherit thread-local fluid values from the parent thread.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fluid_002dthread_002dlocal_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fluid-thread-local?</strong> <var class="def-var-arguments">fluid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fluid_002dthread_002dlocal_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffluid_005fthread_005flocal_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fluid_thread_local_p</strong> <var class="def-var-arguments">(fluid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffluid_005fthread_005flocal_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the fluid <var class="var">fluid</var> is is thread-local, or
<code class="code">#f</code> otherwise.
</p></dd></dl>

<p>For example:
</p>
<div class="example">
<pre class="example-preformatted">(define %thread-local (make-thread-local-fluid))

(with-fluids ((%thread-local (compute-data)))
  ... (fluid-ref %thread-local) ...)
</pre></div>

<p>You can also make a thread-local parameter out of a thread-local fluid
using the normal <code class="code">fluid-&gt;parameter</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define param (fluid-&gt;parameter (make-thread-local-fluid)))

(parameterize ((param (compute-data)))
  ... (param) ...)
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="Asyncs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Atomics" accesskey="n" rel="next">Atomics</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Thread-Local-Variables" accesskey="p" rel="prev">Thread-Local Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Asynchronous-Interrupts">6.22.3 Asynchronous Interrupts</h4>

<a class="index-entry-id" id="index-asyncs"></a>
<a class="index-entry-id" id="index-asynchronous-interrupts"></a>
<a class="index-entry-id" id="index-interrupts"></a>

<p>Every Guile thread can be interrupted.  Threads running Guile code will
periodically check if there are pending interrupts and run them if
necessary.  To interrupt a thread, call <code class="code">system-async-mark</code> on that
thread.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-system_002dasync_002dmark"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">system-async-mark</strong> <var class="def-var-arguments">proc [thread]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-system_002dasync_002dmark"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsystem_005fasync_005fmark"><span class="category-def">C Function: </span><span><strong class="def-name">scm_system_async_mark</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsystem_005fasync_005fmark"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsystem_005fasync_005fmark_005ffor_005fthread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_system_async_mark_for_thread</strong> <var class="def-var-arguments">(proc, thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsystem_005fasync_005fmark_005ffor_005fthread"> ¶</a></span></dt>
<dd><p>Enqueue <var class="var">proc</var> (a procedure with zero arguments) for future
execution in <var class="var">thread</var>.  When <var class="var">proc</var> has already been enqueued
for <var class="var">thread</var> but has not been executed yet, this call has no effect.
When <var class="var">thread</var> is omitted, the thread that called
<code class="code">system-async-mark</code> is used.
</p></dd></dl>

<p>Note that <code class="code">scm_system_async_mark_for_thread</code> is not
“async-signal-safe” and so cannot be called from a C signal handler.
(Indeed in general, <code class="code">libguile</code> functions are not safe to call from
C signal handlers.)
</p>
<p>Though an interrupt procedure can have any side effect permitted to
Guile code, asynchronous interrupts are generally used either for
profiling or for prematurely cancelling a computation.  The former case
is mostly transparent to the program being run, by design, but the
latter case can introduce bugs.  Like finalizers (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>), asynchronous interrupts introduce concurrency in a
program.  An asyncronous interrupt can run in the middle of some
mutex-protected operation, for example, and potentially corrupt the
program’s state.
</p>
<p>If some bit of Guile code needs to temporarily inhibit interrupts, it
can use <code class="code">call-with-blocked-asyncs</code>.  This function works by
temporarily increasing the <em class="emph">async blocking level</em> of the current
thread while a given procedure is running.  The blocking level starts
out at zero, and whenever a safe point is reached, a blocking level
greater than zero will prevent the execution of queued asyncs.
</p>
<p>Analogously, the procedure <code class="code">call-with-unblocked-asyncs</code> will
temporarily decrease the blocking level of the current thread.  You
can use it when you want to disable asyncs by default and only allow
them temporarily.
</p>
<p>In addition to the C versions of <code class="code">call-with-blocked-asyncs</code> and
<code class="code">call-with-unblocked-asyncs</code>, C code can use
<code class="code">scm_dynwind_block_asyncs</code> and <code class="code">scm_dynwind_unblock_asyncs</code>
inside a <em class="dfn">dynamic context</em> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>) to block or
unblock asyncs temporarily.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dblocked_002dasyncs"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-blocked-asyncs</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dblocked_002dasyncs"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005fwith_005fblocked_005fasyncs"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_with_blocked_asyncs</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005fwith_005fblocked_005fasyncs"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> and block the execution of asyncs by one level for the
current thread while it is running.  Return the value returned by
<var class="var">proc</var>.  For the first two variants, call <var class="var">proc</var> with no
arguments; for the third, call it with <var class="var">data</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fcall_005fwith_005fblocked_005fasyncs"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_c_call_with_blocked_asyncs</strong> <code class="def-code-arguments">(void * (*proc) (void *data), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fcall_005fwith_005fblocked_005fasyncs"> ¶</a></span></dt>
<dd><p>The same but with a C function <var class="var">proc</var> instead of a Scheme thunk.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dunblocked_002dasyncs"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-unblocked-asyncs</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dunblocked_002dasyncs"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcall_005fwith_005funblocked_005fasyncs"><span class="category-def">C Function: </span><span><strong class="def-name">scm_call_with_unblocked_asyncs</strong> <var class="def-var-arguments">(proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcall_005fwith_005funblocked_005fasyncs"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> and unblock the execution of asyncs by one level for the
current thread while it is running.  Return the value returned by
<var class="var">proc</var>.  For the first two variants, call <var class="var">proc</var> with no
arguments; for the third, call it with <var class="var">data</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fcall_005fwith_005funblocked_005fasyncs"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_c_call_with_unblocked_asyncs</strong> <code class="def-code-arguments">(void *(*proc) (void *data), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fcall_005fwith_005funblocked_005fasyncs"> ¶</a></span></dt>
<dd><p>The same but with a C function <var class="var">proc</var> instead of a Scheme thunk.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005fblock_005fasyncs"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_block_asyncs</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005fblock_005fasyncs"> ¶</a></span></dt>
<dd><p>During the current dynwind context, increase the blocking of asyncs by
one level.  This function must be used inside a pair of calls to
<code class="code">scm_dynwind_begin</code> and <code class="code">scm_dynwind_end</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005funblock_005fasyncs"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_unblock_asyncs</strong> <code class="def-code-arguments">()</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005funblock_005fasyncs"> ¶</a></span></dt>
<dd><p>During the current dynwind context, decrease the blocking of asyncs by
one level.  This function must be used inside a pair of calls to
<code class="code">scm_dynwind_begin</code> and <code class="code">scm_dynwind_end</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>).
</p></dd></dl>

<p>Sometimes you want to interrupt a thread that might be waiting for
something to happen, for example on a file descriptor or a condition
variable.  In that case you can inform Guile of how to interrupt that
wait using the following procedures:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fprepare_005fto_005fwait_005fon_005ffd"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_c_prepare_to_wait_on_fd</strong> <code class="def-code-arguments">(int fd)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprepare_005fto_005fwait_005fon_005ffd"> ¶</a></span></dt>
<dd><p>Inform Guile that the current thread is about to sleep, and that if an
asynchronous interrupt is signalled on this thread, Guile should wake up
the thread by writing a zero byte to <var class="var">fd</var>.  Returns zero if the
prepare succeeded, or nonzero if the thread already has a pending async
and that it should avoid waiting.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fprepare_005fto_005fwait_005fon_005fcond"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_c_prepare_to_wait_on_cond</strong> <code class="def-code-arguments">(scm_i_pthread_mutex_t *mutex, scm_i_pthread_cond_t *cond)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fprepare_005fto_005fwait_005fon_005fcond"> ¶</a></span></dt>
<dd><p>Inform Guile that the current thread is about to sleep, and that if an
asynchronous interrupt is signalled on this thread, Guile should wake up
the thread by acquiring <var class="var">mutex</var> and signalling <var class="var">cond</var>.  The
caller must already hold <var class="var">mutex</var> and only drop it as part of the
<code class="code">pthread_cond_wait</code> call.  Returns zero if the prepare succeeded,
or nonzero if the thread already has a pending async and that it should
avoid waiting.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fwait_005ffinished"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_c_wait_finished</strong> <code class="def-code-arguments">(void)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fwait_005ffinished"> ¶</a></span></dt>
<dd><p>Inform Guile that the current thread has finished waiting, and that
asynchronous interrupts no longer need any special wakeup action; the
current thread will periodically poll its internal queue instead.
</p></dd></dl>

<p>Guile’s own interface to <code class="code">sleep</code>, <code class="code">wait-condition-variable</code>,
<code class="code">select</code>, and so on all call the above routines as appropriate.
</p>
<p>Finally, note that threads can also be interrupted via POSIX signals.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Signals">Signals</a>.  As an implementation detail, signal handlers will
effectively call <code class="code">system-async-mark</code> in a signal-safe way,
eventually running the signal handler using the same async mechanism.
In this way you can temporarily inhibit signal handlers from running
using the above interfaces.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Atomics">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables" accesskey="n" rel="next">Mutexes and Condition Variables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs" accesskey="p" rel="prev">Asynchronous Interrupts</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Atomics-1">6.22.4 Atomics</h4>

<p>When accessing data in parallel from multiple threads, updates made by
one thread are not generally guaranteed to be visible by another thread.
It could be that your hardware requires special instructions to be
emitted to propagate a change from one CPU core to another.  Or, it
could be that your hardware updates values with a sequence of
instructions, and a parallel thread could see a value that is in the
process of being updated but not fully updated.
</p>
<p>Atomic references solve this problem.  Atomics are a standard, primitive
facility to allow for concurrent access and update of mutable variables
from multiple threads with guaranteed forward-progress and well-defined
intermediate states.
</p>
<p>Atomic references serve not only as a hardware memory barrier but also
as a compiler barrier.  Normally a compiler might choose to reorder or
elide certain memory accesses due to optimizations like common
subexpression elimination.  Atomic accesses however will not be
reordered relative to each other, and normal memory accesses will not be
reordered across atomic accesses.
</p>
<p>As an implementation detail, currently all atomic accesses and updates
use the sequential consistency memory model from C11.  We may relax this
in the future to the acquire/release semantics, which still issues a
memory barrier so that non-atomic updates are not reordered across
atomic accesses or updates.
</p>
<p>To use Guile’s atomic operations, load the <code class="code">(ice-9 atomic)</code> module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 atomic))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002datomic_002dbox"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-atomic-box</strong> <var class="def-var-arguments">init</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002datomic_002dbox"> ¶</a></span></dt>
<dd><p>Return an atomic box initialized to value <var class="var">init</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atomic_002dbox_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atomic-box?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atomic_002dbox_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is an atomic-box object, else
return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atomic_002dbox_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atomic-box-ref</strong> <var class="def-var-arguments">box</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atomic_002dbox_002dref"> ¶</a></span></dt>
<dd><p>Fetch the value stored in the atomic box <var class="var">box</var> and return it.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atomic_002dbox_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atomic-box-set!</strong> <var class="def-var-arguments">box  val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atomic_002dbox_002dset_0021"> ¶</a></span></dt>
<dd><p>Store <var class="var">val</var> into the atomic box <var class="var">box</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atomic_002dbox_002dswap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atomic-box-swap!</strong> <var class="def-var-arguments">box val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atomic_002dbox_002dswap_0021"> ¶</a></span></dt>
<dd><p>Store <var class="var">val</var> into the atomic box <var class="var">box</var>, and return the value that
was previously stored in the box.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-atomic_002dbox_002dcompare_002dand_002dswap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">atomic-box-compare-and-swap!</strong> <var class="def-var-arguments">box expected desired</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-atomic_002dbox_002dcompare_002dand_002dswap_0021"> ¶</a></span></dt>
<dd><p>If the value of the atomic box <var class="var">box</var> is the same as, <var class="var">expected</var>
(in the sense of <code class="code">eq?</code>), replace the contents of the box with
<var class="var">desired</var>.  Otherwise does not update the box.  Returns the previous
value of the box in either case, so you can know if the swap worked by
checking if the return value is <code class="code">eq?</code> to <var class="var">expected</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Mutexes-and-Condition-Variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Blocking" accesskey="n" rel="next">Blocking in Guile Mode</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Atomics" accesskey="p" rel="prev">Atomics</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Mutexes-and-Condition-Variables-1">6.22.5 Mutexes and Condition Variables</h4>
<a class="index-entry-id" id="index-mutex"></a>
<a class="index-entry-id" id="index-condition-variable"></a>

<p>Mutexes are low-level primitives used to coordinate concurrent access to
mutable data.  Short for “mutual exclusion”, the name “mutex”
indicates that only one thread at a time can acquire access to data that
is protected by a mutex – threads are excluded from accessing data at
the same time.  If one thread has locked a mutex, then another thread
attempting to lock that same mutex will wait until the first thread is
done.
</p>
<p>Mutexes can be used to build robust multi-threaded programs that take
advantage of multiple cores.  However, they provide very low-level
functionality and are somewhat dangerous; usually you end up wanting to
acquire multiple mutexes at the same time to perform a multi-object
access, but this can easily lead to deadlocks if the program is not
carefully written.  For example, if objects A and B are protected by
associated mutexes M and N, respectively, then to access both of them
then you need to acquire both mutexes.  But what if one thread acquires
M first and then N, at the same time that another thread acquires N them
M?  You can easily end up in a situation where one is waiting for the
other.
</p>
<p>There’s no easy way around this problem on the language level.  A
function A that uses mutexes does not necessarily compose nicely with a
function B that uses mutexes.  For this reason we suggest using atomic
variables when you can (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Atomics">Atomics</a>), as they do not have this problem.
</p>
<p>Still, if you as a programmer are responsible for a whole system, then
you can use mutexes as a primitive to provide safe concurrent
abstractions to your users.  (For example, given all locks in a system,
if you establish an order such that M is consistently acquired before N,
you can avoid the “deadly-embrace” deadlock described above.  The
problem is enumerating all mutexes and establishing this order from a
system perspective.)  Guile gives you the low-level facilities to build
such systems.
</p>
<p>In Guile there are additional considerations beyond the usual ones in
other programming languages: non-local control flow and asynchronous
interrupts.  What happens if you hold a mutex, but somehow you cause an
exception to be thrown?  There is no one right answer.  You might want
to keep the mutex locked to prevent any other code from ever entering
that critical section again.  Or, your critical section might be fine if
you unlock the mutex “on the way out”, via an exception handler or
<code class="code">dynamic-wind</code>.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>, and See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>.
</p>
<p>But if you arrange to unlock the mutex when leaving a dynamic extent via
<code class="code">dynamic-wind</code>, what to do if control re-enters that dynamic extent
via a continuation invocation?  Surely re-entering the dynamic extent
without the lock is a bad idea, so there are two options on the table:
either prevent re-entry via <code class="code">with-continuation-barrier</code> or similar,
or reacquire the lock in the entry thunk of a <code class="code">dynamic-wind</code>.
</p>
<p>You might think that because you don’t use continuations, that you don’t
have to think about this, and you might be right.  If you control the
whole system, you can reason about continuation use globally.  Or, if
you know all code that can be called in a dynamic extent, and none of
that code can call continuations, then you don’t have to worry about
re-entry, and you might not have to worry about early exit either.
</p>
<p>However, do consider the possibility of asynchronous interrupts
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>).  If the user interrupts your code interactively, that
can cause an exception; or your thread might be cancelled, which does
the same; or the user could be running your code under some pre-emptive
system that periodically causes lightweight task switching.  (Guile does
not currently include such a system, but it’s possible to implement as a
library.)  Probably you also want to defer asynchronous interrupt
processing while you hold the mutex, and probably that also means that
you should not hold the mutex for very long.
</p>
<p>All of these additional Guile-specific considerations mean that from a
system perspective, you would do well to avoid these hazards if you can
by not requiring mutexes.  Instead, work with immutable data that can be
shared between threads without hazards, or use persistent data
structures with atomic updates based on the atomic variable library
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Atomics">Atomics</a>).
</p>
<p>There are three types of mutexes in Guile: “standard”, “recursive”,
and “unowned”.
</p>
<p>Calling <code class="code">make-mutex</code> with no arguments makes a standard mutex.  A
standard mutex can only be locked once.  If you try to lock it again
from the thread that locked it to begin with (the "owner" thread), it
throws an error.  It can only be unlocked from the thread that locked it
in the first place.
</p>
<p>Calling <code class="code">make-mutex</code> with the symbol <code class="code">recursive</code> as the
argument, or calling <code class="code">make-recursive-mutex</code>, will give you a
recursive mutex.  A recursive mutex can be locked multiple times by its
owner.  It then has to be unlocked the corresponding number of times,
and like standard mutexes can only be unlocked by the owner thread.
</p>
<p>Finally, calling <code class="code">make-mutex</code> with the symbol
<code class="code">allow-external-unlock</code> creates an unowned mutex.  An unowned mutex
is like a standard mutex, except that it can be unlocked by any thread.
A corollary of this behavior is that a thread’s attempt to lock a mutex
that it already owns will block instead of signalling an error, as it
could be that some other thread unlocks the mutex, allowing the owner
thread to proceed.  This kind of mutex is a bit strange and is here for
use by SRFI-18.
</p>
<p>The mutex procedures in Guile can operate on all three kinds of mutexes.
</p>
<p>To use these facilities, load the <code class="code">(ice-9 threads)</code> module.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 threads))
</pre></div>

<br>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dmutex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-mutex</strong> <var class="def-var-arguments">[kind]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_mutex</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fmutex_005fwith_005fkind"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_mutex_with_kind</strong> <var class="def-var-arguments">(SCM kind)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fmutex_005fwith_005fkind"> ¶</a></span></dt>
<dd><p>Return a new mutex.  It will be a standard non-recursive mutex, unless
the <code class="code">recursive</code> symbol is passed as the optional <var class="var">kind</var>
argument, in which case it will be recursive.  It’s also possible to
pass <code class="code">unowned</code> for semantics tailored to SRFI-18’s use case; see
above for details.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mutex_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mutex?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmutex_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mutex_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmutex_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a mutex; otherwise, return
<code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002drecursive_002dmutex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-recursive-mutex</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002drecursive_002dmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005frecursive_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_recursive_mutex</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005frecursive_005fmutex"> ¶</a></span></dt>
<dd><p>Create a new recursive mutex.  It is initially unlocked.  Calling this
function is equivalent to calling <code class="code">make-mutex</code> with the
<code class="code">recursive</code> kind.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lock_002dmutex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lock-mutex</strong> <var class="def-var-arguments">mutex [timeout]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lock_002dmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flock_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lock_mutex</strong> <var class="def-var-arguments">(mutex)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flock_005fmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftimed_005flock_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_timed_lock_mutex</strong> <var class="def-var-arguments">(mutex, timeout)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftimed_005flock_005fmutex"> ¶</a></span></dt>
<dd><p>Lock <var class="var">mutex</var> and return <code class="code">#t</code>.  If the mutex is already locked,
then block and return only when <var class="var">mutex</var> has been acquired.
</p>
<p>When <var class="var">timeout</var> is given, it specifies a point in time where the
waiting should be aborted.  It can be either an integer as returned
by <code class="code">current-time</code> or a pair as returned by <code class="code">gettimeofday</code>.
When the waiting is aborted, <code class="code">#f</code> is returned.
</p>
<p>For standard mutexes (<code class="code">make-mutex</code>), an error is signalled if the
thread has itself already locked <var class="var">mutex</var>.
</p>
<p>For a recursive mutex (<code class="code">make-recursive-mutex</code>), if the thread has
itself already locked <var class="var">mutex</var>, then a further <code class="code">lock-mutex</code>
call increments the lock count.  An additional <code class="code">unlock-mutex</code>
will be required to finally release.
</p>
<p>When an asynchronous interrupt (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>) is scheduled for a
thread blocked in <code class="code">lock-mutex</code>, Guile will interrupt the wait, run
the interrupts, and then resume the wait.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fdynwind_005flock_005fmutex"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_dynwind_lock_mutex</strong> <code class="def-code-arguments">(SCM mutex)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdynwind_005flock_005fmutex"> ¶</a></span></dt>
<dd><p>Arrange for <var class="var">mutex</var> to be locked whenever the current dynwind
context is entered and to be unlocked when it is exited.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-try_002dmutex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">try-mutex</strong> <var class="def-var-arguments">mx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-try_002dmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftry_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_try_mutex</strong> <var class="def-var-arguments">(mx)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftry_005fmutex"> ¶</a></span></dt>
<dd><p>Try to lock <var class="var">mutex</var> and return <code class="code">#t</code> if successful, or <code class="code">#f</code>
otherwise.  This is like calling <code class="code">lock-mutex</code> with an expired
timeout.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unlock_002dmutex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unlock-mutex</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unlock_002dmutex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005funlock_005fmutex"><span class="category-def">C Function: </span><span><strong class="def-name">scm_unlock_mutex</strong> <var class="def-var-arguments">(mutex)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funlock_005fmutex"> ¶</a></span></dt>
<dd><p>Unlock <var class="var">mutex</var>.  An error is signalled if <var class="var">mutex</var> is not locked.
</p>
<p>“Standard” and “recursive” mutexes can only be unlocked by the
thread that locked them; Guile detects this situation and signals an
error.  “Unowned” mutexes can be unlocked by any thread.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mutex_002downer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mutex-owner</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002downer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmutex_005fowner"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mutex_owner</strong> <var class="def-var-arguments">(mutex)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmutex_005fowner"> ¶</a></span></dt>
<dd><p>Return the current owner of <var class="var">mutex</var>, in the form of a thread or
<code class="code">#f</code> (indicating no owner).  Note that a mutex may be unowned but
still locked.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mutex_002dlevel"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mutex-level</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dlevel"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmutex_005flevel"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mutex_level</strong> <var class="def-var-arguments">(mutex)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmutex_005flevel"> ¶</a></span></dt>
<dd><p>Return the current lock level of <var class="var">mutex</var>.  If <var class="var">mutex</var> is
currently unlocked, this value will be 0; otherwise, it will be the
number of times <var class="var">mutex</var> has been recursively locked by its current
owner.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mutex_002dlocked_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mutex-locked?</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dlocked_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmutex_005flocked_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mutex_locked_p</strong> <var class="def-var-arguments">(mutex)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmutex_005flocked_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">mutex</var> is locked, regardless of ownership;
otherwise, return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcondition_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-condition-variable</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcondition_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fcondition_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_condition_variable</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fcondition_005fvariable"> ¶</a></span></dt>
<dd><p>Return a new condition variable.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition_002dvariable_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">condition-variable?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcondition_005fvariable_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_condition_variable_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcondition_005fvariable_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a condition variable; otherwise,
return <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-wait_002dcondition_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">wait-condition-variable</strong> <var class="def-var-arguments">condvar mutex [time]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-wait_002dcondition_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwait_005fcondition_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_wait_condition_variable</strong> <var class="def-var-arguments">(condvar, mutex, time)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwait_005fcondition_005fvariable"> ¶</a></span></dt>
<dd><p>Wait until <var class="var">condvar</var> has been signalled.  While waiting,
<var class="var">mutex</var> is atomically unlocked (as with <code class="code">unlock-mutex</code>) and
is locked again when this function returns.  When <var class="var">time</var> is given,
it specifies a point in time where the waiting should be aborted.  It
can be either a integer as returned by <code class="code">current-time</code> or a pair
as returned by <code class="code">gettimeofday</code>.  When the waiting is aborted,
<code class="code">#f</code> is returned.  When the condition variable has in fact been
signalled, <code class="code">#t</code> is returned.  The mutex is re-locked in any case
before <code class="code">wait-condition-variable</code> returns.
</p>
<p>When an async is activated for a thread that is blocked in a call to
<code class="code">wait-condition-variable</code>, the waiting is interrupted, the mutex is
locked, and the async is executed.  When the async returns, the mutex is
unlocked again and the waiting is resumed.  When the thread block while
re-acquiring the mutex, execution of asyncs is blocked.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-signal_002dcondition_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">signal-condition-variable</strong> <var class="def-var-arguments">condvar</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-signal_002dcondition_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsignal_005fcondition_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_signal_condition_variable</strong> <var class="def-var-arguments">(condvar)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsignal_005fcondition_005fvariable"> ¶</a></span></dt>
<dd><p>Wake up one thread that is waiting for <var class="var">condvar</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-broadcast_002dcondition_002dvariable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">broadcast-condition-variable</strong> <var class="def-var-arguments">condvar</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-broadcast_002dcondition_002dvariable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbroadcast_005fcondition_005fvariable"><span class="category-def">C Function: </span><span><strong class="def-name">scm_broadcast_condition_variable</strong> <var class="def-var-arguments">(condvar)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbroadcast_005fcondition_005fvariable"> ¶</a></span></dt>
<dd><p>Wake up all threads that are waiting for <var class="var">condvar</var>.
</p></dd></dl>

<p>Guile also includes some higher-level abstractions for working with
mutexes.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dmutex"><span class="category-def">macro: </span><span><strong class="def-name">with-mutex</strong> <var class="def-var-arguments">mutex body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dmutex"> ¶</a></span></dt>
<dd><p>Lock <var class="var">mutex</var>, evaluate the body <var class="var">body1</var> <var class="var">body2</var> …,
then unlock <var class="var">mutex</var>.  The return value is that returned by the last
body form.
</p>
<p>The lock, body and unlock form the branches of a <code class="code">dynamic-wind</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Wind">Dynamic Wind</a>), so <var class="var">mutex</var> is automatically unlocked if an
error or new continuation exits the body, and is re-locked if
the body is re-entered by a captured continuation.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-monitor"><span class="category-def">macro: </span><span><strong class="def-name">monitor</strong> <var class="def-var-arguments">body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-monitor"> ¶</a></span></dt>
<dd><p>Evaluate the body form <var class="var">body1</var> <var class="var">body2</var> … with a mutex
locked so only one thread can execute that code at any one time.  The
return value is the return from the last body form.
</p>
<p>Each <code class="code">monitor</code> form has its own private mutex and the locking and
evaluation is as per <code class="code">with-mutex</code> above.  A standard mutex
(<code class="code">make-mutex</code>) is used, which means the body must not
recursively re-enter the <code class="code">monitor</code> form.
</p>
<p>The term “monitor” comes from operating system theory, where it
means a particular bit of code managing access to some resource and
which only ever executes on behalf of one process at any one time.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Blocking">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Futures" accesskey="n" rel="next">Futures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables" accesskey="p" rel="prev">Mutexes and Condition Variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Blocking-in-Guile-Mode">6.22.6 Blocking in Guile Mode</h4>

<p>Up to Guile version 1.8, a thread blocked in guile mode would prevent
the garbage collector from running.  Thus threads had to explicitly
leave guile mode with <code class="code">scm_without_guile ()</code> before making a
potentially blocking call such as a mutex lock, a <code class="code">select ()</code>
system call, etc.  The following functions could be used to temporarily
leave guile mode or to perform some common blocking operations in a
supported way.
</p>
<p>Starting from Guile 2.0, blocked threads no longer hinder garbage
collection.  Thus, the functions below are not needed anymore.  They can
still be used to inform the GC that a thread is about to block, giving
it a (small) optimization opportunity for “stop the world” garbage
collections, should they occur while the thread is blocked.
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fwithout_005fguile"><span class="category-def">C Function: </span><span><code class="def-type">void *</code> <strong class="def-name">scm_without_guile</strong> <code class="def-code-arguments">(void *(*func) (void *), void *data)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwithout_005fguile"> ¶</a></span></dt>
<dd><p>Leave guile mode, call <var class="var">func</var> on <var class="var">data</var>, enter guile mode and
return the result of calling <var class="var">func</var>.
</p>
<p>While a thread has left guile mode, it must not call any libguile
functions except <code class="code">scm_with_guile</code> or <code class="code">scm_without_guile</code> and
must not use any libguile macros.  Also, local variables of type
<code class="code">SCM</code> that are allocated while not in guile mode are not
protected from the garbage collector.
</p>
<p>When used from non-guile mode, calling <code class="code">scm_without_guile</code> is
still allowed: it simply calls <var class="var">func</var>.  In that way, you can leave
guile mode without having to know whether the current thread is in
guile mode or not.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpthread_005fmutex_005flock"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_pthread_mutex_lock</strong> <code class="def-code-arguments">(pthread_mutex_t *mutex)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpthread_005fmutex_005flock"> ¶</a></span></dt>
<dd><p>Like <code class="code">pthread_mutex_lock</code>, but leaves guile mode while waiting for
the mutex.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fpthread_005fcond_005fwait"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_pthread_cond_wait</strong> <code class="def-code-arguments">(pthread_cond_t *cond, pthread_mutex_t *mutex)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpthread_005fcond_005fwait"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fpthread_005fcond_005ftimedwait"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_pthread_cond_timedwait</strong> <code class="def-code-arguments">(pthread_cond_t *cond, pthread_mutex_t *mutex, struct timespec *abstime)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpthread_005fcond_005ftimedwait"> ¶</a></span></dt>
<dd><p>Like <code class="code">pthread_cond_wait</code> and <code class="code">pthread_cond_timedwait</code>, but
leaves guile mode while waiting for the condition variable.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fstd_005fselect"><span class="category-def">C Function: </span><span><code class="def-type">int</code> <strong class="def-name">scm_std_select</strong> <code class="def-code-arguments">(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstd_005fselect"> ¶</a></span></dt>
<dd><p>Like <code class="code">select</code> but leaves guile mode while waiting.  Also, the
delivery of an async causes this function to be interrupted with error
code <code class="code">EINTR</code>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fstd_005fsleep"><span class="category-def">C Function: </span><span><code class="def-type">unsigned int</code> <strong class="def-name">scm_std_sleep</strong> <code class="def-code-arguments">(unsigned int seconds)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstd_005fsleep"> ¶</a></span></dt>
<dd><p>Like <code class="code">sleep</code>, but leaves guile mode while sleeping.  Also, the
delivery of an async causes this function to be interrupted.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fstd_005fusleep"><span class="category-def">C Function: </span><span><code class="def-type">unsigned long</code> <strong class="def-name">scm_std_usleep</strong> <code class="def-code-arguments">(unsigned long usecs)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstd_005fusleep"> ¶</a></span></dt>
<dd><p>Like <code class="code">usleep</code>, but leaves guile mode while sleeping.  Also, the
delivery of an async causes this function to be interrupted.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Futures">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Parallel-Forms" accesskey="n" rel="next">Parallel forms</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Blocking" accesskey="p" rel="prev">Blocking in Guile Mode</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Futures-1">6.22.7 Futures</h4>
<a class="index-entry-id" id="index-futures"></a>
<a class="index-entry-id" id="index-fine_002dgrain-parallelism"></a>
<a class="index-entry-id" id="index-parallelism"></a>

<p>The <code class="code">(ice-9 futures)</code> module provides <em class="dfn">futures</em>, a construct
for fine-grain parallelism.  A future is a wrapper around an expression
whose computation may occur in parallel with the code of the calling
thread, and possibly in parallel with other futures.  Like promises,
futures are essentially proxies that can be queried to obtain the value
of the enclosed expression:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(touch (future (+ 2 3)))
⇒ 5
</pre></div>

<p>However, unlike promises, the expression associated with a future may be
evaluated on another CPU core, should one be available.  This supports
<em class="dfn">fine-grain parallelism</em>, because even relatively small computations
can be embedded in futures.  Consider this sequential code:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (find-prime lst1 lst2)
  (or (find prime? lst1)
      (find prime? lst2)))
</pre></div>

<p>The two arms of <code class="code">or</code> are potentially computation-intensive.  They
are independent of one another, yet, they are evaluated sequentially
when the first one returns <code class="code">#f</code>.  Using futures, one could rewrite
it like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (find-prime lst1 lst2)
  (let ((f (future (find prime? lst2))))
    (or (find prime? lst1)
        (touch f))))
</pre></div>

<p>This preserves the semantics of <code class="code">find-prime</code>.  On a multi-core
machine, though, the computation of <code class="code">(find prime? lst2)</code> may be
done in parallel with that of the other <code class="code">find</code> call, which can
reduce the execution time of <code class="code">find-prime</code>.
</p>
<p>Futures may be nested: a future can itself spawn and then <code class="code">touch</code>
other futures, leading to a directed acyclic graph of futures.  Using
this facility, a parallel <code class="code">map</code> procedure can be defined along
these lines:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 futures) (ice-9 match))

(define (par-map proc lst)
  (match lst
    (()
     '())
    ((head tail ...)
     (let ((tail (future (par-map proc tail)))
           (head (proc head)))
       (cons head (touch tail))))))
</pre></div>

<p>Note that futures are intended for the evaluation of purely functional
expressions.  Expressions that have side-effects or rely on I/O may
require additional care, such as explicit synchronization
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables">Mutexes and Condition Variables</a>).
</p>
<p>Guile’s futures are implemented on top of POSIX threads
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>).  Internally, a fixed-size pool of threads is used to
evaluate futures, such that offloading the evaluation of an expression
to another thread doesn’t incur thread creation costs.  By default, the
pool contains one thread per available CPU core, minus one, to account
for the main thread.  The number of available CPU cores is determined
using <code class="code">current-processor-count</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>).
</p>
<p>When a thread touches a future that has not completed yet, it processes
any pending future while waiting for it to complete, or just waits if
there are no pending futures.  When <code class="code">touch</code> is called from within a
future, the execution of the calling future is suspended, allowing its
host thread to process other futures, and resumed when the touched
future has completed.  This suspend/resume is achieved by capturing the
calling future’s continuation, and later reinstating it (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">delimited continuations</a>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-future"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">future</strong> <var class="def-var-arguments">exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-future"> ¶</a></span></dt>
<dd><p>Return a future for expression <var class="var">exp</var>.  This is equivalent to:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-future (lambda () exp))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dfuture"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-future</strong> <var class="def-var-arguments">thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dfuture"> ¶</a></span></dt>
<dd><p>Return a future for <var class="var">thunk</var>, a zero-argument procedure.
</p>
<p>This procedure returns immediately.  Execution of <var class="var">thunk</var> may begin
in parallel with the calling thread’s computations, if idle CPU cores
are available, or it may start when <code class="code">touch</code> is invoked on the
returned future.
</p>
<p>If the execution of <var class="var">thunk</var> throws an exception, that exception will
be re-thrown when <code class="code">touch</code> is invoked on the returned future.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-future_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">future?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-future_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a future.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-touch"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">touch</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-touch"> ¶</a></span></dt>
<dd><p>Return the result of the expression embedded in future <var class="var">f</var>.
</p>
<p>If the result was already computed in parallel, <code class="code">touch</code> returns
instantaneously.  Otherwise, it waits for the computation to complete,
if it already started, or initiates it.  In the former case, the calling
thread may process other futures in the meantime.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Parallel-Forms">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Futures" accesskey="p" rel="prev">Futures</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="u" rel="up">Threads, Mutexes, Asyncs and Dynamic Roots</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Parallel-forms">6.22.8 Parallel forms</h4>
<a class="index-entry-id" id="index-parallel-forms"></a>

<p>The functions described in this section are available from
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 threads))
</pre></div>

<p>They provide high-level parallel constructs.  The following functions
are implemented in terms of futures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Futures">Futures</a>).  Thus they are
relatively cheap as they re-use existing threads, and portable, since
they automatically use one thread per available CPU core.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-parallel"><span class="category-def">syntax: </span><span><strong class="def-name">parallel</strong> <var class="def-var-arguments">expr …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parallel"> ¶</a></span></dt>
<dd><p>Evaluate each <var class="var">expr</var> expression in parallel, each in its own thread.
Return the results of <var class="var">n</var> expressions as a set of <var class="var">n</var> multiple
values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-letpar"><span class="category-def">syntax: </span><span><strong class="def-name">letpar</strong> <var class="def-var-arguments">((var expr) …) body1 body2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-letpar"> ¶</a></span></dt>
<dd><p>Evaluate each <var class="var">expr</var> in parallel, each in its own thread, then bind
the results to the corresponding <var class="var">var</var> variables, and then evaluate
<var class="var">body1</var> <var class="var">body2</var> <small class="enddots">...</small>
</p>
<p><code class="code">letpar</code> is like <code class="code">let</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>), but all the
expressions for the bindings are evaluated in parallel.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-par_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">par-map</strong> <var class="def-var-arguments">proc lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-par_002dmap"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-par_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">par-for-each</strong> <var class="def-var-arguments">proc lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-par_002dfor_002deach"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> on the elements of the given lists.  <code class="code">par-map</code>
returns a list comprising the return values from <var class="var">proc</var>.
<code class="code">par-for-each</code> returns an unspecified value, but waits for all
calls to complete.
</p>
<p>The <var class="var">proc</var> calls are <code class="code">(<var class="var">proc</var> <var class="var">elem1</var> <var class="var">elem2</var>
…)</code>, where each <var class="var">elem</var> is from the corresponding <var class="var">lst</var> .
Each <var class="var">lst</var> must be the same length.  The calls are potentially made
in parallel, depending on the number of CPU cores available.
</p>
<p>These functions are like <code class="code">map</code> and <code class="code">for-each</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Mapping">List Mapping</a>), but make their <var class="var">proc</var> calls in parallel.
</p></dd></dl>

<p>Unlike those above, the functions described below take a number of
threads as an argument.  This makes them inherently non-portable since
the specified number of threads may differ from the number of available
CPU cores as returned by <code class="code">current-processor-count</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>).  In addition, these functions create the specified
number of threads when they are called and terminate them upon
completion, which makes them quite expensive.
</p>
<p>Therefore, they should be avoided.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-n_002dpar_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">n-par-map</strong> <var class="def-var-arguments">n proc lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-n_002dpar_002dmap"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-n_002dpar_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">n-par-for-each</strong> <var class="def-var-arguments">n proc lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-n_002dpar_002dfor_002deach"> ¶</a></span></dt>
<dd><p>Call <var class="var">proc</var> on the elements of the given lists, in the same way as
<code class="code">par-map</code> and <code class="code">par-for-each</code> above, but use no more than
<var class="var">n</var> threads at any one time.  The order in which calls are
initiated within that threads limit is unspecified.
</p>
<p>These functions are good for controlling resource consumption if
<var class="var">proc</var> calls might be costly, or if there are many to be made.  On
a dual-CPU system for instance <em class="math"><var class="var">n</var>=4</em> might be enough to
keep the CPUs utilized, and not consume too much memory.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-n_002dfor_002deach_002dpar_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">n-for-each-par-map</strong> <var class="def-var-arguments">n sproc pproc lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-n_002dfor_002deach_002dpar_002dmap"> ¶</a></span></dt>
<dd><p>Apply <var class="var">pproc</var> to the elements of the given lists, and apply
<var class="var">sproc</var> to each result returned by <var class="var">pproc</var>.  The final return
value is unspecified, but all calls will have been completed before
returning.
</p>
<p>The calls made are <code class="code">(<var class="var">sproc</var> (<var class="var">pproc</var> <var class="var">elem1</var> …
<var class="var">elemN</var>))</code>, where each <var class="var">elem</var> is from the corresponding
<var class="var">lst</var>.  Each <var class="var">lst</var> must have the same number of elements.
</p>
<p>The <var class="var">pproc</var> calls are made in parallel, in separate threads.  No more
than <var class="var">n</var> threads are used at any one time.  The order in which
<var class="var">pproc</var> calls are initiated within that limit is unspecified.
</p>
<p>The <var class="var">sproc</var> calls are made serially, in list element order, one at
a time.  <var class="var">pproc</var> calls on later elements may execute in parallel
with the <var class="var">sproc</var> calls.  Exactly which thread makes each
<var class="var">sproc</var> call is unspecified.
</p>
<p>This function is designed for individual calculations that can be done
in parallel, but with results needing to be handled serially, for
instance to write them to a file.  The <var class="var">n</var> limit on threads
controls system resource usage when there are many calculations or
when they might be costly.
</p>
<p>It will be seen that <code class="code">n-for-each-par-map</code> is like a combination
of <code class="code">n-par-map</code> and <code class="code">for-each</code>,
</p>
<div class="example">
<pre class="example-preformatted">(for-each sproc (n-par-map n pproc lst1 ... lstN))
</pre></div>

<p>But the actual implementation is more efficient since each <var class="var">sproc</var>
call, in turn, can be initiated once the relevant <var class="var">pproc</var> call has
completed, it doesn’t need to wait for all to finish.
</p></dd></dl>




<hr>
</div>
</div>
<div class="section-level-extent" id="Options-and-Config">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages" accesskey="n" rel="next">Support for Other Languages</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Scheduling" accesskey="p" rel="prev">Threads, Mutexes, Asyncs and Dynamic Roots</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Configuration_002c-Features-and-Runtime-Options">6.23 Configuration, Features and Runtime Options</h3>

<p>Why is my Guile different from your Guile?  There are three kinds of
possible variation:
</p>
<ul class="itemize mark-bullet">
<li>build differences — different versions of the Guile source code,
installation directories, configuration flags that control pieces of
functionality being included or left out, etc.

</li><li>differences in dynamically loaded code — behaviour and features
provided by modules that can be dynamically loaded into a running Guile

</li><li>different runtime options — some of the options that are provided for
controlling Guile’s behaviour may be set differently.
</li></ul>

<p>Guile provides “introspective” variables and procedures to query all
of these possible variations at runtime.  For runtime options, it also
provides procedures to change the settings of options and to obtain
documentation on what the options mean.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config" accesskey="1">Configuration, Build and Installation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking" accesskey="2">Feature Tracking</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Options" accesskey="3">Runtime Options</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Build-Config">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking" accesskey="n" rel="next">Feature Tracking</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config" accesskey="u" rel="up">Configuration, Features and Runtime Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Configuration_002c-Build-and-Installation">6.23.1 Configuration, Build and Installation</h4>

<p>The following procedures and variables provide information about how
Guile was configured, built and installed on your system.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-version"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">version</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-version"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-effective_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">effective-version</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-effective_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-major_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">major-version</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-major_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-minor_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">minor-version</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-minor_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-micro_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">micro-version</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-micro_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fversion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_version</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005feffective_005fversion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_effective_version</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005feffective_005fversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmajor_005fversion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_major_version</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmajor_005fversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fminor_005fversion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_minor_version</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fminor_005fversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmicro_005fversion"><span class="category-def">C Function: </span><span><strong class="def-name">scm_micro_version</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmicro_005fversion"> ¶</a></span></dt>
<dd><p>Return a string describing Guile’s full version number, effective
version number, major, minor or micro version number, respectively.
The <code class="code">effective-version</code> function returns the version name that
should remain unchanged during a stable series.  Currently that means
that it omits the micro version.  The effective version should be used
for items like the versioned share directory name
i.e. <samp class="file">/usr/share/guile/3.0/</samp>
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(version) ⇒ "3.0.0"
(effective-version) ⇒ "3.0"
(major-version) ⇒ "3"
(minor-version) ⇒ "0"
(micro-version) ⇒ "0"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025package_002ddata_002ddir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%package-data-dir</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025package_002ddata_002ddir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fpackage_005fdata_005fdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_package_data_dir</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fpackage_005fdata_005fdir"> ¶</a></span></dt>
<dd><p>Return the name of the directory under which Guile Scheme files in
general are stored.  On Unix-like systems, this is usually
<samp class="file">/usr/local/share/guile</samp> or <samp class="file">/usr/share/guile</samp>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025library_002ddir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%library-dir</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025library_002ddir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005flibrary_005fdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_library_dir</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005flibrary_005fdir"> ¶</a></span></dt>
<dd><p>Return the name of the directory where the Guile Scheme files that
belong to the core Guile installation (as opposed to files from a 3rd
party package) are installed.  On Unix-like systems this is usually
<samp class="file">/usr/local/share/guile/<var class="var">GUILE_EFFECTIVE_VERSION</var></samp> or
<samp class="file">/usr/share/guile/<var class="var">GUILE_EFFECTIVE_VERSION</var></samp>;
</p>
<p>for example <samp class="file">/usr/local/share/guile/3.0</samp>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025site_002ddir-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%site-dir</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025site_002ddir-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fsite_005fdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_site_dir</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fsite_005fdir"> ¶</a></span></dt>
<dd><p>Return the name of the directory where Guile Scheme files specific to
your site should be installed.  On Unix-like systems, this is usually
<samp class="file">/usr/local/share/guile/site</samp> or <samp class="file">/usr/share/guile/site</samp>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-_0025site_002dccache_002ddir-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">%site-ccache-dir</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025site_002dccache_002ddir-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsys_005fsite_005fccache_005fdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sys_site_ccache_dir</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsys_005fsite_005fccache_005fdir"> ¶</a></span></dt>
<dd><p>Return the directory where users should install compiled <code class="code">.go</code>
files for use with this version of Guile.  Might look something like
<samp class="file">/usr/lib/guile/3.0/site-ccache</samp>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025guile_002dbuild_002dinfo"><span class="category-def">Variable: </span><span><strong class="def-name">%guile-build-info</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025guile_002dbuild_002dinfo"> ¶</a></span></dt>
<dd><p>Alist of information collected during the building of a particular
Guile.  Entries can be grouped into one of several categories:
directories, env vars, and versioning info.
</p>
<p>Briefly, here are the keys in <code class="code">%guile-build-info</code>, by group:
</p>
<a class="index-entry-id" id="index-srcdir"></a>
<a class="index-entry-id" id="index-top_005fsrcdir"></a>
<a class="index-entry-id" id="index-prefix-1"></a>
<a class="index-entry-id" id="index-exec_005fprefix"></a>
<a class="index-entry-id" id="index-bindir"></a>
<a class="index-entry-id" id="index-sbindir"></a>
<a class="index-entry-id" id="index-libexecdir"></a>
<a class="index-entry-id" id="index-datadir"></a>
<a class="index-entry-id" id="index-sysconfdir"></a>
<a class="index-entry-id" id="index-sharedstatedir"></a>
<a class="index-entry-id" id="index-localstatedir"></a>
<a class="index-entry-id" id="index-libdir"></a>
<a class="index-entry-id" id="index-infodir"></a>
<a class="index-entry-id" id="index-mandir"></a>
<a class="index-entry-id" id="index-includedir"></a>
<a class="index-entry-id" id="index-pkgdatadir"></a>
<a class="index-entry-id" id="index-pkglibdir"></a>
<a class="index-entry-id" id="index-pkgincludedir"></a>
<dl class="table">
<dt>directories</dt>
<dd><p>srcdir, top_srcdir, prefix, exec_prefix, bindir, sbindir, libexecdir,
datadir, sysconfdir, sharedstatedir, localstatedir, libdir, infodir,
mandir, includedir, pkgdatadir, pkglibdir, pkgincludedir
<a class="index-entry-id" id="index-LIBS"></a>
</p></dd>
<dt>env vars</dt>
<dd><p>LIBS
<a class="index-entry-id" id="index-guileversion"></a>
<a class="index-entry-id" id="index-libguileinterface"></a>
<a class="index-entry-id" id="index-buildstamp"></a>
</p></dd>
<dt>versioning info</dt>
<dd><p>guileversion, libguileinterface, buildstamp
</p></dd>
</dl>

<p>Values are all strings.  The value for <code class="code">LIBS</code> is typically found
also as a part of <code class="code">pkg-config --libs
guile-3.0</code> output.  The value for
<code class="code">guileversion</code> has form X.Y.Z, and should be the same as returned
by <code class="code">(version)</code>.  The value for <code class="code">libguileinterface</code> is libtool
compatible and has form CURRENT:REVISION:AGE (see <a data-manual="libtool" href="http://www.gnu.org/software/libtool/manual/libtool.html#Versioning">Library interface versions</a> in <cite class="cite">GNU Libtool</cite>).  The value for
<code class="code">buildstamp</code> is the output of the command ‘<samp class="samp">date -u +'%Y-%m-%d
%T'</samp>’ (UTC).
</p>
<p>In the source, <code class="code">%guile-build-info</code> is initialized from
libguile/libpath.h, which is completely generated, so deleting this file
before a build guarantees up-to-date values for that build.
</p></dd></dl>

<a class="index-entry-id" id="index-GNU-triplet"></a>
<a class="index-entry-id" id="index-canonical-host-type"></a>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0025host_002dtype"><span class="category-def">Variable: </span><span><strong class="def-name">%host-type</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025host_002dtype"> ¶</a></span></dt>
<dd><p>The canonical host type (GNU triplet) of the host Guile was configured
for, e.g., <code class="code">"x86_64-unknown-linux-gnu"</code> (see <a data-manual="autoconf" href="http://www.gnu.org/software/autoconf/manual/autoconf.html#Canonicalizing">Canonicalizing</a> in <cite class="cite">The GNU Autoconf Manual</cite>).
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Feature-Tracking">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Options" accesskey="n" rel="next">Runtime Options</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Build-Config" accesskey="p" rel="prev">Configuration, Build and Installation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config" accesskey="u" rel="up">Configuration, Features and Runtime Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Feature-Tracking-1">6.23.2 Feature Tracking</h4>

<p>Guile has a Scheme level variable <code class="code">*features*</code> that keeps track to
some extent of the features that are available in a running Guile.
<code class="code">*features*</code> is a list of symbols, for example <code class="code">threads</code>, each
of which describes a feature of the running Guile process.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_002afeatures_002a"><span class="category-def">Variable: </span><span><strong class="def-name">*features*</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_002afeatures_002a"> ¶</a></span></dt>
<dd><p>A list of symbols describing available features of the Guile process.
</p></dd></dl>

<p>You shouldn’t modify the <code class="code">*features*</code> variable directly using
<code class="code">set!</code>.  Instead, see the procedures that are provided for this
purpose in the following subsection.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Manipulation" accesskey="1">Feature Manipulation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Common-Feature-Symbols" accesskey="2">Common Feature Symbols</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Feature-Manipulation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Common-Feature-Symbols" accesskey="n" rel="next">Common Feature Symbols</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking" accesskey="u" rel="up">Feature Tracking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Feature-Manipulation-1">6.23.2.1 Feature Manipulation</h4>

<p>To check whether a particular feature is available, use the
<code class="code">provided?</code> procedure:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-provided_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">provided?</strong> <var class="def-var-arguments">feature</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-provided_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-feature_003f"><span class="category-def">Deprecated Scheme Procedure: </span><span><strong class="def-name">feature?</strong> <var class="def-var-arguments">feature</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-feature_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the specified <var class="var">feature</var> is available, otherwise
<code class="code">#f</code>.
</p></dd></dl>

<p>To advertise a feature from your own Scheme code, you can use the
<code class="code">provide</code> procedure:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-provide"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">provide</strong> <var class="def-var-arguments">feature</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-provide"> ¶</a></span></dt>
<dd><p>Add <var class="var">feature</var> to the list of available features in this Guile
process.
</p></dd></dl>

<p>For C code, the equivalent function takes its feature name as a
<code class="code">char *</code> argument for convenience:
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fadd_005ffeature"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_add_feature</strong> <code class="def-code-arguments">(const char *str)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fadd_005ffeature"> ¶</a></span></dt>
<dd><p>Add a symbol with name <var class="var">str</var> to the list of available features in
this Guile process.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Common-Feature-Symbols">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Manipulation" accesskey="p" rel="prev">Feature Manipulation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking" accesskey="u" rel="up">Feature Tracking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Common-Feature-Symbols-1">6.23.2.2 Common Feature Symbols</h4>

<p>In general, a particular feature may be available for one of two
reasons.  Either because the Guile library was configured and compiled
with that feature enabled — i.e. the feature is built into the library
on your system.  Or because some C or Scheme code that was dynamically
loaded by Guile has added that feature to the list.
</p>
<p>In the first category, here are the features that the current version of
Guile may define (depending on how it is built), and what they mean.
</p>
<dl class="table">
<dt><code class="code">array</code></dt>
<dd><p>Indicates support for arrays (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a>).
</p>
</dd>
<dt><code class="code">array-for-each</code></dt>
<dd><p>Indicates availability of <code class="code">array-for-each</code> and other array mapping
procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Arrays">Arrays</a>).
</p>
</dd>
<dt><code class="code">char-ready?</code></dt>
<dd><p>Indicates that the <code class="code">char-ready?</code> function is available
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Venerable-Port-Interfaces">Venerable Port Interfaces</a>).
</p>
</dd>
<dt><code class="code">complex</code></dt>
<dd><p>Indicates support for complex numbers.
</p>
</dd>
<dt><code class="code">current-time</code></dt>
<dd><p>Indicates availability of time-related functions: <code class="code">times</code>,
<code class="code">get-internal-run-time</code> and so on (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>).
</p>
</dd>
<dt><code class="code">debug-extensions</code></dt>
<dd><p>Indicates that the debugging evaluator is available, together with the
options for controlling it.
</p>
</dd>
<dt><code class="code">delay</code></dt>
<dd><p>Indicates support for promises (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Delayed-Evaluation">Delayed Evaluation</a>).
</p>
</dd>
<dt><code class="code">EIDs</code></dt>
<dd><p>Indicates that the <code class="code">geteuid</code> and <code class="code">getegid</code> really return
effective user and group IDs (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>).
</p>
</dd>
<dt><code class="code">inexact</code></dt>
<dd><p>Indicates support for inexact numbers.
</p>
</dd>
<dt><code class="code">i/o-extensions</code></dt>
<dd><p>Indicates availability of the following extended I/O procedures:
<code class="code">ftell</code>, <code class="code">redirect-port</code>, <code class="code">dup-&gt;fdes</code>, <code class="code">dup2</code>,
<code class="code">fileno</code>, <code class="code">isatty?</code>, <code class="code">fdopen</code>,
<code class="code">primitive-move-&gt;fdes</code> and <code class="code">fdes-&gt;ports</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors">Ports and File Descriptors</a>).
</p>
</dd>
<dt><code class="code">net-db</code></dt>
<dd><p>Indicates availability of network database functions:
<code class="code">scm_gethost</code>, <code class="code">scm_getnet</code>, <code class="code">scm_getproto</code>,
<code class="code">scm_getserv</code>, <code class="code">scm_sethost</code>, <code class="code">scm_setnet</code>, <code class="code">scm_setproto</code>,
<code class="code">scm_setserv</code>, and their ‘byXXX’ variants (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases">Network Databases</a>).
</p>
</dd>
<dt><code class="code">posix</code></dt>
<dd><p>Indicates support for POSIX functions: <code class="code">pipe</code>, <code class="code">getgroups</code>,
<code class="code">kill</code>, <code class="code">execl</code> and so on (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#POSIX"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a>).
</p>
</dd>
<dt><code class="code">fork</code></dt>
<dd><p>Indicates support for the POSIX <code class="code">fork</code> function (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes"><code class="code">primitive-fork</code></a>).
</p>
</dd>
<dt><code class="code">popen</code></dt>
<dd><p>Indicates support for <code class="code">open-pipe</code> in the <code class="code">(ice-9 popen)</code>
module (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Pipes">Pipes</a>).
</p>
</dd>
<dt><code class="code">random</code></dt>
<dd><p>Indicates availability of random number generation functions:
<code class="code">random</code>, <code class="code">copy-random-state</code>, <code class="code">random-uniform</code> and so on
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Random">Random Number Generation</a>).
</p>
</dd>
<dt><code class="code">reckless</code></dt>
<dd><p>Indicates that Guile was built with important checks omitted — you
should never see this!
</p>
</dd>
<dt><code class="code">regex</code></dt>
<dd><p>Indicates support for POSIX regular expressions using
<code class="code">make-regexp</code>, <code class="code">regexp-exec</code> and friends (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Regexp-Functions">Regexp Functions</a>).
</p>
</dd>
<dt><code class="code">socket</code></dt>
<dd><p>Indicates availability of socket-related functions: <code class="code">socket</code>,
<code class="code">bind</code>, <code class="code">connect</code> and so on (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">Network Sockets and Communication</a>).
</p>
</dd>
<dt><code class="code">sort</code></dt>
<dd><p>Indicates availability of sorting and merging functions
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Sorting">Sorting</a>).
</p>
</dd>
<dt><code class="code">system</code></dt>
<dd><p>Indicates that the <code class="code">system</code> function is available
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>).
</p>
</dd>
<dt><code class="code">threads</code></dt>
<dd><p>Indicates support for multithreading (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>).
</p>
</dd>
<dt><code class="code">values</code></dt>
<dd><p>Indicates support for multiple return values using <code class="code">values</code> and
<code class="code">call-with-values</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>).
</p></dd>
</dl>

<p>Available features in the second category depend, by definition, on what
additional code your Guile process has loaded in.  The following table
lists features that you might encounter for this reason.
</p>
<dl class="table">
<dt><code class="code">defmacro</code></dt>
<dd><p>Indicates that the <code class="code">defmacro</code> macro is available (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Macros">Macros</a>).
</p>
</dd>
<dt><code class="code">describe</code></dt>
<dd><p>Indicates that the <code class="code">(oop goops describe)</code> module has been loaded,
which provides a procedure for describing the contents of GOOPS
instances.
</p>
</dd>
<dt><code class="code">readline</code></dt>
<dd><p>Indicates that Guile has loaded in Readline support, for command line
editing (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Support">Readline Support</a>).
</p>
</dd>
<dt><code class="code">record</code></dt>
<dd><p>Indicates support for record definition using <code class="code">make-record-type</code>
and friends (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Records">Records</a>).
</p></dd>
</dl>

<p>Although these tables may seem exhaustive, it is probably unwise in
practice to rely on them, as the correspondences between feature symbols
and available procedures/behaviour are not strictly defined.  If you are
writing code that needs to check for the existence of some procedure, it
is probably safer to do so directly using the <code class="code">defined?</code> procedure
than to test for the corresponding feature using <code class="code">provided?</code>.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Runtime-Options">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking" accesskey="p" rel="prev">Feature Tracking</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config" accesskey="u" rel="up">Configuration, Features and Runtime Options</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Runtime-Options-1">6.23.3 Runtime Options</h4>

<p>There are a number of runtime options available for paramaterizing
built-in procedures, like <code class="code">read</code>, and built-in behavior, like what
happens on an uncaught error.
</p>
<p>For more information on reader options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>.
</p>
<p>For more information on print options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Write">Writing Scheme Values</a>.
</p>
<p>Finally, for more information on debugger options, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Options">Debug options</a>.
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Examples-of-option-use" accesskey="1">Examples of option use</a></li>
</ul>
<div class="subsubsection-level-extent" id="Examples-of-option-use">
<h4 class="subsubsection">6.23.3.1 Examples of option use</h4>

<p>Here is an example of a session in which some read and debug option
handling procedures are used.  In this example, the user
</p>
<ol class="enumerate">
<li> Notices that the symbols <code class="code">abc</code> and <code class="code">aBc</code> are not the same
</li><li> Examines the <code class="code">read-options</code>, and sees that <code class="code">case-insensitive</code>
is set to “no”.
</li><li> Enables <code class="code">case-insensitive</code>
</li><li> Quits the recursive prompt
</li><li> Verifies that now <code class="code">aBc</code> and <code class="code">abc</code> are the same
</li></ol>

<div class="example smalllisp lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (define abc "hello")
scheme@(guile-user)&gt; abc
$1 = "hello"
scheme@(guile-user)&gt; aBc
&lt;unknown-location&gt;: warning: possibly unbound variable `aBc'
ERROR: In procedure module-lookup:
ERROR: Unbound variable: aBc
Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt; (read-options 'help)
copy              no    Copy source code expressions.
positions         yes   Record positions of source code expressions.
case-insensitive  no    Convert symbols to lower case.
keywords          #f    Style of keyword recognition: #f, 'prefix or 'postfix.
r6rs-hex-escapes  no    Use R6RS variable-length character and string hex escapes.
square-brackets   yes   Treat `[' and `]' as parentheses, for R6RS compatibility.
hungry-eol-escapes no   In strings, consume leading whitespace after an
                        escaped end-of-line.
curly-infix       no    Support SRFI-105 curly infix expressions.
scheme@(guile-user) [1]&gt; (read-enable 'case-insensitive)
$2 = (square-brackets keywords #f case-insensitive positions)
scheme@(guile-user) [1]&gt; ,q
scheme@(guile-user)&gt; aBc
$3 = "hello"
</pre></div>



<hr>
</div>
</div>
</div>
<div class="section-level-extent" id="Other-Languages">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="n" rel="next">Support for Internationalization</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Options-and-Config" accesskey="p" rel="prev">Configuration, Features and Runtime Options</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Support-for-Other-Languages">6.24 Support for Other Languages</h3>

<p>In addition to Scheme, a user may write a Guile program in an increasing
number of other languages. Currently supported languages include Emacs
Lisp and ECMAScript.
</p>
<p>Guile is still fundamentally a Scheme, but it tries to support a wide
variety of language building-blocks, so that other languages can be
implemented on top of Guile. This allows users to write or extend
applications in languages other than Scheme, too. This section describes
the languages that have been implemented.
</p>
<p>(For details on how to implement a language, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiling-to-the-Virtual-Machine">Compiling to the Virtual Machine</a>.)
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Other-Languages" accesskey="1">Using Other Languages</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="2">Emacs Lisp</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#ECMAScript" accesskey="3">ECMAScript</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Using-Other-Languages">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="n" rel="next">Emacs Lisp</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages" accesskey="u" rel="up">Support for Other Languages</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Using-Other-Languages-1">6.24.1 Using Other Languages</h4>

<p>There are currently only two ways to access other languages from within
Guile: at the REPL, and programmatically, via <code class="code">compile</code>,
<code class="code">read-and-compile</code>, and <code class="code">compile-file</code>.
</p>
<p>The REPL is Guile’s command prompt (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Using-Guile-Interactively">Using Guile Interactively</a>).
The REPL has a concept of the “current language”, which defaults to
Scheme. The user may change that language, via the meta-command
<code class="code">,language</code>.
</p>
<p>For example, the following meta-command enables Emacs Lisp input:
</p>
<div class="example">
<pre class="example-preformatted">scheme@(guile-user)&gt; ,language elisp
Happy hacking with Emacs Lisp!  To switch back, type `,L scheme'.
elisp@(guile-user)&gt; (eq 1 2)
$1 = #nil
</pre></div>

<p>Each language has its short name: for example, <code class="code">elisp</code>, for Elisp.
The same short name may be used to compile source code programmatically,
via <code class="code">compile</code>:
</p>
<div class="example">
<pre class="example-preformatted">elisp@(guile-user)&gt; ,L scheme
Happy hacking with Guile Scheme!  To switch back, type `,L elisp'.
scheme@(guile-user)&gt; (compile '(eq 1 2) #:from 'elisp)
$2 = #nil
</pre></div>

<p>Granted, as the input to <code class="code">compile</code> is a datum, this works best for
Lispy languages, which have a straightforward datum representation.
Other languages that need more parsing are better dealt with as strings.
</p>
<p>The easiest way to deal with syntax-heavy language is with files, via
<code class="code">compile-file</code> and friends. However it is possible to invoke a
language’s reader on a port, and then compile the resulting expression
(which is a datum at that point). For more information,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>.
</p>
<p>For more details on introspecting aspects of different languages,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compiler-Tower">Compiler Tower</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="Emacs-Lisp">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#ECMAScript" accesskey="n" rel="next">ECMAScript</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Using-Other-Languages" accesskey="p" rel="prev">Using Other Languages</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages" accesskey="u" rel="up">Support for Other Languages</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Emacs-Lisp-1">6.24.2 Emacs Lisp</h4>

<p>Emacs Lisp (Elisp) is a dynamically-scoped Lisp dialect used in the
Emacs editor. See <a data-manual="elisp" href="http://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Top">Overview</a> in <cite class="cite">Emacs Lisp</cite>, for more
information on Emacs Lisp.
</p>
<p>We hope that eventually Guile’s implementation of Elisp will be good
enough to replace Emacs’ own implementation of Elisp. For that reason,
we have thought long and hard about how to support the various features
of Elisp in a performant and compatible manner.
</p>
<p>Readers familiar with Emacs Lisp might be curious about how exactly
these various Elisp features are supported in Guile. The rest of this
section focuses on addressing these concerns of the Elisp elect.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Nil" accesskey="1">Nil</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Binding" accesskey="2">Dynamic Binding</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Elisp-Features" accesskey="3">Other Elisp Features</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Nil">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Binding" accesskey="n" rel="next">Dynamic Binding</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="u" rel="up">Emacs Lisp</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Nil-1">6.24.2.1 Nil</h4>

<p><code class="code">nil</code> in ELisp is an amalgam of Scheme’s <code class="code">#f</code> and <code class="code">'()</code>.
It is false, and it is the end-of-list; thus it is a boolean, and a list
as well.
</p>
<p>Guile has chosen to support <code class="code">nil</code> as a separate value, distinct
from <code class="code">#f</code> and <code class="code">'()</code>. This allows existing Scheme and Elisp
code to maintain their current semantics. <code class="code">nil</code>, which in Elisp
would just be written and read as <code class="code">nil</code>, in Scheme has the external
representation <code class="code">#nil</code>.
</p>
<p>In Elisp code, <code class="code">#nil</code>, <code class="code">#f</code>, and <code class="code">'()</code> behave like
<code class="code">nil</code>, in the sense that they are all interpreted as <code class="code">nil</code> by
Elisp <code class="code">if</code>, <code class="code">cond</code>, <code class="code">when</code>, <code class="code">not</code>, <code class="code">null</code>, etc.
To test whether Elisp would interpret an object as <code class="code">nil</code> from
within Scheme code, use <code class="code">nil?</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-nil_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">nil?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-nil_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> would be interpreted as <code class="code">nil</code> by
Emacs Lisp code, else return <code class="code">#f</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(nil? #nil) ⇒ #t
(nil? #f)   ⇒ #t
(nil? '())  ⇒ #t
(nil? 3)    ⇒ #f
</pre></div>
</dd></dl>

<p>This decision to have <code class="code">nil</code> as a low-level distinct value
facilitates interoperability between the two languages. Guile has chosen
to have Scheme deal with <code class="code">nil</code> as follows:
</p>
<div class="example">
<pre class="example-preformatted">(boolean? #nil) ⇒ #t
(not #nil) ⇒ #t
(null? #nil) ⇒ #t
</pre></div>

<p>And in C, one has:
</p>
<div class="example">
<pre class="example-preformatted">scm_is_bool (SCM_ELISP_NIL) ⇒ 1
scm_is_false (SCM_ELISP_NIL) ⇒ 1
scm_is_null (SCM_ELISP_NIL) ⇒ 1
</pre></div>

<p>In this way, a version of <code class="code">fold</code> written in Scheme can correctly
fold a function written in Elisp (or in fact any other language) over a
nil-terminated list, as Elisp makes. The converse holds as well; a
version of <code class="code">fold</code> written in Elisp can fold over a
<code class="code">'()</code>-terminated list, as made by Scheme.
</p>
<p>On a low level, the bit representations for <code class="code">#f</code>, <code class="code">#t</code>,
<code class="code">nil</code>, and <code class="code">'()</code> are made in such a way that they differ by
only one bit, and so a test for, for example, <code class="code">#f</code>-or-<code class="code">nil</code>
may be made very efficiently. See <code class="code">libguile/boolean.h</code>, for more
information.
</p>
<h4 class="subsubheading" id="Equality-2">Equality</h4>

<p>Since Scheme’s <code class="code">equal?</code> must be transitive, and <code class="code">'()</code>
is not <code class="code">equal?</code> to <code class="code">#f</code>, to Scheme <code class="code">nil</code> is not
<code class="code">equal?</code> to <code class="code">#f</code> or <code class="code">'()</code>.
</p>
<div class="example">
<pre class="example-preformatted">(eq? #f '()) ⇒ #f
(eq? #nil '()) ⇒ #f
(eq? #nil #f) ⇒ #f
(eqv? #f '()) ⇒ #f
(eqv? #nil '()) ⇒ #f
(eqv? #nil #f) ⇒ #f
(equal? #f '()) ⇒ #f
(equal? #nil '()) ⇒ #f
(equal? #nil #f) ⇒ #f
</pre></div>

<p>However, in Elisp, <code class="code">'()</code>, <code class="code">#f</code>, and <code class="code">nil</code> are all
<code class="code">equal</code> (though not <code class="code">eq</code>).
</p>
<div class="example">
<pre class="example-preformatted">(defvar f (make-scheme-false))
(defvar eol (make-scheme-null))
(eq f eol) ⇒ nil
(eq nil eol) ⇒ nil
(eq nil f) ⇒ nil
(equal f eol) ⇒ t
(equal nil eol) ⇒ t
(equal nil f) ⇒ t
</pre></div>

<p>These choices facilitate interoperability between Elisp and Scheme code,
but they are not perfect. Some code that is correct standard Scheme is
not correct in the presence of a second false and null value. For
example:
</p>
<div class="example">
<pre class="example-preformatted">(define (truthiness x)
  (if (eq? x #f)
      #f
      #t))
</pre></div>

<p>This code seems to be meant to test a value for truth, but now that
there are two false values, <code class="code">#f</code> and <code class="code">nil</code>, it is no longer
correct.
</p>
<p>Similarly, there is the loop:
</p>
<div class="example">
<pre class="example-preformatted">(define (my-length l)
  (let lp ((l l) (len 0))
    (if (eq? l '())
        len
        (lp (cdr l) (1+ len)))))
</pre></div>

<p>Here, <code class="code">my-length</code> will raise an error if <var class="var">l</var> is a
<code class="code">nil</code>-terminated list.
</p>
<p>Both of these examples are correct standard Scheme, but, depending on
what they really want to do, they are not correct Guile Scheme.
Correctly written, they would test the <em class="emph">properties</em> of falsehood or
nullity, not the individual members of that set. That is to say, they
should use <code class="code">not</code> or <code class="code">null?</code> to test for falsehood or nullity,
not <code class="code">eq?</code> or <code class="code">memv</code> or the like.
</p>
<p>Fortunately, using <code class="code">not</code> and <code class="code">null?</code> is in good style, so all
well-written standard Scheme programs are correct, in Guile Scheme.
</p>
<p>Here are correct versions of the above examples:
</p>
<div class="example">
<pre class="example-preformatted">(define (truthiness* x)
  (if (not x)
      #f
      #t))
;; or: (define (t* x) (not (not x)))
;; or: (define (t** x) x)

(define (my-length* l)
  (let lp ((l l) (len 0))
    (if (null? l)
        len
        (lp (cdr l) (1+ len)))))
</pre></div>

<p>This problem has a mirror-image case in Elisp:
</p>
<div class="example">
<pre class="example-preformatted">(defun my-falsep (x)
  (if (eq x nil)
      t
      nil))
</pre></div>

<p>Guile can warn when compiling code that has equality comparisons with
<code class="code">#f</code>, <code class="code">'()</code>, or <code class="code">nil</code>. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Compilation">Compiling Scheme Code</a>, for details.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Dynamic-Binding">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Elisp-Features" accesskey="n" rel="next">Other Elisp Features</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Nil" accesskey="p" rel="prev">Nil</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="u" rel="up">Emacs Lisp</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Dynamic-Binding-1">6.24.2.2 Dynamic Binding</h4>

<p>In contrast to Scheme, which uses “lexical scoping”, Emacs Lisp scopes
its variables dynamically. Guile supports dynamic scoping with its
“fluids” facility. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Fluids-and-Dynamic-States">Fluids and Dynamic States</a>, for more
information.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Other-Elisp-Features">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Dynamic-Binding" accesskey="p" rel="prev">Dynamic Binding</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="u" rel="up">Emacs Lisp</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Other-Elisp-Features-1">6.24.2.3 Other Elisp Features</h4>

<p>Buffer-local and mode-local variables should be mentioned here, along
with buckybits on characters, Emacs primitive data types, the
Lisp-2-ness of Elisp, and other things. Contributions to the
documentation are most welcome!
</p>
<hr>
</div>
</div>
<div class="subsection-level-extent" id="ECMAScript">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Emacs-Lisp" accesskey="p" rel="prev">Emacs Lisp</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages" accesskey="u" rel="up">Support for Other Languages</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="ECMAScript-1">6.24.3 ECMAScript</h4>

<p><a class="url" href="http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf">ECMAScript</a>
was not the first non-Schemey language implemented by Guile, but it was
the first implemented for Guile’s bytecode compiler. The goal was to
support ECMAScript version 3.1, a relatively small language, but the
implementor was completely irresponsible and got distracted by other
things before finishing the standard library, and even some bits of the
syntax. So, ECMAScript does deserve a mention in the manual, but it
doesn’t deserve an endorsement until its implementation is completed,
perhaps by some more responsible hacker.
</p>
<p>In the meantime, the charitable user might investigate such invocations
as <code class="code">,L ecmascript</code> and <code class="code">cat test-suite/tests/ecmascript.test</code>.
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="Internationalization">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="n" rel="next">Debugging Infrastructure</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Other-Languages" accesskey="p" rel="prev">Support for Other Languages</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Support-for-Internationalization">6.25 Support for Internationalization</h3>

<a class="index-entry-id" id="index-internationalization"></a>
<a class="index-entry-id" id="index-i18n"></a>

<p>Guile provides internationalization<a class="footnote" id="DOCF22" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT22"><sup>22</sup></a>
support for Scheme programs in two ways.  First, procedures to
manipulate text and data in a way that conforms to particular cultural
conventions (i.e., in a “locale-dependent” way) are provided in the
<code class="code">(ice-9 i18n)</code>.  Second, Guile allows the use of GNU
<code class="code">gettext</code> to translate program message strings.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#i18n-Introduction" accesskey="1">Internationalization with Guile</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Text-Collation" accesskey="2">Text Collation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Case-Mapping" accesskey="3">Character Case Mapping</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output" accesskey="4">Number Input and Output</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information" accesskey="5">Accessing Locale Information</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Gettext-Support" accesskey="6">Gettext Support</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="i18n-Introduction">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Text-Collation" accesskey="n" rel="next">Text Collation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="p" rel="prev">Support for Internationalization</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Internationalization-with-Guile">6.25.1 Internationalization with Guile</h4>

<p>In order to make use of the functions described thereafter, the
<code class="code">(ice-9 i18n)</code> module must be imported in the usual way:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 i18n))
</pre></div>

<a class="index-entry-id" id="index-cultural-conventions"></a>

<p>The <code class="code">(ice-9 i18n)</code> module provides procedures to manipulate text
and other data in a way that conforms to the cultural conventions
chosen by the user.  Each region of the world or language has its own
customs to, for instance, represent real numbers, classify characters,
collate text, etc.  All these aspects comprise the so-called
“cultural conventions” of that region or language.
</p>
<a class="index-entry-id" id="index-locale-1"></a>
<a class="index-entry-id" id="index-locale-category"></a>

<p>Computer systems typically refer to a set of cultural conventions as a
<em class="dfn">locale</em>.  For each particular aspect that comprise those cultural
conventions, a <em class="dfn">locale category</em> is defined.  For instance, the
way characters are classified is defined by the <code class="code">LC_CTYPE</code>
category, while the language in which program messages are issued to
the user is defined by the <code class="code">LC_MESSAGES</code> category
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">General Locale Information</a> for details).
</p>
<a class="index-entry-id" id="index-locale-object"></a>

<p>The procedures provided by this module allow the development of
programs that adapt automatically to any locale setting.  As we will
see later, many of these procedures can optionally take a <em class="dfn">locale
object</em> argument.  This additional argument defines the locale
settings that must be followed by the invoked procedure.  When it is
omitted, then the current locale settings of the process are followed
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales"><code class="code">setlocale</code></a>).
</p>
<p>The following procedures allow the manipulation of such locale
objects.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dlocale"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-locale</strong> <var class="def-var-arguments">category-list locale-name [base-locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dlocale"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005flocale"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_locale</strong> <var class="def-var-arguments">(category_list, locale_name, base_locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005flocale"> ¶</a></span></dt>
<dd><p>Return a reference to a data structure representing a set of locale
datasets.  <var class="var">locale-name</var> should be a string denoting a particular
locale (e.g., <code class="code">"aa_DJ"</code>) and <var class="var">category-list</var> should be either
a list of locale categories or a single category as used with
<code class="code">setlocale</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales"><code class="code">setlocale</code></a>).  Optionally, if
<code class="code">base-locale</code> is passed, it should be a locale object denoting
settings for categories not listed in <var class="var">category-list</var>.
</p>
<p>The following invocation creates a locale object that combines the use
of Swedish for messages and character classification with the
default settings for the other categories (i.e., the settings of the
default <code class="code">C</code> locale which usually represents conventions in use in
the USA):
</p>
<div class="example">
<pre class="example-preformatted">(make-locale (list LC_MESSAGES LC_CTYPE) "sv_SE")
</pre></div>

<p>The following example combines the use of Esperanto messages and
conventions with monetary conventions from Croatia:
</p>
<div class="example">
<pre class="example-preformatted">(make-locale LC_MONETARY "hr_HR"
             (make-locale LC_ALL "eo_EO"))
</pre></div>

<p>A <code class="code">system-error</code> exception (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Handling-Errors">How to Handle Errors</a>) is raised by
<code class="code">make-locale</code> when <var class="var">locale-name</var> does not match any of the
locales compiled on the system.  Note that on non-GNU systems, this
error may be raised later, when the locale object is actually used.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flocale_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_locale_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flocale_005fp"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a locale object.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-_0025global_002dlocale"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">%global-locale</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0025global_002dlocale"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-scm_005fglobal_005flocale"><span class="category-def">C Variable: </span><span><strong class="def-name">scm_global_locale</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fglobal_005flocale"> ¶</a></span></dt>
<dd><p>This variable is bound to a locale object denoting the current process
locale as installed using <code class="code">setlocale ()</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>).  It
may be used like any other locale object, including as a third
argument to <code class="code">make-locale</code>, for instance.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Text-Collation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Case-Mapping" accesskey="n" rel="next">Character Case Mapping</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#i18n-Introduction" accesskey="p" rel="prev">Internationalization with Guile</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Text-Collation-1">6.25.2 Text Collation</h4>

<p>The following procedures provide support for text collation, i.e.,
locale-dependent string and character sorting.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlocale_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale&lt;?</strong> <var class="def-var-arguments">s1 s2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_003c_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_lt</strong> <var class="def-var-arguments">(s1, s2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005flt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dlocale_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale&gt;?</strong> <var class="def-var-arguments">s1 s2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_003e_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_gt</strong> <var class="def-var-arguments">(s1, s2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fgt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dlocale_002dci_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-ci&lt;?</strong> <var class="def-var-arguments">s1 s2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002dci_003c_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fci_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_ci_lt</strong> <var class="def-var-arguments">(s1, s2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fci_005flt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-string_002dlocale_002dci_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-ci&gt;?</strong> <var class="def-var-arguments">s1 s2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002dci_003e_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fci_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_ci_gt</strong> <var class="def-var-arguments">(s1, s2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fci_005fgt"> ¶</a></span></dt>
<dd><p>Compare strings <var class="var">s1</var> and <var class="var">s2</var> in a locale-dependent way.  If
<var class="var">locale</var> is provided, it should be locale object (as returned by
<code class="code">make-locale</code>) and will be used to perform the comparison;
otherwise, the current system locale is used.  For the <code class="code">-ci</code>
variants, the comparison is made in a case-insensitive way.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlocale_002dci_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-ci=?</strong> <var class="def-var-arguments">s1 s2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002dci_003d_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fci_005feq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_ci_eq</strong> <var class="def-var-arguments">(s1, s2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fci_005feq"> ¶</a></span></dt>
<dd><p>Compare strings <var class="var">s1</var> and <var class="var">s2</var> in a case-insensitive, and
locale-dependent way.  If <var class="var">locale</var> is provided, it should be
a locale object (as returned by <code class="code">make-locale</code>) and will be used to
perform the comparison; otherwise, the current system locale is used.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlocale_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale&lt;?</strong> <var class="def-var-arguments">c1 c2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_003c_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_lt</strong> <var class="def-var-arguments">(c1, c2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005flt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-char_002dlocale_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale&gt;?</strong> <var class="def-var-arguments">c1 c2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_003e_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_gt</strong> <var class="def-var-arguments">(c1, c2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fgt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-char_002dlocale_002dci_003c_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-ci&lt;?</strong> <var class="def-var-arguments">c1 c2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002dci_003c_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fci_005flt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_ci_lt</strong> <var class="def-var-arguments">(c1, c2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fci_005flt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-char_002dlocale_002dci_003e_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-ci&gt;?</strong> <var class="def-var-arguments">c1 c2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002dci_003e_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fci_005fgt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_ci_gt</strong> <var class="def-var-arguments">(c1, c2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fci_005fgt"> ¶</a></span></dt>
<dd><p>Compare characters <var class="var">c1</var> and <var class="var">c2</var> according to either
<var class="var">locale</var> (a locale object as returned by <code class="code">make-locale</code>) or
the current locale.  For the <code class="code">-ci</code> variants, the comparison is
made in a case-insensitive way.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlocale_002dci_003d_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-ci=?</strong> <var class="def-var-arguments">c1 c2 [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002dci_003d_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fci_005feq"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_ci_eq</strong> <var class="def-var-arguments">(c1, c2, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fci_005feq"> ¶</a></span></dt>
<dd><p>Return true if character <var class="var">c1</var> is equal to <var class="var">c2</var>, in a case
insensitive way according to <var class="var">locale</var> or to the current locale.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Character-Case-Mapping">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output" accesskey="n" rel="next">Number Input and Output</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Text-Collation" accesskey="p" rel="prev">Text Collation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Character-Case-Mapping-1">6.25.3 Character Case Mapping</h4>

<p>The procedures below provide support for “character case mapping”,
i.e., to convert characters or strings to their upper-case or
lower-case equivalent.  Note that SRFI-13 provides procedures that
look similar (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Alphabetic-Case-Mapping">Alphabetic Case Mapping</a>).  However, the SRFI-13
procedures are locale-independent.  Therefore, they do not take into
account specificities of the customs in use in a particular language
or region of the world.  For instance, while most languages using the
Latin alphabet map lower-case letter “i” to upper-case letter “I”,
Turkish maps lower-case “i” to “Latin capital letter I with dot
above”.  The following procedures allow programmers to provide
idiomatic character mapping.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlocale_002ddowncase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-downcase</strong> <var class="def-var-arguments">chr [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002ddowncase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fupcase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_upcase</strong> <var class="def-var-arguments">(chr, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fupcase"> ¶</a></span></dt>
<dd><p>Return the lowercase character that corresponds to <var class="var">chr</var> according
to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlocale_002dupcase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-upcase</strong> <var class="def-var-arguments">chr [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002dupcase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005fdowncase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_downcase</strong> <var class="def-var-arguments">(chr, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005fdowncase"> ¶</a></span></dt>
<dd><p>Return the uppercase character that corresponds to <var class="var">chr</var> according
to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-char_002dlocale_002dtitlecase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">char-locale-titlecase</strong> <var class="def-var-arguments">chr [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-char_002dlocale_002dtitlecase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchar_005flocale_005ftitlecase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_char_locale_titlecase</strong> <var class="def-var-arguments">(chr, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchar_005flocale_005ftitlecase"> ¶</a></span></dt>
<dd><p>Return the titlecase character that corresponds to <var class="var">chr</var> according
to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlocale_002dupcase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-upcase</strong> <var class="def-var-arguments">str [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002dupcase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fupcase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_upcase</strong> <var class="def-var-arguments">(str, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fupcase"> ¶</a></span></dt>
<dd><p>Return a new string that is the uppercase version of <var class="var">str</var>
according to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlocale_002ddowncase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-downcase</strong> <var class="def-var-arguments">str [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002ddowncase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005fdowncase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_downcase</strong> <var class="def-var-arguments">(str, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005fdowncase"> ¶</a></span></dt>
<dd><p>Return a new string that is the down-case version of <var class="var">str</var>
according to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002dlocale_002dtitlecase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-locale-titlecase</strong> <var class="def-var-arguments">str [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002dlocale_002dtitlecase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstring_005flocale_005ftitlecase"><span class="category-def">C Function: </span><span><strong class="def-name">scm_string_locale_titlecase</strong> <var class="def-var-arguments">(str, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstring_005flocale_005ftitlecase"> ¶</a></span></dt>
<dd><p>Return a new string that is the titlecase version of <var class="var">str</var>
according to either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Number-Input-and-Output">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information" accesskey="n" rel="next">Accessing Locale Information</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Character-Case-Mapping" accesskey="p" rel="prev">Character Case Mapping</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Number-Input-and-Output-1">6.25.4 Number Input and Output</h4>

<p>The following procedures allow programs to read and write numbers
written according to a particular locale.  As an example, in English,
“ten thousand and a half” is usually written <code class="code">10,000.5</code> while
in French it is written <code class="code">10 000,5</code>.  These procedures allow such
differences to be taken into account.
</p>
<a class="index-entry-id" id="index-strtod"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dstring_002d_003einteger"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-string-&gt;integer</strong> <var class="def-var-arguments">str [base [locale]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dstring_002d_003einteger"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flocale_005fstring_005fto_005finteger"><span class="category-def">C Function: </span><span><strong class="def-name">scm_locale_string_to_integer</strong> <var class="def-var-arguments">(str, base, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flocale_005fstring_005fto_005finteger"> ¶</a></span></dt>
<dd><p>Convert string <var class="var">str</var> into an integer according to either
<var class="var">locale</var> (a locale object as returned by <code class="code">make-locale</code>) or
the current process locale.  If <var class="var">base</var> is specified, then it
determines the base of the integer being read (e.g., <code class="code">16</code> for an
hexadecimal number, <code class="code">10</code> for a decimal number); by default,
decimal numbers are read.  Return two values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>): an integer (on success) or <code class="code">#f</code>, and the number of
characters read from <var class="var">str</var> (<code class="code">0</code> on failure).
</p>
<p>This function is based on the C library’s <code class="code">strtol</code> function
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Parsing-of-Integers"><code class="code">strtol</code></a> in <cite class="cite">The GNU C Library
Reference Manual</cite>).
</p></dd></dl>

<a class="index-entry-id" id="index-strtod-1"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dstring_002d_003einexact"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-string-&gt;inexact</strong> <var class="def-var-arguments">str [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dstring_002d_003einexact"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flocale_005fstring_005fto_005finexact"><span class="category-def">C Function: </span><span><strong class="def-name">scm_locale_string_to_inexact</strong> <var class="def-var-arguments">(str, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flocale_005fstring_005fto_005finexact"> ¶</a></span></dt>
<dd><p>Convert string <var class="var">str</var> into an inexact number according to either
<var class="var">locale</var> (a locale object as returned by <code class="code">make-locale</code>) or
the current process locale.  Return two values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>): an inexact number (on success) or <code class="code">#f</code>, and the number
of characters read from <var class="var">str</var> (<code class="code">0</code> on failure).
</p>
<p>This function is based on the C library’s <code class="code">strtod</code> function
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Parsing-of-Floats"><code class="code">strtod</code></a> in <cite class="cite">The GNU C Library
Reference Manual</cite>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-number_002d_003elocale_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">number-&gt;locale-string</strong> <var class="def-var-arguments">number [fraction-digits [locale]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-number_002d_003elocale_002dstring"> ¶</a></span></dt>
<dd><p>Convert <var class="var">number</var> (an inexact) into a string according to the
cultural conventions of either <var class="var">locale</var> (a locale object) or the
current locale.  By default, print as many fractional digits as
necessary, up to an upper bound.  Optionally, <var class="var">fraction-digits</var> may
be bound to an integer specifying the number of fractional digits to be
displayed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-monetary_002damount_002d_003elocale_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">monetary-amount-&gt;locale-string</strong> <var class="def-var-arguments">amount intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-monetary_002damount_002d_003elocale_002dstring"> ¶</a></span></dt>
<dd><p>Convert <var class="var">amount</var> (an inexact denoting a monetary amount) into a
string according to the cultural conventions of either <var class="var">locale</var> (a
locale object) or the current locale.  If <var class="var">intl?</var> is true, then
the international monetary format for the given locale is used
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Currency-Symbol">international and locale monetary formats</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Accessing-Locale-Information">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Gettext-Support" accesskey="n" rel="next">Gettext Support</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output" accesskey="p" rel="prev">Number Input and Output</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Accessing-Locale-Information-1">6.25.5 Accessing Locale Information</h4>

<a class="index-entry-id" id="index-nl_005flanginfo"></a>
<a class="index-entry-id" id="index-low_002dlevel-locale-information"></a>
<p>It is sometimes useful to obtain very specific information about a
locale such as the word it uses for days or months, its format for
representing floating-point figures, etc.  The <code class="code">(ice-9 i18n)</code>
module provides support for this in a way that is similar to the libc
functions <code class="code">nl_langinfo ()</code> and <code class="code">localeconv ()</code>
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Locale-Information">accessing locale information from C</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).  The available functions
are listed below.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-encoding</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dencoding"> ¶</a></span></dt>
<dd><p>Return the name of the encoding (a string whose interpretation is
system-dependent) of either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<p>The following functions deal with dates and times.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-day</strong> <var class="def-var-arguments">day [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dday"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dday_002dshort"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-day-short</strong> <var class="def-var-arguments">day [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dday_002dshort"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dmonth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-month</strong> <var class="def-var-arguments">month [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dmonth_002dshort"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-month-short</strong> <var class="def-var-arguments">month [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonth_002dshort"> ¶</a></span></dt>
<dd><p>Return the word (a string) used in either <var class="var">locale</var> or the current
locale to name the day (or month) denoted by <var class="var">day</var> (or
<var class="var">month</var>), an integer between 1 and 7 (or 1 and 12).  The
<code class="code">-short</code> variants provide an abbreviation instead of a full name.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dam_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-am-string</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dam_002dstring"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dpm_002dstring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-pm-string</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dpm_002dstring"> ¶</a></span></dt>
<dd><p>Return a (potentially empty) string that is used to denote <i class="i">ante
meridiem</i> (or <i class="i">post meridiem</i>) hours in 12-hour format.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002ddate_002btime_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-date+time-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002ddate_002btime_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002ddate_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-date-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002ddate_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dtime_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-time-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dtime_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dtime_002bam_002fpm_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-time+am/pm-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dtime_002bam_002fpm_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dera_002ddate_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-era-date-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dera_002ddate_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dera_002ddate_002btime_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-era-date+time-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dera_002ddate_002btime_002dformat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dera_002dtime_002dformat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-era-time-format</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dera_002dtime_002dformat"> ¶</a></span></dt>
<dd><p>These procedures return format strings suitable to <code class="code">strftime</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>) that may be used to display (part of) a date/time
according to certain constraints and to the conventions of either
<var class="var">locale</var> or the current locale (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#The-Elegant-and-Fast-Way">the <code class="code">nl_langinfo ()</code> items</a> in <cite class="cite">The GNU C Library Reference
Manual</cite>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dera"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-era</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dera"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dera_002dyear"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-era-year</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dera_002dyear"> ¶</a></span></dt>
<dd><p>These functions return, respectively, the era and the year of the
relevant era used in <var class="var">locale</var> or the current locale.  Most locales
do not define this value.  In this case, the empty string is returned.
An example of a locale that does define this value is the Japanese
one.
</p></dd></dl>

<p>The following procedures give information about number representation.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002ddecimal_002dpoint"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-decimal-point</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002ddecimal_002dpoint"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dthousands_002dseparator"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-thousands-separator</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dthousands_002dseparator"> ¶</a></span></dt>
<dd><p>These functions return a string denoting the representation of the
decimal point or that of the thousand separator (respectively) for
either <var class="var">locale</var> or the current locale.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002ddigit_002dgrouping"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-digit-grouping</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002ddigit_002dgrouping"> ¶</a></span></dt>
<dd><p>Return a (potentially circular) list of integers denoting how digits
of the integer part of a number are to be grouped, starting at the
decimal point and going to the left.  The list contains integers
indicating the size of the successive groups, from right to left.  If
the list is non-circular, then no grouping occurs for digits beyond
the last group.
</p>
<p>For instance, if the returned list is a circular list that contains
only <code class="code">3</code> and the thousand separator is <code class="code">","</code> (as is the case
with English locales), then the number <code class="code">12345678</code> should be
printed <code class="code">12,345,678</code>.
</p></dd></dl>

<p>The following procedures deal with the representation of monetary
amounts.  Some of them take an additional <var class="var">intl?</var> argument (a
boolean) that tells whether the international or local monetary
conventions for the given locale are to be used.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dmonetary_002ddecimal_002dpoint"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-decimal-point</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002ddecimal_002dpoint"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dmonetary_002dthousands_002dseparator"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-thousands-separator</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002dthousands_002dseparator"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dmonetary_002dgrouping"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-grouping</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002dgrouping"> ¶</a></span></dt>
<dd><p>These are the monetary counterparts of the above procedures.  These
procedures apply to monetary amounts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dcurrency_002dsymbol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-currency-symbol</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dcurrency_002dsymbol"> ¶</a></span></dt>
<dd><p>Return the currency symbol (a string) of either <var class="var">locale</var> or the
current locale.
</p>
<p>The following example illustrates the difference between the local and
international monetary formats:
</p>
<div class="example">
<pre class="example-preformatted">(define us (make-locale LC_MONETARY "en_US"))
(locale-currency-symbol #f us)
⇒ "-$"
(locale-currency-symbol #t us)
⇒ "USD "
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dmonetary_002dfractional_002ddigits"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-fractional-digits</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002dfractional_002ddigits"> ¶</a></span></dt>
<dd><p>Return the number of fractional digits to be used when printing
monetary amounts according to either <var class="var">locale</var> or the current
locale.  If the locale does not specify it, then <code class="code">#f</code> is
returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dcurrency_002dsymbol_002dprecedes_002dpositive_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-currency-symbol-precedes-positive?</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dcurrency_002dsymbol_002dprecedes_002dpositive_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dcurrency_002dsymbol_002dprecedes_002dnegative_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-currency-symbol-precedes-negative?</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dcurrency_002dsymbol_002dprecedes_002dnegative_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dpositive_002dseparated_002dby_002dspace_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-positive-separated-by-space?</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dpositive_002dseparated_002dby_002dspace_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dnegative_002dseparated_002dby_002dspace_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-negative-separated-by-space?</strong> <var class="def-var-arguments">intl? [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dnegative_002dseparated_002dby_002dspace_003f"> ¶</a></span></dt>
<dd><p>These procedures return a boolean indicating whether the currency
symbol should precede a positive/negative number, and whether a
whitespace should be inserted between the currency symbol and a
positive/negative amount.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dmonetary_002dpositive_002dsign"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-positive-sign</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002dpositive_002dsign"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dmonetary_002dnegative_002dsign"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-monetary-negative-sign</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dmonetary_002dnegative_002dsign"> ¶</a></span></dt>
<dd><p>Return a string denoting the positive (respectively negative) sign
that should be used when printing a monetary amount.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dpositive_002dsign_002dposition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-positive-sign-position</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dpositive_002dsign_002dposition"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dnegative_002dsign_002dposition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-negative-sign-position</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dnegative_002dsign_002dposition"> ¶</a></span></dt>
<dd><p>These functions return a symbol telling where a sign of a
positive/negative monetary amount is to appear when printing it.  The
possible values are:
</p>
<dl class="table">
<dt><code class="code">parenthesize</code></dt>
<dd><p>The currency symbol and quantity should be surrounded by parentheses.
</p></dd>
<dt><code class="code">sign-before</code></dt>
<dd><p>Print the sign string before the quantity and currency symbol.
</p></dd>
<dt><code class="code">sign-after</code></dt>
<dd><p>Print the sign string after the quantity and currency symbol.
</p></dd>
<dt><code class="code">sign-before-currency-symbol</code></dt>
<dd><p>Print the sign string right before the currency symbol.
</p></dd>
<dt><code class="code">sign-after-currency-symbol</code></dt>
<dd><p>Print the sign string right after the currency symbol.
</p></dd>
<dt><code class="code">unspecified</code></dt>
<dd><p>Unspecified.  We recommend you print the sign after the currency
symbol.
</p></dd>
</dl>

</dd></dl>

<p>Finally, the two following procedures may be helpful when programming
user interfaces:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-locale_002dyes_002dregexp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-yes-regexp</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dyes_002dregexp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-locale_002dno_002dregexp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">locale-no-regexp</strong> <var class="def-var-arguments">[locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-locale_002dno_002dregexp"> ¶</a></span></dt>
<dd><p>Return a string that can be used as a regular expression to recognize
a positive (respectively, negative) response to a yes/no question.
For the C locale, the default values are typically <code class="code">"^[yY]"</code> and
<code class="code">"^[nN]"</code>, respectively.
</p>
<p>Here is an example:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 rdelim))
(format #t "Does Guile rock?~%")
(let lp ((answer (read-line)))
  (cond ((string-match (locale-yes-regexp) answer)
         (format #t "High fives!~%"))
        ((string-match (locale-no-regexp) answer)
         (format #t "How about now? Does it rock yet?~%")
         (lp (read-line)))
        (else
         (format #t "What do you mean?~%")
         (lp (read-line)))))
</pre></div>

<p>For an internationalized yes/no string output, <code class="code">gettext</code> should
be used (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Gettext-Support">Gettext Support</a>).
</p></dd></dl>

<p>Example uses of some of these functions are the implementation of the
<code class="code">number-&gt;locale-string</code> and <code class="code">monetary-amount-&gt;locale-string</code>
procedures (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Number-Input-and-Output">Number Input and Output</a>), as well as that the
SRFI-19 date and time conversion to/from strings (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19">SRFI-19 - Time/Date Library</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Gettext-Support">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information" accesskey="p" rel="prev">Accessing Locale Information</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="u" rel="up">Support for Internationalization</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Gettext-Support-1">6.25.6 Gettext Support</h4>

<p>Guile provides an interface to GNU <code class="code">gettext</code> for translating
message strings (see <a data-manual="gettext" href="http://www.gnu.org/software/gettext/manual/gettext.html#Introduction">Introduction</a> in <cite class="cite">GNU <code class="code">gettext</code>
utilities</cite>).
</p>
<p>Messages are collected in domains, so different libraries and programs
maintain different message catalogues.  The <var class="var">domain</var> parameter in
the functions below is a string (it becomes part of the message
catalog filename).
</p>
<p>When <code class="code">gettext</code> is not available, or if Guile was configured
‘<samp class="samp">--without-nls</samp>’, dummy functions doing no translation are
provided.  When <code class="code">gettext</code> support is available in Guile, the
<code class="code">i18n</code> feature is provided (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking">Feature Tracking</a>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-gettext"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gettext</strong> <var class="def-var-arguments">msg [domain [category]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gettext"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgettext"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gettext</strong> <var class="def-var-arguments">(msg, domain, category)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgettext"> ¶</a></span></dt>
<dd><p>Return the translation of <var class="var">msg</var> in <var class="var">domain</var>.  <var class="var">domain</var> is
optional and defaults to the domain set through <code class="code">textdomain</code>
below.  <var class="var">category</var> is optional and defaults to <code class="code">LC_MESSAGES</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>).
</p>
<p>Normal usage is for <var class="var">msg</var> to be a literal string.
<code class="command">xgettext</code> can extract those from the source to form a message
catalogue ready for translators (see <a data-manual="gettext" href="http://www.gnu.org/software/gettext/manual/gettext.html#xgettext-Invocation">Invoking
the <code class="command">xgettext</code> Program</a> in <cite class="cite">GNU <code class="code">gettext</code>
utilities</cite>).
</p>
<div class="example">
<pre class="example-preformatted">(display (gettext "You are in a maze of twisty passages."))
</pre></div>

<p>It is conventional to use <code class="code">G_</code> as a shorthand for
<code class="code">gettext</code>.<a class="footnote" id="DOCF23" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT23"><sup>23</sup></a>  Libraries can define <code class="code">G_</code> in such
a way to look up translations using its specific <var class="var">domain</var>, allowing
different parts of a program to have different translation sources.
</p>
<div class="example">
<pre class="example-preformatted">(define (G_ msg) (gettext msg "mylibrary"))
(display (G_ "File not found."))
</pre></div>

<p><code class="code">G_</code> is also a good place to perhaps strip disambiguating extra
text from the message string, as for instance in <a data-manual="gettext" href="http://www.gnu.org/software/gettext/manual/gettext.html#GUI-program-problems">How to use <code class="code">gettext</code> in GUI programs</a> in <cite class="cite">GNU
<code class="code">gettext</code> utilities</cite>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ngettext"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ngettext</strong> <var class="def-var-arguments">msg msgplural n [domain [category]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ngettext"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fngettext"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ngettext</strong> <var class="def-var-arguments">(msg, msgplural, n, domain, category)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fngettext"> ¶</a></span></dt>
<dd><p>Return the translation of <var class="var">msg</var>/<var class="var">msgplural</var> in <var class="var">domain</var>,
with a plural form chosen appropriately for the number <var class="var">n</var>.
<var class="var">domain</var> is optional and defaults to the domain set through
<code class="code">textdomain</code> below.  <var class="var">category</var> is optional and defaults to
<code class="code">LC_MESSAGES</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>).
</p>
<p><var class="var">msg</var> is the singular form, and <var class="var">msgplural</var> the plural.  When
no translation is available, <var class="var">msg</var> is used if <em class="math"><var class="var">n</var> = 1</em>,
or <var class="var">msgplural</var> otherwise.  When translated, the message catalogue
can have a different rule, and can have more than two possible forms.
</p>
<p>As per <code class="code">gettext</code> above, normal usage is for <var class="var">msg</var> and
<var class="var">msgplural</var> to be literal strings, since <code class="command">xgettext</code> can
extract them from the source to build a message catalogue.  For
example,
</p>
<div class="example">
<pre class="example-preformatted">(define (done n)
  (format #t (ngettext "~a file processed\n"
                       "~a files processed\n" n)
             n))

(done 1) -| 1 file processed
(done 3) -| 3 files processed
</pre></div>

<p>It’s important to use <code class="code">ngettext</code> rather than plain <code class="code">gettext</code>
for plurals, since the rules for singular and plural forms in English
are not the same in other languages.  Only <code class="code">ngettext</code> will allow
translators to give correct forms (see <a data-manual="gettext" href="http://www.gnu.org/software/gettext/manual/gettext.html#Plural-forms">Additional
functions for plural forms</a> in <cite class="cite">GNU <code class="code">gettext</code> utilities</cite>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-textdomain"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">textdomain</strong> <var class="def-var-arguments">[domain]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-textdomain"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftextdomain"><span class="category-def">C Function: </span><span><strong class="def-name">scm_textdomain</strong> <var class="def-var-arguments">(domain)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftextdomain"> ¶</a></span></dt>
<dd><p>Get or set the default gettext domain.  When called with no parameter
the current domain is returned.  When called with a parameter,
<var class="var">domain</var> is set as the current domain, and that new value
returned.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(textdomain "myprog")
⇒ "myprog"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bindtextdomain"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bindtextdomain</strong> <var class="def-var-arguments">domain [directory]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bindtextdomain"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbindtextdomain"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bindtextdomain</strong> <var class="def-var-arguments">(domain, directory)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbindtextdomain"> ¶</a></span></dt>
<dd><p>Get or set the directory under which to find message files for
<var class="var">domain</var>.  When called without a <var class="var">directory</var> the current
setting is returned.  When called with a <var class="var">directory</var>,
<var class="var">directory</var> is set for <var class="var">domain</var> and that new setting returned.
For example,
</p>
<div class="example">
<pre class="example-preformatted">(bindtextdomain "myprog" "/my/tree/share/locale")
⇒ "/my/tree/share/locale"
</pre></div>

<p>When using Autoconf/Automake, an application should arrange for the
configured <code class="code">localedir</code> to get into the program (by substituting,
or by generating a config file) and set that for its domain.  This
ensures the catalogue can be found even when installed in a
non-standard location.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bind_002dtextdomain_002dcodeset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bind-textdomain-codeset</strong> <var class="def-var-arguments">domain [encoding]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bind_002dtextdomain_002dcodeset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbind_005ftextdomain_005fcodeset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bind_textdomain_codeset</strong> <var class="def-var-arguments">(domain, encoding)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbind_005ftextdomain_005fcodeset"> ¶</a></span></dt>
<dd><p>Get or set the text encoding to be used by <code class="code">gettext</code> for messages
from <var class="var">domain</var>.  <var class="var">encoding</var> is a string, the name of a coding
system, for instance <code class="code">"8859_1"</code>.  (On a Unix/POSIX system the
<code class="command">iconv</code> program can list all available encodings.)
</p>
<p>When called without an <var class="var">encoding</var> the current setting is returned,
or <code class="code">#f</code> if none yet set.  When called with an <var class="var">encoding</var>, it
is set for <var class="var">domain</var> and that new setting returned.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(bind-textdomain-codeset "myprog")
⇒ #f
(bind-textdomain-codeset "myprog" "latin-9")
⇒ "latin-9"
</pre></div>

<p>The encoding requested can be different from the translated data file,
messages will be recoded as necessary.  But note that when there is no
translation, <code class="code">gettext</code> returns its <var class="var">msg</var> unchanged, ie.
without any recoding.  For that reason source message strings are best
as plain ASCII.
</p>
<p>Currently Guile has no understanding of multi-byte characters, and
string functions won’t recognise character boundaries in multi-byte
strings.  An application will at least be able to pass such strings
through to some output though.  Perhaps this will change in the
future.
</p></dd></dl>


<hr>
</div>
</div>
<div class="section-level-extent" id="Debugging">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Code-Coverage" accesskey="n" rel="next">Code Coverage Reports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internationalization" accesskey="p" rel="prev">Support for Internationalization</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Debugging-Infrastructure">6.26 Debugging Infrastructure</h3>

<a class="index-entry-id" id="index-Debugging"></a>
<p>In order to understand Guile’s debugging facilities, you first need to
understand a little about how Guile represents the Scheme control stack.
With that in place we explain the low level trap calls that the virtual
machine can be configured to make, and the trap and breakpoint
infrastructure that builds on top of those calls.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model" accesskey="1">Evaluation and the Scheme Stack</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties" accesskey="2">Source Properties</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="3">Programmatic Error Handling</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="4">Traps</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#GDB-Support" accesskey="5">GDB Support</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Evaluation-Model">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties" accesskey="n" rel="next">Source Properties</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="u" rel="up">Debugging Infrastructure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Evaluation-and-the-Scheme-Stack">6.26.1 Evaluation and the Scheme Stack</h4>

<p>The idea of the Scheme stack is central to a lot of debugging.  The
Scheme stack is a reified representation of the pending function returns
in an expression’s continuation.  As Guile implements function calls
using a stack, this reification takes the form of a number of nested
stack frames, each of which corresponds to the application of a
procedure to a set of arguments.
</p>
<p>A Scheme stack always exists implicitly, and can be summoned into
concrete existence as a first-class Scheme value by the
<code class="code">make-stack</code> call, so that an introspective Scheme program – such
as a debugger – can present it in some way and allow the user to query
its details. The first thing to understand, therefore, is how Guile’s
function call convention creates the stack.
</p>
<p>Broadly speaking, Guile represents all control flow on a stack. Calling
a function involves pushing an empty frame on the stack, then evaluating
the procedure and its arguments, then fixing up the new frame so that it
points to the old one. Frames on the stack are thus linked together. A
tail call is the same, except it reuses the existing frame instead of
pushing on a new one.
</p>
<p>In this way, the only frames that are on the stack are “active”
frames, frames which need to do some work before the computation is
complete. On the other hand, a function that has tail-called another
function will not be on the stack, as it has no work left to do.
</p>
<p>Therefore, when an error occurs in a running program, or the program
hits a breakpoint, or in fact at any point that the programmer chooses,
its state at that point can be represented by a <em class="dfn">stack</em> of all the
procedure applications that are logically in progress at that time, each
of which is known as a <em class="dfn">frame</em>.  The programmer can learn more about
the program’s state at that point by inspecting the stack and its
frames.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Capture" accesskey="1">Stack Capture</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Stacks" accesskey="2">Stacks</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Frames" accesskey="3">Frames</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Stack-Capture">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Stacks" accesskey="n" rel="next">Stacks</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model" accesskey="u" rel="up">Evaluation and the Scheme Stack</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Stack-Capture-1">6.26.1.1 Stack Capture</h4>

<p>A Scheme program can use the <code class="code">make-stack</code> primitive anywhere in its
code, with first arg <code class="code">#t</code>, to construct a Scheme value that
describes the Scheme stack at that point.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(make-stack #t)
⇒
#&lt;stack 25205a0&gt;
</pre></div>

<p>Use <code class="code">start-stack</code> to limit the stack extent captured by future
<code class="code">make-stack</code> calls.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dstack"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-stack</strong> <var class="def-var-arguments">obj arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dstack"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fstack"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_stack</strong> <var class="def-var-arguments">(obj, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fstack"> ¶</a></span></dt>
<dd><p>Create a new stack. If <var class="var">obj</var> is <code class="code">#t</code>, the current
evaluation stack is used for creating the stack frames,
otherwise the frames are taken from <var class="var">obj</var> (which must be
a continuation or a frame object).
</p>
<p><var class="var">arg</var> … can be any combination of integer, procedure, address
range, and prompt tag values.
</p>
<p>These values specify various ways of cutting away uninteresting stack
frames from the top and bottom of the stack that <code class="code">make-stack</code>
returns.  They come in pairs like this:  <code class="code">(<var class="var">inner_cut_1</var>
<var class="var">outer_cut_1</var> <var class="var">inner_cut_2</var> <var class="var">outer_cut_2</var> …)</code>.
</p>
<p>Each <var class="var">inner_cut_i</var> can be an integer, a procedure, an address range,
or a prompt tag.  An integer means to cut away exactly that number of
frames.  A procedure means to cut away all frames up to but excluding
the frame whose procedure matches the specified one.  An address range
is a pair of integers indicating the low and high addresses of a
procedure’s code, and is the same as cutting away to a procedure (though
with less work).  Anything else is interpreted as a prompt tag which
cuts away all frames that are inside a prompt with the given tag.
</p>
<p>Each <var class="var">outer_cut_i</var> can likewise be an integer, a procedure, an
address range, or a prompt tag.  An integer means to cut away that
number of frames.  A procedure means to cut away frames down to but
excluding the frame whose procedure matches the specified one.  An
address range is the same, but with the procedure’s code specified as an
address range.  Anything else is taken to be a prompt tag, which cuts
away all frames that are outside a prompt with the given tag.
</p>

<p>If the <var class="var">outer_cut_i</var> of the last pair is missing, it is taken as 0.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-start_002dstack"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">start-stack</strong> <var class="def-var-arguments">id exp</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-start_002dstack"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">exp</var> on a new calling stack with identity <var class="var">id</var>.  If
<var class="var">exp</var> is interrupted during evaluation, backtraces will not display
frames farther back than <var class="var">exp</var>’s top-level form.  This macro is a
way of artificially limiting backtraces and stack procedures, largely as
a convenience to the user.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Stacks">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Frames" accesskey="n" rel="next">Frames</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Capture" accesskey="p" rel="prev">Stack Capture</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model" accesskey="u" rel="up">Evaluation and the Scheme Stack</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Stacks-1">6.26.1.2 Stacks</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-stack_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stack?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stack_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstack_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stack_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstack_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a calling stack.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stack_002did"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stack-id</strong> <var class="def-var-arguments">stack</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stack_002did"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstack_005fid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stack_id</strong> <var class="def-var-arguments">(stack)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstack_005fid"> ¶</a></span></dt>
<dd><p>Return the identifier given to <var class="var">stack</var> by <code class="code">start-stack</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stack_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stack-length</strong> <var class="def-var-arguments">stack</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stack_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstack_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stack_length</strong> <var class="def-var-arguments">(stack)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstack_005flength"> ¶</a></span></dt>
<dd><p>Return the length of <var class="var">stack</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-stack_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stack-ref</strong> <var class="def-var-arguments">stack index</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stack_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstack_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stack_ref</strong> <var class="def-var-arguments">(stack, index)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstack_005fref"> ¶</a></span></dt>
<dd><p>Return the <var class="var">index</var>’th frame from <var class="var">stack</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-display_002dbacktrace"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">display-backtrace</strong> <var class="def-var-arguments">stack port [first [depth [highlights]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-display_002dbacktrace"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdisplay_005fbacktrace_005fwith_005fhighlights"><span class="category-def">C Function: </span><span><strong class="def-name">scm_display_backtrace_with_highlights</strong> <var class="def-var-arguments">(stack, port, first, depth, highlights)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdisplay_005fbacktrace_005fwith_005fhighlights"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdisplay_005fbacktrace"><span class="category-def">C Function: </span><span><strong class="def-name">scm_display_backtrace</strong> <var class="def-var-arguments">(stack, port, first, depth)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdisplay_005fbacktrace"> ¶</a></span></dt>
<dd><p>Display a backtrace to the output port <var class="var">port</var>.  <var class="var">stack</var>
is the stack to take the backtrace from, <var class="var">first</var> specifies
where in the stack to start and <var class="var">depth</var> how many frames
to display.  <var class="var">first</var> and <var class="var">depth</var> can be <code class="code">#f</code>,
which means that default values will be used.
If <var class="var">highlights</var> is given it should be a list; the elements
of this list will be highlighted wherever they appear in the
backtrace.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Frames">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Stacks" accesskey="p" rel="prev">Stacks</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model" accesskey="u" rel="up">Evaluation and the Scheme Stack</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Frames-1">6.26.1.3 Frames</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fframe_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_frame_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fframe_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a stack frame.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002dprevious"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-previous</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dprevious"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fframe_005fprevious"><span class="category-def">C Function: </span><span><strong class="def-name">scm_frame_previous</strong> <var class="def-var-arguments">(frame)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fframe_005fprevious"> ¶</a></span></dt>
<dd><p>Return the previous frame of <var class="var">frame</var>, or <code class="code">#f</code> if
<var class="var">frame</var> is the first frame in its stack.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002dprocedure_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-procedure-name</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dprocedure_002dname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fframe_005fprocedure_005fname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_frame_procedure_name</strong> <var class="def-var-arguments">(frame)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fframe_005fprocedure_005fname"> ¶</a></span></dt>
<dd><p>Return the name of the procedure being applied in <var class="var">frame</var>, as a
symbol, or <code class="code">#f</code> if the procedure has no name.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002darguments"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-arguments</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002darguments"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fframe_005farguments"><span class="category-def">C Function: </span><span><strong class="def-name">scm_frame_arguments</strong> <var class="def-var-arguments">(frame)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fframe_005farguments"> ¶</a></span></dt>
<dd><p>Return the arguments of <var class="var">frame</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002daddress"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-address</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002daddress"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-frame_002dinstruction_002dpointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-instruction-pointer</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dinstruction_002dpointer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-frame_002dstack_002dpointer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-stack-pointer</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dstack_002dpointer"> ¶</a></span></dt>
<dd><p>Accessors for the three VM registers associated with this frame: the
frame pointer (fp), instruction pointer (ip), and stack pointer (sp),
respectively. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Concepts">VM Concepts</a>, for more information.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002ddynamic_002dlink"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-dynamic-link</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002ddynamic_002dlink"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-frame_002dreturn_002daddress"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-return-address</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dreturn_002daddress"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-frame_002dmv_002dreturn_002daddress"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-mv-return-address</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dmv_002dreturn_002daddress"> ¶</a></span></dt>
<dd><p>Accessors for the three saved VM registers in a frame: the previous
frame pointer, the single-value return address, and the multiple-value
return address.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Layout">Stack Layout</a>, for more information.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002dbindings"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-bindings</strong> <var class="def-var-arguments">frame</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dbindings"> ¶</a></span></dt>
<dd><p>Return a list of binding records indicating the local variables that are
live in a frame.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-frame_002dlookup_002dbinding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">frame-lookup-binding</strong> <var class="def-var-arguments">frame var</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-frame_002dlookup_002dbinding"> ¶</a></span></dt>
<dd><p>Fetch the bindings in <var class="var">frame</var>, and return the first one whose name
is <var class="var">var</var>, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-binding_002dindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-index</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002dindex"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-name</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002dname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_002dslot"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-slot</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002dslot"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_002drepresentation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-representation</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002drepresentation"> ¶</a></span></dt>
<dd><p>Accessors for the various fields in a binding.  The implicit “callee”
argument is index 0, the first argument is index 1, and so on to the end
of the arguments.  After that are temporary variables.  Note that if a
variable is dead, it might not be available.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-binding_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-ref</strong> <var class="def-var-arguments">binding</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-binding_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">binding-set!</strong> <var class="def-var-arguments">binding val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-binding_002dset_0021"> ¶</a></span></dt>
<dd><p>Accessors for the values of local variables in a frame.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-display_002dapplication"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">display-application</strong> <var class="def-var-arguments">frame [port [indent]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-display_002dapplication"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdisplay_005fapplication"><span class="category-def">C Function: </span><span><strong class="def-name">scm_display_application</strong> <var class="def-var-arguments">(frame, port, indent)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdisplay_005fapplication"> ¶</a></span></dt>
<dd><p>Display a procedure application <var class="var">frame</var> to the output port
<var class="var">port</var>. <var class="var">indent</var> specifies the indentation of the
output.
</p></dd></dl>

<p>Additionally, the <code class="code">(system vm frame)</code> module defines a number of
higher-level introspective procedures, for example to retrieve the names
of local variables, and the source location to correspond to a
frame. See its source code for more details.
</p>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Source-Properties">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="n" rel="next">Programmatic Error Handling</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Evaluation-Model" accesskey="p" rel="prev">Evaluation and the Scheme Stack</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="u" rel="up">Debugging Infrastructure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Source-Properties-1">6.26.2 Source Properties</h4>

<p>How best to associate source locations with datums parsed from a port?
The right way to do this is to annotate all components of each parsed
datum.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Annotated-Scheme-Read">Reading Scheme Code, For the Compiler</a>, for more on <code class="code">read-syntax</code>.
</p>
<a class="index-entry-id" id="index-source-properties"></a>
<p>Guile only switched to use <code class="code">read-syntax</code> in 2021, however.  For the
previous thirty years, it used a mechanism known as <em class="dfn">source
properties</em>.
</p>
<p>As Guile reads in Scheme code from file or from standard input, it can
record the file name, line number and column number where each
expression begins in a side table.
</p>
<p>The way that this side table associates datums with source properties
has a limitation, however: Guile can only associate source properties
with freshly allocated objects.  This notably excludes individual
symbols, keywords, characters, booleans, or small integers.  This
limitation finally motivated the switch to <code class="code">read-syntax</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-supports_002dsource_002dproperties_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">supports-source-properties?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-supports_002dsource_002dproperties_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsupports_005fsource_005fproperties_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_supports_source_properties_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsupports_005fsource_005fproperties_005fp"> ¶</a></span></dt>
<dd><p>Return #t if source properties can be associated with <var class="var">obj</var>,
otherwise return #f.
</p></dd></dl>

<p>The recording of source properties is controlled by the read option
named “positions” (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Scheme-Read">Reading Scheme Code</a>).  This option is switched
<em class="emph">on</em> by default.  Now that <code class="code">read-syntax</code> is available,
however, Guile may change the default for this flag to off in the
future.
</p>
<p>The following procedures can be used to access and set the source
properties of read expressions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-set_002dsource_002dproperties_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-source-properties!</strong> <var class="def-var-arguments">obj alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dsource_002dproperties_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fsource_005fproperties_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_source_properties_x</strong> <var class="def-var-arguments">(obj, alist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsource_005fproperties_005fx"> ¶</a></span></dt>
<dd><p>Install the association list <var class="var">alist</var> as the source property
list for <var class="var">obj</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dsource_002dproperty_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-source-property!</strong> <var class="def-var-arguments">obj key datum</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dsource_002dproperty_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fsource_005fproperty_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_source_property_x</strong> <var class="def-var-arguments">(obj, key, datum)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fsource_005fproperty_005fx"> ¶</a></span></dt>
<dd><p>Set the source property of object <var class="var">obj</var>, which is specified by
<var class="var">key</var> to <var class="var">datum</var>.  Normally, the key will be a symbol.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-source_002dproperties"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source-properties</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_002dproperties"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsource_005fproperties"><span class="category-def">C Function: </span><span><strong class="def-name">scm_source_properties</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsource_005fproperties"> ¶</a></span></dt>
<dd><p>Return the source property association list of <var class="var">obj</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-source_002dproperty"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">source-property</strong> <var class="def-var-arguments">obj key</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-source_002dproperty"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsource_005fproperty"><span class="category-def">C Function: </span><span><strong class="def-name">scm_source_property</strong> <var class="def-var-arguments">(obj, key)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsource_005fproperty"> ¶</a></span></dt>
<dd><p>Return the property specified by <var class="var">key</var> from <var class="var">obj</var>’s source
properties.
</p></dd></dl>

<p>If the <code class="code">positions</code> reader option is enabled, supported expressions
will have values set for the <code class="code">filename</code>, <code class="code">line</code> and
<code class="code">column</code> properties.
</p>
<p>Source properties are also associated with syntax objects.  Procedural
macros can get at the source location of their input using the
<code class="code">syntax-source</code> accessor.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Syntax-Transformer-Helpers">Syntax Transformer Helpers</a>, for
more.
</p>
<p>Guile also defines a couple of convenience macros built on
<code class="code">syntax-source</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-current_002dsource_002dlocation"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">current-source-location</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dsource_002dlocation"> ¶</a></span></dt>
<dd><p>Expands to the source properties corresponding to the location of the
<code class="code">(current-source-location)</code> form.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dfilename"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">current-filename</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dfilename"> ¶</a></span></dt>
<dd><p>Expands to the current filename: the filename that the
<code class="code">(current-filename)</code> form appears in.  Expands to <code class="code">#f</code> if this
information is unavailable.
</p></dd></dl>

<p>If you’re stuck with defmacros (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Defmacros">Lisp-style Macro Definitions</a>), and want to preserve
source information, the following helper function might be useful to
you:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-cons_002dsource"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">cons-source</strong> <var class="def-var-arguments">xorig x y</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cons_002dsource"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcons_005fsource"><span class="category-def">C Function: </span><span><strong class="def-name">scm_cons_source</strong> <var class="def-var-arguments">(xorig, x, y)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcons_005fsource"> ¶</a></span></dt>
<dd><p>Create and return a new pair whose car and cdr are <var class="var">x</var> and <var class="var">y</var>.
Any source properties associated with <var class="var">xorig</var> are also associated
with the new pair.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Programmatic-Error-Handling">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="n" rel="next">Traps</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Source-Properties" accesskey="p" rel="prev">Source Properties</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="u" rel="up">Debugging Infrastructure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Programmatic-Error-Handling-1">6.26.3 Programmatic Error Handling</h4>

<p>For better or for worse, all programs have bugs, and dealing with bugs
is part of programming. This section deals with that class of bugs that
causes an exception to be raised – from your own code, from within a
library, or from Guile itself.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Catching-Exceptions" accesskey="1">Catching Exceptions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Pre_002dUnwind-Debugging" accesskey="2">Pre-Unwind Debugging</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Error-Handling" accesskey="3">call-with-error-handling</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Overflow" accesskey="4">Stack Overflow</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Options" accesskey="5">Debug options</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Catching-Exceptions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pre_002dUnwind-Debugging" accesskey="n" rel="next">Pre-Unwind Debugging</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="u" rel="up">Programmatic Error Handling</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Catching-Exceptions-1">6.26.3.1 Catching Exceptions</h4>

<p>A common requirement is to be able to show as much useful context as
possible when a Scheme program hits an error.  The most immediate
information about an error is the kind of error that it is – such as
“division by zero” – and any parameters that the code which signalled
the error chose explicitly to provide.  This information originates with
the <code class="code">error</code> or <code class="code">raise-exception</code> call (or their C code
equivalents, if the error is detected by C code) that signals the error,
and is passed automatically to the handler procedure of the innermost
applicable exception handler.
</p>
<p>Therefore, to catch errors that occur within a chunk of Scheme code, and
to intercept basic information about those errors, you need to execute
that code inside the dynamic context of a <code class="code">with-exception-handler</code>,
or the equivalent in C.
</p>
<p>For example, to print out a message and return #f when an error occurs,
you might use:
</p>
<div class="example smalllisp lisp">
<pre class="lisp-preformatted">(define (catch-all thunk)
  (with-exception-handler
    (lambda (exn)
      (format (current-error-port)
              "Uncaught exception: ~s\n" exn)
      #f)
    thunk
    #:unwind? #t))

(catch-all
 (lambda () (error "Not a vegetable: tomato")))
-| Uncaught exception: #&lt;&amp;exception-with-kind-and-args ...&gt;
⇒ #f
</pre></div>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>, for full details.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Pre_002dUnwind-Debugging">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Error-Handling" accesskey="n" rel="next">call-with-error-handling</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Catching-Exceptions" accesskey="p" rel="prev">Catching Exceptions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="u" rel="up">Programmatic Error Handling</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Pre_002dUnwind-Debugging-1">6.26.3.2 Pre-Unwind Debugging</h4>

<p>Sometimes when something goes wrong, what you want is not just a
representation of the exceptional situation, but the context that
brought about that situation.  The example in the previous section
passed <code class="code">#:unwind #t</code> to <code class="code">with-exception-handler</code>, indicating
that <code class="code">raise-exception</code> should unwind the stack before invoking the
exception handler.  However if you don’t take this approach and instead
let the exception handler be invoked in the context of the
<code class="code">raise-exception</code>, you can print a backtrace, launch a recursive
debugger, or take other “pre-unwind” actions.
</p>
<p>The most basic idea would be to simply print a backtrace:
</p>
<div class="example">
<pre class="example-preformatted">(define (call-with-backtrace thunk)
  (with-exception-handler
    (lambda (exn)
      (backtrace)
      (raise-exception exn))
    thunk))
</pre></div>

<p>Here we use the built-in <code class="code">backtrace</code> procedure to print the
backtrace.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-backtrace-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">backtrace</strong> <var class="def-var-arguments">[highlights]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-backtrace-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbacktrace_005fwith_005fhighlights"><span class="category-def">C Function: </span><span><strong class="def-name">scm_backtrace_with_highlights</strong> <var class="def-var-arguments">(highlights)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbacktrace_005fwith_005fhighlights"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbacktrace"><span class="category-def">C Function: </span><span><strong class="def-name">scm_backtrace</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbacktrace"> ¶</a></span></dt>
<dd><p>Display a backtrace of the current stack to the current output port.  If
<var class="var">highlights</var> is given it should be a list; the elements of this list
will be highlighted wherever they appear in the backtrace.
</p></dd></dl>

<p>By re-raising the exception, <code class="code">call-with-backtrace</code> doesn’t actually
handle the error.  We could define a version that instead aborts the
computation:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 control))
(define (call-with-backtrace thunk)
  (let/ec cancel
    (with-exception-handler
      (lambda (exn)
        (backtrace)
        (cancel #f))
      thunk)))
</pre></div>

<p>In this second example, we use an escape continuation to abort the
computation after printing the backtrace, returning <code class="code">#f</code> instead.
</p>
<p>It could be that you want to only print a limited backtrace.  In that
case, use <code class="code">start-stack</code>:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 control))
(define (call-with-backtrace thunk)
  (let/ec cancel
    (start-stack 'stack-with-backtrace
      (with-exception-handler
        (lambda (exn)
          (backtrace)
          (cancel #f))
        thunk))))
</pre></div>

<p>There are also more powerful, programmatic ways to walk the stack using
<code class="code">make-stack</code> and friends; see the API described in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Stacks">Stacks</a> and
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Frames">Frames</a>.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Standard-Error-Handling">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Overflow" accesskey="n" rel="next">Stack Overflow</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pre_002dUnwind-Debugging" accesskey="p" rel="prev">Pre-Unwind Debugging</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="u" rel="up">Programmatic Error Handling</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="call_002dwith_002derror_002dhandling">6.26.3.3 call-with-error-handling</h4>

<p>The Guile REPL code (in <samp class="file">system/repl/repl.scm</samp> and related files)
uses a <code class="code">catch</code> with a pre-unwind handler to capture the stack when
an error occurs in an expression that was typed into the REPL, and debug
that stack interactively in the context of the error.
</p>
<p>These procedures are available for use by user programs, in the
<code class="code">(system repl error-handling)</code> module.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system repl error-handling))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002derror_002dhandling"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-error-handling</strong> <var class="def-var-arguments">thunk        [#:on-error on-error=’debug] [#:post-error post-error=’catch]        [#:pass-keys pass-keys=’(quit)]        [#:report-keys report-keys=’(stack-overflow)]        [#:trap-handler trap-handler=’debug]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002derror_002dhandling"> ¶</a></span></dt>
<dd><p>Call a thunk in a context in which errors are handled.
</p>
<p>Note that this function was written when <code class="code">throw</code>/<code class="code">catch</code> were
the fundamental exception handling primitives in Guile, and so exposes
some aspects of that interface (notably in the form of the procedural
handlers).  Guile will probably replace this function with a
<code class="code">call-with-standard-exception-handling</code> in the future.
</p>
<p>There are five keyword arguments:
</p>
<dl class="table">
<dt><var class="var">on-error</var></dt>
<dd><p>Specifies what to do before the stack is unwound.
</p>
<p>Valid options are <code class="code">debug</code> (the default), which will enter a
debugger; <code class="code">pass</code>, in which case nothing is done, and the exception
is rethrown; or a procedure, which will be the pre-unwind handler.
</p>
</dd>
<dt><var class="var">post-error</var></dt>
<dd><p>Specifies what to do after the stack is unwound.
</p>
<p>Valid options are <code class="code">catch</code> (the default), which will silently catch
errors, returning the unspecified value; <code class="code">report</code>, which prints out
a description of the error (via <code class="code">display-error</code>), and then returns
the unspecified value; or a procedure, which will be the catch handler.
</p>
</dd>
<dt><var class="var">trap-handler</var></dt>
<dd><p>Specifies a trap handler: what to do when a breakpoint is hit.
</p>
<p>Valid options are <code class="code">debug</code>, which will enter the debugger;
<code class="code">pass</code>, which does nothing; or <code class="code">disabled</code>, which disables
traps entirely.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Traps">Traps</a>, for more information.
</p>
</dd>
<dt><var class="var">pass-keys</var></dt>
<dd><p>A set of keys to ignore, as a list.
</p>
</dd>
<dt><var class="var">report-keys</var></dt>
<dd><p>A set of keys to always report even if the post-error handler is
<code class="code">catch</code>, as a list.
</p></dd>
</dl>
</dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Stack-Overflow">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debug-Options" accesskey="n" rel="next">Debug options</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Standard-Error-Handling" accesskey="p" rel="prev">call-with-error-handling</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="u" rel="up">Programmatic Error Handling</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Stack-Overflow-1">6.26.3.4 Stack Overflow</h4>

<a class="index-entry-id" id="index-overflow_002c-stack"></a>
<a class="index-entry-id" id="index-stack-overflow"></a>
<p>Every time a Scheme program makes a call that is not in tail position,
it pushes a new frame onto the stack.  Returning a value from a function
pops the top frame off the stack.  Stack frames take up memory, and as
nobody has an infinite amount of memory, deep recursion could cause
Guile to run out of memory.  Running out of stack memory is called
<em class="dfn">stack overflow</em>.
</p>
<h4 class="subsubheading" id="Stack-Limits">Stack Limits</h4>

<p>Most languages have a terrible stack overflow story.  For example, in C,
if you use too much stack, your program will exhibit “undefined
behavior”, which if you are lucky means that it will crash.  It’s
especially bad in C, as you neither know ahead of time how much stack
your functions use, nor the stack limit imposed by the user’s system,
and the stack limit is often quite small relative to the total memory
size.
</p>
<p>Managed languages like Python have a better error story, as they are
defined to raise an exception on stack overflow – but like C, Python
and most dynamic languages still have a fixed stack size limit that is
usually much smaller than the heap.
</p>
<p>Arbitrary stack limits would have an unfortunate effect on Guile
programs.  For example, the following implementation of the inner loop
of <code class="code">map</code> is clean and elegant:
</p>
<div class="example">
<pre class="example-preformatted">(define (map f l)
  (if (pair? l)
      (cons (f (car l))
            (map f (cdr l)))
      '()))
</pre></div>

<p>However, if there were a stack limit, that would limit the size of lists
that can be processed with this <code class="code">map</code>.  Eventually, you would have
to rewrite it to use iteration with an accumulator:
</p>
<div class="example">
<pre class="example-preformatted">(define (map f l)
  (let lp ((l l) (out '()))
    (if (pair? l)
        (lp (cdr l) (cons (f (car l)) out))
        (reverse out))))
</pre></div>

<p>This second version is sadly not as clear, and it also allocates more
heap memory (once to build the list in reverse, and then again to
reverse the list).  You would be tempted to use the destructive
<code class="code">reverse!</code> to save memory and time, but then your code would not be
continuation-safe – if <var class="var">f</var> returned again after the map had
finished, it would see an <var class="var">out</var> list that had already been
reversed.  The recursive <code class="code">map</code> has none of these problems.
</p>
<p>Guile has no stack limit for Scheme code.  When a thread makes its first
Guile call, a small stack is allocated – just one page of memory.
Whenever that memory limit would be reached, Guile arranges to grow the
stack by a factor of two.  When garbage collection happens, Guile
arranges to return the unused part of the stack to the operating system,
but without causing the stack to shrink.  In this way, the stack can
grow to consume up to all memory available to the Guile process, and
when the recursive computation eventually finishes, that stack memory is
returned to the system.
</p>
<h4 class="subsubheading" id="Exceptional-Situations">Exceptional Situations</h4>

<p>Of course, it’s still possible to run out of stack memory.  The most
common cause of this is program bugs that cause unbounded recursion, as
in:
</p>
<div class="example">
<pre class="example-preformatted">(define (faulty-map f l)
  (if (pair? l)
      (cons (f (car l)) (faulty-map f l))
      '()))
</pre></div>

<p>Did you spot the bug?  The recursive call to <code class="code">faulty-map</code> recursed
on <var class="var">l</var>, not <code class="code">(cdr <var class="var">l</var>)</code>.  Running this program would cause
Guile to use up all memory in your system, and eventually Guile would
fail to grow the stack.  At that point you have a problem: Guile needs
to raise an exception to unwind the stack and return memory to the
system, but the user might have exception handlers in place
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions">Raising and Handling Exceptions</a>) that want to run before the
stack is unwound, and we don’t have any stack in which to run them.
</p>
<p>Therefore in this case, Guile raises an unwind-only exception that does
not run pre-unwind handlers.  Because this is such an odd case, Guile
prints out a message on the console, in case the user was expecting to
be able to get a backtrace from any pre-unwind handler.
</p>
<h4 class="subsubheading" id="Runaway-Recursion">Runaway Recursion</h4>

<p>Still, this failure mode is not so nice.  If you are running an
environment in which you are interactively building a program while it
is running, such as at a REPL, you might want to impose an artificial
stack limit on the part of your program that you are building to detect
accidental runaway recursion.  For that purpose, there is
<code class="code">call-with-stack-overflow-handler</code>, from <code class="code">(system vm vm)</code>.
</p>
<div class="example">
<pre class="example-preformatted">(use-module (system vm vm))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dstack_002doverflow_002dhandler"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-stack-overflow-handler</strong> <var class="def-var-arguments">limit thunk handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dstack_002doverflow_002dhandler"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var> in an environment in which the stack limit has been
reduced to <var class="var">limit</var> additional words.  If the limit is reached,
<var class="var">handler</var> (a thunk) will be invoked in the dynamic environment of
the error.  For the extent of the call to <var class="var">handler</var>, the stack limit
and handler are restored to the values that were in place when
<code class="code">call-with-stack-overflow-handler</code> was called.
</p>
<p>Usually, <var class="var">handler</var> should raise an exception or abort to an outer
prompt.  However if <var class="var">handler</var> does return, it should return a number
of additional words of stack space to allow to the inner environment.
</p></dd></dl>

<p>A stack overflow handler may only ever “credit” the inner thunk with
stack space that was available when the handler was instated.  When
Guile first starts, there is no stack limit in place, so the outer
handler may allow the inner thunk an arbitrary amount of space, but any
nested stack overflow handler will not be able to consume more than its
limit.
</p>
<p>Unlike the unwind-only exception that is thrown if Guile is unable to
grow its stack, any exception thrown by a stack overflow handler might
invoke pre-unwind handlers.  Indeed, the stack overflow handler is
itself a pre-unwind handler of sorts.  If the code imposing the stack
limit wants to protect itself against malicious pre-unwind handlers from
the inner thunk, it should abort to a prompt of its own making instead
of throwing an exception that might be caught by the inner thunk.
</p>
<h4 class="subsubheading" id="C-Stack-Usage">C Stack Usage</h4>

<p>It is also possible for Guile to run out of space on the C stack.  If
you call a primitive procedure which then calls a Scheme procedure in a
loop, you will consume C stack space.  Guile tries to detect excessive
consumption of C stack space, throwing an error when you have hit 80% of
the process’ available stack (as allocated by the operating system), or
160 kilowords in the absence of a strict limit.
</p>
<p>For example, looping through <code class="code">call-with-vm</code>, a primitive that calls
a thunk, gives us the following:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (use-modules (system vm vm))
scheme@(guile-user)&gt; (let lp () (call-with-vm lp))
ERROR: Stack overflow
</pre></div>

<p>Unfortunately, that’s all the information we get.  Overrunning the C
stack will throw an unwind-only exception, because it’s not safe to
do very much when you are close to the C stack limit.
</p>
<p>If you get an error like this, you can either try rewriting your code to
use less stack space, or increase the maximum stack size.  To increase
the maximum stack size, use <code class="code">debug-set!</code>, for example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(debug-set! stack 200000)
</pre></div>

<p>The next section describes <code class="code">debug-set!</code> more thoroughly.  Of course
the best thing is to have your code operate without so much resource
consumption by avoiding loops through C trampolines.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="Debug-Options">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Stack-Overflow" accesskey="p" rel="prev">Stack Overflow</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="u" rel="up">Programmatic Error Handling</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Debug-options">6.26.3.5 Debug options</h4>

<p>The behavior of the <code class="code">backtrace</code> procedure and of the default error
handler can be parameterized via the debug options.
</p>
<a class="index-entry-id" id="index-options-_002d-debug"></a>
<a class="index-entry-id" id="index-debug-options"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-debug_002doptions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">debug-options</strong> <var class="def-var-arguments">[setting]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debug_002doptions"> ¶</a></span></dt>
<dd><p>Display the current settings of the debug options.  If <var class="var">setting</var> is
omitted, only a short form of the current read options is printed.
Otherwise if <var class="var">setting</var> is the symbol <code class="code">help</code>, a complete options
description is displayed.
</p></dd></dl>

<p>The set of available options, and their default values, may be had by
invoking <code class="code">debug-options</code> at the prompt.
</p>
<div class="example smallexample">
<pre class="example-preformatted">scheme@(guile-user)&gt;
backwards       no      Display backtrace in anti-chronological order.
width           79      Maximal width of backtrace.
depth           20      Maximal length of printed backtrace.
backtrace       yes     Show backtrace on error.
stack           1048576 Stack size limit (measured in words;
                        0 = no check). 
show-file-name  #t      Show file names and line numbers in backtraces
                        when not `#f'.  A value of `base' displays only
                        base names, while `#t' displays full names. 
warn-deprecated no      Warn when deprecated features are used.
</pre></div>

<p>The boolean options may be toggled with <code class="code">debug-enable</code> and
<code class="code">debug-disable</code>. The non-boolean options must be set using
<code class="code">debug-set!</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-debug_002denable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">debug-enable</strong> <var class="def-var-arguments">option-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debug_002denable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-debug_002ddisable"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">debug-disable</strong> <var class="def-var-arguments">option-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debug_002ddisable"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-debug_002dset_0021"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">debug-set!</strong> <var class="def-var-arguments">option-name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-debug_002dset_0021"> ¶</a></span></dt>
<dd><p>Modify the debug options.  <code class="code">debug-enable</code> should be used with boolean
options and switches them on, <code class="code">debug-disable</code> switches them off.
</p>
<p><code class="code">debug-set!</code> can be used to set an option to a specific value.  Due
to historical oddities, it is a macro that expects an unquoted option
name.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="Traps">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#GDB-Support" accesskey="n" rel="next">GDB Support</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Programmatic-Error-Handling" accesskey="p" rel="prev">Programmatic Error Handling</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="u" rel="up">Debugging Infrastructure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Traps-1">6.26.4 Traps</h4>

<a class="index-entry-id" id="index-Traps"></a>
<a class="index-entry-id" id="index-VM-hooks"></a>
<a class="index-entry-id" id="index-Breakpoints"></a>
<a class="index-entry-id" id="index-Trace"></a>
<a class="index-entry-id" id="index-Tracing"></a>
<a class="index-entry-id" id="index-Code-coverage"></a>
<a class="index-entry-id" id="index-Profiling"></a>
<p>Guile’s virtual machine can be configured to call out at key points to
arbitrary user-specified procedures.
</p>
<p>In principle, these <em class="dfn">hooks</em> allow Scheme code to implement any model
it chooses for examining the evaluation stack as program execution
proceeds, and for suspending execution to be resumed later.
</p>
<p>VM hooks are very low-level, though, and so Guile also has a library of
higher-level <em class="dfn">traps</em> on top of the VM hooks. A trap is an execution
condition that, when fulfilled, will fire a handler. For example, Guile
defines a trap that fires when control reaches a certain source
location.
</p>
<p>Finally, Guile also defines a third level of abstractions: per-thread
<em class="dfn">trap states</em>. A trap state exists to give names to traps, and to
hold on to the set of traps so that they can be enabled, disabled, or
removed. The trap state infrastructure defines the most useful
abstractions for most cases. For example, Guile’s REPL uses trap state
functions to set breakpoints and tracepoints.
</p>
<p>The following subsections describe all this in detail, for both the
user wanting to use traps, and the developer interested in
understanding how the interface hangs together.
</p>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks" accesskey="1">VM Hooks</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-Interface" accesskey="2">Trap Interface</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Low_002dLevel-Traps" accesskey="3">Low-Level Traps</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps" accesskey="4">Tracing Traps</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-States" accesskey="5">Trap States</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#High_002dLevel-Traps" accesskey="6">High-Level Traps</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="VM-Hooks">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-Interface" accesskey="n" rel="next">Trap Interface</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="VM-Hooks-1">6.26.4.1 VM Hooks</h4>

<p>Everything that runs in Guile runs on its virtual machine, a C program
that defines a number of operations that Scheme programs can
perform.
</p>
<p>Note that there are multiple VM “engines” for Guile. Only some of them
have support for hooks compiled in. Normally the deal is that you get
hooks if you are running interactively, and otherwise they are disabled,
as they do have some overhead (about 10 or 20 percent).
</p>
<p>To ensure that you are running with hooks, pass <code class="code">--debug</code> to Guile
when running your program, or otherwise use the <code class="code">call-with-vm</code> and
<code class="code">set-vm-engine!</code>  procedures to ensure that you are running in a VM
with the <code class="code">debug</code> engine.
</p>
<p>To digress, Guile’s VM has 4 different hooks that can be fired at
different times.  For implementation reasons, these hooks are not
actually implemented with first-class Scheme hooks (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Hooks">Hooks</a>); they
are managed using an ad-hoc interface.
</p>
<p>VM hooks are called with one argument: the current frame.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Frames">Frames</a>.  Since these hooks may be fired very frequently, Guile
does a terrible thing: it allocates the frames on the C stack instead of
the garbage-collected heap.
</p>
<p>The upshot here is that the frames are only valid within the dynamic
extent of the call to the hook. If a hook procedure keeps a reference to
the frame outside the extent of the hook, bad things will happen.
</p>
<p>The interface to hooks is provided by the <code class="code">(system vm vm)</code> module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system vm vm))
</pre></div>

<p>All of these functions implicitly act on the VM for the current thread
only.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dadd_002dnext_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-add-next-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dadd_002dnext_002dhook_0021"> ¶</a></span></dt>
<dd><p>Arrange to call <var class="var">f</var> when before an instruction is retired (and
executed).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dadd_002dapply_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-add-apply-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dadd_002dapply_002dhook_0021"> ¶</a></span></dt>
<dd><p>Arrange to call <var class="var">f</var> whenever a procedure is applied.  The frame
locals will be the callee, followed by the arguments to the call.
</p>
<p>Note that procedure application is somewhat orthogonal to continuation
pushes and pops.  To know whether a call is a tail call or not, with
respect to the frame previously in place, check the value of the frame
pointer compared the previous frame pointer.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dadd_002dreturn_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-add-return-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dadd_002dreturn_002dhook_0021"> ¶</a></span></dt>
<dd><p>Arrange to call <var class="var">f</var> before returning from a frame.  The values in
the frame will be the frame’s return values.
</p>
<p>Note that it’s possible to return from an “inner” frame: one that was
not immediately proceeded by a call with that frame pointer.  In that
case, it corresponds to a non-local control flow jump, either because of
applying a composable continuation or because of restoring a saved
undelimited continuation.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dadd_002dabort_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-add-abort-hook!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dadd_002dabort_002dhook_0021"> ¶</a></span></dt>
<dd><p>Arrange to call <var class="var">f</var> after aborting to a prompt.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Prompts">Prompts</a>.
</p>
<p>Unfortunately, the values passed to the prompt handler are not easily
available to <var class="var">f</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dremove_002dnext_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-remove-next-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dremove_002dnext_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vm_002dremove_002dapply_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-remove-apply-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dremove_002dapply_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vm_002dremove_002dreturn_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-remove-return-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dremove_002dreturn_002dhook_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-vm_002dremove_002dabort_002dhook_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-remove-abort-hook!</strong> <var class="def-var-arguments">f</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dremove_002dabort_002dhook_0021"> ¶</a></span></dt>
<dd><p>Remove <var class="var">f</var> from the corresponding VM hook for the current thread.
</p></dd></dl>

<a class="index-entry-id" id="index-VM-trace-level"></a>
<p>These hooks do impose a performance penalty, if they are on. Obviously,
the <code class="code">vm-next-hook</code> has quite an impact, performance-wise. Therefore
Guile exposes a single, heavy-handed knob to turn hooks on or off, the
<em class="dfn">VM trace level</em>. If the trace level is positive, hooks run;
otherwise they don’t.
</p>
<p>For convenience, when the VM fires a hook, it does so with the trap
level temporarily set to 0.  That way the hooks don’t fire while you’re
handling a hook.  The trace level is restored to whatever it was once the hook
procedure finishes.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-vm_002dtrace_002dlevel"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">vm-trace-level</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vm_002dtrace_002dlevel"> ¶</a></span></dt>
<dd><p>Retrieve the “trace level” of the VM. If positive, the trace hooks
associated with <var class="var">vm</var> will be run. The initial trace level is 0.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dvm_002dtrace_002dlevel_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-vm-trace-level!</strong> <var class="def-var-arguments">level</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dvm_002dtrace_002dlevel_0021"> ¶</a></span></dt>
<dd><p>Set the “trace level” of the VM.
</p></dd></dl>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#A-Virtual-Machine-for-Guile">A Virtual Machine for Guile</a>, for more information on Guile’s
virtual machine.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Trap-Interface">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Low_002dLevel-Traps" accesskey="n" rel="next">Low-Level Traps</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks" accesskey="p" rel="prev">VM Hooks</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Trap-Interface-1">6.26.4.2 Trap Interface</h4>

<p>The capabilities provided by hooks are great, but hooks alone rarely
correspond to what users want to do.
</p>
<p>For example, if a user wants to break when and if control reaches a
certain source location, how do you do it?  If you install a “next”
hook, you get unacceptable overhead for the execution of the entire
program. It would be possible to install an “apply” hook, then if the
procedure encompasses those source locations, install a “next” hook,
but already you’re talking about one concept that might be implemented
by a varying number of lower-level concepts.
</p>
<p>It’s best to be clear about things and define one abstraction for all
such conditions: the <em class="dfn">trap</em>.
</p>
<p>Considering the myriad capabilities offered by the hooks though, there
is only a minimum of functionality shared by all traps. Guile’s current
take is to reduce this to the absolute minimum, and have the only
standard interface of a trap be “turn yourself on” or “turn yourself
off”.
</p>
<p>This interface sounds a bit strange, but it is useful to procedurally
compose higher-level traps from lower-level building blocks. For
example, Guile defines a trap that calls one handler when control enters
a procedure, and another when control leaves the procedure. Given that
trap, one can define a trap that adds to the next-hook only when within
a given procedure. Building further, one can define a trap that fires
when control reaches particular instructions within a procedure.
</p>
<p>Or of course you can stop at any of these intermediate levels. For
example, one might only be interested in calls to a given procedure. But
the point is that a simple enable/disable interface is all the
commonality that exists between the various kinds of traps, and
furthermore that such an interface serves to allow “higher-level”
traps to be composed from more primitive ones.
</p>
<p>Specifically, a trap, in Guile, is a procedure. When a trap is created,
by convention the trap is enabled; therefore, the procedure that is the
trap will, when called, disable the trap, and return a procedure that
will enable the trap, and so on.
</p>
<p>Trap procedures take one optional argument: the current frame. (A trap
may want to add to different sets of hooks depending on the frame that
is current at enable-time.)
</p>
<p>If this all sounds very complicated, it’s because it is. Some of it is
essential, but probably most of it is not. The advantage of using this
minimal interface is that composability is more lexically apparent than
when, for example, using a stateful interface based on GOOPS. But
perhaps this reflects the cognitive limitations of the programmer who
made the current interface more than anything else.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Low_002dLevel-Traps">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps" accesskey="n" rel="next">Tracing Traps</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-Interface" accesskey="p" rel="prev">Trap Interface</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Low_002dLevel-Traps-1">6.26.4.3 Low-Level Traps</h4>

<p>To summarize the last sections, traps are enabled or disabled, and when
they are enabled, they add to various VM hooks.
</p>
<p>Note, however, that <em class="emph">traps do not increase the VM trace level</em>. So
if you create a trap, it will be enabled, but unless something else
increases the VM’s trace level (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks">VM Hooks</a>), the trap will not
fire.  It turns out that getting the VM trace level right is tricky
without a global view of what traps are enabled.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Trap-States">Trap States</a>,
for Guile’s answer to this problem.
</p>
<p>Traps are created by calling procedures. Most of these procedures share
a set of common keyword arguments, so rather than document them
separately, we discuss them all together here:
</p>
<dl class="table">
<dt><code class="code">#:vm</code></dt>
<dd><p>The VM to instrument. Defaults to the current thread’s VM.
</p></dd>
<dt><code class="code">#:current-frame</code></dt>
<dd><p>For traps that enable more hooks depending on their dynamic context,
this argument gives the current frame that the trap is running in.
Defaults to <code class="code">#f</code>.
</p></dd>
</dl>

<p>To have access to these procedures, you’ll need to have imported the
<code class="code">(system vm traps)</code> module:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system vm traps))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dat_002dprocedure_002dcall"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-at-procedure-call</strong> <var class="def-var-arguments">proc handler        [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dat_002dprocedure_002dcall"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">handler</var> when <var class="var">proc</var> is applied.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002din_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-in-procedure</strong> <var class="def-var-arguments">proc        enter-handler exit-handler [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002din_002dprocedure"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">enter-handler</var> when control enters <var class="var">proc</var>,
and <var class="var">exit-handler</var> when control leaves <var class="var">proc</var>.
</p>
<p>Control can enter a procedure via:
</p><ul class="itemize mark-bullet">
<li>A procedure call.
</li><li>A return to a procedure’s frame on the stack.
</li><li>A continuation returning directly to an application of this procedure.
</li></ul>

<p>Control can leave a procedure via:
</p><ul class="itemize mark-bullet">
<li>A normal return from the procedure.
</li><li>An application of another procedure.
</li><li>An invocation of a continuation.
</li><li>An abort.
</li></ul>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dinstructions_002din_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-instructions-in-procedure</strong> <var class="def-var-arguments">proc        next-handler exit-handler [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dinstructions_002din_002dprocedure"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">next-handler</var> for every instruction executed in
<var class="var">proc</var>, and <var class="var">exit-handler</var> when execution leaves <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dat_002dprocedure_002dip_002din_002drange"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-at-procedure-ip-in-range</strong> <var class="def-var-arguments">proc range        handler [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dat_002dprocedure_002dip_002din_002drange"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">handler</var> when execution enters a range of
instructions in <var class="var">proc</var>. <var class="var">range</var> is a simple of pairs,
<code class="code">((<var class="var">start</var> . <var class="var">end</var>) ...)</code>. The <var class="var">start</var> addresses are
inclusive, and <var class="var">end</var> addresses are exclusive.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dat_002dsource_002dlocation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-at-source-location</strong> <var class="def-var-arguments">file user-line handler        [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dat_002dsource_002dlocation"> ¶</a></span></dt>
<dd><p>A trap that fires when control reaches a given source location.  The
<var class="var">user-line</var> parameter is one-indexed, as a user counts lines,
instead of zero-indexed, as Guile counts lines.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dframe_002dfinish"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-frame-finish</strong> <var class="def-var-arguments">frame        return-handler abort-handler [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dframe_002dfinish"> ¶</a></span></dt>
<dd><p>A trap that fires when control leaves the given frame. <var class="var">frame</var>
should be a live frame in the current continuation. <var class="var">return-handler</var>
will be called on a normal return, and <var class="var">abort-handler</var> on a nonlocal
exit.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002din_002ddynamic_002dextent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-in-dynamic-extent</strong> <var class="def-var-arguments">proc        enter-handler return-handler abort-handler [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002din_002ddynamic_002dextent"> ¶</a></span></dt>
<dd><p>A more traditional dynamic-wind trap, which fires <var class="var">enter-handler</var>
when control enters <var class="var">proc</var>, <var class="var">return-handler</var> on a normal return,
and <var class="var">abort-handler</var> on a nonlocal exit.
</p>
<p>Note that rewinds are not handled, so there is no rewind handler.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dcalls_002din_002ddynamic_002dextent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-calls-in-dynamic-extent</strong> <var class="def-var-arguments">proc        apply-handler return-handler [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dcalls_002din_002ddynamic_002dextent"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">apply-handler</var> every time a procedure is applied,
and <var class="var">return-handler</var> for returns, but only during the dynamic extent
of an application of <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dinstructions_002din_002ddynamic_002dextent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-instructions-in-dynamic-extent</strong> <var class="def-var-arguments">proc        next-handler [#:current-frame] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dinstructions_002din_002ddynamic_002dextent"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">next-handler</var> for all retired instructions within
the dynamic extent of a call to <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dcalls_002dto_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-calls-to-procedure</strong> <var class="def-var-arguments">proc        apply-handler return-handler [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dcalls_002dto_002dprocedure"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">apply-handler</var> whenever <var class="var">proc</var> is applied,
and <var class="var">return-handler</var> when it returns, but with an additional
argument, the call depth.
</p>
<p>That is to say, the handlers will get two arguments: the frame in
question, and the call depth (a non-negative integer).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dmatching_002dinstructions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-matching-instructions</strong> <var class="def-var-arguments">frame-pred handler [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dmatching_002dinstructions"> ¶</a></span></dt>
<dd><p>A trap that calls <var class="var">frame-pred</var> at every instruction, and if
<var class="var">frame-pred</var> returns a true value, calls <var class="var">handler</var> on the
frame.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="Tracing-Traps">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-States" accesskey="n" rel="next">Trap States</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Low_002dLevel-Traps" accesskey="p" rel="prev">Low-Level Traps</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Tracing-Traps-1">6.26.4.4 Tracing Traps</h4>

<p>The <code class="code">(system vm trace)</code> module defines a number of traps for
tracing of procedure applications.  When a procedure is <em class="dfn">traced</em>, it
means that every call to that procedure is reported to the user during a
program run.  The idea is that you can mark a collection of procedures
for tracing, and Guile will subsequently print out a line of the form
</p>
<div class="example lisp">
<pre class="lisp-preformatted">|  |  (<var class="var">procedure</var> <var class="var">args</var> …)
</pre></div>

<p>whenever a marked procedure is about to be applied to its arguments.
This can help a programmer determine whether a function is being called
at the wrong time or with the wrong set of arguments.
</p>
<p>In addition, the indentation of the output is useful for demonstrating
how the traced applications are or are not tail recursive with respect
to each other.  Thus, a trace of a non-tail recursive factorial
implementation looks like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (define (fact1 n) 
                       (if (zero? n) 1
                           (* n (fact1 (1- n)))))
scheme@(guile-user)&gt; ,trace (fact1 4)
trace: (fact1 4)
trace: |  (fact1 3)
trace: |  |  (fact1 2)
trace: |  |  |  (fact1 1)
trace: |  |  |  |  (fact1 0)
trace: |  |  |  |  1
trace: |  |  |  1
trace: |  |  2
trace: |  6
trace: 24
</pre></div>

<p>While a typical tail recursive implementation would look more like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">scheme@(guile-user)&gt; (define (facti acc n)
                       (if (zero? n) acc
                           (facti (* n acc) (1- n))))
scheme@(guile-user)&gt; (define (fact2 n) (facti 1 n))
scheme@(guile-user)&gt; ,trace (fact2 4)
trace: (fact2 4)
trace: (facti 1 4)
trace: (facti 4 3)
trace: (facti 12 2)
trace: (facti 24 1)
trace: (facti 24 0)
trace: 24
</pre></div>

<p>The low-level traps below (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Low_002dLevel-Traps">Low-Level Traps</a>) share some common
options:
</p>
<dl class="table">
<dt><code class="code">#:width</code></dt>
<dd><p>The maximum width of trace output. Trace printouts will try not to
exceed this column, but for highly nested procedure calls, it may be
unavoidable. Defaults to 80.
</p></dd>
<dt><code class="code">#:vm</code></dt>
<dd><p>The VM on which to add the traps. Defaults to the current thread’s VM.
</p></dd>
<dt><code class="code">#:prefix</code></dt>
<dd><p>A string to print out before each trace line. As seen above in the
examples, defaults to <code class="code">"trace: "</code>.
</p></dd>
</dl>

<p>To have access to these procedures, you’ll need to have imported the
<code class="code">(system vm trace)</code> module:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system vm trace))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-trace_002dcalls_002dto_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trace-calls-to-procedure</strong> <var class="def-var-arguments">proc        [#:width] [#:vm] [#:prefix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trace_002dcalls_002dto_002dprocedure"> ¶</a></span></dt>
<dd><p>Print a trace at applications of and returns from <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trace_002dcalls_002din_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trace-calls-in-procedure</strong> <var class="def-var-arguments">proc        [#:width] [#:vm] [#:prefix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trace_002dcalls_002din_002dprocedure"> ¶</a></span></dt>
<dd><p>Print a trace at all applications and returns within the dynamic extent
of calls to <var class="var">proc</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trace_002dinstructions_002din_002dprocedure"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trace-instructions-in-procedure</strong> <var class="def-var-arguments">proc [#:width] [#:vm]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trace_002dinstructions_002din_002dprocedure"> ¶</a></span></dt>
<dd><p>Print a trace at all instructions executed in the dynamic extent of
calls to <var class="var">proc</var>.
</p></dd></dl>

<p>In addition, Guile defines a procedure to call a thunk, tracing all
procedure calls and returns within the thunk.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-call_002dwith_002dtrace"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">call-with-trace</strong> <var class="def-var-arguments">thunk [#:calls?=#t]                           [#:instructions?=#f]                           [#:width=80]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-call_002dwith_002dtrace"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var>, tracing all execution within its dynamic extent.
</p>
<p>If <var class="var">calls?</var> is true, Guile will print a brief report at each
procedure call and return, as given above.
</p>
<p>If <var class="var">instructions?</var> is true, Guile will also print a message each
time an instruction is executed.  This is a lot of output, but it is
sometimes useful when doing low-level optimization.
</p>
<p>Note that because this procedure manipulates the VM trace level
directly, it doesn’t compose well with traps at the REPL.
</p></dd></dl>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Profile-Commands">Profile Commands</a>, for more information on tracing at the REPL.
</p>
<hr>
</div>
<div class="subsubsection-level-extent" id="Trap-States">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#High_002dLevel-Traps" accesskey="n" rel="next">High-Level Traps</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps" accesskey="p" rel="prev">Tracing Traps</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Trap-States-1">6.26.4.5 Trap States</h4>

<p>When multiple traps are present in a system, we begin to have a
bookkeeping problem. How are they named? How does one disable, enable,
or delete them?
</p>
<p>Guile’s answer to this is to keep an implicit per-thread <em class="dfn">trap
state</em>. The trap state object is not exposed to the user; rather, API
that works on trap states fetches the current trap state from the
dynamic environment.
</p>
<p>Traps are identified by integers. A trap can be enabled, disabled, or
removed, and can have an associated user-visible name.
</p>
<p>These procedures have their own module:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system vm trap-state))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dtrap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-trap!</strong> <var class="def-var-arguments">trap name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dtrap_0021"> ¶</a></span></dt>
<dd><p>Add a trap to the current trap state, associating the given <var class="var">name</var>
with it. Returns a fresh trap identifier (an integer).
</p>
<p>Note that usually the more specific functions detailed in
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#High_002dLevel-Traps">High-Level Traps</a> are used in preference to this one.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dtraps"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-traps</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dtraps"> ¶</a></span></dt>
<dd><p>List the current set of traps, both enabled and disabled. Returns a list
of integers.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002dname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-name</strong> <var class="def-var-arguments">idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002dname"> ¶</a></span></dt>
<dd><p>Returns the name associated with trap <var class="var">idx</var>, or <code class="code">#f</code> if there
is no such trap.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-trap_002denabled_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">trap-enabled?</strong> <var class="def-var-arguments">idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trap_002denabled_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if trap <var class="var">idx</var> is present and enabled, or <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-enable_002dtrap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">enable-trap!</strong> <var class="def-var-arguments">idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-enable_002dtrap_0021"> ¶</a></span></dt>
<dd><p>Enables trap <var class="var">idx</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-disable_002dtrap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">disable-trap!</strong> <var class="def-var-arguments">idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-disable_002dtrap_0021"> ¶</a></span></dt>
<dd><p>Disables trap <var class="var">idx</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delete_002dtrap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete-trap!</strong> <var class="def-var-arguments">idx</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_002dtrap_0021"> ¶</a></span></dt>
<dd><p>Removes trap <var class="var">idx</var>, disabling it first, if necessary.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="High_002dLevel-Traps">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Trap-States" accesskey="p" rel="prev">Trap States</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="u" rel="up">Traps</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="High_002dLevel-Traps-1">6.26.4.6 High-Level Traps</h4>

<p>The low-level trap API allows one to make traps that call procedures,
and the trap state API allows one to keep track of what traps are
there.  But neither of these APIs directly helps you when you want to
set a breakpoint, because it’s unclear what to do when the trap fires.
Do you enter a debugger, or mail a summary of the situation to your
great-aunt, or what?
</p>
<p>So for the common case in which you just want to install breakpoints,
and then have them all result in calls to one parameterizable procedure,
we have the high-level trap interface.
</p>
<p>Perhaps we should have started this section with this interface, as it’s
clearly the one most people should use.  But as its capabilities and
limitations proceed from the lower layers, we felt that the
character-building exercise of building a mental model might be helpful.
</p>
<p>These procedures share a module with trap states:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (system vm trap-state))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-with_002ddefault_002dtrap_002dhandler"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-default-trap-handler</strong> <var class="def-var-arguments">handler thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002ddefault_002dtrap_002dhandler"> ¶</a></span></dt>
<dd><p>Call <var class="var">thunk</var> in a dynamic context in which <var class="var">handler</var> is the
current trap handler.
</p>
<p>Additionally, during the execution of <var class="var">thunk</var>, the VM trace level
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#VM-Hooks">VM Hooks</a>) is set to the number of enabled traps. This ensures
that traps will in fact fire.
</p>
<p><var class="var">handler</var> may be <code class="code">#f</code>, in which case VM hooks are not enabled
as they otherwise would be, as there is nothing to handle the traps.
</p></dd></dl>

<p>The trace-level-setting behavior of <code class="code">with-default-trap-handler</code> is
one of its more useful aspects, but if you are willing to forgo that,
and just want to install a global trap handler, there’s a function for
that too:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-install_002dtrap_002dhandler_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">install-trap-handler!</strong> <var class="def-var-arguments">handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-install_002dtrap_002dhandler_0021"> ¶</a></span></dt>
<dd><p>Set the current thread’s trap handler to <var class="var">handler</var>.
</p></dd></dl>

<p>Trap handlers are called when traps installed by procedures from this
module fire.  The current “consumer” of this API is Guile’s REPL, but
one might easily imagine other trap handlers being used to integrate
with other debugging tools.
</p>
<a class="index-entry-id" id="index-Breakpoints-1"></a>
<a class="index-entry-id" id="index-Setting-breakpoints"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-add_002dtrap_002dat_002dprocedure_002dcall_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-trap-at-procedure-call!</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dtrap_002dat_002dprocedure_002dcall_0021"> ¶</a></span></dt>
<dd><p>Install a trap that will fire when <var class="var">proc</var> is called.
</p>
<p>This is a breakpoint.
</p></dd></dl>

<a class="index-entry-id" id="index-Tracepoints"></a>
<a class="index-entry-id" id="index-Setting-tracepoints"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-add_002dtrace_002dat_002dprocedure_002dcall_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-trace-at-procedure-call!</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dtrace_002dat_002dprocedure_002dcall_0021"> ¶</a></span></dt>
<dd><p>Install a trap that will print a tracing message when <var class="var">proc</var> is
called. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Tracing-Traps">Tracing Traps</a>, for more information.
</p>
<p>This is a tracepoint.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dtrap_002dat_002dsource_002dlocation_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-trap-at-source-location!</strong> <var class="def-var-arguments">file user-line</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dtrap_002dat_002dsource_002dlocation_0021"> ¶</a></span></dt>
<dd><p>Install a trap that will fire when control reaches the given source
location. <var class="var">user-line</var> is one-indexed, as users count lines, instead
of zero-indexed, as Guile counts lines.
</p>
<p>This is a source breakpoint.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dephemeral_002dtrap_002dat_002dframe_002dfinish_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-ephemeral-trap-at-frame-finish!</strong> <var class="def-var-arguments">frame handler</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dephemeral_002dtrap_002dat_002dframe_002dfinish_0021"> ¶</a></span></dt>
<dd><p>Install a trap that will call <var class="var">handler</var> when <var class="var">frame</var> finishes
executing. The trap will be removed from the trap state after firing, or
on nonlocal exit.
</p>
<p>This is a finish trap, used to implement the “finish” REPL command.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dephemeral_002dstepping_002dtrap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-ephemeral-stepping-trap!</strong> <var class="def-var-arguments">frame handler [#:into?] [#:instruction?]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dephemeral_002dstepping_002dtrap_0021"> ¶</a></span></dt>
<dd><p>Install a trap that will call <var class="var">handler</var> after stepping to a
different source line or instruction.  The trap will be removed from the
trap state after firing, or on nonlocal exit.
</p>
<p>If <var class="var">instruction?</var> is false (the default), the trap will fire when
control reaches a new source line. Otherwise it will fire when control
reaches a new instruction.
</p>
<p>Additionally, if <var class="var">into?</var> is false (not the default), the trap will
only fire for frames at or prior to the given frame. If <var class="var">into?</var> is
true (the default), the trap may step into nested procedure
invocations.
</p>
<p>This is a stepping trap, used to implement the “step”, “next”,
“step-instruction”, and “next-instruction” REPL commands.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="GDB-Support">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Traps" accesskey="p" rel="prev">Traps</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="u" rel="up">Debugging Infrastructure</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="GDB-Support-1">6.26.5 GDB Support</h4>

<a class="index-entry-id" id="index-GDB-support"></a>

<p>Sometimes, you may find it necessary to debug Guile applications at the
C level.  Doing so can be tedious, in particular because the debugger is
oblivious to Guile’s <code class="code">SCM</code> type, and thus unable to display
<code class="code">SCM</code> values in any meaningful way:
</p>
<div class="example">
<pre class="example-preformatted">(gdb) frame
#0  scm_display (obj=0xf04310, port=0x6f9f30) at print.c:1437
</pre></div>

<p>To address that, Guile comes with an extension of the GNU Debugger (GDB)
that contains a “pretty-printer” for <code class="code">SCM</code> values.  With this GDB
extension, the C frame in the example above shows up like this:
</p>
<div class="example">
<pre class="example-preformatted">(gdb) frame
#0  scm_display (obj=("hello" GDB!), port=#&lt;port file 6f9f30&gt;) at print.c:1437
</pre></div>

<p>Here GDB was able to decode the list pointed to by <var class="var">obj</var>, and to
print it using Scheme’s read syntax.
</p>
<p>That extension is a <code class="code">.scm</code> file installed alongside the
<samp class="file">libguile</samp> shared library.  When GDB 7.8 or later is installed and
compiled with support for extensions written in Guile, the extension is
automatically loaded when debugging a program linked against
<samp class="file">libguile</samp> (see <a data-manual="gdb" href="https://sourceware.org/gdb/current/onlinedocs/gdb.html#Auto_002dloading">Auto-loading</a> in <cite class="cite">Debugging with GDB</cite>).  Note
that the directory where <samp class="file">libguile</samp> is installed must be among
GDB’s auto-loading “safe directories” (see <a data-manual="gdb" href="https://sourceware.org/gdb/current/onlinedocs/gdb.html#Auto_002dloading-safe-path">Auto-loading safe
path</a> in <cite class="cite">Debugging with GDB</cite>).
</p>



<hr>
</div>
</div>
<div class="section-level-extent" id="Code-Coverage">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Debugging" accesskey="p" rel="prev">Debugging Infrastructure</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="u" rel="up">API Reference</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="Code-Coverage-Reports">6.27 Code Coverage Reports</h3>

<a class="index-entry-id" id="index-code-coverage"></a>
<a class="index-entry-id" id="index-coverage"></a>
<p>When writing a test suite for a program or library, it is desirable to know what
part of the code is <em class="dfn">covered</em> by the test suite.  The <code class="code">(system vm
coverage)</code> module provides tools to gather code coverage data and to present
them, as detailed below.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-with_002dcode_002dcoverage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">with-code-coverage</strong> <var class="def-var-arguments">thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dcode_002dcoverage"> ¶</a></span></dt>
<dd><p>Run <var class="var">thunk</var>, a zero-argument procedure, while instrumenting Guile’s
virtual machine to collect code coverage data.  Return code coverage
data and the values returned by <var class="var">thunk</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-coverage_002ddata_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">coverage-data?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-coverage_002ddata_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a <em class="dfn">coverage data</em> object as returned by
<code class="code">with-code-coverage</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-coverage_002ddata_002d_003elcov"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">coverage-data-&gt;lcov</strong> <var class="def-var-arguments">data port #:key modules</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-coverage_002ddata_002d_003elcov"> ¶</a></span></dt>
<dd><p>Traverse code coverage information <var class="var">data</var>, as obtained with
<code class="code">with-code-coverage</code>, and write coverage information to port in the
<code class="code">.info</code> format used by <a class="url" href="http://ltp.sourceforge.net/coverage/lcov.php">LCOV</a>.  The report will include all of <var class="var">modules</var> (or, by default, all the
currently loaded modules) even if their code was not executed.
</p>
<p>The generated data can be fed to LCOV’s <code class="command">genhtml</code> command to produce an
HTML report, which aids coverage data visualization.
</p></dd></dl>

<p>Here’s an example use:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (system vm coverage)
             (system vm vm))

(call-with-values (lambda ()
                    (with-code-coverage
                      (lambda ()
                        (do-something-tricky))))
  (lambda (data result)
    (let ((port (open-output-file "lcov.info")))
      (coverage-data-&gt;lcov data port)
      (close port))))
</pre></div>

<p>In addition, the module provides low-level procedures that would make it
possible to write other user interfaces to the coverage data.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-instrumented_002dsource_002dfiles"><span class="category-def">Scheme Procedures: </span><span><strong class="def-name">instrumented-source-files</strong> <var class="def-var-arguments">data</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-instrumented_002dsource_002dfiles"> ¶</a></span></dt>
<dd><p>Return the list of “instrumented” source files, i.e., source files whose
code was loaded at the time <var class="var">data</var> was collected.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-line_002dexecution_002dcounts"><span class="category-def">Scheme Procedures: </span><span><strong class="def-name">line-execution-counts</strong> <var class="def-var-arguments">data file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-line_002dexecution_002dcounts"> ¶</a></span></dt>
<dd><p>Return a list of line number/execution count pairs for <var class="var">file</var>, or
<code class="code">#f</code> if <var class="var">file</var> is not among the files covered by <var class="var">data</var>.  This
includes lines with zero count.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-instrumented_002fexecuted_002dlines"><span class="category-def">Scheme Procedures: </span><span><strong class="def-name">instrumented/executed-lines</strong> <var class="def-var-arguments">data file</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-instrumented_002fexecuted_002dlines"> ¶</a></span></dt>
<dd><p>Return the number of instrumented and the number of executed source lines
in <var class="var">file</var> according to <var class="var">data</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-procedure_002dexecution_002dcount"><span class="category-def">Scheme Procedures: </span><span><strong class="def-name">procedure-execution-count</strong> <var class="def-var-arguments">data proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-procedure_002dexecution_002dcount"> ¶</a></span></dt>
<dd><p>Return the number of times <var class="var">proc</var>’s code was executed, according to
<var class="var">data</var>, or <code class="code">#f</code> if <var class="var">proc</var> was not executed.  When <var class="var">proc</var>
is a closure, the number of times its code was executed is returned, not
the number of times this code associated with this particular closure was
executed.
</p></dd></dl>

<hr>
</div>
</div>
<div class="chapter-level-extent" id="Guile-Modules">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#GOOPS" accesskey="n" rel="next">GOOPS</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#API-Reference" accesskey="p" rel="prev">API Reference</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Top" accesskey="u" rel="up">The Guile Reference Manual</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h2 class="chapter" id="Guile-Modules-1">7 Guile Modules</h2>



<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB" accesskey="1">SLIB</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="2"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="3"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="4">The (ice-9 getopt-long) Module</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="5">SRFI Support Modules</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support" accesskey="6">R6RS Support</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#R7RS-Support" accesskey="7">R7RS Support</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Pattern-Matching" accesskey="8">Pattern Matching</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Readline-Support" accesskey="9">Readline Support</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Pretty-Printing">Pretty Printing</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Formatted-Output">Formatted Output</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#File-Tree-Walk">File Tree Walk</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Queues">Queues</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Streams">Streams</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Buffered-Input">Buffered Input</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Expect">Expect</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#sxml_002dmatch"><code class="code">sxml-match</code>: Pattern Matching of SXML</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-shell-_0028scsh_0029">The Scheme shell (scsh)</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Curried-Definitions">Curried Definitions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Statprof">Statprof</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SXML">SXML</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Texinfo-Processing">Texinfo Processing</a></li>
</ul>
<hr>
<div class="section-level-extent" id="SLIB">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="n" rel="next"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="u" rel="up">Guile Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="SLIB-1">7.1 SLIB</h3>
<a class="index-entry-id" id="index-SLIB"></a>

<p>SLIB is a portable library of Scheme packages which can be used with
Guile and other Scheme implementations.  SLIB is not included in the
Guile distribution, but can be installed separately (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SLIB-installation">SLIB installation</a>).  It is available from
<a class="url" href="http://people.csail.mit.edu/jaffer/SLIB.html">http://people.csail.mit.edu/jaffer/SLIB.html</a>.
</p>
<p>After SLIB is installed, the following Scheme expression must be
executed before the SLIB facilities can be used:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 slib))
</pre></div>

<a class="index-entry-id" id="index-require"></a>
<p><code class="code">require</code> can then be used in the usual way (see <a data-manual="slib" href="https://www.gnu.org/software/guile/manual/slib.html#Require">Require</a> in <cite class="cite">The SLIB Manual</cite>).  For example,
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 slib))
(require 'primes)
(prime? 13)
⇒ #t
</pre></div>

<p>A few Guile core functions are overridden by the SLIB setups; for
example the SLIB version of <code class="code">delete-file</code> returns a boolean
indicating success or failure, whereas the Guile core version throws
an error for failure.  In general (and as might be expected) when SLIB
is loaded it’s the SLIB specifications that are followed.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB-installation" accesskey="1">SLIB installation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#JACAL" accesskey="2">JACAL</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="SLIB-installation">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#JACAL" accesskey="n" rel="next">JACAL</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB" accesskey="u" rel="up">SLIB</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SLIB-installation-1">7.1.1 SLIB installation</h4>

<p>The following procedure works, e.g., with SLIB version 3a3
(see <a data-manual="slib" href="https://www.gnu.org/software/guile/manual/slib.html#Installation">SLIB installation</a> in <cite class="cite">The SLIB Portable Scheme
Library</cite>):
</p>
<ol class="enumerate">
<li> Unpack SLIB and install it using <code class="code">make install</code> from its directory.
By default, this will install SLIB in <samp class="file">/usr/local/lib/slib/</samp>.
Running <code class="code">make install-info</code> installs its documentation, by default
under <samp class="file">/usr/local/info/</samp>.

</li><li> Define the <code class="code">SCHEME_LIBRARY_PATH</code> environment variable:

<div class="example">
<pre class="example-preformatted">$ SCHEME_LIBRARY_PATH=/usr/local/lib/slib/
$ export SCHEME_LIBRARY_PATH
</pre></div>

<p>Alternatively, you can create a symlink in the Guile directory to SLIB,
e.g.:
</p>
<div class="example">
<pre class="example-preformatted">ln -s /usr/local/lib/slib /usr/local/share/guile/3.0/slib
</pre></div>

</li><li> Use Guile to create the catalog file, e.g.,:

<div class="example">
<pre class="example-preformatted"># guile
guile&gt; (use-modules (ice-9 slib))
guile&gt; (require 'new-catalog)
guile&gt; (quit)
</pre></div>

<p>The catalog data should now be in
<samp class="file">/usr/local/share/guile/3.0/slibcat</samp>.
</p>
<p>If instead you get an error such as:
</p>
<div class="example">
<pre class="example-preformatted">Unbound variable: scheme-implementation-type
</pre></div>

<p>then a solution is to get a newer version of Guile,
or to modify <samp class="file">ice-9/slib.scm</samp> to use <code class="code">define-public</code> for the
offending variables.
</p>
</li></ol>

<hr>
</div>
<div class="subsection-level-extent" id="JACAL">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB-installation" accesskey="p" rel="prev">SLIB installation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB" accesskey="u" rel="up">SLIB</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="JACAL-1">7.1.2 JACAL</h4>
<a class="index-entry-id" id="index-JACAL"></a>

<a class="index-entry-id" id="index-Jaffer_002c-Aubrey"></a>
<a class="index-entry-id" id="index-symbolic-math"></a>
<a class="index-entry-id" id="index-math-_002d_002d-symbolic"></a>
<p>Jacal is a symbolic math package written in Scheme by Aubrey Jaffer.
It is usually installed as an extra package in SLIB.
</p>
<p>You can use Guile’s interface to SLIB to invoke Jacal:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 slib))
(slib:load "math")
(math)
</pre></div>

<p>For complete documentation on Jacal, please read the Jacal manual.  If
it has been installed on line, you can look at <a data-manual="jacal" href="https://www.gnu.org/software/guile/manual/jacal.html#Top">Jacal</a> in <cite class="cite">JACAL Symbolic Mathematics System</cite>.  Otherwise you can find it on the web at
<a class="url" href="http://www-swiss.ai.mit.edu/~jaffer/JACAL.html">http://www-swiss.ai.mit.edu/~jaffer/JACAL.html</a>
</p>


<hr>
</div>
</div>
<div class="section-level-extent" id="POSIX">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="n" rel="next"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SLIB" accesskey="p" rel="prev">SLIB</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="u" rel="up">Guile Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="POSIX-System-Calls-and-Networking">7.2 <abbr class="acronym">POSIX</abbr> System Calls and Networking</h3>
<a class="index-entry-id" id="index-POSIX"></a>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Conventions" accesskey="1"><abbr class="acronym">POSIX</abbr> Interface Conventions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors" accesskey="2">Ports and File Descriptors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#File-System" accesskey="3">File System</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#User-Information" accesskey="4">User Information</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Time" accesskey="5">Time</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment" accesskey="6">Runtime Environment</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Processes" accesskey="7">Processes</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Signals" accesskey="8">Signals</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Terminals-and-Ptys" accesskey="9">Terminals and Ptys</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Pipes">Pipes</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Networking">Networking</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#System-Identification">System Identification</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Encryption">Encryption</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Conventions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors" accesskey="n" rel="next">Ports and File Descriptors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="POSIX-Interface-Conventions">7.2.1 <abbr class="acronym">POSIX</abbr> Interface Conventions</h4>

<p>These interfaces provide access to operating system facilities.
They provide a simple wrapping around the underlying C interfaces
to make usage from Scheme more convenient.  They are also used
to implement the Guile port of scsh (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-shell-_0028scsh_0029">The Scheme shell (scsh)</a>).
</p>
<p>Generally there is a single procedure for each corresponding Unix
facility.  There are some exceptions, such as procedures implemented for
speed and convenience in Scheme with no primitive Unix equivalent,
e.g. <code class="code">copy-file</code>.
</p>
<p>The interfaces are intended as far as possible to be portable across
different versions of Unix.  In some cases procedures which can’t be
implemented on particular systems may become no-ops, or perform limited
actions.  In other cases they may throw errors.
</p>
<p>General naming conventions are as follows:
</p>
<ul class="itemize mark-bullet">
<li>The Scheme name is often identical to the name of the underlying Unix
facility.
</li><li>Underscores in Unix procedure names are converted to hyphens.
</li><li>Procedures which destructively modify Scheme data have exclamation
marks appended, e.g., <code class="code">recv!</code>.
</li><li>Predicates (returning only <code class="code">#t</code> or <code class="code">#f</code>) have question marks
appended, e.g., <code class="code">access?</code>.
</li><li>Some names are changed to avoid conflict with dissimilar interfaces
defined by scsh, e.g., <code class="code">primitive-fork</code>.
</li><li>Unix preprocessor names such as <code class="code">EPERM</code> or <code class="code">R_OK</code> are converted
to Scheme variables of the same name (underscores are not replaced
with hyphens).
</li></ul>

<p>Unexpected conditions are generally handled by raising exceptions.
There are a few procedures which return a special value if they don’t
succeed, e.g., <code class="code">getenv</code> returns <code class="code">#f</code> if it the requested
string is not found in the environment.  These cases are noted in
the documentation.
</p>
<p>For ways to deal with exceptions, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>.
</p>
<a class="index-entry-id" id="index-errno"></a>
<p>Errors which the C library would report by returning a null pointer or
through some other means are reported by raising a <code class="code">system-error</code>
exception with <code class="code">scm-error</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Error-Reporting">Procedures for Signaling Errors</a>).  The
<var class="var">data</var> parameter is a list containing the Unix <code class="code">errno</code> value
(an integer).  For example,
</p>
<div class="example">
<pre class="example-preformatted">(define (my-handler key func fmt fmtargs data)
  (display key) (newline)
  (display func) (newline)
  (apply format #t fmt fmtargs) (newline)
  (display data) (newline))

(catch 'system-error
  (lambda () (dup2 -123 -456))
  my-handler)

-|
system-error
dup2
Bad file descriptor
(9)
</pre></div>


<br>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-system_002derror_002derrno"><span class="category-def">Function: </span><span><strong class="def-name">system-error-errno</strong> <var class="def-var-arguments">arglist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-system_002derror_002derrno"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-errno-1"></a>
<p>Return the <code class="code">errno</code> value from a list which is the arguments to an
exception handler.  If the exception is not a <code class="code">system-error</code>,
then the return is <code class="code">#f</code>.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(catch
 'system-error
 (lambda ()
   (mkdir "/this-ought-to-fail-if-I'm-not-root"))
 (lambda stuff
   (let ((errno (system-error-errno stuff)))
     (cond
      ((= errno EACCES)
       (display "You're not allowed to do that."))
      ((= errno EEXIST)
       (display "Already exists."))
      (#t
       (display (strerror errno))))
     (newline))))
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Ports-and-File-Descriptors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#File-System" accesskey="n" rel="next">File System</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Conventions" accesskey="p" rel="prev"><abbr class="acronym">POSIX</abbr> Interface Conventions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Ports-and-File-Descriptors-1">7.2.2 Ports and File Descriptors</h4>
<a class="index-entry-id" id="index-file-descriptor"></a>

<p>Conventions generally follow those of scsh, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#The-Scheme-shell-_0028scsh_0029">The Scheme shell (scsh)</a>.
</p>
<p>Each open file port has an associated operating system file descriptor.
File descriptors are generally not useful in Scheme programs; however
they may be needed when interfacing with foreign code and the Unix
environment.
</p>
<p>A file descriptor can be extracted from a port and a new port can be
created from a file descriptor.  However a file descriptor is just an
integer and the garbage collector doesn’t recognize it as a reference
to the port.  If all other references to the port were dropped, then
it’s likely that the garbage collector would free the port, with the
side-effect of closing the file descriptor prematurely.
</p>
<p>To assist the programmer in avoiding this problem, each port has an
associated <em class="dfn">revealed count</em> which can be used to keep track of how many
times the underlying file descriptor has been stored in other places.
If a port’s revealed count is greater than zero, the file descriptor
will not be closed when the port is garbage collected.  A programmer
can therefore ensure that the revealed count will be greater than
zero if the file descriptor is needed elsewhere.
</p>
<p>For the simple case where a file descriptor is “imported” once to become
a port, it does not matter if the file descriptor is closed when the
port is garbage collected.  There is no need to maintain a revealed
count.  Likewise when “exporting” a file descriptor to the external
environment, setting the revealed count is not required provided the
port is kept open (i.e., is pointed to by a live Scheme binding) while
the file descriptor is in use.
</p>
<p>To correspond with traditional Unix behaviour, three file descriptors
(0, 1, and 2) are automatically imported when a program starts up and
assigned to the initial values of the current/standard input, output,
and error ports, respectively.  The revealed count for each is
initially set to one, so that dropping references to one of these
ports will not result in its garbage collection: it could be retrieved
with <code class="code">fdopen</code> or <code class="code">fdes-&gt;ports</code>.
</p>
<p>Guile’s ports can be buffered.  This means that writing a byte to a file
port goes to the internal buffer first, and only when the buffer is full
(or the user invokes <code class="code">force-output</code> on the port) is the data
actually written to the file descriptor.  Likewise on input, bytes are
read in from the file descriptor in blocks and placed in a buffer.
Reading a character via <code class="code">read-char</code> first goes to the buffer,
filling it as needed.  Usually read buffering is more or less
transparent, but write buffering can sometimes cause writes to be
delayed unexpectedly, if you forget to call <code class="code">force-output</code>.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>, for more on how to control port buffers.
</p>
<p>Note however that some procedures (e.g., <code class="code">recv!</code>) will accept ports
as arguments, but will actually operate directly on the file descriptor
underlying the port.  Any port buffering is ignored, including the
buffer which implements <code class="code">peek-char</code> and <code class="code">unread-char</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-port_002drevealed"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-revealed</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002drevealed"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005frevealed"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_revealed</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005frevealed"> ¶</a></span></dt>
<dd><p>Return the revealed count for <var class="var">port</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-set_002dport_002drevealed_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-port-revealed!</strong> <var class="def-var-arguments">port rcount</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dport_002drevealed_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fport_005frevealed_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_port_revealed_x</strong> <var class="def-var-arguments">(port, rcount)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fport_005frevealed_005fx"> ¶</a></span></dt>
<dd><p>Sets the revealed count for a <var class="var">port</var> to <var class="var">rcount</var>.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fileno"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fileno</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fileno"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffileno"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fileno</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffileno"> ¶</a></span></dt>
<dd><p>Return the integer file descriptor underlying <var class="var">port</var>.  Does
not change its revealed count.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-port_002d_003efdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-&gt;fdes</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002d_003efdes"> ¶</a></span></dt>
<dd><p>Returns the integer file descriptor underlying <var class="var">port</var>.  As a
side effect the revealed count of <var class="var">port</var> is incremented.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fdopen"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fdopen</strong> <var class="def-var-arguments">fdes modes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fdopen"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffdopen"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fdopen</strong> <var class="def-var-arguments">(fdes, modes)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffdopen"> ¶</a></span></dt>
<dd><p>Return a new port based on the file descriptor <var class="var">fdes</var>.  Modes are
given by the string <var class="var">modes</var>.  The revealed count of the port is
initialized to zero.  The <var class="var">modes</var> string is the same as that
accepted by <code class="code">open-file</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">open-file</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fdes_002d_003eports"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fdes-&gt;ports</strong> <var class="def-var-arguments">fdes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fdes_002d_003eports"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffdes_005fto_005fports"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fdes_to_ports</strong> <var class="def-var-arguments">(fdes)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffdes_005fto_005fports"> ¶</a></span></dt>
<dd><p>Return a list of existing ports which have <var class="var">fdes</var> as an
underlying file descriptor, without changing their revealed
counts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fdes_002d_003einport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fdes-&gt;inport</strong> <var class="def-var-arguments">fdes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fdes_002d_003einport"> ¶</a></span></dt>
<dd><p>Returns an existing input port which has <var class="var">fdes</var> as its underlying file
descriptor, if one exists, and increments its revealed count.
Otherwise, returns a new input port with a revealed count of 1.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fdes_002d_003eoutport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fdes-&gt;outport</strong> <var class="def-var-arguments">fdes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fdes_002d_003eoutport"> ¶</a></span></dt>
<dd><p>Returns an existing output port which has <var class="var">fdes</var> as its underlying file
descriptor, if one exists, and increments its revealed count.
Otherwise, returns a new output port with a revealed count of 1.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002dmove_002d_003efdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-move-&gt;fdes</strong> <var class="def-var-arguments">port fdes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002dmove_002d_003efdes"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005fmove_005fto_005ffdes"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive_move_to_fdes</strong> <var class="def-var-arguments">(port, fdes)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005fmove_005fto_005ffdes"> ¶</a></span></dt>
<dd><p>Moves the underlying file descriptor for <var class="var">port</var> to the integer
value <var class="var">fdes</var> without changing the revealed count of <var class="var">port</var>.
Any other ports already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is <code class="code">#f</code> if the file descriptor already had the
required value or <code class="code">#t</code> if it was moved.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-move_002d_003efdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">move-&gt;fdes</strong> <var class="def-var-arguments">port fdes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-move_002d_003efdes"> ¶</a></span></dt>
<dd><p>Moves the underlying file descriptor for <var class="var">port</var> to the integer
value <var class="var">fdes</var> and sets its revealed count to one.  Any other ports
already using this descriptor will be automatically
shifted to new descriptors and their revealed counts reset to zero.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-release_002dport_002dhandle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">release-port-handle</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-release_002dport_002dhandle"> ¶</a></span></dt>
<dd><p>Decrements the revealed count for a port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fsync"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fsync</strong> <var class="def-var-arguments">port_or_fd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fsync"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffsync"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fsync</strong> <var class="def-var-arguments">(port_or_fd)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffsync"> ¶</a></span></dt>
<dd><p>Copies any unwritten data for the specified output file descriptor to disk.
If <var class="var">port_or_fd</var> is a port, its buffer is flushed before the underlying
file descriptor is fsync’d.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open</strong> <var class="def-var-arguments">path flags [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open</strong> <var class="def-var-arguments">(path, flags, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen"> ¶</a></span></dt>
<dd><p>Open the file named by <var class="var">path</var> for reading and/or writing.
<var class="var">flags</var> is an integer specifying how the file should be opened.
<var class="var">mode</var> is an integer specifying the permission bits of the file,
if it needs to be created, before the umask (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>) is
applied.  The default is 666 (Unix itself has no default).
</p>
<p><var class="var">flags</var> can be constructed by combining variables using <code class="code">logior</code>.
Basic flags are:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-O_005fRDONLY"><span class="category-def">Variable: </span><span><strong class="def-name">O_RDONLY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-O_005fRDONLY"> ¶</a></span></dt>
<dd><p>Open the file read-only.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-O_005fWRONLY"><span class="category-def">Variable: </span><span><strong class="def-name">O_WRONLY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-O_005fWRONLY"> ¶</a></span></dt>
<dd><p>Open the file write-only.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-O_005fRDWR"><span class="category-def">Variable: </span><span><strong class="def-name">O_RDWR</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-O_005fRDWR"> ¶</a></span></dt>
<dd><p>Open the file read/write.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-O_005fAPPEND"><span class="category-def">Variable: </span><span><strong class="def-name">O_APPEND</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-O_005fAPPEND"> ¶</a></span></dt>
<dd><p>Append to the file instead of truncating.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-O_005fCREAT"><span class="category-def">Variable: </span><span><strong class="def-name">O_CREAT</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-O_005fCREAT"> ¶</a></span></dt>
<dd><p>Create the file if it does not already exist.
</p></dd></dl>

<p>See <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Status-Flags">File Status Flags</a> in <cite class="cite">The GNU C Library Reference Manual</cite>,
for additional flags.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-openat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">openat</strong> <var class="def-var-arguments">dir path flags [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-openat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopenat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_openat</strong> <var class="def-var-arguments">(dir, path, flags, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopenat"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">open</code>, but resolve the file name <var class="var">path</var>
relative to the directory referred to by the file port <var class="var">dir</var>
instead.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dfdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-fdes</strong> <var class="def-var-arguments">path flags [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dfdes"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005ffdes"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_fdes</strong> <var class="def-var-arguments">(path, flags, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005ffdes"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">open</code> but return a file descriptor instead of
a port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dfdes_002dat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-fdes-at</strong> <var class="def-var-arguments">dir path flags [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dfdes_002dat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopen_005ffdes_005fat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_open_fdes_at</strong> <var class="def-var-arguments">(dir, path, flags, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopen_005ffdes_005fat"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">openat</code>, but return a file descriptor instead
of a port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-close"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">close</strong> <var class="def-var-arguments">fd_or_port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-close"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fclose"><span class="category-def">C Function: </span><span><strong class="def-name">scm_close</strong> <var class="def-var-arguments">(fd_or_port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fclose"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">close-port</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">close-port</a>),
but also works on file descriptors.  A side
effect of closing a file descriptor is that any ports using that file
descriptor are moved to a different file descriptor and have
their revealed counts set to zero.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-close_002dfdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">close-fdes</strong> <var class="def-var-arguments">fd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-close_002dfdes"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fclose_005ffdes"><span class="category-def">C Function: </span><span><strong class="def-name">scm_close_fdes</strong> <var class="def-var-arguments">(fd)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fclose_005ffdes"> ¶</a></span></dt>
<dd><p>A simple wrapper for the <code class="code">close</code> system call.  Close file
descriptor <var class="var">fd</var>, which must be an integer.  Unlike <code class="code">close</code>,
the file descriptor will be closed even if a port is using it.  The
return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pipe-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pipe</strong> <var class="def-var-arguments">[flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pipe-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpipe"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pipe</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpipe"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-pipe"></a>
<p>Return a newly created pipe: a pair of ports which are linked together
on the local machine.  The <abbr class="acronym">CAR</abbr> is the input port and the
<abbr class="acronym">CDR</abbr> is the output port.  Data written (and flushed) to the
output port can be read from the input port.  Pipes are commonly used
for communication with a newly forked child process.  The need to flush
the output port can be avoided by making it unbuffered using
<code class="code">setvbuf</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>).
</p>
<p>Optionally, on systems that support it such as GNU/Linux and
GNU/Hurd, <var class="var">flags</var> can specify a bitwise-or of the following
constants:
</p>
<dl class="table">
<dt><code class="code">O_CLOEXEC</code></dt>
<dd><p>Mark the returned file descriptors as close-on-exec;
</p></dd>
<dt><code class="code">O_DIRECT</code></dt>
<dd><p>Create a pipe that performs input/output in “packet"
mode—see <code class="command">man 2 pipe</code> for details;
</p></dd>
<dt><code class="code">O_NONBLOCK</code></dt>
<dd><p>Set the <code class="code">O_NONBLOCK</code> status flag (non-blocking input and
output) on the file descriptors.
</p></dd>
</dl>

<p>On systems that do <em class="emph">not</em> support it, passing a non-zero
<var class="var">flags</var> value triggers a <code class="code">system-error</code> exception.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-PIPE_005fBUF"><span class="category-def">Variable: </span><span><strong class="def-name">PIPE_BUF</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-PIPE_005fBUF"> ¶</a></span></dt>
<dd><p>A write of up to <code class="code">PIPE_BUF</code> many bytes to a pipe is atomic,
meaning when done it goes into the pipe instantaneously and as a
contiguous block (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Pipe-Atomicity">Atomicity of Pipe I/O</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).
</p></dd></dl>

<p>Note that the output port is likely to block if too much data has been
written but not yet read from the input port.  Typically the capacity
is <code class="code">PIPE_BUF</code> bytes.
</p></dd></dl>

<p>The next group of procedures perform a <code class="code">dup2</code>
system call, if <var class="var">newfd</var> (an
integer) is supplied, otherwise a <code class="code">dup</code>.  The file descriptor to be
duplicated can be supplied as an integer or contained in a port.  The
type of value returned varies depending on which procedure is used.
</p>
<p>All procedures also have the side effect when performing <code class="code">dup2</code> that any
ports using <var class="var">newfd</var> are moved to a different file descriptor and have
their revealed counts set to zero.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-dup_002d_003efdes"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup-&gt;fdes</strong> <var class="def-var-arguments">fd_or_port [fd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup_002d_003efdes"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdup_005fto_005ffdes"><span class="category-def">C Function: </span><span><strong class="def-name">scm_dup_to_fdes</strong> <var class="def-var-arguments">(fd_or_port, fd)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdup_005fto_005ffdes"> ¶</a></span></dt>
<dd><p>Return a new integer file descriptor referring to the open file
designated by <var class="var">fd_or_port</var>, which must be either an open
file port or a file descriptor.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dup_002d_003einport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup-&gt;inport</strong> <var class="def-var-arguments">port/fd [newfd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup_002d_003einport"> ¶</a></span></dt>
<dd><p>Returns a new input port using the new file descriptor.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dup_002d_003eoutport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup-&gt;outport</strong> <var class="def-var-arguments">port/fd [newfd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup_002d_003eoutport"> ¶</a></span></dt>
<dd><p>Returns a new output port using the new file descriptor.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dup"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup</strong> <var class="def-var-arguments">port/fd [newfd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup"> ¶</a></span></dt>
<dd><p>Returns a new port if <var class="var">port/fd</var> is a port, with the same mode as the
supplied port, otherwise returns an integer file descriptor.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dup_002d_003eport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup-&gt;port</strong> <var class="def-var-arguments">port/fd mode [newfd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup_002d_003eport"> ¶</a></span></dt>
<dd><p>Returns a new port using the new file descriptor.  <var class="var">mode</var> supplies a
mode string for the port (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">open-file</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-duplicate_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">duplicate-port</strong> <var class="def-var-arguments">port modes</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-duplicate_002dport"> ¶</a></span></dt>
<dd><p>Returns a new port which is opened on a duplicate of the file
descriptor underlying <var class="var">port</var>, with mode string <var class="var">modes</var>
as for <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Ports">open-file</a>.  The two ports
will share a file position and file status flags.
</p>
<p>Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.
The mode string can include <code class="code">0</code> to obtain an unbuffered duplicate
port.
</p>
<p>This procedure is equivalent to <code class="code">(dup-&gt;port <var class="var">port</var> <var class="var">modes</var>)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-redirect_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">redirect-port</strong> <var class="def-var-arguments">old_port new_port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-redirect_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fredirect_005fport"><span class="category-def">C Function: </span><span><strong class="def-name">scm_redirect_port</strong> <var class="def-var-arguments">(old_port, new_port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fredirect_005fport"> ¶</a></span></dt>
<dd><p>This procedure takes two ports and duplicates the underlying file
descriptor from <var class="var">old_port</var> into <var class="var">new_port</var>.  The
current file descriptor in <var class="var">new_port</var> will be closed.
After the redirection the two ports will share a file position
and file status flags.
</p>
<p>The return value is unspecified.
</p>
<p>Unexpected behaviour can result if both ports are subsequently used
and the original and/or duplicate ports are buffered.
</p>
<p>This procedure does not have any side effects on other ports or
revealed counts.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dup2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dup2</strong> <var class="def-var-arguments">oldfd newfd</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dup2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdup2"><span class="category-def">C Function: </span><span><strong class="def-name">scm_dup2</strong> <var class="def-var-arguments">(oldfd, newfd)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdup2"> ¶</a></span></dt>
<dd><p>A simple wrapper for the <code class="code">dup2</code> system call.
Copies the file descriptor <var class="var">oldfd</var> to descriptor
number <var class="var">newfd</var>, replacing the previous meaning
of <var class="var">newfd</var>.  Both <var class="var">oldfd</var> and <var class="var">newfd</var> must
be integers.
Unlike for <code class="code">dup-&gt;fdes</code> or <code class="code">primitive-move-&gt;fdes</code>, no attempt
is made to move away ports which are using <var class="var">newfd</var>.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-port_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">port-for-each</strong> <var class="def-var-arguments">proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-port_002dfor_002deach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fport_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_port_for_each</strong> <var class="def-var-arguments">(SCM proc)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fport_005ffor_005feach"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc_005fport_005ffor_005feach"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c_port_for_each</strong> <var class="def-var-arguments">(void (*proc)(void *, SCM), void *data)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fport_005ffor_005feach"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to each port in the Guile port table
(FIXME: what is the Guile port table?)
in turn.  The return value is unspecified.  More specifically,
<var class="var">proc</var> is applied exactly once to every port that exists in the
system at the time <code class="code">port-for-each</code> is invoked.  Changes to the
port table while <code class="code">port-for-each</code> is running have no effect as far
as <code class="code">port-for-each</code> is concerned.
</p>
<p>The C function <code class="code">scm_port_for_each</code> takes a Scheme procedure
encoded as a <code class="code">SCM</code> value, while <code class="code">scm_c_port_for_each</code> takes
a pointer to a C function and passes along a arbitrary <var class="var">data</var>
cookie.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-fcntl"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fcntl</strong> <var class="def-var-arguments">port/fd cmd [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fcntl"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffcntl"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fcntl</strong> <var class="def-var-arguments">(object, cmd, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffcntl"> ¶</a></span></dt>
<dd><p>Apply <var class="var">cmd</var> on <var class="var">port/fd</var>, either a port or file descriptor.
The <var class="var">value</var> argument is used by the <code class="code">SET</code> commands described
below, it’s an integer value.
</p>
<p>Values for <var class="var">cmd</var> are:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-F_005fDUPFD"><span class="category-def">Variable: </span><span><strong class="def-name">F_DUPFD</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fDUPFD"> ¶</a></span></dt>
<dd><p>Duplicate the file descriptor, the same as <code class="code">dup-&gt;fdes</code> above
does.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-F_005fGETFD"><span class="category-def">Variable: </span><span><strong class="def-name">F_GETFD</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fGETFD"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-F_005fSETFD"><span class="category-def">Variable: </span><span><strong class="def-name">F_SETFD</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fSETFD"> ¶</a></span></dt>
<dd><p>Get or set flags associated with the file descriptor.  The only flag
is the following,
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-FD_005fCLOEXEC"><span class="category-def">Variable: </span><span><strong class="def-name">FD_CLOEXEC</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-FD_005fCLOEXEC"> ¶</a></span></dt>
<dd><p>“Close on exec”, meaning the file descriptor will be closed on an
<code class="code">exec</code> call (a successful such call).  For example to set that
flag,
</p>
<div class="example">
<pre class="example-preformatted">(fcntl port F_SETFD FD_CLOEXEC)
</pre></div>

<p>Or better, set it but leave any other possible future flags unchanged,
</p>
<div class="example">
<pre class="example-preformatted">(fcntl port F_SETFD (logior FD_CLOEXEC
                            (fcntl port F_GETFD)))
</pre></div>
</dd></dl>
</dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-F_005fGETFL"><span class="category-def">Variable: </span><span><strong class="def-name">F_GETFL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fGETFL"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-F_005fSETFL"><span class="category-def">Variable: </span><span><strong class="def-name">F_SETFL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fSETFL"> ¶</a></span></dt>
<dd><p>Get or set flags associated with the open file.  These flags are
<code class="code">O_RDONLY</code> etc described under <code class="code">open</code> above.
</p>
<p>A common use is to set <code class="code">O_NONBLOCK</code> on a network socket.  The
following sets that flag, and leaves other flags unchanged.
</p>
<div class="example">
<pre class="example-preformatted">(fcntl sock F_SETFL (logior O_NONBLOCK
                            (fcntl sock F_GETFL)))
</pre></div>
</dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-F_005fGETOWN"><span class="category-def">Variable: </span><span><strong class="def-name">F_GETOWN</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fGETOWN"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-F_005fSETOWN"><span class="category-def">Variable: </span><span><strong class="def-name">F_SETOWN</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fSETOWN"> ¶</a></span></dt>
<dd><p>Get or set the process ID of a socket’s owner, for <code class="code">SIGIO</code> signals.
</p></dd></dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-flock"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">flock</strong> <var class="def-var-arguments">file operation</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-flock"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fflock"><span class="category-def">C Function: </span><span><strong class="def-name">scm_flock</strong> <var class="def-var-arguments">(file, operation)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fflock"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-file-locking"></a>
<p>Apply or remove an advisory lock on an open file.
<var class="var">operation</var> specifies the action to be done:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-LOCK_005fSH"><span class="category-def">Variable: </span><span><strong class="def-name">LOCK_SH</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LOCK_005fSH"> ¶</a></span></dt>
<dd><p>Shared lock.  More than one process may hold a shared lock
for a given file at a given time.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-LOCK_005fEX"><span class="category-def">Variable: </span><span><strong class="def-name">LOCK_EX</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LOCK_005fEX"> ¶</a></span></dt>
<dd><p>Exclusive lock.  Only one process may hold an exclusive lock
for a given file at a given time.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-LOCK_005fUN"><span class="category-def">Variable: </span><span><strong class="def-name">LOCK_UN</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LOCK_005fUN"> ¶</a></span></dt>
<dd><p>Unlock the file.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-LOCK_005fNB"><span class="category-def">Variable: </span><span><strong class="def-name">LOCK_NB</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LOCK_005fNB"> ¶</a></span></dt>
<dd><p>Don’t block when locking.  This is combined with one of the other
operations using <code class="code">logior</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</a>).  If
<code class="code">flock</code> would block an <code class="code">EWOULDBLOCK</code> error is thrown
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Conventions"><abbr class="acronym">POSIX</abbr> Interface Conventions</a>).
</p></dd></dl>

<p>The return value is not specified. <var class="var">file</var> may be an open
file descriptor or an open file descriptor port.
</p>
<p>Note that <code class="code">flock</code> does not lock files across NFS.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-select"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">select</strong> <var class="def-var-arguments">reads writes excepts [secs [usecs]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-select"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fselect"><span class="category-def">C Function: </span><span><strong class="def-name">scm_select</strong> <var class="def-var-arguments">(reads, writes, excepts, secs, usecs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fselect"> ¶</a></span></dt>
<dd><p>This procedure has a variety of uses: waiting for the ability
to provide input, accept output, or the existence of
exceptional conditions on a collection of ports or file
descriptors, or waiting for a timeout to occur.
</p>
<p>When an error occurs, this procedure throws a <code class="code">system-error</code>
exception (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Conventions"><code class="code">system-error</code></a>).  Note that
<code class="code">select</code> may return early for other reasons, for example due to
pending interrupts.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>, for more on interrupts.
</p>
<p><var class="var">reads</var>, <var class="var">writes</var> and <var class="var">excepts</var> can be lists or
vectors, with each member a port or a file descriptor.
The value returned is a list of three corresponding
lists or vectors containing only the members which meet the
specified requirement.  The ability of port buffers to
provide input or accept output is taken into account.
Ordering of the input lists or vectors is not preserved.
</p>
<p>The optional arguments <var class="var">secs</var> and <var class="var">usecs</var> specify the
timeout.  Either <var class="var">secs</var> can be specified alone, as
either an integer or a real number, or both <var class="var">secs</var> and
<var class="var">usecs</var> can be specified as integers, in which case
<var class="var">usecs</var> is an additional timeout expressed in
microseconds.  If <var class="var">secs</var> is omitted or is <code class="code">#f</code> then
select will wait for as long as it takes for one of the other
conditions to be satisfied.
</p>
<p>The scsh version of <code class="code">select</code> differs as follows:
Only vectors are accepted for the first three arguments.
The <var class="var">usecs</var> argument is not supported.
Multiple values are returned instead of a list.
Duplicates in the input vectors appear only once in output.
An additional <code class="code">select!</code> interface is provided.
</p></dd></dl>

<p>While it is sometimes necessary to operate at the level of file
descriptors, this is an operation whose correctness can only be
considered as part of a whole program.  So for example while the effects
of <code class="code">(string-set! x 34 #\y)</code> are limited to the bits of code that
can access <var class="var">x</var>, <code class="code">(close-fdes 34)</code> mutates the state of the
entire process.  In particular if another thread is using file
descriptor 34 then their state might be corrupted; and another thread
which opens a file might cause file descriptor 34 to be re-used, so that
corruption could manifest itself in a strange way.
</p>
<a class="index-entry-id" id="index-fdes-finalizers"></a>
<a class="index-entry-id" id="index-file-descriptor-finalizers"></a>
<a class="index-entry-id" id="index-finalizers_002c-file-descriptor"></a>
<p>However when working with file descriptors, it’s common to want to
associate information with the file descriptor, perhaps in a side table.
To support this use case and to allow user code to remove an association
when a file descriptor is closed, Guile offers <em class="dfn">fdes finalizers</em>.
</p>
<p>As the name indicates, fdes finalizers are finalizers – they can run in
response to garbage collection, and they can also run in response to
explicit calls to <code class="code">close-port</code>, <code class="code">close-fdes</code>, or the like.  As
such they inherit many of the pitfalls of finalizers: they may be
invoked from concurrent threads, or not at all.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Foreign-Object-Memory-Management">Foreign Object Memory Management</a>, for more on finalizers.
</p>
<p>To use fdes finalizers, import their module;
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 fdes-finalizers))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-add_002dfdes_002dfinalizer_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">add-fdes-finalizer!</strong> <var class="def-var-arguments">fdes finalizer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dfdes_002dfinalizer_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-remove_002dfdes_002dfinalizer_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">remove-fdes-finalizer!</strong> <var class="def-var-arguments">fdes finalizer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-remove_002dfdes_002dfinalizer_0021"> ¶</a></span></dt>
<dd><p>Add or remove a finalizer for <var class="var">fdes</var>.  A finalizer is a procedure
that is called by Guile when a file descriptor is closed.  The file
descriptor being closed is passed as the one argument to the finalizer.
If a finalizer has been added multiple times to a file descriptor, to
remove it would require that number of calls to
<code class="code">remove-fdes-finalizer!</code>.
</p>
<p>The finalizers added to a file descriptor are called by Guile in an
unspecified order, and their return values are ignored.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="File-System">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#User-Information" accesskey="n" rel="next">User Information</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors" accesskey="p" rel="prev">Ports and File Descriptors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="File-System-1">7.2.3 File System</h4>
<a class="index-entry-id" id="index-file-system"></a>

<p>These procedures allow querying and setting file system attributes
(such as owner,
permissions, sizes and types of files); deleting, copying, renaming and
linking files; creating and removing directories and querying their
contents; syncing the file system and creating special files.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-access_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">access?</strong> <var class="def-var-arguments">path how</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-access_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005faccess"><span class="category-def">C Function: </span><span><strong class="def-name">scm_access</strong> <var class="def-var-arguments">(path, how)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005faccess"> ¶</a></span></dt>
<dd><p>Test accessibility of a file under the real UID and GID of the calling
process.  The return is <code class="code">#t</code> if <var class="var">path</var> exists and the
permissions requested by <var class="var">how</var> are all allowed, or <code class="code">#f</code> if
not.
</p>
<p><var class="var">how</var> is an integer which is one of the following values, or a
bitwise-OR (<code class="code">logior</code>) of multiple values.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-R_005fOK"><span class="category-def">Variable: </span><span><strong class="def-name">R_OK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-R_005fOK"> ¶</a></span></dt>
<dd><p>Test for read permission.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-W_005fOK"><span class="category-def">Variable: </span><span><strong class="def-name">W_OK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-W_005fOK"> ¶</a></span></dt>
<dd><p>Test for write permission.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-X_005fOK"><span class="category-def">Variable: </span><span><strong class="def-name">X_OK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-X_005fOK"> ¶</a></span></dt>
<dd><p>Test for execute permission.
</p></dd></dl>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-F_005fOK"><span class="category-def">Variable: </span><span><strong class="def-name">F_OK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-F_005fOK"> ¶</a></span></dt>
<dd><p>Test for existence of the file.  This is implied by each of the other
tests, so there’s no need to combine it with them.
</p></dd></dl>

<p>It’s important to note that <code class="code">access?</code> does not simply indicate
what will happen on attempting to read or write a file.  In normal
circumstances it does, but in a set-UID or set-GID program it doesn’t
because <code class="code">access?</code> tests the real ID, whereas an open or execute
attempt uses the effective ID.
</p>
<p>A program which will never run set-UID/GID can ignore the difference
between real and effective IDs, but for maximum generality, especially
in library functions, it’s best not to use <code class="code">access?</code> to predict
the result of an open or execute, instead simply attempt that and
catch any exception.
</p>
<p>The main use for <code class="code">access?</code> is to let a set-UID/GID program
determine what the invoking user would have been allowed to do,
without the greater (or perhaps lesser) privileges afforded by the
effective ID.  For more on this, see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Testing-File-Access">Testing File Access</a> in <cite class="cite">The GNU C Library Reference Manual</cite>.
</p></dd></dl>

<a class="index-entry-id" id="index-fstat"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-stat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat</strong> <var class="def-var-arguments">object [exception-on-error?]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_stat</strong> <var class="def-var-arguments">(object, exception_on_error)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstat"> ¶</a></span></dt>
<dd><p>Return an object containing various information about the file
determined by <var class="var">object</var>.  <var class="var">object</var> can be a string containing
a file name or a port or integer file descriptor which is open
on a file (in which case <code class="code">fstat</code> is used as the underlying
system call).
</p>
<p>If the optional <var class="var">exception_on_error</var> argument is true, which
is the default, an exception will be raised if the underlying
system call returns an error, for example if the file is not
found or is not readable. Otherwise, an error will cause
<code class="code">stat</code> to return <code class="code">#f</code>.
</p>
<p>The object returned by <code class="code">stat</code> can be passed as a single
parameter to the following procedures, all of which return
integers:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003adev"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:dev</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003adev"> ¶</a></span></dt>
<dd><p>The device number containing the file.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003aino"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:ino</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003aino"> ¶</a></span></dt>
<dd><p>The file serial number, which distinguishes this file from all
other files on the same device.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003amode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:mode</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003amode"> ¶</a></span></dt>
<dd><p>The mode of the file.  This is an integer which incorporates file type
information and file permission bits.  See also <code class="code">stat:type</code> and
<code class="code">stat:perms</code> below.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003anlink"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:nlink</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003anlink"> ¶</a></span></dt>
<dd><p>The number of hard links to the file.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003auid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:uid</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003auid"> ¶</a></span></dt>
<dd><p>The user ID of the file’s owner.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003agid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:gid</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003agid"> ¶</a></span></dt>
<dd><p>The group ID of the file.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003ardev"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:rdev</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003ardev"> ¶</a></span></dt>
<dd><p>Device ID; this entry is defined only for character or block special
files.  On some systems this field is not available at all, in which
case <code class="code">stat:rdev</code> returns <code class="code">#f</code>.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003asize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:size</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003asize"> ¶</a></span></dt>
<dd><p>The size of a regular file in bytes.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003aatime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:atime</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003aatime"> ¶</a></span></dt>
<dd><p>The last access time for the file, in seconds.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003amtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:mtime</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003amtime"> ¶</a></span></dt>
<dd><p>The last modification time for the file, in seconds.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003actime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:ctime</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003actime"> ¶</a></span></dt>
<dd><p>The last modification time for the attributes of the file, in seconds.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003aatimensec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:atimensec</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003aatimensec"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-stat_003amtimensec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:mtimensec</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003amtimensec"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-stat_003actimensec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:ctimensec</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003actimensec"> ¶</a></span></dt>
<dd><p>The fractional part of a file’s access, modification, or attribute modification
time, in nanoseconds. Nanosecond timestamps are only available on some operating
systems and file systems. If Guile cannot retrieve nanosecond-level timestamps
for a file, these fields will be set to 0.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003ablksize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:blksize</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003ablksize"> ¶</a></span></dt>
<dd><p>The optimal block size for reading or writing the file, in bytes.  On
some systems this field is not available, in which case
<code class="code">stat:blksize</code> returns a sensible suggested block size.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003ablocks"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:blocks</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003ablocks"> ¶</a></span></dt>
<dd><p>The amount of disk space that the file occupies measured in units of
512 byte blocks.  On some systems this field is not available, in
which case <code class="code">stat:blocks</code> returns <code class="code">#f</code>.
</p></dd></dl>

<p>In addition, the following procedures return the information
from <code class="code">stat:mode</code> in a more convenient form:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003atype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:type</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003atype"> ¶</a></span></dt>
<dd><p>A symbol representing the type of file.  Possible values are
‘<samp class="samp">regular</samp>’, ‘<samp class="samp">directory</samp>’, ‘<samp class="samp">symlink</samp>’,
‘<samp class="samp">block-special</samp>’, ‘<samp class="samp">char-special</samp>’, ‘<samp class="samp">fifo</samp>’, ‘<samp class="samp">socket</samp>’,
and ‘<samp class="samp">unknown</samp>’.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-stat_003aperms"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">stat:perms</strong> <var class="def-var-arguments">st</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-stat_003aperms"> ¶</a></span></dt>
<dd><p>An integer representing the access permission bits.
</p></dd></dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lstat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lstat</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lstat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flstat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lstat</strong> <var class="def-var-arguments">(path)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flstat"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">stat</code>, but does not follow symbolic links, i.e.,
it will return information about a symbolic link itself, not the
file it points to.  <var class="var">path</var> must be a string.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-statat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">statat</strong> <var class="def-var-arguments">dir filename [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-statat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstatat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_statat</strong> <var class="def-var-arguments">dir filename flags</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstatat"> ¶</a></span></dt>
<dd><p>Like <code class="code">stat</code>, but resolve <var class="var">filename</var> relative to the directory
referred to by the file port <var class="var">dir</var> instead.  The optional argument
<var class="var">flags</var> argument can be <code class="code">AT_SYMLINK_NOFOLLOW</code>, in which case
<var class="var">filename</var> will not be dereferenced even if it is a symbolic link.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-readlink"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">readlink</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-readlink"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freadlink"><span class="category-def">C Function: </span><span><strong class="def-name">scm_readlink</strong> <var class="def-var-arguments">(path)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freadlink"> ¶</a></span></dt>
<dd><p>Return the value of the symbolic link named by <var class="var">path</var> (a string, or
a port if supported by the system), i.e., the file that the link points
to.
</p>
<p>To read a symbolic link represented by a port, the symbolic link must
have been opened with the <code class="code">O_NOFOLLOW</code> and <code class="code">O_PATH</code> flags.
<code class="code">(provided? 'readlink-port)</code> reports whether ports are supported.
</p></dd></dl>

<a class="index-entry-id" id="index-fchown"></a>
<a class="index-entry-id" id="index-lchown"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-chown"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">chown</strong> <var class="def-var-arguments">object owner group</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-chown"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchown"><span class="category-def">C Function: </span><span><strong class="def-name">scm_chown</strong> <var class="def-var-arguments">(object, owner, group)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchown"> ¶</a></span></dt>
<dd><p>Change the ownership and group of the file referred to by <var class="var">object</var>
to the integer values <var class="var">owner</var> and <var class="var">group</var>.  <var class="var">object</var> can
be a string containing a file name or, if the platform supports
<code class="code">fchown</code> (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#File-Owner">File Owner</a> in <cite class="cite">The GNU C Library Reference
Manual</cite>), a port or integer file descriptor which is open on the file.
The return value is unspecified.
</p>
<p>If <var class="var">object</var> is a symbolic link, either the
ownership of the link or the ownership of the referenced file will be
changed depending on the operating system (lchown is
unsupported at present).  If <var class="var">owner</var> or <var class="var">group</var> is specified
as <code class="code">-1</code>, then that ID is not changed.
</p></dd></dl>

<a class="index-entry-id" id="index-fchownat"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-chownat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">chownat</strong> <var class="def-var-arguments">dir name owner group [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-chownat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchownat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_chownat</strong> <var class="def-var-arguments">(dir, name, owner, group, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchownat"> ¶</a></span></dt>
<dd><p>Like <code class="code">chown</code>, but modify the owner and/or group of
the file named <var class="var">name</var> in the directory referred to
by the file port <var class="var">dir</var> instead.  The optional argument
<var class="var">flags</var> is a bitmask.  If <code class="code">AT_SYMLINK_NOFOLLOW</code> is
present, then <var class="var">name</var> will not be dereferenced if it is a
symbolic link.
</p></dd></dl>

<a class="index-entry-id" id="index-fchmod"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-chmod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">chmod</strong> <var class="def-var-arguments">object mode</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-chmod"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchmod"><span class="category-def">C Function: </span><span><strong class="def-name">scm_chmod</strong> <var class="def-var-arguments">(object, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchmod"> ¶</a></span></dt>
<dd><p>Changes the permissions of the file referred to by <var class="var">object</var>.
<var class="var">object</var> can be a string containing a file name or a port or integer file
descriptor which is open on a file (in which case <code class="code">fchmod</code> is used
as the underlying system call).
<var class="var">mode</var> specifies
the new permissions as a decimal number, e.g., <code class="code">(chmod "foo" #o755)</code>.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-utime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utime</strong> <var class="def-var-arguments">object [actime [modtime [actimens [modtimens [flags]]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005futime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_utime</strong> <var class="def-var-arguments">(object, actime, modtime, actimens, modtimens, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005futime"> ¶</a></span></dt>
<dd><p><code class="code">utime</code> sets the access and modification times for the
file named by <var class="var">object</var>.  If <var class="var">actime</var> or <var class="var">modtime</var> is
not supplied, then the current time is used.  <var class="var">actime</var> and
<var class="var">modtime</var> must be integer time values as returned by the
<code class="code">current-time</code> procedure.
</p>
<p><var class="var">object</var> must be a file name or a port (if supported by the system).
</p>
<p>The optional <var class="var">actimens</var> and <var class="var">modtimens</var> are nanoseconds
to add <var class="var">actime</var> and <var class="var">modtime</var>. Nanosecond precision is
only supported on some combinations of file systems and operating
systems.
</p><div class="example lisp">
<pre class="lisp-preformatted">(utime "foo" (- (current-time) 3600))
</pre></div>
<p>will set the access time to one hour in the past and the
modification time to the current time.
</p>
<a class="index-entry-id" id="index-AT_005fSYMLINK_005fNOFOLLOW"></a>
<p>Last, <var class="var">flags</var> may be either <code class="code">0</code> or the
<code class="code">AT_SYMLINK_NOFOLLOW</code> constant, to set the time of
<var class="var">object</var> even if it is a symbolic link.
</p></dd></dl>

<p>On GNU/Linux systems, at least when using the Linux kernel 5.10.46,
if <var class="var">object</var> is a port, it may not be a symbolic link,
even if <code class="code">AT_SYMLINK_NOFOLLOW</code> is set.  This is either a bug
in Linux or Guile’s wrappers.  The exact cause is unclear.
</p>
<a class="index-entry-id" id="index-unlink"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-delete_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete-file</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelete_005ffile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delete_file</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelete_005ffile"> ¶</a></span></dt>
<dd><p>Deletes (or “unlinks”) the file whose path is specified by
<var class="var">str</var>.
</p></dd></dl>

<a class="index-entry-id" id="index-unlinkat"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-delete_002dfile_002dat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete-file-at</strong> <var class="def-var-arguments">dir str [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_002dfile_002dat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdelete_005ffile_005fat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_delete_file_at</strong> <var class="def-var-arguments">(dir, str, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdelete_005ffile_005fat"> ¶</a></span></dt>
<dd><p>Like <code class="code">unlink</code>, but resolve <var class="var">str</var> relative to the
directory referred to by the file port <var class="var">dir</var> instead.
</p>
<p>The optional <var class="var">flags</var> argument can be <code class="code">AT_REMOVEDIR</code>,
in which case <code class="code">delete-file-at</code> will act like <code class="code">rmdir</code> instead
of <code class="code">delete-file</code>.  Why doesn’t POSIX have a <code class="code">rmdirat</code> function
for this instead?  No idea!
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-copy_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">copy-file</strong> <var class="def-var-arguments">oldfile newfile</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-copy_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcopy_005ffile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_copy_file</strong> <var class="def-var-arguments">(oldfile, newfile)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcopy_005ffile"> ¶</a></span></dt>
<dd><p>Copy the file specified by <var class="var">oldfile</var> to <var class="var">newfile</var>.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sendfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sendfile</strong> <var class="def-var-arguments">out in count [offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sendfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsendfile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sendfile</strong> <var class="def-var-arguments">(out, in, count, offset)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsendfile"> ¶</a></span></dt>
<dd><p>Send <var class="var">count</var> bytes from <var class="var">in</var> to <var class="var">out</var>, both of which
must be either open file ports or file descriptors.  When
<var class="var">offset</var> is omitted, start reading from <var class="var">in</var>’s current
position; otherwise, start reading at <var class="var">offset</var>.  Return
the number of bytes actually sent.
</p>
<p>When <var class="var">in</var> is a port, it is often preferable to specify <var class="var">offset</var>,
because <var class="var">in</var>’s offset as a port may be different from the offset of
its underlying file descriptor.
</p>
<p>On systems that support it, such as GNU/Linux, this procedure uses the
<code class="code">sendfile</code> libc function, which usually corresponds to a system
call.  This is faster than doing a series of <code class="code">read</code> and
<code class="code">write</code> system calls.  A typical application is to send a file over
a socket.
</p>
<p>In some cases, the <code class="code">sendfile</code> libc function may return
<code class="code">EINVAL</code> or <code class="code">ENOSYS</code>.  In that case, Guile’s <code class="code">sendfile</code>
procedure automatically falls back to doing a series of <code class="code">read</code> and
<code class="code">write</code> calls.
</p>
<p>In other cases, the libc function may send fewer bytes than
<var class="var">count</var>—for instance because <var class="var">out</var> is a slow or limited
device, such as a pipe.  When that happens, Guile’s <code class="code">sendfile</code>
automatically retries until exactly <var class="var">count</var> bytes were sent or an
error occurs.
</p></dd></dl>

<a class="index-entry-id" id="index-rename"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-rename_002dfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rename-file</strong> <var class="def-var-arguments">oldname newname</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rename_002dfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frename"><span class="category-def">C Function: </span><span><strong class="def-name">scm_rename</strong> <var class="def-var-arguments">(oldname, newname)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frename"> ¶</a></span></dt>
<dd><p>Renames the file specified by <var class="var">oldname</var> to <var class="var">newname</var>.
The return value is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-renameat"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-rename_002dfile_002dat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rename-file-at</strong> <var class="def-var-arguments">olddir oldname newdir newname</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rename_002dfile_002dat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frenameat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_renameat</strong> <var class="def-var-arguments">(olddir, oldname, newdir, newname)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frenameat"> ¶</a></span></dt>
<dd><p>Like <code class="code">rename-file</code>, but when <var class="var">olddir</var> or <var class="var">newdir</var> is true,
resolve <var class="var">oldname</var> or <var class="var">newname</var> relative to the directory
specified by the file port <var class="var">olddir</var> or <var class="var">newdir</var> instead of the
current working directory.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-link"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">link</strong> <var class="def-var-arguments">oldpath newpath</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-link"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flink"><span class="category-def">C Function: </span><span><strong class="def-name">scm_link</strong> <var class="def-var-arguments">(oldpath, newpath)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flink"> ¶</a></span></dt>
<dd><p>Creates a new name <var class="var">newpath</var> in the file system for the
file named by <var class="var">oldpath</var>.  If <var class="var">oldpath</var> is a symbolic
link, the link may or may not be followed depending on the
system.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-symlink"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symlink</strong> <var class="def-var-arguments">oldpath newpath</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symlink"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymlink"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symlink</strong> <var class="def-var-arguments">(oldpath, newpath)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymlink"> ¶</a></span></dt>
<dd><p>Create a symbolic link named <var class="var">newpath</var> with the value (i.e., pointing to)
<var class="var">oldpath</var>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-symlinkat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">symlinkat</strong> <var class="def-var-arguments">dir oldpath newpath</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-symlinkat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsymlinkat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_symlinkat</strong> <var class="def-var-arguments">(dir, oldpath, newpath)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsymlinkat"> ¶</a></span></dt>
<dd><p>Like <code class="code">symlink</code>, but resolve <var class="var">newpath</var> relative to
the directory referred to by the file port <var class="var">dir</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mkdir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mkdir</strong> <var class="def-var-arguments">path [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mkdir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmkdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mkdir</strong> <var class="def-var-arguments">(path, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmkdir"> ¶</a></span></dt>
<dd><p>Create a new directory named by <var class="var">path</var>.  If <var class="var">mode</var> is omitted
then the permissions of the directory are set to <code class="code">#o777</code>
masked with the current umask (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes"><code class="code">umask</code></a>).
Otherwise they are set to the value specified with <var class="var">mode</var>
masked with the current umask.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mkdirat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mkdirat</strong> <var class="def-var-arguments">dir path [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mkdirat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmkdirat"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mkdirat</strong> <var class="def-var-arguments">(dir, path, mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmkdirat"> ¶</a></span></dt>
<dd><p>Like <code class="code">mkdir</code>, but resolve <var class="var">path</var> relative to the directory
referred to by the file port <var class="var">dir</var> instead.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-rmdir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rmdir</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rmdir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frmdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_rmdir</strong> <var class="def-var-arguments">(path)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frmdir"> ¶</a></span></dt>
<dd><p>Remove the existing directory named by <var class="var">path</var>.  The directory must
be empty for this to succeed.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-opendir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">opendir</strong> <var class="def-var-arguments">dirname</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-opendir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fopendir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_opendir</strong> <var class="def-var-arguments">(dirname)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fopendir"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-directory-contents"></a>
<p>Open the directory specified by <var class="var">dirname</var> and return a directory
stream.
</p>
<p>Before using this and the procedures below, make sure to see the
higher-level procedures for directory traversal that are available
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#File-Tree-Walk">File Tree Walk</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-directory_002dstream_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">directory-stream?</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-directory_002dstream_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdirectory_005fstream_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_directory_stream_p</strong> <var class="def-var-arguments">(object)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdirectory_005fstream_005fp"> ¶</a></span></dt>
<dd><p>Return a boolean indicating whether <var class="var">object</var> is a directory
stream as returned by <code class="code">opendir</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-readdir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">readdir</strong> <var class="def-var-arguments">stream</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-readdir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005freaddir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_readdir</strong> <var class="def-var-arguments">(stream)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005freaddir"> ¶</a></span></dt>
<dd><p>Return (as a string) the next directory entry from the directory stream
<var class="var">stream</var>.  If there is no remaining entry to be read then the
end of file object is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-rewinddir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">rewinddir</strong> <var class="def-var-arguments">stream</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-rewinddir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frewinddir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_rewinddir</strong> <var class="def-var-arguments">(stream)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frewinddir"> ¶</a></span></dt>
<dd><p>Reset the directory port <var class="var">stream</var> so that the next call to
<code class="code">readdir</code> will return the first directory entry.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-closedir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">closedir</strong> <var class="def-var-arguments">stream</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-closedir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fclosedir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_closedir</strong> <var class="def-var-arguments">(stream)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fclosedir"> ¶</a></span></dt>
<dd><p>Close the directory stream <var class="var">stream</var>.
The return value is unspecified.
</p></dd></dl>

<p>Here is an example showing how to display all the entries in a
directory:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define dir (opendir "/usr/lib"))
(do ((entry (readdir dir) (readdir dir)))
    ((eof-object? entry))
  (display entry)(newline))
(closedir dir)
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-sync"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sync</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sync"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsync"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sync</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsync"> ¶</a></span></dt>
<dd><p>Flush the operating system disk buffers.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mknod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mknod</strong> <var class="def-var-arguments">path type perms dev</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mknod"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmknod"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mknod</strong> <var class="def-var-arguments">(path, type, perms, dev)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmknod"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-device-file"></a>
<p>Creates a new special file, such as a file corresponding to a device.
<var class="var">path</var> specifies the name of the file.  <var class="var">type</var> should be one
of the following symbols: ‘<samp class="samp">regular</samp>’, ‘<samp class="samp">directory</samp>’,
‘<samp class="samp">symlink</samp>’, ‘<samp class="samp">block-special</samp>’, ‘<samp class="samp">char-special</samp>’,
‘<samp class="samp">fifo</samp>’, or ‘<samp class="samp">socket</samp>’.  <var class="var">perms</var> (an integer) specifies the
file permissions.  <var class="var">dev</var> (an integer) specifies which device the
special file refers to.  Its exact interpretation depends on the kind
of special file being created.
</p>
<p>E.g.,
</p><div class="example lisp">
<pre class="lisp-preformatted">(mknod "/dev/fd0" 'block-special #o660 (+ (* 2 256) 2))
</pre></div>

<p>The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tmpnam"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tmpnam</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tmpnam"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftmpnam"><span class="category-def">C Function: </span><span><strong class="def-name">scm_tmpnam</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftmpnam"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-temporary-file"></a>
<p>Return an auto-generated name of a temporary file, a file which
doesn’t already exist.  The name includes a path, it’s usually in
<samp class="file">/tmp</samp> but that’s system dependent.
</p>
<p>Care must be taken when using <code class="code">tmpnam</code>.  In between choosing the
name and creating the file another program might use that name, or an
attacker might even make it a symlink pointing at something important
and causing you to overwrite that.
</p>
<p>The safe way is to create the file using <code class="code">open</code> with
<code class="code">O_EXCL</code> to avoid any overwriting.  A loop can try again with
another name if the file exists (error <code class="code">EEXIST</code>).
<code class="code">mkstemp</code> below does that.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mkstemp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mkstemp</strong> <var class="def-var-arguments">tmpl [mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mkstemp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-temporary-file-1"></a>
<p>Create a new unique file in the file system and return a new buffered
port open for reading and writing to the file.
</p>
<p><var class="var">tmpl</var> is a string specifying where the file should be created: it
must end with ‘<samp class="samp">XXXXXX</samp>’.  The name of the newly created file will be
the same as <var class="var">tmpl</var>, but with those ‘<samp class="samp">X</samp>’s changed, and can be
determined by calling <code class="code">port-filename</code> on the returned port.
</p>
<p>Note that the newly created file is not deleted automatically by Guile;
probably the caller should arrange to call <code class="code">delete-file</code> when the
file is no longer needed.
</p>
<p>POSIX doesn’t specify the permissions mode of the file.  On GNU and most
systems it’s <code class="code">#o600</code>; an application can use <code class="code">chmod</code> to relax
that if desired.  For example <code class="code">#o666</code> less <code class="code">umask</code>, which is
usual for ordinary file creation,
</p>
<div class="example">
<pre class="example-preformatted">(let ((port (mkstemp "/tmp/myfile-XXXXXX")))
  (chmod port (logand #o666 (lognot (umask))))
  ...)
</pre></div>

<p>The optional <var class="var">mode</var> argument specifies a mode with which to open the
new file, as a string in the same format that <code class="code">open-file</code> takes.
It defaults to <code class="code">"w+"</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tmpfile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tmpfile</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tmpfile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftmpfile"><span class="category-def">C Function: </span><span><strong class="def-name">scm_tmpfile</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftmpfile"> ¶</a></span></dt>
<dd><p>Return an input/output port to a unique temporary file
named using the path prefix <code class="code">P_tmpdir</code> defined in
<samp class="file">stdio.h</samp>.
The file is automatically deleted when the port is closed
or the program terminates.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mkdtemp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mkdtemp</strong> <var class="def-var-arguments">tmpl</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mkdtemp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmkdtemp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mkdtemp</strong> <var class="def-var-arguments">(tmpl)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmkdtemp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-temporary-directory"></a>
<p>Create a new directory named in accordance with the template string
<var class="var">tmpl</var>.
</p>
<p><var class="var">tmpl</var> is a string specifying the directory’s name. The last six
characters of <var class="var">tmpl</var> must be ‘<samp class="samp">XXXXXX</samp>’. Upon successful
execution, the name of the new directory is returned which has the same
form as <var class="var">tmpl</var> but with the ‘<samp class="samp">XXXXXX</samp>’ characters modified to
ensure the directory name is unique.
</p>
<p>The permissions of the directory created are OS dependent, but, are
usually <code class="code">#o700</code>.
</p>
<p>An error may be thrown if the template has the wrong format or if the
directory cannot be created.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dirname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dirname</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dirname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fdirname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_dirname</strong> <var class="def-var-arguments">(filename)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fdirname"> ¶</a></span></dt>
<dd><p>Return the directory name component of the file name
<var class="var">filename</var>. If <var class="var">filename</var> does not contain a directory
component, <code class="code">.</code> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-basename"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">basename</strong> <var class="def-var-arguments">filename [suffix]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-basename"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbasename"><span class="category-def">C Function: </span><span><strong class="def-name">scm_basename</strong> <var class="def-var-arguments">(filename, suffix)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbasename"> ¶</a></span></dt>
<dd><p>Return the base name of the file name <var class="var">filename</var>. The
base name is the file name without any directory components.
If <var class="var">suffix</var> is provided, and is equal to the end of
<var class="var">basename</var>, it is removed also.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(basename "/tmp/test.xml" ".xml")
⇒ "test"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-canonicalize_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">canonicalize-path</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-canonicalize_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcanonicalize_005fpath"><span class="category-def">C Function: </span><span><strong class="def-name">scm_canonicalize_path</strong> <var class="def-var-arguments">(path)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcanonicalize_005fpath"> ¶</a></span></dt>
<dd><p>Return the canonical (absolute) path of <var class="var">path</var>.
A canonical path has no <code class="code">.</code> or <code class="code">..</code> components,
nor any repeated path separators (<code class="code">/</code>) nor symlinks.
</p>
<p>Raises an error if any component of <var class="var">path</var> does not
exist.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(canonicalize-path "test.xml")
⇒ "/tmp/test.xml"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-file_002dexists_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">file-exists?</strong> <var class="def-var-arguments">filename</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-file_002dexists_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if the file named <var class="var">filename</var> exists, <code class="code">#f</code> if
not.
</p></dd></dl>

<a class="index-entry-id" id="index-file-name-separator"></a>
<a class="index-entry-id" id="index-absolute-file-name"></a>

<p>Many operating systems, such as GNU, use <code class="code">/</code> (forward slash) to
separate the components of a file name; any file name starting with
<code class="code">/</code> is considered an <em class="dfn">absolute file name</em>.  These conventions
are specified by the POSIX Base Definitions, which refer to conforming
file names as “pathnames”.  Some operating systems use a different
convention; in particular, Windows uses <code class="code">\</code> (backslash) as the file
name separator, and also has the notion of <em class="dfn">volume names</em> like
<code class="code">C:\</code> for absolute file names.  The following procedures and
variables provide support for portable file name manipulations.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-system_002dfile_002dname_002dconvention"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">system-file-name-convention</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-system_002dfile_002dname_002dconvention"> ¶</a></span></dt>
<dd><p>Return either <code class="code">posix</code> or <code class="code">windows</code>, depending on
what kind of system this Guile is running on.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-file_002dname_002dseparator_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">file-name-separator?</strong> <var class="def-var-arguments">c</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-file_002dname_002dseparator_003f"> ¶</a></span></dt>
<dd><p>Return true if character <var class="var">c</var> is a file name separator on the host
platform.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-absolute_002dfile_002dname_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">absolute-file-name?</strong> <var class="def-var-arguments">file-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-absolute_002dfile_002dname_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">file-name</var> denotes an absolute file name on the host
platform.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-file_002dname_002dseparator_002dstring"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">file-name-separator-string</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-file_002dname_002dseparator_002dstring"> ¶</a></span></dt>
<dd><p>The preferred file name separator.
</p>
<p>Note that on MinGW builds for Windows, both <code class="code">/</code> and <code class="code">\</code> are
valid separators.  Thus, programs should not assume that
<code class="code">file-name-separator-string</code> is the <em class="emph">only</em> file name
separator—e.g., when extracting the components of a file name.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="User-Information">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Time" accesskey="n" rel="next">Time</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#File-System" accesskey="p" rel="prev">File System</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="User-Information-1">7.2.4 User Information</h4>
<a class="index-entry-id" id="index-user-information"></a>
<a class="index-entry-id" id="index-password-file"></a>
<a class="index-entry-id" id="index-group-file"></a>

<p>The facilities in this section provide an interface to the user and
group database.
They should be used with care since they are not reentrant.
</p>
<p>The following functions accept an object representing user information
and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:name</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003aname"> ¶</a></span></dt>
<dd><p>The name of the userid.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003apasswd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:passwd</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003apasswd"> ¶</a></span></dt>
<dd><p>The encrypted passwd.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003auid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:uid</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003auid"> ¶</a></span></dt>
<dd><p>The user id number.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003agid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:gid</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003agid"> ¶</a></span></dt>
<dd><p>The group id number.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003agecos"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:gecos</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003agecos"> ¶</a></span></dt>
<dd><p>The full name.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003adir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:dir</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003adir"> ¶</a></span></dt>
<dd><p>The home directory.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-passwd_003ashell"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">passwd:shell</strong> <var class="def-var-arguments">pw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-passwd_003ashell"> ¶</a></span></dt>
<dd><p>The login shell.
</p></dd></dl>
<br>

<dl class="first-deffn">
<dt class="deffn" id="index-getpwuid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpwuid</strong> <var class="def-var-arguments">uid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpwuid"> ¶</a></span></dt>
<dd><p>Look up an integer userid in the user database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpwnam"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpwnam</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpwnam"> ¶</a></span></dt>
<dd><p>Look up a user name string in the user database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setpwent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setpwent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setpwent"> ¶</a></span></dt>
<dd><p>Initializes a stream used by <code class="code">getpwent</code> to read from the user database.
The next use of <code class="code">getpwent</code> will return the first entry.  The
return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpwent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpwent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpwent"> ¶</a></span></dt>
<dd><p>Read the next entry in the user database stream.  The return is a
passwd user object as above, or <code class="code">#f</code> when no more entries.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endpwent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endpwent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endpwent"> ¶</a></span></dt>
<dd><p>Closes the stream used by <code class="code">getpwent</code>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setpw"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setpw</strong> <var class="def-var-arguments">[arg]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setpw"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetpwent"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setpwent</strong> <var class="def-var-arguments">(arg)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetpwent"> ¶</a></span></dt>
<dd><p>If called with a true argument, initialize or reset the password data
stream.  Otherwise, close the stream.  The <code class="code">setpwent</code> and
<code class="code">endpwent</code> procedures are implemented on top of this.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpw"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpw</strong> <var class="def-var-arguments">[user]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpw"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpwuid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpwuid</strong> <var class="def-var-arguments">(user)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpwuid"> ¶</a></span></dt>
<dd><p>Look up an entry in the user database.  <var class="var">user</var> can be an integer,
a string, or omitted, giving the behaviour of getpwuid, getpwnam
or getpwent respectively.
</p></dd></dl>

<p>The following functions accept an object representing group information
and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-group_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">group:name</strong> <var class="def-var-arguments">gr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-group_003aname"> ¶</a></span></dt>
<dd><p>The group name.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-group_003apasswd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">group:passwd</strong> <var class="def-var-arguments">gr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-group_003apasswd"> ¶</a></span></dt>
<dd><p>The encrypted group password.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-group_003agid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">group:gid</strong> <var class="def-var-arguments">gr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-group_003agid"> ¶</a></span></dt>
<dd><p>The group id number.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-group_003amem"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">group:mem</strong> <var class="def-var-arguments">gr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-group_003amem"> ¶</a></span></dt>
<dd><p>A list of userids which have this group as a supplementary group.
</p></dd></dl>
<br>

<dl class="first-deffn">
<dt class="deffn" id="index-getgrgid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgrgid</strong> <var class="def-var-arguments">gid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgrgid"> ¶</a></span></dt>
<dd><p>Look up an integer group id in the group database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getgrnam"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgrnam</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgrnam"> ¶</a></span></dt>
<dd><p>Look up a group name in the group database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setgrent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setgrent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setgrent"> ¶</a></span></dt>
<dd><p>Initializes a stream used by <code class="code">getgrent</code> to read from the group database.
The next use of <code class="code">getgrent</code> will return the first entry.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getgrent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgrent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgrent"> ¶</a></span></dt>
<dd><p>Return the next entry in the group database, using the stream set by
<code class="code">setgrent</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endgrent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endgrent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endgrent"> ¶</a></span></dt>
<dd><p>Closes the stream used by <code class="code">getgrent</code>.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setgr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setgr</strong> <var class="def-var-arguments">[arg]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setgr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetgrent"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setgrent</strong> <var class="def-var-arguments">(arg)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetgrent"> ¶</a></span></dt>
<dd><p>If called with a true argument, initialize or reset the group data
stream.  Otherwise, close the stream.  The <code class="code">setgrent</code> and
<code class="code">endgrent</code> procedures are implemented on top of this.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getgr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgr</strong> <var class="def-var-arguments">[group]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetgrgid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getgrgid</strong> <var class="def-var-arguments">(group)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetgrgid"> ¶</a></span></dt>
<dd><p>Look up an entry in the group database.  <var class="var">group</var> can be an integer,
a string, or omitted, giving the behaviour of getgrgid, getgrnam
or getgrent respectively.
</p></dd></dl>

<p>In addition to the accessor procedures for the user database, the
following shortcut procedure is also available.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getlogin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getlogin</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getlogin"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetlogin"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getlogin</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetlogin"> ¶</a></span></dt>
<dd><p>Return a string containing the name of the user logged in on
the controlling terminal of the process, or <code class="code">#f</code> if this
information cannot be obtained.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Time">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment" accesskey="n" rel="next">Runtime Environment</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#User-Information" accesskey="p" rel="prev">User Information</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Time-1">7.2.5 Time</h4>
<a class="index-entry-id" id="index-time"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-current_002dtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">current-time</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dtime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcurrent_005ftime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_current_time</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcurrent_005ftime"> ¶</a></span></dt>
<dd><p>Return the number of seconds since 1970-01-01 00:00:00 <abbr class="acronym">UTC</abbr>,
excluding leap seconds.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gettimeofday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gettimeofday</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gettimeofday"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgettimeofday"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gettimeofday</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgettimeofday"> ¶</a></span></dt>
<dd><p>Return a pair containing the number of seconds and microseconds
since 1970-01-01 00:00:00 <abbr class="acronym">UTC</abbr>, excluding leap seconds.  Note:
whether true microsecond resolution is available depends on the
operating system.
</p></dd></dl>

<p>The following procedures either accept an object representing a broken down
time and return a selected component, or accept an object representing
a broken down time and a value and set the component to the value.
The numbers in parentheses give the usual range.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003asec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:sec</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003asec"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003asec"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:sec</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003asec"> ¶</a></span></dt>
<dd><p>Seconds (0-59).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003amin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:min</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003amin"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003amin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:min</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003amin"> ¶</a></span></dt>
<dd><p>Minutes (0-59).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003ahour"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:hour</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003ahour"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003ahour"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:hour</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003ahour"> ¶</a></span></dt>
<dd><p>Hours (0-23).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003amday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:mday</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003amday"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003amday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:mday</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003amday"> ¶</a></span></dt>
<dd><p>Day of the month (1-31).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003amon"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:mon</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003amon"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003amon"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:mon</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003amon"> ¶</a></span></dt>
<dd><p>Month (0-11).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003ayear"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:year</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003ayear"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003ayear"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:year</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003ayear"> ¶</a></span></dt>
<dd><p>Year (70-), the year minus 1900.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003awday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:wday</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003awday"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003awday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:wday</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003awday"> ¶</a></span></dt>
<dd><p>Day of the week (0-6) with Sunday represented as 0.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003ayday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:yday</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003ayday"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003ayday"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:yday</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003ayday"> ¶</a></span></dt>
<dd><p>Day of the year (0-364, 365 in leap years).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003aisdst"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:isdst</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003aisdst"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003aisdst"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:isdst</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003aisdst"> ¶</a></span></dt>
<dd><p>Daylight saving indicator (0 for “no”, greater than 0 for “yes”, less than
0 for “unknown”).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003agmtoff"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:gmtoff</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003agmtoff"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003agmtoff"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:gmtoff</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003agmtoff"> ¶</a></span></dt>
<dd><p>Time zone offset in seconds west of <abbr class="acronym">UTC</abbr> (-46800 to 43200).
For example on East coast USA (zone ‘<samp class="samp">EST+5</samp>’) this would be 18000
(ie. <em class="math">5*60*60</em>) in winter, or 14400
(ie. <em class="math">4*60*60</em>) during daylight savings.
</p>
<p>Note <code class="code">tm:gmtoff</code> is not the same as <code class="code">tm_gmtoff</code> in the C
<code class="code">tm</code> structure.  <code class="code">tm_gmtoff</code> is seconds east and hence the
negative of the value here.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tm_003azone"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tm:zone</strong> <var class="def-var-arguments">tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tm_003azone"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dtm_003azone"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-tm:zone</strong> <var class="def-var-arguments">tm val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtm_003azone"> ¶</a></span></dt>
<dd><p>Time zone label (a string), not necessarily unique.
</p></dd></dl>
<br>

<dl class="first-deffn">
<dt class="deffn" id="index-localtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">localtime</strong> <var class="def-var-arguments">time [zone]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-localtime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flocaltime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_localtime</strong> <var class="def-var-arguments">(time, zone)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flocaltime"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-local-time"></a>
<p>Return an object representing the broken down components of
<var class="var">time</var>, an integer like the one returned by
<code class="code">current-time</code>.  The time zone for the calculation is
optionally specified by <var class="var">zone</var> (a string), otherwise the
<code class="env">TZ</code> environment variable or the system default is used.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gmtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gmtime</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gmtime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgmtime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gmtime</strong> <var class="def-var-arguments">(time)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgmtime"> ¶</a></span></dt>
<dd><p>Return an object representing the broken down components of
<var class="var">time</var>, an integer like the one returned by
<code class="code">current-time</code>.  The values are calculated for <abbr class="acronym">UTC</abbr>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-mktime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">mktime</strong> <var class="def-var-arguments">sbd-time [zone]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mktime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmktime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_mktime</strong> <var class="def-var-arguments">(sbd_time, zone)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmktime"> ¶</a></span></dt>
<dd><p>For a broken down time object <var class="var">sbd-time</var>, return a pair the
<code class="code">car</code> of which is an integer time like <code class="code">current-time</code>, and
the <code class="code">cdr</code> of which is a new broken down time with normalized
fields.
</p>
<p><var class="var">zone</var> is a timezone string, or the default is the <code class="env">TZ</code>
environment variable or the system default (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#TZ-Variable">Specifying the Time Zone with <code class="env">TZ</code></a> in <cite class="cite">GNU C Library Reference
Manual</cite>).  <var class="var">sbd-time</var> is taken to be in that <var class="var">zone</var>.
</p>
<p>The following fields of <var class="var">sbd-time</var> are used: <code class="code">tm:year</code>,
<code class="code">tm:mon</code>, <code class="code">tm:mday</code>, <code class="code">tm:hour</code>, <code class="code">tm:min</code>,
<code class="code">tm:sec</code>, <code class="code">tm:isdst</code>.  The values can be outside their usual
ranges.  For example <code class="code">tm:hour</code> normally goes up to 23, but a
value say 33 would mean 9 the following day.
</p>
<p><code class="code">tm:isdst</code> in <var class="var">sbd-time</var> says whether the time given is with
daylight savings or not.  This is ignored if <var class="var">zone</var> doesn’t have
any daylight savings adjustment amount.
</p>
<p>The broken down time in the return normalizes the values of
<var class="var">sbd-time</var> by bringing them into their usual ranges, and using the
actual daylight savings rule for that time in <var class="var">zone</var> (which may
differ from what <var class="var">sbd-time</var> had).  The easiest way to think of
this is that <var class="var">sbd-time</var> plus <var class="var">zone</var> converts to the integer
UTC time, then a <code class="code">localtime</code> is applied to get the normal
presentation of that time, in <var class="var">zone</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tzset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tzset</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tzset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftzset"><span class="category-def">C Function: </span><span><strong class="def-name">scm_tzset</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftzset"> ¶</a></span></dt>
<dd><p>Initialize the timezone from the <code class="env">TZ</code> environment variable
or the system default.  It’s not usually necessary to call this procedure
since it’s done automatically by other procedures that depend on the
timezone.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-strftime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">strftime</strong> <var class="def-var-arguments">format tm</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-strftime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstrftime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_strftime</strong> <var class="def-var-arguments">(format, tm)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstrftime"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-time-formatting"></a>
<p>Return a string which is broken-down time structure <var class="var">tm</var> formatted
according to the given <var class="var">format</var> string.
</p>
<p><var class="var">format</var> contains field specifications introduced by a ‘<samp class="samp">%</samp>’
character.  See <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Formatting-Calendar-Time">Formatting Calendar Time</a> in <cite class="cite">The GNU C
Library Reference Manual</cite>, or ‘<samp class="samp">man 3 strftime</samp>’, for the available
formatting.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(strftime "%c" (localtime (current-time)))
⇒ "Mon Mar 11 20:17:43 2002"
</pre></div>

<p>If <code class="code">setlocale</code> has been called (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales">Locales</a>), month and day
names are from the current locale and in the locale character set.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-strptime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">strptime</strong> <var class="def-var-arguments">format string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-strptime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstrptime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_strptime</strong> <var class="def-var-arguments">(format, string)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstrptime"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-time-parsing"></a>
<p>Performs the reverse action to <code class="code">strftime</code>, parsing
<var class="var">string</var> according to the specification supplied in
<var class="var">format</var>.  The interpretation of month and day names is
dependent on the current locale.  The value returned is a pair.
The <abbr class="acronym">CAR</abbr> has an object with time components
in the form returned by <code class="code">localtime</code> or <code class="code">gmtime</code>,
but the time zone components
are not usefully set.
The <abbr class="acronym">CDR</abbr> reports the number of characters from <var class="var">string</var>
which were used for the conversion.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-internal_002dtime_002dunits_002dper_002dsecond"><span class="category-def">Variable: </span><span><strong class="def-name">internal-time-units-per-second</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-internal_002dtime_002dunits_002dper_002dsecond"> ¶</a></span></dt>
<dd><p>The value of this variable is the number of time units per second
reported by the following procedures.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-times"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">times</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-times"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftimes"><span class="category-def">C Function: </span><span><strong class="def-name">scm_times</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftimes"> ¶</a></span></dt>
<dd><p>Return an object with information about real and processor
time.  The following procedures accept such an object as an
argument and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-tms_003aclock"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tms:clock</strong> <var class="def-var-arguments">tms</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tms_003aclock"> ¶</a></span></dt>
<dd><p>The current real time, expressed as time units relative to an
arbitrary base.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tms_003autime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tms:utime</strong> <var class="def-var-arguments">tms</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tms_003autime"> ¶</a></span></dt>
<dd><p>The CPU time units used by the calling process.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tms_003astime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tms:stime</strong> <var class="def-var-arguments">tms</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tms_003astime"> ¶</a></span></dt>
<dd><p>The CPU time units used by the system on behalf of the calling
process.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tms_003acutime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tms:cutime</strong> <var class="def-var-arguments">tms</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tms_003acutime"> ¶</a></span></dt>
<dd><p>The CPU time units used by terminated child processes of the
calling process, whose status has been collected (e.g., using
<code class="code">waitpid</code>).
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-tms_003acstime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tms:cstime</strong> <var class="def-var-arguments">tms</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tms_003acstime"> ¶</a></span></dt>
<dd><p>Similarly, the CPU times units used by the system on behalf of
terminated child processes.
</p></dd></dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dinternal_002dreal_002dtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-internal-real-time</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dinternal_002dreal_002dtime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005finternal_005freal_005ftime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_internal_real_time</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005finternal_005freal_005ftime"> ¶</a></span></dt>
<dd><p>Return the number of time units since the interpreter was
started.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-get_002dinternal_002drun_002dtime"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">get-internal-run-time</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-get_002dinternal_002drun_002dtime"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fget_005finternal_005frun_005ftime"><span class="category-def">C Function: </span><span><strong class="def-name">scm_get_internal_run_time</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fget_005finternal_005frun_005ftime"> ¶</a></span></dt>
<dd><p>Return the number of time units of processor time used by the
interpreter.  Both <em class="emph">system</em> and <em class="emph">user</em> time are
included but subprocesses are not.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Runtime-Environment">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Processes" accesskey="n" rel="next">Processes</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Time" accesskey="p" rel="prev">Time</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Runtime-Environment-1">7.2.6 Runtime Environment</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-program_002darguments"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">program-arguments</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-program_002darguments"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-command_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">command-line</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-command_002dline"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-set_002dprogram_002darguments"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">set-program-arguments</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dprogram_002darguments"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprogram_005farguments"><span class="category-def">C Function: </span><span><strong class="def-name">scm_program_arguments</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprogram_005farguments"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fset_005fprogram_005farguments_005fscm"><span class="category-def">C Function: </span><span><strong class="def-name">scm_set_program_arguments_scm</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fprogram_005farguments_005fscm"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-command-line"></a>
<a class="index-entry-id" id="index-program-arguments"></a>
<p>Get the command line arguments passed to Guile, or set new arguments.
</p>
<p>The arguments are a list of strings, the first of which is the invoked
program name.  This is just <code class="code">"guile"</code> (or the executable path)
when run interactively, or it’s the script name when running a script
with <samp class="option">-s</samp> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile">Invoking Guile</a>).
</p>
<div class="example">
<pre class="example-preformatted">guile -L /my/extra/dir -s foo.scm abc def

(program-arguments) ⇒ ("foo.scm" "abc" "def")
</pre></div>

<p><code class="code">set-program-arguments</code> allows a library module or similar to
modify the arguments, for example to strip options it recognises,
leaving the rest for the mainline.
</p>
<p>The argument list is held in a fluid, which means it’s separate for
each thread.  Neither the list nor the strings within it are copied at
any point and normally should not be mutated.
</p>
<p>The two names <code class="code">program-arguments</code> and <code class="code">command-line</code> are an
historical accident, they both do exactly the same thing.  The name
<code class="code">scm_set_program_arguments_scm</code> has an extra <code class="code">_scm</code> on the
end to avoid clashing with the C function below.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fset_005fprogram_005farguments"><span class="category-def">C Function: </span><span><code class="def-type">void</code> <strong class="def-name">scm_set_program_arguments</strong> <code class="def-code-arguments">(int argc, char **argv, char *first)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fset_005fprogram_005farguments"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-command-line-1"></a>
<a class="index-entry-id" id="index-program-arguments-1"></a>
<p>Set the list of command line arguments for <code class="code">program-arguments</code>
and <code class="code">command-line</code> above.
</p>
<p><var class="var">argv</var> is an array of null-terminated strings, as in a C
<code class="code">main</code> function.  <var class="var">argc</var> is the number of strings in
<var class="var">argv</var>, or if it’s negative then a <code class="code">NULL</code> in <var class="var">argv</var> marks
its end.
</p>
<p><var class="var">first</var> is an extra string put at the start of the arguments, or
<code class="code">NULL</code> for no such extra.  This is a convenient way to pass the
program name after advancing <var class="var">argv</var> to strip option arguments.
Eg.
</p>
<div class="example">
<pre class="example-preformatted">{
  char *progname = argv[0];
  for (argv++; argv[0] != NULL &amp;&amp; argv[0][0] == '-'; argv++)
    {
      /* munch option ... */
    }
  /* remaining args for scheme level use */
  scm_set_program_arguments (-1, argv, progname);
}
</pre></div>

<p>This sort of thing is often done at startup under
<code class="code">scm_boot_guile</code> with options handled at the C level removed.
The given strings are all copied, so the C data is not accessed again
once <code class="code">scm_set_program_arguments</code> returns.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getenv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getenv</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getenv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetenv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getenv</strong> <var class="def-var-arguments">(name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetenv"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-environment-2"></a>
<p>Looks up the string <var class="var">name</var> in the current environment.  The return
value is <code class="code">#f</code> unless a string of the form <code class="code">NAME=VALUE</code> is
found, in which case the string <code class="code">VALUE</code> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setenv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setenv</strong> <var class="def-var-arguments">name value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setenv"> ¶</a></span></dt>
<dd><p>Modifies the environment of the current process, which is
also the default environment inherited by child processes.
</p>
<p>If <var class="var">value</var> is <code class="code">#f</code>, then <var class="var">name</var> is removed from the
environment.  Otherwise, the string <var class="var">name</var>=<var class="var">value</var> is added
to the environment, replacing any existing string with name matching
<var class="var">name</var>.
</p>
<p>The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unsetenv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unsetenv</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unsetenv"> ¶</a></span></dt>
<dd><p>Remove variable <var class="var">name</var> from the environment.  The
name can not contain a ‘<samp class="samp">=</samp>’ character.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-environ"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">environ</strong> <var class="def-var-arguments">[env]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-environ"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fenviron"><span class="category-def">C Function: </span><span><strong class="def-name">scm_environ</strong> <var class="def-var-arguments">(env)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fenviron"> ¶</a></span></dt>
<dd><p>If <var class="var">env</var> is omitted, return the current environment (in the
Unix sense) as a list of strings.  Otherwise set the current
environment, which is also the default environment for child
processes, to the supplied list of strings.  Each member of
<var class="var">env</var> should be of the form <var class="var">name</var>=<var class="var">value</var> and values of
<var class="var">name</var> should not be duplicated.  If <var class="var">env</var> is supplied
then the return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-putenv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">putenv</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-putenv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fputenv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_putenv</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fputenv"> ¶</a></span></dt>
<dd><p>Modifies the environment of the current process, which is
also the default environment inherited by child processes.
</p>
<p>If <var class="var">str</var> is of the form <code class="code">NAME=VALUE</code> then it will be written
directly into the environment, replacing any existing environment string
with
name matching <code class="code">NAME</code>.  If <var class="var">str</var> does not contain an equal
sign, then any existing string with name matching <var class="var">str</var> will
be removed.
</p>
<p>The return value is unspecified.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Processes">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Signals" accesskey="n" rel="next">Signals</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Runtime-Environment" accesskey="p" rel="prev">Runtime Environment</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Processes-1">7.2.7 Processes</h4>
<a class="index-entry-id" id="index-processes"></a>
<a class="index-entry-id" id="index-child-processes"></a>

<a class="index-entry-id" id="index-cd"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-chdir"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">chdir</strong> <var class="def-var-arguments">str</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-chdir"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchdir"><span class="category-def">C Function: </span><span><strong class="def-name">scm_chdir</strong> <var class="def-var-arguments">(str)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchdir"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-current-directory"></a>
<p>Change the current working directory to <var class="var">str</var>.  <var class="var">str</var> can be a
string containing a file name, or a port if supported by the system.
<code class="code">(provided? 'chdir-port)</code> reports whether ports are supported.
The return value is unspecified.
</p></dd></dl>

<a class="index-entry-id" id="index-pwd"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-getcwd"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getcwd</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getcwd"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetcwd"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getcwd</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetcwd"> ¶</a></span></dt>
<dd><p>Return the name of the current working directory.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-umask"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">umask</strong> <var class="def-var-arguments">[mode]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-umask"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fumask"><span class="category-def">C Function: </span><span><strong class="def-name">scm_umask</strong> <var class="def-var-arguments">(mode)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fumask"> ¶</a></span></dt>
<dd><p>If <var class="var">mode</var> is omitted, returns a decimal number representing the
current file creation mask.  Otherwise the file creation mask is set
to <var class="var">mode</var> and the previous value is returned. See <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Permissions">Assigning File Permissions</a> in <cite class="cite">The GNU C Library
Reference Manual</cite>, for more on how to use umasks.
</p>
<p>E.g., <code class="code">(umask #o022)</code> sets the mask to octal 22/decimal 18.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-chroot"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">chroot</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-chroot"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fchroot"><span class="category-def">C Function: </span><span><strong class="def-name">scm_chroot</strong> <var class="def-var-arguments">(path)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fchroot"> ¶</a></span></dt>
<dd><p>Change the root directory to that specified in <var class="var">path</var>.
This directory will be used for path names beginning with
<samp class="file">/</samp>.  The root directory is inherited by all children
of the current process.  Only the superuser may change the
root directory.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpid"> ¶</a></span></dt>
<dd><p>Return an integer representing the current process ID.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getgroups"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgroups</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgroups"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetgroups"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getgroups</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetgroups"> ¶</a></span></dt>
<dd><p>Return a vector of integers representing the current
supplementary group IDs.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getppid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getppid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getppid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetppid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getppid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetppid"> ¶</a></span></dt>
<dd><p>Return an integer representing the process ID of the parent
process.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getuid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getuid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getuid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetuid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getuid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetuid"> ¶</a></span></dt>
<dd><p>Return an integer representing the current real user ID.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getgid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getgid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getgid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetgid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getgid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetgid"> ¶</a></span></dt>
<dd><p>Return an integer representing the current real group ID.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-geteuid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">geteuid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-geteuid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgeteuid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_geteuid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgeteuid"> ¶</a></span></dt>
<dd><p>Return an integer representing the current effective user ID.
If the system does not support effective IDs, then the real ID
is returned.  <code class="code">(provided? 'EIDs)</code> reports whether the
system supports effective IDs.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getegid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getegid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getegid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetegid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getegid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetegid"> ¶</a></span></dt>
<dd><p>Return an integer representing the current effective group ID.
If the system does not support effective IDs, then the real ID
is returned.  <code class="code">(provided? 'EIDs)</code> reports whether the
system supports effective IDs.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setgroups"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setgroups</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setgroups"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetgroups"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setgroups</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetgroups"> ¶</a></span></dt>
<dd><p>Set the current set of supplementary group IDs to the integers in the
given vector <var class="var">vec</var>.  The return value is unspecified.
</p>
<p>Generally only the superuser can set the process group IDs
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Setting-Groups">Setting the Group IDs</a> in <cite class="cite">The GNU C
Library Reference Manual</cite>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setuid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setuid</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setuid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetuid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setuid</strong> <var class="def-var-arguments">(id)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetuid"> ¶</a></span></dt>
<dd><p>Sets both the real and effective user IDs to the integer <var class="var">id</var>, provided
the process has appropriate privileges.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setgid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setgid</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setgid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetgid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setgid</strong> <var class="def-var-arguments">(id)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetgid"> ¶</a></span></dt>
<dd><p>Sets both the real and effective group IDs to the integer <var class="var">id</var>, provided
the process has appropriate privileges.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-seteuid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">seteuid</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-seteuid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fseteuid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_seteuid</strong> <var class="def-var-arguments">(id)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fseteuid"> ¶</a></span></dt>
<dd><p>Sets the effective user ID to the integer <var class="var">id</var>, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead—<code class="code">(provided? 'EIDs)</code> reports whether the
system supports effective IDs.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setegid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setegid</strong> <var class="def-var-arguments">id</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setegid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetegid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setegid</strong> <var class="def-var-arguments">(id)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetegid"> ¶</a></span></dt>
<dd><p>Sets the effective group ID to the integer <var class="var">id</var>, provided the process
has appropriate privileges.  If effective IDs are not supported, the
real ID is set instead—<code class="code">(provided? 'EIDs)</code> reports whether the
system supports effective IDs.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpgrp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpgrp</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpgrp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpgrp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpgrp</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpgrp"> ¶</a></span></dt>
<dd><p>Return an integer representing the current process group ID.
This is the <abbr class="acronym">POSIX</abbr> definition, not <abbr class="acronym">BSD</abbr>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setpgid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setpgid</strong> <var class="def-var-arguments">pid pgid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setpgid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetpgid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setpgid</strong> <var class="def-var-arguments">(pid, pgid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetpgid"> ¶</a></span></dt>
<dd><p>Move the process <var class="var">pid</var> into the process group <var class="var">pgid</var>.  <var class="var">pid</var> or
<var class="var">pgid</var> must be integers: they can be zero to indicate the ID of the
current process.
Fails on systems that do not support job control.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setsid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setsid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setsid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetsid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setsid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetsid"> ¶</a></span></dt>
<dd><p>Creates a new session.  The current process becomes the session leader
and is put in a new process group.  The process will be detached
from its controlling terminal if it has one.
The return value is an integer representing the new process group ID.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getsid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getsid</strong> <var class="def-var-arguments">pid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getsid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetsid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getsid</strong> <var class="def-var-arguments">(pid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetsid"> ¶</a></span></dt>
<dd><p>Returns the session ID of process <var class="var">pid</var>.  (The session
ID of a process is the process group ID of its session leader.)
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-waitpid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">waitpid</strong> <var class="def-var-arguments">pid [options]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-waitpid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fwaitpid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_waitpid</strong> <var class="def-var-arguments">(pid, options)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fwaitpid"> ¶</a></span></dt>
<dd><p>This procedure collects status information from a child process which
has terminated or (optionally) stopped.  Normally it will
suspend the calling process until this can be done.  If more than one
child process is eligible then one will be chosen by the operating system.
</p>
<p>The value of <var class="var">pid</var> determines the behaviour:
</p>
<dl class="table">
<dt><var class="var">pid</var> greater than 0</dt>
<dd><p>Request status information from the specified child process.
</p></dd>
<dt id="index-WAIT_005fANY"><span><var class="var">pid</var> equal to -1 or <code class="code">WAIT_ANY</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-WAIT_005fANY"> ¶</a></span></dt>
<dd><p>Request status information for any child process.
</p></dd>
<dt id="index-WAIT_005fMYPGRP"><span><var class="var">pid</var> equal to 0 or <code class="code">WAIT_MYPGRP</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-WAIT_005fMYPGRP"> ¶</a></span></dt>
<dd><p>Request status information for any child process in the current process
group.
</p></dd>
<dt><var class="var">pid</var> less than -1</dt>
<dd><p>Request status information for any child process whose process group ID
is −<var class="var">pid</var>.
</p></dd>
</dl>

<p>The <var class="var">options</var> argument, if supplied, should be the bitwise OR of the
values of zero or more of the following variables:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-WNOHANG"><span class="category-def">Variable: </span><span><strong class="def-name">WNOHANG</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-WNOHANG"> ¶</a></span></dt>
<dd><p>Return immediately even if there are no child processes to be collected.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-WUNTRACED"><span class="category-def">Variable: </span><span><strong class="def-name">WUNTRACED</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-WUNTRACED"> ¶</a></span></dt>
<dd><p>Report status information for stopped processes as well as terminated
processes.
</p></dd></dl>

<p>The return value is a pair containing:
</p>
<ol class="enumerate">
<li> The process ID of the child process, or 0 if <code class="code">WNOHANG</code> was
specified and no process was collected.
</li><li> The integer status value (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Process-Completion-Status">Process Completion Status</a> in <cite class="cite">The
GNU C Library Reference Manual</cite>).
</li></ol>
</dd></dl>

<p>The following three
functions can be used to decode the integer status value returned by
<code class="code">waitpid</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-status_003aexit_002dval"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">status:exit-val</strong> <var class="def-var-arguments">status</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-status_003aexit_002dval"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstatus_005fexit_005fval"><span class="category-def">C Function: </span><span><strong class="def-name">scm_status_exit_val</strong> <var class="def-var-arguments">(status)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstatus_005fexit_005fval"> ¶</a></span></dt>
<dd><p>Return the exit status value, as would be set if a process
ended normally through a call to <code class="code">exit</code> or <code class="code">_exit</code>,
if any, otherwise <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-status_003aterm_002dsig"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">status:term-sig</strong> <var class="def-var-arguments">status</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-status_003aterm_002dsig"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstatus_005fterm_005fsig"><span class="category-def">C Function: </span><span><strong class="def-name">scm_status_term_sig</strong> <var class="def-var-arguments">(status)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstatus_005fterm_005fsig"> ¶</a></span></dt>
<dd><p>Return the signal number which terminated the process, if any,
otherwise <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-status_003astop_002dsig"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">status:stop-sig</strong> <var class="def-var-arguments">status</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-status_003astop_002dsig"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fstatus_005fstop_005fsig"><span class="category-def">C Function: </span><span><strong class="def-name">scm_status_stop_sig</strong> <var class="def-var-arguments">(status)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fstatus_005fstop_005fsig"> ¶</a></span></dt>
<dd><p>Return the signal number which stopped the process, if any,
otherwise <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-system"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">system</strong> <var class="def-var-arguments">[cmd]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-system"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsystem"><span class="category-def">C Function: </span><span><strong class="def-name">scm_system</strong> <var class="def-var-arguments">(cmd)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsystem"> ¶</a></span></dt>
<dd><p>Execute <var class="var">cmd</var> using the operating system’s “command
processor”.  Under Unix this is usually the default shell
<code class="code">sh</code>.  The value returned is <var class="var">cmd</var>’s exit status as
returned by <code class="code">waitpid</code>, which can be interpreted using the
functions above.
</p>
<p>If <code class="code">system</code> is called without arguments, return a boolean
indicating whether the command processor is available.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-system_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">system*</strong> <var class="def-var-arguments">arg1 arg2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-system_002a"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsystem_005fstar"><span class="category-def">C Function: </span><span><strong class="def-name">scm_system_star</strong> <var class="def-var-arguments">(args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsystem_005fstar"> ¶</a></span></dt>
<dd><p>Execute the command indicated by <var class="var">arg1</var> <var class="var">arg2</var> <small class="enddots">...</small>.  The
first element must be a string indicating the command to be executed,
and the remaining items must be strings representing each of the
arguments to that command.
</p>
<p>This function returns the exit status of the command as provided by
<code class="code">waitpid</code>.  This value can be handled with <code class="code">status:exit-val</code>
and the related functions.
</p>
<p><code class="code">system*</code> is similar to <code class="code">system</code>, but accepts only one
string per-argument, and performs no shell interpretation.  The
command is executed using fork and execlp.  Accordingly this function
may be safer than <code class="code">system</code> in situations where shell
interpretation is not required.
</p>
<p>Example: (system* "echo" "foo" "bar")
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-quit-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">quit</strong> <var class="def-var-arguments">[status]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-quit-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-exit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">exit</strong> <var class="def-var-arguments">[status]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-exit"> ¶</a></span></dt>
<dd><p>Terminate the current process with proper unwinding of the Scheme stack.
The exit status zero if <var class="var">status</var> is not supplied.  If <var class="var">status</var>
is supplied, and it is an integer, that integer is used as the exit
status.  If <var class="var">status</var> is <code class="code">#t</code> or <code class="code">#f</code>, the exit status is
<var class="var">EXIT_SUCCESS</var> or <var class="var">EXIT_FAILURE</var>, respectively.
</p>
<p>The procedure <code class="code">exit</code> is an alias of <code class="code">quit</code>.  They have the
same functionality.
</p></dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-EXIT_005fSUCCESS"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">EXIT_SUCCESS</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-EXIT_005fSUCCESS"> ¶</a></span></dt>
<dt class="defvrx def-cmd-defvr" id="index-EXIT_005fFAILURE"><span class="category-def">Scheme Variable: </span><span><strong class="def-name">EXIT_FAILURE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-EXIT_005fFAILURE"> ¶</a></span></dt>
<dd><p>These constants represent the standard exit codes for success (zero) or
failure (one.)
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002dexit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-exit</strong> <var class="def-var-arguments">[status]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002dexit"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-primitive_002d_005fexit"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-_exit</strong> <var class="def-var-arguments">[status]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002d_005fexit"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005fexit"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive_exit</strong> <var class="def-var-arguments">(status)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005fexit"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fprimitive_005f_005fexit"><span class="category-def">C Function: </span><span><strong class="def-name">scm_primitive__exit</strong> <var class="def-var-arguments">(status)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fprimitive_005f_005fexit"> ¶</a></span></dt>
<dd><p>Terminate the current process without unwinding the Scheme stack.  The
exit status is <var class="var">status</var> if supplied, otherwise zero.
</p>
<p><code class="code">primitive-exit</code> uses the C <code class="code">exit</code> function and hence runs
usual C level cleanups (flush output streams, call <code class="code">atexit</code>
functions, etc, see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Normal-Termination">Normal Termination</a> in <cite class="cite">The GNU C Library
Reference Manual</cite>)).
</p>
<p><code class="code">primitive-_exit</code> is the <code class="code">_exit</code> system call
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Termination-Internals">Termination Internals</a> in <cite class="cite">The GNU C Library Reference
Manual</cite>).  This terminates the program immediately, with neither
Scheme-level nor C-level cleanups.
</p>
<p>The typical use for <code class="code">primitive-_exit</code> is from a child process
created with <code class="code">primitive-fork</code>.  For example in a Gdk program the
child process inherits the X server connection and a C-level
<code class="code">atexit</code> cleanup which will close that connection.  But closing
in the child would upset the protocol in the parent, so
<code class="code">primitive-_exit</code> should be used to exit without that.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-execl"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">execl</strong> <var class="def-var-arguments">filename arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-execl"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexecl"><span class="category-def">C Function: </span><span><strong class="def-name">scm_execl</strong> <var class="def-var-arguments">(filename, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexecl"> ¶</a></span></dt>
<dd><p>Executes the file named by <var class="var">filename</var> as a new process image.
The remaining arguments are supplied to the process; from a C program
they are accessible as the <code class="code">argv</code> argument to <code class="code">main</code>.
Conventionally the first <var class="var">arg</var> is the same as <var class="var">filename</var>.
All arguments must be strings.
</p>
<p>If <var class="var">arg</var> is missing, <var class="var">filename</var> is executed with a null
argument list, which may have system-dependent side-effects.
</p>
<p>This procedure is currently implemented using the <code class="code">execv</code> system
call, but we call it <code class="code">execl</code> because of its Scheme calling interface.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-execlp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">execlp</strong> <var class="def-var-arguments">filename arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-execlp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexeclp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_execlp</strong> <var class="def-var-arguments">(filename, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexeclp"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">execl</code>, however if
<var class="var">filename</var> does not contain a slash
then the file to execute will be located by searching the
directories listed in the <code class="code">PATH</code> environment variable.
</p>
<p>This procedure is currently implemented using the <code class="code">execvp</code> system
call, but we call it <code class="code">execlp</code> because of its Scheme calling interface.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-execle"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">execle</strong> <var class="def-var-arguments">filename env arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-execle"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fexecle"><span class="category-def">C Function: </span><span><strong class="def-name">scm_execle</strong> <var class="def-var-arguments">(filename, env, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fexecle"> ¶</a></span></dt>
<dd><p>Similar to <code class="code">execl</code>, but the environment of the new process is
specified by <var class="var">env</var>, which must be a list of strings as returned by the
<code class="code">environ</code> procedure.
</p>
<p>This procedure is currently implemented using the <code class="code">execve</code> system
call, but we call it <code class="code">execle</code> because of its Scheme calling interface.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-primitive_002dfork"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">primitive-fork</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-primitive_002dfork"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ffork"><span class="category-def">C Function: </span><span><strong class="def-name">scm_fork</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffork"> ¶</a></span></dt>
<dd><p>Creates a new “child” process by duplicating the current “parent” process.
In the child the return value is 0.  In the parent the return value is
the integer process ID of the child.
</p>
<p>Note that it is unsafe to fork a process that has multiple threads
running, as only the thread that calls <code class="code">primitive-fork</code> will
persist in the child.  Any resources that other threads held, such as
locked mutexes or open file descriptors, are lost.  Indeed,
<abbr class="acronym">POSIX</abbr> specifies that only async-signal-safe procedures are
safe to call after a multithreaded fork, which is a very limited set.
Guile issues a warning if it detects a fork from a multi-threaded
program.
</p>
<blockquote class="quotation">
<p><b class="b">Note:</b> If you are looking to spawn a process with some pipes set up, using the
<code class="code">spawn</code> procedure described below will be more robust (in
particular in multi-threaded contexts), more portable, and usually more
efficient than the combination of <code class="code">primitive-fork</code> and
<code class="code">execl</code>.
</p>
</blockquote>

<p>This procedure has been renamed from <code class="code">fork</code> to avoid a naming conflict
with the scsh fork.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-spawn"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">spawn</strong> <var class="def-var-arguments"><var class="var">program</var> <var class="var">arguments</var>        [#:environment=(environ)]        [#:input=(current-input-port)]        [#:output=(current-output-port)]        [#:error=(current-error-port)]        [#:search-path?=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-spawn"> ¶</a></span></dt>
<dd><p>Spawn a new child process executing <var class="var">program</var> with the
given <var class="var">arguments</var>, a list of one or more strings (by
convention, the first argument is typically <var class="var">program</var>),
and return its PID.  Raise a <code class="code">system-error</code> exception if
<var class="var">program</var> could not be found or could not be executed.
</p>
<p>If the keyword argument <code class="code">#:search-path?</code> is true, it
selects whether the <code class="env">PATH</code> environment variable should be
inspected to find <var class="var">program</var>.  It is true by default.
</p>
<p>The <code class="code">#:environment</code> keyword parameter specifies the
list of environment variables of the child process.  It
defaults to <code class="code">(environ)</code>.
</p>
<p>The keyword arguments <code class="code">#:input</code>, <code class="code">#:output</code>, and
<code class="code">#:error</code> specify the port or file descriptor for the
child process to use as standard input, standard output, and
standard error.  No other file descriptors are inherited
from the parent process.
</p></dd></dl>

<p>The example below shows how to spawn the <code class="command">uname</code> program with
the <samp class="option">-o</samp> option (see <a data-manual="coreutils" href="http://www.gnu.org/software/coreutils/manual/coreutils#uname-invocation">uname invocation</a> in <cite class="cite">GNU
Coreutils</cite>), redirect its standard output to a pipe, and read from it:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (rnrs io ports))

(let* ((input+output (pipe))
       (pid (spawn "uname" '("uname" "-o")
                    #:output (cdr input+output))))
  (close-port (cdr input+output))
  (format #t "read ~s~%" (get-string-all (car input+output)))
  (close-port (car input+output))
  (waitpid pid))

-| read "GNU/Linux\n"
⇒ (1234 . 0)
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-nice"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">nice</strong> <var class="def-var-arguments">incr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-nice"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fnice"><span class="category-def">C Function: </span><span><strong class="def-name">scm_nice</strong> <var class="def-var-arguments">(incr)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fnice"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-process-priority"></a>
<p>Increment the priority of the current process by <var class="var">incr</var>.  A higher
priority value means that the process runs less often.
The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setpriority"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setpriority</strong> <var class="def-var-arguments">which who prio</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setpriority"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetpriority"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setpriority</strong> <var class="def-var-arguments">(which, who, prio)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetpriority"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-PRIO_005fPROCESS"></a>
<a class="index-entry-id" id="index-PRIO_005fPGRP"></a>
<a class="index-entry-id" id="index-PRIO_005fUSER"></a>
<p>Set the scheduling priority of the process, process group
or user, as indicated by <var class="var">which</var> and <var class="var">who</var>. <var class="var">which</var>
is one of the variables <code class="code">PRIO_PROCESS</code>, <code class="code">PRIO_PGRP</code>
or <code class="code">PRIO_USER</code>, and <var class="var">who</var> is interpreted relative to
<var class="var">which</var> (a process identifier for <code class="code">PRIO_PROCESS</code>,
process group identifier for <code class="code">PRIO_PGRP</code>, and a user
identifier for <code class="code">PRIO_USER</code>.  A zero value of <var class="var">who</var>
denotes the current process, process group, or user.
<var class="var">prio</var> is a value in the range [−20,20].  The default
priority is 0; lower priorities (in numerical terms) cause more
favorable scheduling.  Sets the priority of all of the specified
processes.  Only the super-user may lower priorities.  The return
value is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpriority"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpriority</strong> <var class="def-var-arguments">which who</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpriority"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpriority"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpriority</strong> <var class="def-var-arguments">(which, who)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpriority"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-PRIO_005fPROCESS-1"></a>
<a class="index-entry-id" id="index-PRIO_005fPGRP-1"></a>
<a class="index-entry-id" id="index-PRIO_005fUSER-1"></a>
<p>Return the scheduling priority of the process, process group
or user, as indicated by <var class="var">which</var> and <var class="var">who</var>. <var class="var">which</var>
is one of the variables <code class="code">PRIO_PROCESS</code>, <code class="code">PRIO_PGRP</code>
or <code class="code">PRIO_USER</code>, and <var class="var">who</var> should be interpreted depending on
<var class="var">which</var> (a process identifier for <code class="code">PRIO_PROCESS</code>,
process group identifier for <code class="code">PRIO_PGRP</code>, and a user
identifier for <code class="code">PRIO_USER</code>).  A zero value of <var class="var">who</var>
denotes the current process, process group, or user.  Return
the highest priority (lowest numerical value) of any of the
specified processes.
</p></dd></dl>

<a class="index-entry-id" id="index-affinity_002c-CPU"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-getaffinity"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getaffinity</strong> <var class="def-var-arguments">pid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getaffinity"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetaffinity"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getaffinity</strong> <var class="def-var-arguments">(pid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetaffinity"> ¶</a></span></dt>
<dd><p>Return a bitvector representing the CPU affinity mask for
process <var class="var">pid</var>.  Each CPU the process has affinity with
has its corresponding bit set in the returned bitvector.
The number of bits set is a good estimate of how many CPUs
Guile can use without stepping on other processes’ toes.
</p>
<p>Currently this procedure is only defined on GNU variants
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#CPU-Affinity"><code class="code">sched_getaffinity</code></a> in <cite class="cite">The
GNU C Library Reference Manual</cite>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setaffinity"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setaffinity</strong> <var class="def-var-arguments">pid mask</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setaffinity"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetaffinity"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setaffinity</strong> <var class="def-var-arguments">(pid, mask)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetaffinity"> ¶</a></span></dt>
<dd><p>Install the CPU affinity mask <var class="var">mask</var>, a bitvector, for
the process or thread with ID <var class="var">pid</var>.  The return value
is unspecified.
</p>
<p>Currently this procedure is only defined on GNU variants
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#CPU-Affinity"><code class="code">sched_setaffinity</code></a> in <cite class="cite">The
GNU C Library Reference Manual</cite>).
</p></dd></dl>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>, for information on how get the number of processors
available on a system.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Signals">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Terminals-and-Ptys" accesskey="n" rel="next">Terminals and Ptys</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Processes" accesskey="p" rel="prev">Processes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Signals-1">7.2.8 Signals</h4>
<a class="index-entry-id" id="index-signal"></a>

<p>The following procedures raise, handle and wait for signals.
</p>
<p>Scheme code signal handlers are run via an async (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Asyncs">Asynchronous Interrupts</a>), so
they’re called in the handler’s thread at the next safe opportunity.
Generally this is after any currently executing primitive procedure
finishes (which could be a long time for primitives that wait for an
external event).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-kill"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">kill</strong> <var class="def-var-arguments">pid sig</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-kill"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fkill"><span class="category-def">C Function: </span><span><strong class="def-name">scm_kill</strong> <var class="def-var-arguments">(pid, sig)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fkill"> ¶</a></span></dt>
<dd><p>Sends a signal to the specified process or group of processes.
</p>
<p><var class="var">pid</var> specifies the processes to which the signal is sent:
</p>
<dl class="table">
<dt><var class="var">pid</var> greater than 0</dt>
<dd><p>The process whose identifier is <var class="var">pid</var>.
</p></dd>
<dt><var class="var">pid</var> equal to 0</dt>
<dd><p>All processes in the current process group.
</p></dd>
<dt><var class="var">pid</var> less than -1</dt>
<dd><p>The process group whose identifier is -<var class="var">pid</var>
</p></dd>
<dt><var class="var">pid</var> equal to -1</dt>
<dd><p>If the process is privileged, all processes except for some special
system processes.  Otherwise, all processes with the current effective
user ID.
</p></dd>
</dl>

<p><var class="var">sig</var> should be specified using a variable corresponding to
the Unix symbolic name, e.g.,
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SIGHUP"><span class="category-def">Variable: </span><span><strong class="def-name">SIGHUP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SIGHUP"> ¶</a></span></dt>
<dd><p>Hang-up signal.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SIGINT"><span class="category-def">Variable: </span><span><strong class="def-name">SIGINT</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SIGINT"> ¶</a></span></dt>
<dd><p>Interrupt signal.
</p></dd></dl>

<p>A full list of signals on the GNU system may be found in <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Standard-Signals">Standard
Signals</a> in <cite class="cite">The GNU C Library Reference Manual</cite>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-raise"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">raise</strong> <var class="def-var-arguments">sig</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-raise"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fraise"><span class="category-def">C Function: </span><span><strong class="def-name">scm_raise</strong> <var class="def-var-arguments">(sig)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fraise"> ¶</a></span></dt>
<dd><p>Sends a specified signal <var class="var">sig</var> to the current process, where
<var class="var">sig</var> is as described for the <code class="code">kill</code> procedure.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sigaction"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sigaction</strong> <var class="def-var-arguments">signum [handler [flags [thread]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sigaction"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsigaction"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sigaction</strong> <var class="def-var-arguments">(signum, handler, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsigaction"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsigaction_005ffor_005fthread"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sigaction_for_thread</strong> <var class="def-var-arguments">(signum, handler, flags, thread)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsigaction_005ffor_005fthread"> ¶</a></span></dt>
<dd><p>Install or report the signal handler for a specified signal.
</p>
<p><var class="var">signum</var> is the signal number, which can be specified using the value
of variables such as <code class="code">SIGINT</code>.
</p>
<p>If <var class="var">handler</var> is omitted, <code class="code">sigaction</code> returns a pair: the
<abbr class="acronym">CAR</abbr> is the current signal hander, which will be either an
integer with the value <code class="code">SIG_DFL</code> (default action) or
<code class="code">SIG_IGN</code> (ignore), or the Scheme procedure which handles the
signal, or <code class="code">#f</code> if a non-Scheme procedure handles the signal.
The <abbr class="acronym">CDR</abbr> contains the current <code class="code">sigaction</code> flags for the
handler.
</p>
<p>If <var class="var">handler</var> is provided, it is installed as the new handler for
<var class="var">signum</var>.  <var class="var">handler</var> can be a Scheme procedure taking one
argument, or the value of <code class="code">SIG_DFL</code> (default action) or
<code class="code">SIG_IGN</code> (ignore), or <code class="code">#f</code> to restore whatever signal handler
was installed before <code class="code">sigaction</code> was first used.  When a scheme
procedure has been specified, that procedure will run in the given
<var class="var">thread</var>.  When no thread has been given, the thread that made this
call to <code class="code">sigaction</code> is used.
</p>
<p><var class="var">flags</var> is a <code class="code">logior</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</a>) of the
following (where provided by the system), or <code class="code">0</code> for none.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SA_005fNOCLDSTOP"><span class="category-def">Variable: </span><span><strong class="def-name">SA_NOCLDSTOP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SA_005fNOCLDSTOP"> ¶</a></span></dt>
<dd><p>By default, <code class="code">SIGCHLD</code> is signalled when a child process stops
(ie. receives <code class="code">SIGSTOP</code>), and when a child process terminates.
With the <code class="code">SA_NOCLDSTOP</code> flag, <code class="code">SIGCHLD</code> is only signalled
for termination, not stopping.
</p>
<p><code class="code">SA_NOCLDSTOP</code> has no effect on signals other than
<code class="code">SIGCHLD</code>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SA_005fRESTART"><span class="category-def">Variable: </span><span><strong class="def-name">SA_RESTART</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SA_005fRESTART"> ¶</a></span></dt>
<dd><p>If a signal occurs while in a system call, deliver the signal then
restart the system call (as opposed to returning an <code class="code">EINTR</code> error
from that call).
</p></dd></dl>

<p>Guile handles signals asynchronously.  When it receives a signal, the
synchronous signal handler just records the fact that a signal was
received and sets a flag to tell the relevant Guile thread that it has a
pending signal.  When the Guile thread checks the pending-interrupt
flag, it will arrange to run the asynchronous part of the signal
handler, which is the handler attached by <code class="code">sigaction</code>.
</p>
<p>This strategy has some perhaps-unexpected interactions with the
<code class="code">SA_RESTART</code> flag, though: because the synchronous handler doesn’t
do very much, and notably it doesn’t run the Guile handler, it’s
impossible to interrupt a thread stuck in a long-running system call via
a signal handler that is installed with <code class="code">SA_RESTART</code>: the
synchronous handler just records the pending interrupt, but then the
system call resumes and Guile doesn’t have a chance to actually check
the flag and run the asynchronous handler.  That’s just how it is.
</p>
<p>The return value is a pair with information about the old handler as
described above.
</p>
<p>This interface does not provide access to the “signal blocking”
facility.  Maybe this is not needed, since the thread support may
provide solutions to the problem of consistent access to data
structures.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-restore_002dsignals"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">restore-signals</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-restore_002dsignals"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frestore_005fsignals"><span class="category-def">C Function: </span><span><strong class="def-name">scm_restore_signals</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frestore_005fsignals"> ¶</a></span></dt>
<dd><p>Return all signal handlers to the values they had before any call to
<code class="code">sigaction</code> was made.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alarm"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alarm</strong> <var class="def-var-arguments">i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alarm"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005falarm"><span class="category-def">C Function: </span><span><strong class="def-name">scm_alarm</strong> <var class="def-var-arguments">(i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005falarm"> ¶</a></span></dt>
<dd><p>Set a timer to raise a <code class="code">SIGALRM</code> signal after the specified
number of seconds (an integer).  It’s advisable to install a signal
handler for
<code class="code">SIGALRM</code> beforehand, since the default action is to terminate
the process.
</p>
<p>The return value indicates the time remaining for the previous alarm,
if any.  The new value replaces the previous alarm.  If there was
no previous alarm, the return value is zero.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pause"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pause</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pause"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fpause"><span class="category-def">C Function: </span><span><strong class="def-name">scm_pause</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fpause"> ¶</a></span></dt>
<dd><p>Pause the current process (thread?) until a signal arrives whose
action is to either terminate the current process or invoke a
handler procedure.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sleep"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sleep</strong> <var class="def-var-arguments">secs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sleep"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-usleep"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">usleep</strong> <var class="def-var-arguments">usecs</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-usleep"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsleep"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sleep</strong> <var class="def-var-arguments">(secs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsleep"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fusleep"><span class="category-def">C Function: </span><span><strong class="def-name">scm_usleep</strong> <var class="def-var-arguments">(usecs)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fusleep"> ¶</a></span></dt>
<dd><p>Wait the given period <var class="var">secs</var> seconds or <var class="var">usecs</var> microseconds
(both integers).  If a signal arrives the wait stops and the return
value is the time remaining, in seconds or microseconds respectively.
If the period elapses with no signal the return is zero.
</p>
<p>On most systems the process scheduler is not microsecond accurate and
the actual period slept by <code class="code">usleep</code> might be rounded to a system
clock tick boundary, which might be 10 milliseconds for instance.
</p>
<p>See <code class="code">scm_std_sleep</code> and <code class="code">scm_std_usleep</code> for equivalents at
the C level (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Blocking">Blocking in Guile Mode</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getitimer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getitimer</strong> <var class="def-var-arguments">which_timer</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getitimer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-setitimer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setitimer</strong> <var class="def-var-arguments">which_timer interval_seconds interval_microseconds value_seconds value_microseconds</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setitimer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetitimer"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getitimer</strong> <var class="def-var-arguments">(which_timer)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetitimer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetitimer"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setitimer</strong> <var class="def-var-arguments">(which_timer, interval_seconds, interval_microseconds, value_seconds, value_microseconds)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetitimer"> ¶</a></span></dt>
<dd><p>Get or set the periods programmed in certain system timers.
</p>
<p>These timers have two settings.  The first setting, the interval, is the
value at which the timer will be reset when the current timer expires.
The second is the current value of the timer, indicating when the next
expiry will be signalled.
</p>
<p><var class="var">which_timer</var> is one of the following values:
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-ITIMER_005fREAL"><span class="category-def">Variable: </span><span><strong class="def-name">ITIMER_REAL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ITIMER_005fREAL"> ¶</a></span></dt>
<dd><p>A real-time timer, counting down elapsed real time.  At zero it raises
<code class="code">SIGALRM</code>.  This is like <code class="code">alarm</code> above, but with a higher
resolution period.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-ITIMER_005fVIRTUAL"><span class="category-def">Variable: </span><span><strong class="def-name">ITIMER_VIRTUAL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ITIMER_005fVIRTUAL"> ¶</a></span></dt>
<dd><p>A virtual-time timer, counting down while the current process is
actually using CPU.  At zero it raises <code class="code">SIGVTALRM</code>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-ITIMER_005fPROF"><span class="category-def">Variable: </span><span><strong class="def-name">ITIMER_PROF</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ITIMER_005fPROF"> ¶</a></span></dt>
<dd><p>A profiling timer, counting down while the process is running (like
<code class="code">ITIMER_VIRTUAL</code>) and also while system calls are running on the
process’s behalf.  At zero it raises a <code class="code">SIGPROF</code>.
</p>
<p>This timer is intended for profiling where a program is spending its
time (by looking where it is when the timer goes off).
</p></dd></dl>

<p><code class="code">getitimer</code> returns the restart timer value and its current value,
as a list containing two pairs.  Each pair is a time in seconds and
microseconds: <code class="code">((<var class="var">interval_secs</var> . <var class="var">interval_usecs</var>)
(<var class="var">value_secs</var> . <var class="var">value_usecs</var>))</code>.
</p>
<p><code class="code">setitimer</code> sets the timer values similarly, in seconds and
microseconds (which must be integers).  The interval value can be zero
to have the timer run down just once.  The return value is the timer’s
previous setting, in the same form as <code class="code">getitimer</code> returns.
</p>
<div class="example">
<pre class="example-preformatted">(setitimer ITIMER_REAL
           5 500000     ;; Raise SIGALRM every 5.5 seconds
           2 0)         ;; with the first SIGALRM in 2 seconds
</pre></div>

<p>Although the timers are programmed in microseconds, the actual
accuracy might not be that high.
</p>
<p>Note that <code class="code">ITIMER_PROF</code> and <code class="code">ITIMER_VIRTUAL</code> are not
functional on all platforms and may always error when called.
<code class="code">(provided? 'ITIMER_PROF)</code> and <code class="code">(provided? 'ITIMER_VIRTUAL)</code>
can be used to test if the those itimers are supported on the given
host.  <code class="code">ITIMER_REAL</code> is supported on all platforms that support
<code class="code">setitimer</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Terminals-and-Ptys">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pipes" accesskey="n" rel="next">Pipes</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Signals" accesskey="p" rel="prev">Signals</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Terminals-and-Ptys-1">7.2.9 Terminals and Ptys</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-isatty_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">isatty?</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-isatty_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fisatty_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_isatty_p</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fisatty_005fp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-terminal"></a>
<p>Return <code class="code">#t</code> if <var class="var">port</var> is using a serial non–file
device, otherwise <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ttyname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ttyname</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ttyname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fttyname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ttyname</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fttyname"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-terminal-1"></a>
<p>Return a string with the name of the serial terminal device
underlying <var class="var">port</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-ctermid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ctermid</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ctermid"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fctermid"><span class="category-def">C Function: </span><span><strong class="def-name">scm_ctermid</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fctermid"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-terminal-2"></a>
<p>Return a string containing the file name of the controlling
terminal for the current process.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tcgetpgrp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tcgetpgrp</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tcgetpgrp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftcgetpgrp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_tcgetpgrp</strong> <var class="def-var-arguments">(port)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftcgetpgrp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-process-group"></a>
<p>Return the process group ID of the foreground process group
associated with the terminal open on the file descriptor
underlying <var class="var">port</var>.
</p>
<p>If there is no foreground process group, the return value is a
number greater than 1 that does not match the process group ID
of any existing process group.  This can happen if all of the
processes in the job that was formerly the foreground job have
terminated, and no other job has yet been moved into the
foreground.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-tcsetpgrp"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tcsetpgrp</strong> <var class="def-var-arguments">port pgid</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tcsetpgrp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ftcsetpgrp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_tcsetpgrp</strong> <var class="def-var-arguments">(port, pgid)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftcsetpgrp"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-process-group-1"></a>
<p>Set the foreground process group ID for the terminal used by the file
descriptor underlying <var class="var">port</var> to the integer <var class="var">pgid</var>.
The calling process
must be a member of the same session as <var class="var">pgid</var> and must have the same
controlling terminal.  The return value is unspecified.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Pipes">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="n" rel="next">Networking</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Terminals-and-Ptys" accesskey="p" rel="prev">Terminals and Ptys</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Pipes-1">7.2.10 Pipes</h4>
<a class="index-entry-id" id="index-pipe-1"></a>

<p>The following procedures are similar to the <code class="code">popen</code> and
<code class="code">pclose</code> system routines.  The code is in a separate “popen”
module<a class="footnote" id="DOCF24" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT24"><sup>24</sup></a>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 popen))
</pre></div>

<a class="index-entry-id" id="index-popen"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-open_002dpipe"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-pipe</strong> <var class="def-var-arguments">command mode</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dpipe"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-open_002dpipe_002a"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-pipe*</strong> <var class="def-var-arguments">mode prog [args...]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dpipe_002a"> ¶</a></span></dt>
<dd><p>Execute a command in a subprocess, with a pipe to it or from it, or
with pipes in both directions.
</p>
<p><code class="code">open-pipe</code> runs the shell <var class="var">command</var> using ‘<samp class="samp">/bin/sh -c</samp>’.
<code class="code">open-pipe*</code> executes <var class="var">prog</var> directly, with the optional
<var class="var">args</var> arguments (all strings).
</p>
<p><var class="var">mode</var> should be one of the following values.  <code class="code">OPEN_READ</code> is
an input pipe, ie. to read from the subprocess.  <code class="code">OPEN_WRITE</code>
is an output pipe, ie. to write to it.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-OPEN_005fREAD"><span class="category-def">Variable: </span><span><strong class="def-name">OPEN_READ</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-OPEN_005fREAD"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-OPEN_005fWRITE"><span class="category-def">Variable: </span><span><strong class="def-name">OPEN_WRITE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-OPEN_005fWRITE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-OPEN_005fBOTH"><span class="category-def">Variable: </span><span><strong class="def-name">OPEN_BOTH</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-OPEN_005fBOTH"> ¶</a></span></dt>
</dl>

<p>For an input pipe, the child’s standard output is the pipe and
standard input is inherited from <code class="code">current-input-port</code>.  For an
output pipe, the child’s standard input is the pipe and standard
output is inherited from <code class="code">current-output-port</code>.  In all cases
the child’s standard error is inherited from
<code class="code">current-error-port</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Default-Ports">Default Ports for Input, Output and Errors</a>).
</p>
<p>If those <code class="code">current-X-ports</code> are not files of some kind, and hence
don’t have file descriptors for the child, then <samp class="file">/dev/null</samp> is
used instead.
</p>
<p>Care should be taken with <code class="code">OPEN_BOTH</code>, a deadlock will occur if
both parent and child are writing, and waiting until the write completes
before doing any reading.  Each direction has <code class="code">PIPE_BUF</code> bytes of
buffering (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>), which will be enough for small writes,
but not for say putting a big file through a filter.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dinput_002dpipe"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-input-pipe</strong> <var class="def-var-arguments">command</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dinput_002dpipe"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">open-pipe</code> with mode <code class="code">OPEN_READ</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let* ((port (open-input-pipe "date --utc"))
       (str  (read-line port))) ; from (ice-9 rdelim)
  (close-pipe port)
  str)
⇒ "Mon Mar 11 20:10:44 UTC 2002"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002doutput_002dpipe"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-output-pipe</strong> <var class="def-var-arguments">command</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002doutput_002dpipe"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">open-pipe</code> with mode <code class="code">OPEN_WRITE</code>.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((port (open-output-pipe "lpr")))
  (display "Something for the line printer.\n" port)
  (if (not (eqv? 0 (status:exit-val (close-pipe port))))
      (error "Cannot print")))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dinput_002doutput_002dpipe"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-input-output-pipe</strong> <var class="def-var-arguments">command</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dinput_002doutput_002dpipe"> ¶</a></span></dt>
<dd><p>Equivalent to <code class="code">open-pipe</code> with mode <code class="code">OPEN_BOTH</code>.
</p></dd></dl>

<a class="index-entry-id" id="index-pclose"></a>
<dl class="first-deffn">
<dt class="deffn" id="index-close_002dpipe"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">close-pipe</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-close_002dpipe"> ¶</a></span></dt>
<dd><p>Close a pipe created by <code class="code">open-pipe</code>, wait for the process to
terminate, and return the wait status code.  The status is as per
<code class="code">waitpid</code> and can be decoded with <code class="code">status:exit-val</code> etc
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Processes">Processes</a>)
</p></dd></dl>

<br>
<p><code class="code">waitpid WAIT_ANY</code> should not be used when pipes are open, since
it can reap a pipe’s child process, causing an error from a subsequent
<code class="code">close-pipe</code>.
</p>
<p><code class="code">close-port</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>) can close a pipe, but it doesn’t reap
the child process.
</p>
<p>The garbage collector will close a pipe no longer in use, and reap the
child process with <code class="code">waitpid</code>.  If the child hasn’t yet terminated
the garbage collector doesn’t block, but instead checks again in the
next GC.
</p>
<p>Many systems have per-user and system-wide limits on the number of
processes, and a system-wide limit on the number of pipes, so pipes
should be closed explicitly when no longer needed, rather than letting
the garbage collector pick them up at some later time.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-pipeline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pipeline</strong> <var class="def-var-arguments"><var class="var">commands</var></var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pipeline"> ¶</a></span></dt>
<dd><p>Execute a pipeline of <var class="var">commands</var>, where each command is a
list of a program and its arguments as strings, returning an input
port to the end of the pipeline, an output port to the beginning of the
pipeline and a list of PIDs of the processes executing the <var class="var">commands</var>.
</p>
<div class="example">
<pre class="example-preformatted">(let ((commands '(("git" "ls-files")
                  ("tar" "-cf-" "-T-")
                  ("sha1sum" "-")))
      (success? (lambda (pid)
                  (zero?
                   (status:exit-val (cdr (waitpid pid)))))))
  (receive (from to pids) (pipeline commands)
    (let* ((sha1 (read-delimited " " from))
           (index (list-index (negate success?) (reverse pids))))
      (close to)
      (close from)
      (if (not index)
          sha1
          (string-append "pipeline failed in command: "
                         (string-join (list-ref commands index)))))))
⇒ "52f99d234503fca8c84ef94b1005a3a28d8b3bc1"
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Networking">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#System-Identification" accesskey="n" rel="next">System Identification</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Pipes" accesskey="p" rel="prev">Pipes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Networking-1">7.2.11 Networking</h4>
<a class="index-entry-id" id="index-network"></a>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion" accesskey="1">Network Address Conversion</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases" accesskey="2">Network Databases</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address" accesskey="3">Network Socket Address</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication" accesskey="4">Network Sockets and Communication</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Internet-Socket-Examples" accesskey="5">Network Socket Examples</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="Network-Address-Conversion">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases" accesskey="n" rel="next">Network Databases</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="u" rel="up">Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Network-Address-Conversion-1">7.2.11.1 Network Address Conversion</h4>
<a class="index-entry-id" id="index-network-address"></a>

<p>This section describes procedures which convert internet addresses
between numeric and string formats.
</p>
<h4 class="subsubheading" id="IPv4-Address-Conversion">IPv4 Address Conversion</h4>
<a class="index-entry-id" id="index-IPv4"></a>

<p>An IPv4 Internet address is a 4-byte value, represented in Guile as an
integer in host byte order, so that say “0.0.0.1” is 1, or
“1.0.0.0” is 16777216.
</p>
<p>Some underlying C functions use network byte order for addresses,
Guile converts as necessary so that at the Scheme level its host byte
order everywhere.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-INADDR_005fANY"><span class="category-def">Variable: </span><span><strong class="def-name">INADDR_ANY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-INADDR_005fANY"> ¶</a></span></dt>
<dd><p>For a server, this can be used with <code class="code">bind</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">Network Sockets and Communication</a>) to allow connections from any interface on
the machine.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-INADDR_005fBROADCAST"><span class="category-def">Variable: </span><span><strong class="def-name">INADDR_BROADCAST</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-INADDR_005fBROADCAST"> ¶</a></span></dt>
<dd><p>The broadcast address on the local network.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-INADDR_005fLOOPBACK"><span class="category-def">Variable: </span><span><strong class="def-name">INADDR_LOOPBACK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-INADDR_005fLOOPBACK"> ¶</a></span></dt>
<dd><p>The address of the local host using the loopback device, ie.
‘<samp class="samp">127.0.0.1</samp>’.
</p></dd></dl>


<dl class="first-deffn">
<dt class="deffn" id="index-inet_002dnetof"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inet-netof</strong> <var class="def-var-arguments">address</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inet_002dnetof"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finet_005fnetof"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inet_netof</strong> <var class="def-var-arguments">(address)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finet_005fnetof"> ¶</a></span></dt>
<dd><p>Return the network number part of the given IPv4
Internet address.  E.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inet-netof 2130706433) ⇒ 127
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inet_002dlnaof"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inet-lnaof</strong> <var class="def-var-arguments">address</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inet_002dlnaof"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flnaof"><span class="category-def">C Function: </span><span><strong class="def-name">scm_lnaof</strong> <var class="def-var-arguments">(address)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flnaof"> ¶</a></span></dt>
<dd><p>Return the local-address-with-network part of the given
IPv4 Internet address, using the obsolete class A/B/C system.
E.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inet-lnaof 2130706433) ⇒ 1
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inet_002dmakeaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inet-makeaddr</strong> <var class="def-var-arguments">net lna</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inet_002dmakeaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finet_005fmakeaddr"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inet_makeaddr</strong> <var class="def-var-arguments">(net, lna)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finet_005fmakeaddr"> ¶</a></span></dt>
<dd><p>Make an IPv4 Internet address by combining the network number
<var class="var">net</var> with the local-address-within-network number
<var class="var">lna</var>.  E.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inet-makeaddr 127 1) ⇒ 2130706433
</pre></div>
</dd></dl>

<h4 class="subsubheading" id="IPv6-Address-Conversion">IPv6 Address Conversion</h4>
<a class="index-entry-id" id="index-IPv6"></a>

<p>An IPv6 Internet address is a 16-byte value, represented in Guile as
an integer in host byte order, so that say “::1” is 1.  The following
constants are defined for convenience.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IN6ADDR_005fANY"><span class="category-def">Variable: </span><span><strong class="def-name">IN6ADDR_ANY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IN6ADDR_005fANY"> ¶</a></span></dt>
<dd><p>For a server, this can be used with <code class="code">bind</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">Network Sockets and Communication</a>) to allow connections from any IPv6 interface on the
machine.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IN6ADDR_005fLOOPBACK"><span class="category-def">Variable: </span><span><strong class="def-name">IN6ADDR_LOOPBACK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IN6ADDR_005fLOOPBACK"> ¶</a></span></dt>
<dd><p>The address of the local host using the loopback device, ie.
‘<samp class="samp">::1</samp>’.
</p></dd></dl>

<p>The procedures below convert an IPv6 <em class="emph">or</em> an IPv4 address to and
from its textual representation.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-inet_002dntop"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inet-ntop</strong> <var class="def-var-arguments">family address</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inet_002dntop"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finet_005fntop"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inet_ntop</strong> <var class="def-var-arguments">(family, address)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finet_005fntop"> ¶</a></span></dt>
<dd><p>Convert a network address from an integer to a printable string.
<var class="var">family</var> can be <code class="code">AF_INET</code> or <code class="code">AF_INET6</code>.  E.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inet-ntop AF_INET 2130706433) ⇒ "127.0.0.1"
(inet-ntop AF_INET6 (- (expt 2 128) 1))
  ⇒ "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff"
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-inet_002dpton"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">inet-pton</strong> <var class="def-var-arguments">family address</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-inet_002dpton"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005finet_005fpton"><span class="category-def">C Function: </span><span><strong class="def-name">scm_inet_pton</strong> <var class="def-var-arguments">(family, address)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005finet_005fpton"> ¶</a></span></dt>
<dd><p>Convert a string containing a printable network address to an integer
address.  <var class="var">family</var> can be <code class="code">AF_INET</code> or <code class="code">AF_INET6</code>.
E.g.,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(inet-pton AF_INET "127.0.0.1") ⇒ 2130706433
(inet-pton AF_INET6 "::1") ⇒ 1
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Network-Databases">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address" accesskey="n" rel="next">Network Socket Address</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion" accesskey="p" rel="prev">Network Address Conversion</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="u" rel="up">Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Network-Databases-1">7.2.11.2 Network Databases</h4>
<a class="index-entry-id" id="index-network-database"></a>

<p>This section describes procedures which query various network databases.
Care should be taken when using the database routines since they are not
reentrant.
</p>
<h4 class="subsubheading" id="getaddrinfo"><code class="code">getaddrinfo</code></h4>

<a class="index-entry-id" id="index-addrinfo-object-type"></a>
<a class="index-entry-id" id="index-host-name-lookup"></a>
<a class="index-entry-id" id="index-service-name-lookup"></a>

<p>The <code class="code">getaddrinfo</code> procedure maps host and service names to socket addresses
and associated information in a protocol-independent way.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getaddrinfo"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getaddrinfo</strong> <var class="def-var-arguments">name service [hint_flags [hint_family [hint_socktype [hint_protocol]]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getaddrinfo"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetaddrinfo"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getaddrinfo</strong> <var class="def-var-arguments">(name, service, hint_flags, hint_family, hint_socktype, hint_protocol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetaddrinfo"> ¶</a></span></dt>
<dd><p>Return a list of <code class="code">addrinfo</code> structures containing
a socket address and associated information for host <var class="var">name</var>
and/or <var class="var">service</var> to be used in creating a socket with
which to address the specified service.
</p>
<div class="example">
<pre class="example-preformatted">(let* ((ai (car (getaddrinfo "www.gnu.org" "http")))
       (s  (socket (addrinfo:fam ai) (addrinfo:socktype ai)
                   (addrinfo:protocol ai))))
  (connect s (addrinfo:addr ai))
  s)
</pre></div>

<p>When <var class="var">service</var> is omitted or is <code class="code">#f</code>, return
network-level addresses for <var class="var">name</var>.  When <var class="var">name</var>
is <code class="code">#f</code> <var class="var">service</var> must be provided and service
locations local to the caller are returned.
</p>
<p>Additional hints can be provided.  When specified,
<var class="var">hint_flags</var> should be a bitwise-or of zero or more
constants among the following:
</p>
<dl class="table">
<dt><code class="code">AI_PASSIVE</code></dt>
<dd><p>Socket address is intended for <code class="code">bind</code>.
</p>
</dd>
<dt><code class="code">AI_CANONNAME</code></dt>
<dd><p>Request for canonical host name, available via
<code class="code">addrinfo:canonname</code>.  This makes sense mainly when
DNS lookups are involved.
</p>
</dd>
<dt><code class="code">AI_NUMERICHOST</code></dt>
<dd><p>Specifies that <var class="var">name</var> is a numeric host address string
(e.g., <code class="code">"127.0.0.1"</code>), meaning that name resolution
will not be used.
</p>
</dd>
<dt><code class="code">AI_NUMERICSERV</code></dt>
<dd><p>Likewise, specifies that <var class="var">service</var> is a numeric port
string (e.g., <code class="code">"80"</code>).
</p>
</dd>
<dt><code class="code">AI_ADDRCONFIG</code></dt>
<dd><p>Return only addresses configured on the local system  It is
highly recommended to provide this flag when the returned
socket addresses are to be used to make connections;
otherwise, some of the returned addresses could be unreachable
or use a protocol that is not supported.
</p>
</dd>
<dt><code class="code">AI_V4MAPPED</code></dt>
<dd><p>When looking up IPv6 addresses, return mapped IPv4 addresses if
there is no IPv6 address available at all.
</p>
</dd>
<dt><code class="code">AI_ALL</code></dt>
<dd><p>If this flag is set along with <code class="code">AI_V4MAPPED</code> when looking up IPv6
addresses, return all IPv6 addresses as well as all IPv4 addresses, the latter
mapped to IPv6 format.
</p></dd>
</dl>

<p>When given, <var class="var">hint_family</var> should specify the requested
address family, e.g., <code class="code">AF_INET6</code>.  Similarly,
<var class="var">hint_socktype</var> should specify the requested socket type
(e.g., <code class="code">SOCK_DGRAM</code>), and <var class="var">hint_protocol</var> should
specify the requested protocol (its value is interpreted
as in calls to <code class="code">socket</code>).
</p>
<p>On error, an exception with key <code class="code">getaddrinfo-error</code> is
thrown, with an error code (an integer) as its argument:
</p>
<div class="example">
<pre class="example-preformatted">(catch 'getaddrinfo-error
  (lambda ()
    (getaddrinfo "www.gnu.org" "gopher"))
  (lambda (key errcode)
    (cond ((= errcode EAI_SERVICE)
	   (display "doesn't know about Gopher!\n"))
	  ((= errcode EAI_NONAME)
	   (display "www.gnu.org not found\\n"))
	  (else
	   (format #t "something wrong: ~a\n"
		   (gai-strerror errcode))))))
</pre></div>

<p>Error codes are:
</p>
<dl class="table">
<dt><code class="code">EAI_AGAIN</code></dt>
<dd><p>The name or service could not be resolved at this time. Future
attempts may succeed.
</p>
</dd>
<dt><code class="code">EAI_BADFLAGS</code></dt>
<dd><p><var class="var">hint_flags</var> contains an invalid value.
</p>
</dd>
<dt><code class="code">EAI_FAIL</code></dt>
<dd><p>A non-recoverable error occurred when attempting to
resolve the name.
</p>
</dd>
<dt><code class="code">EAI_FAMILY</code></dt>
<dd><p><var class="var">hint_family</var> was not recognized.
</p>
</dd>
<dt><code class="code">EAI_NONAME</code></dt>
<dd><p>Either <var class="var">name</var> does not resolve for the supplied parameters,
or neither <var class="var">name</var> nor <var class="var">service</var> were supplied.
</p>
</dd>
<dt><code class="code">EAI_NODATA</code></dt>
<dd><p>This non-POSIX error code can be returned on some systems (GNU
and Darwin, at least), for example when <var class="var">name</var> is known
but requests that were made turned out no data.  Error handling
code should be prepared to handle it when it is defined.
</p>
</dd>
<dt><code class="code">EAI_SERVICE</code></dt>
<dd><p><var class="var">service</var> was not recognized for the specified socket type.
</p>
</dd>
<dt><code class="code">EAI_SOCKTYPE</code></dt>
<dd><p><var class="var">hint_socktype</var> was not recognized.
</p>
</dd>
<dt><code class="code">EAI_SYSTEM</code></dt>
<dd><p>A system error occurred.  In C, the error code can be found in
<code class="code">errno</code>; this value is not accessible from Scheme, but in
practice it provides little information about the actual error
cause.
</p></dd>
</dl>

<p>Users are encouraged to read the
<a class="url" href="http://www.opengroup.org/onlinepubs/9699919799/functions/getaddrinfo.html">"POSIX specification</a> for more details.
</p></dd></dl>

<p>The following procedures take an <code class="code">addrinfo</code> object as returned by
<code class="code">getaddrinfo</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003aflags"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:flags</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003aflags"> ¶</a></span></dt>
<dd><p>Return flags for <var class="var">ai</var> as a bitwise or of <code class="code">AI_</code> values (see above).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003afam"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:fam</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003afam"> ¶</a></span></dt>
<dd><p>Return the address family of <var class="var">ai</var> (a <code class="code">AF_</code> value).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003asocktype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:socktype</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003asocktype"> ¶</a></span></dt>
<dd><p>Return the socket type for <var class="var">ai</var> (a <code class="code">SOCK_</code> value).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003aprotocol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:protocol</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003aprotocol"> ¶</a></span></dt>
<dd><p>Return the protocol of <var class="var">ai</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003aaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:addr</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003aaddr"> ¶</a></span></dt>
<dd><p>Return the socket address associated with <var class="var">ai</var> as a <code class="code">sockaddr</code>
object (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-addrinfo_003acanonname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">addrinfo:canonname</strong> <var class="def-var-arguments">ai</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-addrinfo_003acanonname"> ¶</a></span></dt>
<dd><p>Return a string for the canonical name associated with <var class="var">ai</var> if
the <code class="code">AI_CANONNAME</code> flag was supplied.
</p></dd></dl>

<h4 class="subsubheading" id="The-Host-Database">The Host Database</h4>
<a class="index-entry-id" id="index-_002fetc_002fhosts"></a>
<a class="index-entry-id" id="index-network-database-1"></a>

<p>A <em class="dfn">host object</em> is a structure that represents what is known about a
network host, and is the usual way of representing a system’s network
identity inside software.
</p>
<p>The following functions accept a host object and return a selected
component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-hostent_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hostent:name</strong> <var class="def-var-arguments">host</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hostent_003aname"> ¶</a></span></dt>
<dd><p>The “official” hostname for <var class="var">host</var>.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-hostent_003aaliases"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hostent:aliases</strong> <var class="def-var-arguments">host</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hostent_003aaliases"> ¶</a></span></dt>
<dd><p>A list of aliases for <var class="var">host</var>.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-hostent_003aaddrtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hostent:addrtype</strong> <var class="def-var-arguments">host</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hostent_003aaddrtype"> ¶</a></span></dt>
<dd><p>The host address type, one of the <code class="code">AF</code> constants, such as
<code class="code">AF_INET</code> or <code class="code">AF_INET6</code>.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-hostent_003alength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hostent:length</strong> <var class="def-var-arguments">host</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hostent_003alength"> ¶</a></span></dt>
<dd><p>The length of each address for <var class="var">host</var>, in bytes.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-hostent_003aaddr_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">hostent:addr-list</strong> <var class="def-var-arguments">host</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-hostent_003aaddr_002dlist"> ¶</a></span></dt>
<dd><p>The list of network addresses associated with <var class="var">host</var>.  For
<code class="code">AF_INET</code> these are integer IPv4 address (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion">Network Address Conversion</a>).
</p></dd></dl>

<p>The following procedures can be used to search the host database.  However,
<code class="code">getaddrinfo</code> should be preferred over them since it’s more generic and
thread-safe.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-gethost"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gethost</strong> <var class="def-var-arguments">[host]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gethost"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-gethostbyname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gethostbyname</strong> <var class="def-var-arguments">hostname</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gethostbyname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-gethostbyaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gethostbyaddr</strong> <var class="def-var-arguments">address</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gethostbyaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgethost"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gethost</strong> <var class="def-var-arguments">(host)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgethost"> ¶</a></span></dt>
<dd><p>Look up a host by name or address, returning a host object.  The
<code class="code">gethost</code> procedure will accept either a string name or an integer
address; if given no arguments, it behaves like <code class="code">gethostent</code> (see
below).  If a name or address is supplied but the address can not be
found, an error will be thrown to one of the keys:
<code class="code">host-not-found</code>, <code class="code">try-again</code>, <code class="code">no-recovery</code> or
<code class="code">no-data</code>, corresponding to the equivalent <code class="code">h_error</code> values.
Unusual conditions may result in errors thrown to the
<code class="code">system-error</code> or <code class="code">misc_error</code> keys.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(gethost "www.gnu.org")
⇒ #("www.gnu.org" () 2 4 (3353880842))

(gethostbyname "www.emacs.org")
⇒ #("emacs.org" ("www.emacs.org") 2 4 (1073448978))
</pre></div>
</dd></dl>

<p>The following procedures may be used to step through the host
database from beginning to end.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-sethostent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sethostent</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sethostent"> ¶</a></span></dt>
<dd><p>Initialize an internal stream from which host objects may be read.  This
procedure must be called before any calls to <code class="code">gethostent</code>, and may
also be called afterward to reset the host entry stream.  If
<var class="var">stayopen</var> is supplied and is not <code class="code">#f</code>, the database is not
closed by subsequent <code class="code">gethostbyname</code> or <code class="code">gethostbyaddr</code> calls,
possibly giving an efficiency gain.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gethostent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gethostent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gethostent"> ¶</a></span></dt>
<dd><p>Return the next host object from the host database, or <code class="code">#f</code> if
there are no more hosts to be found (or an error has been encountered).
This procedure may not be used before <code class="code">sethostent</code> has been called.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endhostent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endhostent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endhostent"> ¶</a></span></dt>
<dd><p>Close the stream used by <code class="code">gethostent</code>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sethost"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sethost</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sethost"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsethost"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sethost</strong> <var class="def-var-arguments">(stayopen)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsethost"> ¶</a></span></dt>
<dd><p>If <var class="var">stayopen</var> is omitted, this is equivalent to <code class="code">endhostent</code>.
Otherwise it is equivalent to <code class="code">sethostent stayopen</code>.
</p></dd></dl>

<h4 class="subsubheading" id="The-Network-Database">The Network Database</h4>
<a class="index-entry-id" id="index-network-database-2"></a>

<p>The following functions accept an object representing a network
and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-netent_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">netent:name</strong> <var class="def-var-arguments">net</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-netent_003aname"> ¶</a></span></dt>
<dd><p>The “official” network name.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-netent_003aaliases"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">netent:aliases</strong> <var class="def-var-arguments">net</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-netent_003aaliases"> ¶</a></span></dt>
<dd><p>A list of aliases for the network.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-netent_003aaddrtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">netent:addrtype</strong> <var class="def-var-arguments">net</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-netent_003aaddrtype"> ¶</a></span></dt>
<dd><p>The type of the network number.  Currently, this returns only
<code class="code">AF_INET</code>.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-netent_003anet"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">netent:net</strong> <var class="def-var-arguments">net</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-netent_003anet"> ¶</a></span></dt>
<dd><p>The network number.
</p></dd></dl>

<p>The following procedures are used to search the network database:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getnet"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getnet</strong> <var class="def-var-arguments">[net]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getnet"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getnetbyname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getnetbyname</strong> <var class="def-var-arguments">net-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getnetbyname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getnetbyaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getnetbyaddr</strong> <var class="def-var-arguments">net-number</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getnetbyaddr"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetnet"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getnet</strong> <var class="def-var-arguments">(net)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetnet"> ¶</a></span></dt>
<dd><p>Look up a network by name or net number in the network database.  The
<var class="var">net-name</var> argument must be a string, and the <var class="var">net-number</var>
argument must be an integer.  <code class="code">getnet</code> will accept either type of
argument, behaving like <code class="code">getnetent</code> (see below) if no arguments are
given.
</p></dd></dl>

<p>The following procedures may be used to step through the network
database from beginning to end.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-setnetent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setnetent</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setnetent"> ¶</a></span></dt>
<dd><p>Initialize an internal stream from which network objects may be read.  This
procedure must be called before any calls to <code class="code">getnetent</code>, and may
also be called afterward to reset the net entry stream.  If
<var class="var">stayopen</var> is supplied and is not <code class="code">#f</code>, the database is not
closed by subsequent <code class="code">getnetbyname</code> or <code class="code">getnetbyaddr</code> calls,
possibly giving an efficiency gain.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getnetent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getnetent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getnetent"> ¶</a></span></dt>
<dd><p>Return the next entry from the network database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endnetent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endnetent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endnetent"> ¶</a></span></dt>
<dd><p>Close the stream used by <code class="code">getnetent</code>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setnet"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setnet</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setnet"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetnet"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setnet</strong> <var class="def-var-arguments">(stayopen)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetnet"> ¶</a></span></dt>
<dd><p>If <var class="var">stayopen</var> is omitted, this is equivalent to <code class="code">endnetent</code>.
Otherwise it is equivalent to <code class="code">setnetent stayopen</code>.
</p></dd></dl>

<h4 class="subsubheading" id="The-Protocol-Database">The Protocol Database</h4>
<a class="index-entry-id" id="index-_002fetc_002fprotocols"></a>
<a class="index-entry-id" id="index-protocols"></a>
<a class="index-entry-id" id="index-network-protocols"></a>

<p>The following functions accept an object representing a protocol
and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-protoent_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">protoent:name</strong> <var class="def-var-arguments">protocol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-protoent_003aname"> ¶</a></span></dt>
<dd><p>The “official” protocol name.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-protoent_003aaliases"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">protoent:aliases</strong> <var class="def-var-arguments">protocol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-protoent_003aaliases"> ¶</a></span></dt>
<dd><p>A list of aliases for the protocol.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-protoent_003aproto"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">protoent:proto</strong> <var class="def-var-arguments">protocol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-protoent_003aproto"> ¶</a></span></dt>
<dd><p>The protocol number.
</p></dd></dl>

<p>The following procedures are used to search the protocol database:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getproto"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getproto</strong> <var class="def-var-arguments">[protocol]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getproto"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getprotobyname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getprotobyname</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getprotobyname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getprotobynumber"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getprotobynumber</strong> <var class="def-var-arguments">number</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getprotobynumber"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetproto"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getproto</strong> <var class="def-var-arguments">(protocol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetproto"> ¶</a></span></dt>
<dd><p>Look up a network protocol by name or by number.  <code class="code">getprotobyname</code>
takes a string argument, and <code class="code">getprotobynumber</code> takes an integer
argument.  <code class="code">getproto</code> will accept either type, behaving like
<code class="code">getprotoent</code> (see below) if no arguments are supplied.
</p></dd></dl>

<p>The following procedures may be used to step through the protocol
database from beginning to end.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-setprotoent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setprotoent</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setprotoent"> ¶</a></span></dt>
<dd><p>Initialize an internal stream from which protocol objects may be read.  This
procedure must be called before any calls to <code class="code">getprotoent</code>, and may
also be called afterward to reset the protocol entry stream.  If
<var class="var">stayopen</var> is supplied and is not <code class="code">#f</code>, the database is not
closed by subsequent <code class="code">getprotobyname</code> or <code class="code">getprotobynumber</code> calls,
possibly giving an efficiency gain.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getprotoent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getprotoent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getprotoent"> ¶</a></span></dt>
<dd><p>Return the next entry from the protocol database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endprotoent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endprotoent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endprotoent"> ¶</a></span></dt>
<dd><p>Close the stream used by <code class="code">getprotoent</code>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setproto"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setproto</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setproto"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetproto"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setproto</strong> <var class="def-var-arguments">(stayopen)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetproto"> ¶</a></span></dt>
<dd><p>If <var class="var">stayopen</var> is omitted, this is equivalent to <code class="code">endprotoent</code>.
Otherwise it is equivalent to <code class="code">setprotoent stayopen</code>.
</p></dd></dl>

<h4 class="subsubheading" id="The-Service-Database">The Service Database</h4>
<a class="index-entry-id" id="index-_002fetc_002fservices"></a>
<a class="index-entry-id" id="index-services"></a>
<a class="index-entry-id" id="index-network-services"></a>

<p>The following functions accept an object representing a service
and return a selected component:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-servent_003aname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">servent:name</strong> <var class="def-var-arguments">serv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-servent_003aname"> ¶</a></span></dt>
<dd><p>The “official” name of the network service.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-servent_003aaliases"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">servent:aliases</strong> <var class="def-var-arguments">serv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-servent_003aaliases"> ¶</a></span></dt>
<dd><p>A list of aliases for the network service.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-servent_003aport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">servent:port</strong> <var class="def-var-arguments">serv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-servent_003aport"> ¶</a></span></dt>
<dd><p>The Internet port used by the service.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-servent_003aproto"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">servent:proto</strong> <var class="def-var-arguments">serv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-servent_003aproto"> ¶</a></span></dt>
<dd><p>The protocol used by the service.  A service may be listed many times
in the database under different protocol names.
</p></dd></dl>

<p>The following procedures are used to search the service database:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getserv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getserv</strong> <var class="def-var-arguments">[name [protocol]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getserv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getservbyname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getservbyname</strong> <var class="def-var-arguments">name protocol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getservbyname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-getservbyport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getservbyport</strong> <var class="def-var-arguments">port protocol</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getservbyport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetserv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getserv</strong> <var class="def-var-arguments">(name, protocol)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetserv"> ¶</a></span></dt>
<dd><p>Look up a network service by name or by service number, and return a
network service object.  The <var class="var">protocol</var> argument specifies the name
of the desired protocol; if the protocol found in the network service
database does not match this name, a system error is signalled.
</p>
<p>The <code class="code">getserv</code> procedure will take either a service name or number
as its first argument; if given no arguments, it behaves like
<code class="code">getservent</code> (see below).
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(getserv "imap" "tcp")
⇒ #("imap2" ("imap") 143 "tcp")

(getservbyport 88 "udp")
⇒ #("kerberos" ("kerberos5" "krb5") 88 "udp")
</pre></div>
</dd></dl>

<p>The following procedures may be used to step through the service
database from beginning to end.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-setservent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setservent</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setservent"> ¶</a></span></dt>
<dd><p>Initialize an internal stream from which service objects may be read.  This
procedure must be called before any calls to <code class="code">getservent</code>, and may
also be called afterward to reset the service entry stream.  If
<var class="var">stayopen</var> is supplied and is not <code class="code">#f</code>, the database is not
closed by subsequent <code class="code">getservbyname</code> or <code class="code">getservbyport</code> calls,
possibly giving an efficiency gain.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getservent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getservent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getservent"> ¶</a></span></dt>
<dd><p>Return the next entry from the services database.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-endservent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">endservent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-endservent"> ¶</a></span></dt>
<dd><p>Close the stream used by <code class="code">getservent</code>.  The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-setserv"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setserv</strong> <var class="def-var-arguments">[stayopen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setserv"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetserv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setserv</strong> <var class="def-var-arguments">(stayopen)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetserv"> ¶</a></span></dt>
<dd><p>If <var class="var">stayopen</var> is omitted, this is equivalent to <code class="code">endservent</code>.
Otherwise it is equivalent to <code class="code">setservent stayopen</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Network-Socket-Address">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication" accesskey="n" rel="next">Network Sockets and Communication</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases" accesskey="p" rel="prev">Network Databases</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="u" rel="up">Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Network-Socket-Address-1">7.2.11.3 Network Socket Address</h4>
<a class="index-entry-id" id="index-socket-address"></a>
<a class="index-entry-id" id="index-network-socket-address"></a>
<a class="index-entry-id" id="index-Socket-address"></a>

<p>A <em class="dfn">socket address</em> object identifies a socket endpoint for
communication.  In the case of <code class="code">AF_INET</code> for instance, the socket
address object comprises the host address (or interface on the host)
and a port number which specifies a particular open socket in a
running client or server process.  A socket address object can be
created with,
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dsocket_002daddress"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-socket-address</strong> <var class="def-var-arguments">AF_INET ipv4addr port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsocket_002daddress"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dsocket_002daddress-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-socket-address</strong> <var class="def-var-arguments">AF_INET6 ipv6addr port [flowinfo [scopeid]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsocket_002daddress-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dsocket_002daddress-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-socket-address</strong> <var class="def-var-arguments">AF_UNIX path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dsocket_002daddress-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fsocket_005faddress"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_socket_address</strong> <var class="def-var-arguments">(family, address, arglist)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fsocket_005faddress"> ¶</a></span></dt>
<dd><p>Return a new socket address object.  The first argument is the address
family, one of the <code class="code">AF</code> constants, then the arguments vary
according to the family.
</p>
<p>For <code class="code">AF_INET</code> the arguments are an IPv4 network address number
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion">Network Address Conversion</a>), and a port number.
</p>
<p>For <code class="code">AF_INET6</code> the arguments are an IPv6 network address number
and a port number.  Optional <var class="var">flowinfo</var> and <var class="var">scopeid</var>
arguments may be given (both integers, default 0).
</p>
<p>For <code class="code">AF_UNIX</code> the argument is a filename (a string).
</p>
<p>The C function <code class="code">scm_make_socket_address</code> takes the <var class="var">family</var>
and <var class="var">address</var> arguments directly, then <var class="var">arglist</var> is a list of
further arguments, being the port for IPv4, port and optional flowinfo
and scopeid for IPv6, or the empty list <code class="code">SCM_EOL</code> for Unix
domain.
</p></dd></dl>

<p>The following functions access the fields of a socket address object,
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003afam"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:fam</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003afam"> ¶</a></span></dt>
<dd><p>Return the address family from socket address object <var class="var">sa</var>.  This
is one of the <code class="code">AF</code> constants (e.g. <code class="code">AF_INET</code>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003apath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:path</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003apath"> ¶</a></span></dt>
<dd><p>For an <code class="code">AF_UNIX</code> socket address object <var class="var">sa</var>, return the
filename.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003aaddr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:addr</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003aaddr"> ¶</a></span></dt>
<dd><p>For an <code class="code">AF_INET</code> or <code class="code">AF_INET6</code> socket address object
<var class="var">sa</var>, return the network address number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003aport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:port</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003aport"> ¶</a></span></dt>
<dd><p>For an <code class="code">AF_INET</code> or <code class="code">AF_INET6</code> socket address object
<var class="var">sa</var>, return the port number.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003aflowinfo"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:flowinfo</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003aflowinfo"> ¶</a></span></dt>
<dd><p>For an <code class="code">AF_INET6</code> socket address object <var class="var">sa</var>, return the
flowinfo value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sockaddr_003ascopeid"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sockaddr:scopeid</strong> <var class="def-var-arguments">sa</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sockaddr_003ascopeid"> ¶</a></span></dt>
<dd><p>For an <code class="code">AF_INET6</code> socket address object <var class="var">sa</var>, return the
scope ID value.
</p></dd></dl>

<a class="index-entry-id" id="index-struct-sockaddr"></a>
<a class="index-entry-id" id="index-sockaddr"></a>
<p>The functions below convert to and from the C <code class="code">struct sockaddr</code>
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Address-Formats">Address Formats</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).
That structure is a generic type, an application can cast to or from
<code class="code">struct sockaddr_in</code>, <code class="code">struct sockaddr_in6</code> or <code class="code">struct
sockaddr_un</code> according to the address family.
</p>
<p>In a <code class="code">struct sockaddr</code> taken or returned, the byte ordering in
the fields follows the C conventions (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Byte-Order">Byte Order
Conversion</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).  This means
network byte order for <code class="code">AF_INET</code> host address
(<code class="code">sin_addr.s_addr</code>) and port number (<code class="code">sin_port</code>), and
<code class="code">AF_INET6</code> port number (<code class="code">sin6_port</code>).  But at the Scheme
level these values are taken or returned in host byte order, so the
port is an ordinary integer, and the host address likewise is an
ordinary integer (as described in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion">Network Address Conversion</a>).
</p>
<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fc_005fmake_005fsocket_005faddress"><span class="category-def">C Function: </span><span><code class="def-type">struct sockaddr *</code> <strong class="def-name">scm_c_make_socket_address</strong> <code class="def-code-arguments">(SCM family, SCM address, SCM args, size_t *outsize)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc_005fmake_005fsocket_005faddress"> ¶</a></span></dt>
<dd><p>Return a newly-<code class="code">malloc</code>ed <code class="code">struct sockaddr</code> created from
arguments like those taken by <code class="code">scm_make_socket_address</code> above.
</p>
<p>The size (in bytes) of the <code class="code">struct sockaddr</code> return is stored
into <code class="code">*<var class="var">outsize</var></code>.  An application must call <code class="code">free</code> to
release the returned structure when no longer required.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ffrom_005fsockaddr"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_from_sockaddr</strong> <code class="def-code-arguments">(const struct sockaddr *address, unsigned address_size)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ffrom_005fsockaddr"> ¶</a></span></dt>
<dd><p>Return a Scheme socket address object from the C <var class="var">address</var>
structure.  <var class="var">address_size</var> is the size in bytes of <var class="var">address</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fto_005fsockaddr"><span class="category-def">C Function: </span><span><code class="def-type">struct sockaddr *</code> <strong class="def-name">scm_to_sockaddr</strong> <code class="def-code-arguments">(SCM address, size_t *address_size)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fto_005fsockaddr"> ¶</a></span></dt>
<dd><p>Return a newly-<code class="code">malloc</code>ed <code class="code">struct sockaddr</code> from a Scheme
level socket address object.
</p>
<p>The size (in bytes) of the <code class="code">struct sockaddr</code> return is stored
into <code class="code">*<var class="var">outsize</var></code>.  An application must call <code class="code">free</code> to
release the returned structure when no longer required.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Network-Sockets-and-Communication">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Internet-Socket-Examples" accesskey="n" rel="next">Network Socket Examples</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address" accesskey="p" rel="prev">Network Socket Address</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="u" rel="up">Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Network-Sockets-and-Communication-1">7.2.11.4 Network Sockets and Communication</h4>
<a class="index-entry-id" id="index-socket"></a>
<a class="index-entry-id" id="index-network-socket"></a>

<p>Socket ports can be created using <code class="code">socket</code> and <code class="code">socketpair</code>.
The ports are initially unbuffered, to make reading and writing to the
same port more reliable.  A buffer can be added to the port using
<code class="code">setvbuf</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Buffering">Buffering</a>).
</p>
<p>Most systems have limits on how many files and sockets can be open, so
it’s strongly recommended that socket ports be closed explicitly when
no longer required (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports">Ports</a>).
</p>
<p>Some of the underlying C functions take values in network byte order,
but the convention in Guile is that at the Scheme level everything is
ordinary host byte order and conversions are made automatically where
necessary.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-socket-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">socket</strong> <var class="def-var-arguments">family style proto</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-socket-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsocket"><span class="category-def">C Function: </span><span><strong class="def-name">scm_socket</strong> <var class="def-var-arguments">(family, style, proto)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsocket"> ¶</a></span></dt>
<dd><p>Return a new socket port of the type specified by <var class="var">family</var>,
<var class="var">style</var> and <var class="var">proto</var>.  All three parameters are integers.  The
possible values for <var class="var">family</var> are as follows, where supported by
the system,
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-PF_005fUNIX"><span class="category-def">Variable: </span><span><strong class="def-name">PF_UNIX</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-PF_005fUNIX"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-PF_005fINET"><span class="category-def">Variable: </span><span><strong class="def-name">PF_INET</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-PF_005fINET"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-PF_005fINET6"><span class="category-def">Variable: </span><span><strong class="def-name">PF_INET6</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-PF_005fINET6"> ¶</a></span></dt>
</dl>

<p>The possible values for <var class="var">style</var> are as follows, again where
supported by the system,
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SOCK_005fSTREAM"><span class="category-def">Variable: </span><span><strong class="def-name">SOCK_STREAM</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOCK_005fSTREAM"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SOCK_005fDGRAM"><span class="category-def">Variable: </span><span><strong class="def-name">SOCK_DGRAM</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOCK_005fDGRAM"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SOCK_005fRAW"><span class="category-def">Variable: </span><span><strong class="def-name">SOCK_RAW</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOCK_005fRAW"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SOCK_005fRDM"><span class="category-def">Variable: </span><span><strong class="def-name">SOCK_RDM</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOCK_005fRDM"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SOCK_005fSEQPACKET"><span class="category-def">Variable: </span><span><strong class="def-name">SOCK_SEQPACKET</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOCK_005fSEQPACKET"> ¶</a></span></dt>
</dl>

<p><var class="var">proto</var> can be obtained from a protocol name using
<code class="code">getprotobyname</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases">Network Databases</a>).  A value of zero
means the default protocol, which is usually right.
</p>
<p>A socket cannot by used for communication until it has been connected
somewhere, usually with either <code class="code">connect</code> or <code class="code">accept</code> below.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-socketpair"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">socketpair</strong> <var class="def-var-arguments">family style proto</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-socketpair"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsocketpair"><span class="category-def">C Function: </span><span><strong class="def-name">scm_socketpair</strong> <var class="def-var-arguments">(family, style, proto)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsocketpair"> ¶</a></span></dt>
<dd><p>Return a pair, the <code class="code">car</code> and <code class="code">cdr</code> of which are two unnamed
socket ports connected to each other.  The connection is full-duplex,
so data can be transferred in either direction between the two.
</p>
<p><var class="var">family</var>, <var class="var">style</var> and <var class="var">proto</var> are as per <code class="code">socket</code>
above.  But many systems only support socket pairs in the
<code class="code">PF_UNIX</code> family.  Zero is likely to be the only meaningful value
for <var class="var">proto</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getsockopt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getsockopt</strong> <var class="def-var-arguments">sock level optname</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getsockopt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-setsockopt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setsockopt</strong> <var class="def-var-arguments">sock level optname value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setsockopt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetsockopt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getsockopt</strong> <var class="def-var-arguments">(sock, level, optname)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetsockopt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetsockopt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setsockopt</strong> <var class="def-var-arguments">(sock, level, optname, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetsockopt"> ¶</a></span></dt>
<dd><p>Get or set an option on socket port <var class="var">sock</var>.  <code class="code">getsockopt</code>
returns the current value.  <code class="code">setsockopt</code> sets a value and the
return is unspecified.
</p>
<p><var class="var">level</var> is an integer specifying a protocol layer, either
<code class="code">SOL_SOCKET</code> for socket level options, or a protocol number from
the <code class="code">IPPROTO</code> constants or <code class="code">getprotoent</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Databases">Network Databases</a>).
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SOL_005fSOCKET"><span class="category-def">Variable: </span><span><strong class="def-name">SOL_SOCKET</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SOL_005fSOCKET"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-IPPROTO_005fIP"><span class="category-def">Variable: </span><span><strong class="def-name">IPPROTO_IP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IPPROTO_005fIP"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-IPPROTO_005fIPV6"><span class="category-def">Variable: </span><span><strong class="def-name">IPPROTO_IPV6</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IPPROTO_005fIPV6"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-IPPROTO_005fTCP"><span class="category-def">Variable: </span><span><strong class="def-name">IPPROTO_TCP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IPPROTO_005fTCP"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-IPPROTO_005fUDP"><span class="category-def">Variable: </span><span><strong class="def-name">IPPROTO_UDP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IPPROTO_005fUDP"> ¶</a></span></dt>
</dl>

<p><var class="var">optname</var> is an integer specifying an option within the protocol
layer.
</p>
<p>For <code class="code">SOL_SOCKET</code> level the following <var class="var">optname</var>s are defined
(when provided by the system).  For their meaning see
<a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Socket_002dLevel-Options">Socket-Level Options</a> in <cite class="cite">The GNU C Library Reference
Manual</cite>, or <code class="command">man 7 socket</code>.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SO_005fDEBUG"><span class="category-def">Variable: </span><span><strong class="def-name">SO_DEBUG</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fDEBUG"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fREUSEADDR"><span class="category-def">Variable: </span><span><strong class="def-name">SO_REUSEADDR</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fREUSEADDR"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fSTYLE"><span class="category-def">Variable: </span><span><strong class="def-name">SO_STYLE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fSTYLE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fTYPE"><span class="category-def">Variable: </span><span><strong class="def-name">SO_TYPE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fTYPE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fERROR"><span class="category-def">Variable: </span><span><strong class="def-name">SO_ERROR</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fERROR"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fDONTROUTE"><span class="category-def">Variable: </span><span><strong class="def-name">SO_DONTROUTE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fDONTROUTE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fBROADCAST"><span class="category-def">Variable: </span><span><strong class="def-name">SO_BROADCAST</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fBROADCAST"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fSNDBUF"><span class="category-def">Variable: </span><span><strong class="def-name">SO_SNDBUF</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fSNDBUF"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fRCVBUF"><span class="category-def">Variable: </span><span><strong class="def-name">SO_RCVBUF</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fRCVBUF"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fKEEPALIVE"><span class="category-def">Variable: </span><span><strong class="def-name">SO_KEEPALIVE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fKEEPALIVE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fOOBINLINE"><span class="category-def">Variable: </span><span><strong class="def-name">SO_OOBINLINE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fOOBINLINE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fNO_005fCHECK"><span class="category-def">Variable: </span><span><strong class="def-name">SO_NO_CHECK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fNO_005fCHECK"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fPRIORITY"><span class="category-def">Variable: </span><span><strong class="def-name">SO_PRIORITY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fPRIORITY"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fREUSEPORT"><span class="category-def">Variable: </span><span><strong class="def-name">SO_REUSEPORT</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fREUSEPORT"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fRCVTIMEO"><span class="category-def">Variable: </span><span><strong class="def-name">SO_RCVTIMEO</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fRCVTIMEO"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-SO_005fSNDTIMEO"><span class="category-def">Variable: </span><span><strong class="def-name">SO_SNDTIMEO</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fSNDTIMEO"> ¶</a></span></dt>
<dd><p>The <var class="var">value</var> taken or returned is an integer.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-SO_005fLINGER"><span class="category-def">Variable: </span><span><strong class="def-name">SO_LINGER</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SO_005fLINGER"> ¶</a></span></dt>
<dd><p>The <var class="var">value</var> taken or returned is a pair of integers
<code class="code">(<var class="var">ENABLE</var> . <var class="var">TIMEOUT</var>)</code>.  On old systems without timeout
support (ie. without <code class="code">struct linger</code>), only <var class="var">ENABLE</var> has an
effect but the value in Guile is always a pair.
</p></dd></dl>

<p>For IP level (<code class="code">IPPROTO_IP</code>) the following <var class="var">optname</var>s are
defined (when provided by the system).  See <code class="command">man ip</code> for what
they mean.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IP_005fMULTICAST_005fIF"><span class="category-def">Variable: </span><span><strong class="def-name">IP_MULTICAST_IF</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IP_005fMULTICAST_005fIF"> ¶</a></span></dt>
<dd><p>This sets the source interface used by multicast traffic.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IP_005fMULTICAST_005fTTL"><span class="category-def">Variable: </span><span><strong class="def-name">IP_MULTICAST_TTL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IP_005fMULTICAST_005fTTL"> ¶</a></span></dt>
<dd><p>This sets the default TTL for multicast traffic. This defaults
to 1 and should be increased to allow traffic to pass beyond the
local network.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IP_005fADD_005fMEMBERSHIP"><span class="category-def">Variable: </span><span><strong class="def-name">IP_ADD_MEMBERSHIP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IP_005fADD_005fMEMBERSHIP"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-IP_005fDROP_005fMEMBERSHIP"><span class="category-def">Variable: </span><span><strong class="def-name">IP_DROP_MEMBERSHIP</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IP_005fDROP_005fMEMBERSHIP"> ¶</a></span></dt>
<dd><p>These can be used only with <code class="code">setsockopt</code>, not <code class="code">getsockopt</code>.
<var class="var">value</var> is a pair <code class="code">(<var class="var">MULTIADDR</var> . <var class="var">INTERFACEADDR</var>)</code>
of integer IPv4 addresses (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Address-Conversion">Network Address Conversion</a>).
<var class="var">MULTIADDR</var> is a multicast address to be added to or dropped from
the interface <var class="var">INTERFACEADDR</var>.  <var class="var">INTERFACEADDR</var> can be
<code class="code">INADDR_ANY</code> to have the system select the interface.
<var class="var">INTERFACEADDR</var> can also be an interface index number, on systems
supporting that.
</p></dd></dl>

<p>Last, for IPv6 level (<code class="code">IPPROTO_IPV6</code>), the following <var class="var">optname</var>s
are defined.  See <code class="command">man 7 ipv6</code> for details.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-IPV6_005fV6ONLY"><span class="category-def">Variable: </span><span><strong class="def-name">IPV6_V6ONLY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-IPV6_005fV6ONLY"> ¶</a></span></dt>
<dd><p>Determines whether an <code class="code">AF_INET6</code> socket is restricted to
transmitting IPv6 packets only, or whether it can also transmit packets
for an IPv4-mapped IPv6 address.
</p></dd></dl>

</dd></dl>

<p>For <code class="code">IPPROTO_TCP</code> level the following <var class="var">optname</var>s are defined
(when provided by the system).  For their meaning see <code class="command">man 7
tcp</code>.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-TCP_005fNODELAY"><span class="category-def">Variable: </span><span><strong class="def-name">TCP_NODELAY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-TCP_005fNODELAY"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-TCP_005fCORK"><span class="category-def">Variable: </span><span><strong class="def-name">TCP_CORK</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-TCP_005fCORK"> ¶</a></span></dt>
<dd><p>The <var class="var">value</var> taken or returned is an integer.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-shutdown"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">shutdown</strong> <var class="def-var-arguments">sock how</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-shutdown"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fshutdown"><span class="category-def">C Function: </span><span><strong class="def-name">scm_shutdown</strong> <var class="def-var-arguments">(sock, how)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fshutdown"> ¶</a></span></dt>
<dd><p>Sockets can be closed simply by using <code class="code">close-port</code>.  The
<code class="code">shutdown</code> procedure allows reception or transmission on a
connection to be shut down individually, according to the parameter
<var class="var">how</var>:
</p>
<dl class="table">
<dt>0</dt>
<dd><p>Stop receiving data for this socket.  If further data arrives, reject it.
</p></dd>
<dt>1</dt>
<dd><p>Stop trying to transmit data from this socket.  Discard any
data waiting to be sent.  Stop looking for acknowledgement of
data already sent; don’t retransmit it if it is lost.
</p></dd>
<dt>2</dt>
<dd><p>Stop both reception and transmission.
</p></dd>
</dl>

<p>The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-connect"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">connect</strong> <var class="def-var-arguments">sock sockaddr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-connect"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-connect-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">connect</strong> <var class="def-var-arguments">sock AF_INET ipv4addr port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-connect-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-connect-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">connect</strong> <var class="def-var-arguments">sock AF_INET6 ipv6addr port [flowinfo [scopeid]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-connect-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-connect-3"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">connect</strong> <var class="def-var-arguments">sock AF_UNIX path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-connect-3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fconnect"><span class="category-def">C Function: </span><span><strong class="def-name">scm_connect</strong> <var class="def-var-arguments">(sock, fam, address, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fconnect"> ¶</a></span></dt>
<dd><p>Initiate a connection on socket port <var class="var">sock</var> to a given address.  The
destination is either a socket address object, or arguments the same as
<code class="code">make-socket-address</code> would take to make such an object
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>).  Return true unless the socket was
configured as non-blocking and the connection could not be made
immediately.
</p>
<div class="example">
<pre class="example-preformatted">(connect sock AF_INET INADDR_LOOPBACK 23)
(connect sock (make-socket-address AF_INET INADDR_LOOPBACK 23))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-bind"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bind</strong> <var class="def-var-arguments">sock sockaddr</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bind"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bind-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bind</strong> <var class="def-var-arguments">sock AF_INET ipv4addr port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bind-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bind-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bind</strong> <var class="def-var-arguments">sock AF_INET6 ipv6addr port [flowinfo [scopeid]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bind-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-bind-3"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">bind</strong> <var class="def-var-arguments">sock AF_UNIX path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-bind-3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fbind"><span class="category-def">C Function: </span><span><strong class="def-name">scm_bind</strong> <var class="def-var-arguments">(sock, fam, address, args)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fbind"> ¶</a></span></dt>
<dd><p>Bind socket port <var class="var">sock</var> to the given address.  The address is
either a socket address object, or arguments the same as
<code class="code">make-socket-address</code> would take to make such an object
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>).  The return value is unspecified.
</p>
<p>Generally a socket is only explicitly bound to a particular address
when making a server, i.e. to listen on a particular port.  For an
outgoing connection the system will assign a local address
automatically, if not already bound.
</p>
<div class="example">
<pre class="example-preformatted">(bind sock AF_INET INADDR_ANY 12345)
(bind sock (make-socket-address AF_INET INADDR_ANY 12345))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-listen"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">listen</strong> <var class="def-var-arguments">sock backlog</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-listen"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flisten"><span class="category-def">C Function: </span><span><strong class="def-name">scm_listen</strong> <var class="def-var-arguments">(sock, backlog)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flisten"> ¶</a></span></dt>
<dd><p>Enable <var class="var">sock</var> to accept connection
requests.  <var class="var">backlog</var> is an integer specifying
the maximum length of the queue for pending connections.
If the queue fills, new clients will fail to connect until
the server calls <code class="code">accept</code> to accept a connection from
the queue.
</p>
<p>The return value is unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-accept"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">accept</strong> <var class="def-var-arguments">sock [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005faccept"><span class="category-def">C Function: </span><span><strong class="def-name">scm_accept</strong> <var class="def-var-arguments">(sock)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005faccept"> ¶</a></span></dt>
<dd><p>Accept a connection from socket port <var class="var">sock</var> which has been enabled
for listening with <code class="code">listen</code> above.
</p>
<p>If there are no incoming connections in the queue, there are two
possible behaviors, depending on whether <var class="var">sock</var> has been configured
for non-blocking operation or not:
</p>
<ul class="itemize mark-bullet">
<li>If there is no connection waiting and the socket was set to non-blocking
mode with the <code class="code">O_NONBLOCK</code> port option (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports-and-File-Descriptors"><code class="code">fcntl</code></a>), return <code class="code">#f</code> directly.

</li><li>Otherwise wait until a connection is available.
</li></ul>

<p>The return value is a pair.  The <code class="code">car</code> is a new socket port,
connected and ready to communicate.  The <code class="code">cdr</code> is a socket address
object (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>) which is where the remote
connection is from (like <code class="code">getpeername</code> below).
</p>
<p><var class="var">flags</var>, if given, may include <code class="code">SOCK_CLOEXEC</code> or
<code class="code">SOCK_NONBLOCK</code>, which like <code class="code">O_CLOEXEC</code> and <code class="code">O_NONBLOCK</code>
apply to the newly accepted socket.
</p>
<p>All communication takes place using the new socket returned.  The
given <var class="var">sock</var> remains bound and listening, and <code class="code">accept</code> may be
called on it again to get another incoming connection when desired.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getsockname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getsockname</strong> <var class="def-var-arguments">sock</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getsockname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetsockname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getsockname</strong> <var class="def-var-arguments">(sock)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetsockname"> ¶</a></span></dt>
<dd><p>Return a socket address object which is the where <var class="var">sock</var> is bound
locally.  <var class="var">sock</var> may have obtained its local address from
<code class="code">bind</code> (above), or if a <code class="code">connect</code> is done with an otherwise
unbound socket (which is usual) then the system will have assigned an
address.
</p>
<p>Note that on many systems the address of a socket in the
<code class="code">AF_UNIX</code> namespace cannot be read.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-getpeername"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpeername</strong> <var class="def-var-arguments">sock</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpeername"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpeername"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpeername</strong> <var class="def-var-arguments">(sock)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpeername"> ¶</a></span></dt>
<dd><p>Return a socket address object which is where <var class="var">sock</var> is connected
to, i.e. the remote endpoint.
</p>
<p>Note that on many systems the address of a socket in the
<code class="code">AF_UNIX</code> namespace cannot be read.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-recv_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">recv!</strong> <var class="def-var-arguments">sock buf [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-recv_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frecv"><span class="category-def">C Function: </span><span><strong class="def-name">scm_recv</strong> <var class="def-var-arguments">(sock, buf, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frecv"> ¶</a></span></dt>
<dd><p>Receive data from a socket port.
<var class="var">sock</var> must already
be bound to the address from which data is to be received.
<var class="var">buf</var> is a bytevector into which
the data will be written.  The size of <var class="var">buf</var> limits
the amount of
data which can be received: in the case of packet
protocols, if a packet larger than this limit is encountered
then some data
will be irrevocably lost.
</p>
<a class="index-entry-id" id="index-MSG_005fOOB"></a>
<a class="index-entry-id" id="index-MSG_005fPEEK"></a>
<a class="index-entry-id" id="index-MSG_005fDONTROUTE"></a>
<p>The optional <var class="var">flags</var> argument is a value or bitwise OR of
<code class="code">MSG_OOB</code>, <code class="code">MSG_PEEK</code>, <code class="code">MSG_DONTROUTE</code> etc.
</p>
<p>The value returned is the number of bytes read from the
socket.
</p>
<p>Note that the data is read directly from the socket file
descriptor:
any unread buffered port data is ignored.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-send"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">send</strong> <var class="def-var-arguments">sock message [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-send"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsend"><span class="category-def">C Function: </span><span><strong class="def-name">scm_send</strong> <var class="def-var-arguments">(sock, message, flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsend"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-MSG_005fOOB-1"></a>
<a class="index-entry-id" id="index-MSG_005fPEEK-1"></a>
<a class="index-entry-id" id="index-MSG_005fDONTROUTE-1"></a>
<p>Transmit bytevector <var class="var">message</var> on socket port <var class="var">sock</var>.
<var class="var">sock</var> must already be bound to a destination address.  The value
returned is the number of bytes transmitted—it’s possible for this
to be less than the length of <var class="var">message</var> if the socket is set to be
non-blocking.  The optional <var class="var">flags</var> argument is a value or bitwise
OR of <code class="code">MSG_OOB</code>, <code class="code">MSG_PEEK</code>, <code class="code">MSG_DONTROUTE</code> etc.
</p>
<p>Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-recvfrom_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">recvfrom!</strong> <var class="def-var-arguments">sock buf [flags [start [end]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-recvfrom_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005frecvfrom"><span class="category-def">C Function: </span><span><strong class="def-name">scm_recvfrom</strong> <var class="def-var-arguments">(sock, buf, flags, start, end)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005frecvfrom"> ¶</a></span></dt>
<dd><p>Receive data from socket port <var class="var">sock</var>, returning the originating
address as well as the data.  This function is usually for datagram
sockets, but can be used on stream-oriented sockets too.
</p>
<p>The data received is stored in bytevector <var class="var">buf</var>, using
either the whole bytevector or just the region between the optional
<var class="var">start</var> and <var class="var">end</var> positions.  The size of <var class="var">buf</var>
limits the amount of data that can be received.  For datagram
protocols if a packet larger than this is received then excess
bytes are irrevocably lost.
</p>
<p>The return value is a pair.  The <code class="code">car</code> is the number of bytes
read.  The <code class="code">cdr</code> is a socket address object (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>) which is where the data came from, or <code class="code">#f</code> if
the origin is unknown.
</p>
<a class="index-entry-id" id="index-MSG_005fOOB-2"></a>
<a class="index-entry-id" id="index-MSG_005fPEEK-2"></a>
<a class="index-entry-id" id="index-MSG_005fDONTROUTE-2"></a>
<p>The optional <var class="var">flags</var> argument is a or bitwise-OR (<code class="code">logior</code>)
of <code class="code">MSG_OOB</code>, <code class="code">MSG_PEEK</code>, <code class="code">MSG_DONTROUTE</code> etc.
</p>
<p>Data is read directly from the socket file descriptor, any buffered
port data is ignored.
</p>
<p>On a GNU/Linux system <code class="code">recvfrom!</code> is not multi-threading, all
threads stop while a <code class="code">recvfrom!</code> call is in progress.  An
application may need to use <code class="code">select</code>, <code class="code">O_NONBLOCK</code> or
<code class="code">MSG_DONTWAIT</code> to avoid this.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sendto"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sendto</strong> <var class="def-var-arguments">sock message sockaddr [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sendto"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-sendto-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sendto</strong> <var class="def-var-arguments">sock message AF_INET ipv4addr port [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sendto-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-sendto-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sendto</strong> <var class="def-var-arguments">sock message AF_INET6 ipv6addr port [flowinfo [scopeid [flags]]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sendto-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-sendto-3"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sendto</strong> <var class="def-var-arguments">sock message AF_UNIX path [flags]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sendto-3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsendto"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sendto</strong> <var class="def-var-arguments">(sock, message, fam, address, args_and_flags)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsendto"> ¶</a></span></dt>
<dd><p>Transmit bytevector <var class="var">message</var> as a datagram socket port
<var class="var">sock</var>.  The destination is specified either as a socket address
object, or as arguments the same as would be taken by
<code class="code">make-socket-address</code> to create such an object (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Socket-Address">Network Socket Address</a>).
</p>
<p>The destination address may be followed by an optional <var class="var">flags</var>
argument which is a <code class="code">logior</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bitwise-Operations">Bitwise Operations</a>) of
<code class="code">MSG_OOB</code>, <code class="code">MSG_PEEK</code>, <code class="code">MSG_DONTROUTE</code> etc.
</p>
<p>The value returned is the number of bytes transmitted –
it’s possible for
this to be less than the length of <var class="var">message</var> if the
socket is
set to be non-blocking.
Note that the data is written directly to the socket
file descriptor:
any unflushed buffered port data is ignored.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="Internet-Socket-Examples">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication" accesskey="p" rel="prev">Network Sockets and Communication</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="u" rel="up">Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Network-Socket-Examples">7.2.11.5 Network Socket Examples</h4>
<a class="index-entry-id" id="index-network-examples"></a>
<a class="index-entry-id" id="index-socket-examples"></a>

<p>The following give examples of how to use network sockets.
</p>
<h4 class="subsubheading" id="Internet-Socket-Client-Example">Internet Socket Client Example</h4>

<a class="index-entry-id" id="index-socket-client-example"></a>
<p>The following example demonstrates an Internet socket client.
It connects to the HTTP daemon running on the local machine and
returns the contents of the root index URL.
</p>
<div class="example">
<pre class="example-preformatted">(let ((s (socket PF_INET SOCK_STREAM 0)))
  (connect s AF_INET (inet-pton AF_INET "127.0.0.1") 80)
  (display "GET / HTTP/1.0\r\n\r\n" s)

  (do ((line (read-line s) (read-line s)))
      ((eof-object? line))
    (display line)
    (newline)))
</pre></div>


<h4 class="subsubheading" id="Internet-Socket-Server-Example">Internet Socket Server Example</h4>

<a class="index-entry-id" id="index-socket-server-example"></a>
<p>The following example shows a simple Internet server which listens on
port 2904 for incoming connections and sends a greeting back to the
client.
</p>
<div class="example">
<pre class="example-preformatted">(let ((s (socket PF_INET SOCK_STREAM 0)))
  (setsockopt s SOL_SOCKET SO_REUSEADDR 1)
  ;; <span class="r">Specific address?</span>
  ;; <span class="r">(bind s AF_INET (inet-pton AF_INET "127.0.0.1") 2904)</span>
  (bind s AF_INET INADDR_ANY 2904)
  (listen s 5)

  (simple-format #t "Listening for clients in pid: ~S" (getpid))
  (newline)

  (while #t
    (let* ((client-connection (accept s))
           (client-details (cdr client-connection))
           (client (car client-connection)))
      (simple-format #t "Got new client connection: ~S"
                     client-details)
      (newline)
      (simple-format #t "Client address: ~S"
                     (gethostbyaddr
                      (sockaddr:addr client-details)))
      (newline)
      ;; <span class="r">Send back the greeting to the client port</span>
      (display "Hello client\r\n" client)
      (close client))))
</pre></div>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="System-Identification">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Locales" accesskey="n" rel="next">Locales</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Networking" accesskey="p" rel="prev">Networking</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="System-Identification-1">7.2.12 System Identification</h4>
<a class="index-entry-id" id="index-system-name"></a>

<p>This section lists the various procedures Guile provides for accessing
information about the system it runs on.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-uname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uname</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005funame"><span class="category-def">C Function: </span><span><strong class="def-name">scm_uname</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005funame"> ¶</a></span></dt>
<dd><p>Return an object with some information about the computer
system the program is running on.
</p>
<p>The following procedures accept an object as returned by <code class="code">uname</code>
and return a selected component (all of which are strings).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-utsname_003asysname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utsname:sysname</strong> <var class="def-var-arguments">un</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utsname_003asysname"> ¶</a></span></dt>
<dd><p>The name of the operating system.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-utsname_003anodename"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utsname:nodename</strong> <var class="def-var-arguments">un</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utsname_003anodename"> ¶</a></span></dt>
<dd><p>The network name of the computer.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-utsname_003arelease"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utsname:release</strong> <var class="def-var-arguments">un</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utsname_003arelease"> ¶</a></span></dt>
<dd><p>The current release level of the operating system implementation.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-utsname_003aversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utsname:version</strong> <var class="def-var-arguments">un</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utsname_003aversion"> ¶</a></span></dt>
<dd><p>The current version level within the release of the operating system.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-utsname_003amachine"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">utsname:machine</strong> <var class="def-var-arguments">un</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-utsname_003amachine"> ¶</a></span></dt>
<dd><p>A description of the hardware.
</p></dd></dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-gethostname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">gethostname</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-gethostname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgethostname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_gethostname</strong> <var class="def-var-arguments">()</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgethostname"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-host-name"></a>
<p>Return the host name of the current processor.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sethostname"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sethostname</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sethostname"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsethostname"><span class="category-def">C Function: </span><span><strong class="def-name">scm_sethostname</strong> <var class="def-var-arguments">(name)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsethostname"> ¶</a></span></dt>
<dd><p>Set the host name of the current processor to <var class="var">name</var>. May
only be used by the superuser.  The return value is not
specified.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Locales">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Encryption" accesskey="n" rel="next">Encryption</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#System-Identification" accesskey="p" rel="prev">System Identification</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Locales-1">7.2.13 Locales</h4>
<a class="index-entry-id" id="index-locale-2"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-setlocale"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">setlocale</strong> <var class="def-var-arguments">category [locale]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-setlocale"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fsetlocale"><span class="category-def">C Function: </span><span><strong class="def-name">scm_setlocale</strong> <var class="def-var-arguments">(category, locale)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fsetlocale"> ¶</a></span></dt>
<dd><p>Get or set the current locale, used for various internationalizations.
Locales are strings, such as ‘<samp class="samp">sv_SE</samp>’.
</p>
<p>If <var class="var">locale</var> is given then the locale for the given <var class="var">category</var>
is set and the new value returned.  If <var class="var">locale</var> is not given then
the current value is returned.  <var class="var">category</var> should be one of the
following values (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Locale-Categories">Categories of Activities
that Locales Affect</a> in <cite class="cite">The GNU C Library Reference Manual</cite>):
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-LC_005fALL"><span class="category-def">Variable: </span><span><strong class="def-name">LC_ALL</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fALL"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fCOLLATE"><span class="category-def">Variable: </span><span><strong class="def-name">LC_COLLATE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fCOLLATE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fCTYPE"><span class="category-def">Variable: </span><span><strong class="def-name">LC_CTYPE</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fCTYPE"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fMESSAGES"><span class="category-def">Variable: </span><span><strong class="def-name">LC_MESSAGES</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fMESSAGES"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fMONETARY"><span class="category-def">Variable: </span><span><strong class="def-name">LC_MONETARY</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fMONETARY"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fNUMERIC"><span class="category-def">Variable: </span><span><strong class="def-name">LC_NUMERIC</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fNUMERIC"> ¶</a></span></dt>
<dt class="defvrx defvarx-alias-defvrx def-cmd-defvr" id="index-LC_005fTIME"><span class="category-def">Variable: </span><span><strong class="def-name">LC_TIME</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-LC_005fTIME"> ¶</a></span></dt>
</dl>

<a class="index-entry-id" id="index-LANG"></a>
<p>A common usage is ‘<samp class="samp">(setlocale LC_ALL "")</samp>’, which initializes all
categories based on standard environment variables (<code class="code">LANG</code> etc).
For full details on categories and locale names see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Locales">Locales and Internationalization</a> in <cite class="cite">The GNU C Library Reference
Manual</cite>.
</p>
<p>Note that <code class="code">setlocale</code> affects locale settings for the whole
process.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#i18n-Introduction">locale objects and
<code class="code">make-locale</code></a>, for a thread-safe alternative.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Encryption">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Locales" accesskey="p" rel="prev">Locales</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="u" rel="up"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Encryption-1">7.2.14 Encryption</h4>
<a class="index-entry-id" id="index-encryption"></a>

<p>Please note that the procedures in this section are not suited for
strong encryption, they are only interfaces to the well-known and
common system library functions of the same name.  They are just as good
(or bad) as the underlying functions, so you should refer to your system
documentation before using them (see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#crypt">Encrypting Passwords</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-crypt"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">crypt</strong> <var class="def-var-arguments">key salt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-crypt"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fcrypt"><span class="category-def">C Function: </span><span><strong class="def-name">scm_crypt</strong> <var class="def-var-arguments">(key, salt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fcrypt"> ¶</a></span></dt>
<dd><p>Encrypt <var class="var">key</var>, with the addition of <var class="var">salt</var> (both strings),
using the <code class="code">crypt</code> C library call.
</p></dd></dl>

<p>Although <code class="code">getpass</code> is not an encryption procedure per se, it
appears here because it is often used in combination with <code class="code">crypt</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-getpass"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getpass</strong> <var class="def-var-arguments">prompt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getpass"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fgetpass"><span class="category-def">C Function: </span><span><strong class="def-name">scm_getpass</strong> <var class="def-var-arguments">(prompt)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fgetpass"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-password"></a>
<p>Display <var class="var">prompt</var> to the standard error output and read
a password from <samp class="file">/dev/tty</samp>.  If this file is not
accessible, it reads from standard input.  The password may be
up to 127 characters in length.  Additional characters and the
terminating newline character are discarded.  While reading
the password, echoing and the generation of signals by special
characters is disabled.
</p></dd></dl>



<hr>
</div>
</div>
<div class="section-level-extent" id="Web">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="n" rel="next">The (ice-9 getopt-long) Module</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#POSIX" accesskey="p" rel="prev"><abbr class="acronym">POSIX</abbr> System Calls and Networking</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="u" rel="up">Guile Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="HTTP_002c-the-Web_002c-and-All-That">7.3 <abbr class="acronym">HTTP</abbr>, the Web, and All That</h3>
<a class="index-entry-id" id="index-Web"></a>
<a class="index-entry-id" id="index-WWW"></a>
<a class="index-entry-id" id="index-HTTP"></a>

<p>It has always been possible to connect computers together and share
information between them, but the rise of the World Wide Web over the
last couple of decades has made it much easier to do so.  The result is
a richly connected network of computation, in which Guile forms a part.
</p>
<p>By “the web”, we mean the HTTP protocol<a class="footnote" id="DOCF25" href="https://www.gnu.org/software/guile/manual/guile.html#FOOT25"><sup>25</sup></a> as handled by
servers, clients, proxies, caches, and the various kinds of messages and
message components that can be sent and received by that protocol,
notably HTML.
</p>
<p>On one level, the web is text in motion: the protocols themselves are
textual (though the payload may be binary), and it’s possible to create
a socket and speak text to the web.  But such an approach is obviously
primitive.  This section details the higher-level data types and
operations provided by Guile: URIs, HTTP request and response records,
and a conventional web server implementation.
</p>
<p>The material in this section is arranged in ascending order, in which
later concepts build on previous ones.  If you prefer to start with the
highest-level perspective, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Examples">Web Examples</a>, and work your way
back.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Types-and-the-Web" accesskey="1">Types and the Web</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#URIs" accesskey="2">Universal Resource Identifiers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP" accesskey="3">The Hyper-Text Transfer Protocol</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers" accesskey="4">HTTP Headers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Transfer-Codings" accesskey="5">Transfer Codings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Requests" accesskey="6">HTTP Requests</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Responses" accesskey="7">HTTP Responses</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Client" accesskey="8">Web Client</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server" accesskey="9">Web Server</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Examples">Web Examples</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="Types-and-the-Web">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#URIs" accesskey="n" rel="next">Universal Resource Identifiers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Types-and-the-Web-1">7.3.1 Types and the Web</h4>

<p>It is a truth universally acknowledged, that a program with good use of
data types, will be free from many common bugs.  Unfortunately, the
common practice in web programming seems to ignore this maxim.  This
subsection makes the case for expressive data types in web programming.
</p>
<p>By “expressive data types”, we mean that the data types <em class="emph">say</em>
something about how a program solves a problem.  For example, if we
choose to represent dates using SRFI 19 date records (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19">SRFI-19 - Time/Date Library</a>),
this indicates that there is a part of the program that will always have
valid dates.  Error handling for a number of basic cases, like invalid
dates, occurs on the boundary in which we produce a SRFI 19 date record
from other types, like strings.
</p>
<p>With regards to the web, data types are helpful in the two broad phases
of HTTP messages: parsing and generation.
</p>
<p>Consider a server, which has to parse a request, and produce a response.
Guile will parse the request into an HTTP request object
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Requests">HTTP Requests</a>), with each header parsed into an appropriate Scheme
data type.  This transition from an incoming stream of characters to
typed data is a state change in a program—the strings might parse, or
they might not, and something has to happen if they do not.  (Guile
throws an error in this case.)  But after you have the parsed request,
“client” code (code built on top of the Guile web framework) will not
have to check for syntactic validity.  The types already make this
information manifest.
</p>
<p>This state change on the parsing boundary makes programs more robust,
as they themselves are freed from the need to do a number of common
error checks, and they can use normal Scheme procedures to handle a
request instead of ad-hoc string parsers.
</p>
<p>The need for types on the response generation side (in a server) is more
subtle, though not less important.  Consider the example of a POST
handler, which prints out the text that a user submits from a form.
Such a handler might include a procedure like this:
</p>
<div class="example">
<pre class="example-preformatted">;; First, a helper procedure
(define (para . contents)
  (string-append "&lt;p&gt;" (string-concatenate contents) "&lt;/p&gt;"))

;; Now the meat of our simple web application
(define (you-said text)
  (para "You said: " text))

(display (you-said "Hi!"))
-| &lt;p&gt;You said: Hi!&lt;/p&gt;
</pre></div>

<p>This is a perfectly valid implementation, provided that the incoming
text does not contain the special HTML characters ‘<samp class="samp">&lt;</samp>’, ‘<samp class="samp">&gt;</samp>’, or
‘<samp class="samp">&amp;</samp>’.  But this provision of a restricted character set is not
reflected anywhere in the program itself: we must <em class="emph">assume</em> that the
programmer understands this, and performs the check elsewhere.
</p>
<p>Unfortunately, the short history of the practice of programming does not
bear out this assumption.  A <em class="dfn">cross-site scripting</em> (<abbr class="acronym">XSS</abbr>)
vulnerability is just such a common error in which unfiltered user input
is allowed into the output.  A user could submit a crafted comment to
your web site which results in visitors running malicious Javascript,
within the security context of your domain:
</p>
<div class="example">
<pre class="example-preformatted">(display (you-said "&lt;script src=\"http://bad.com/nasty.js\" /&gt;"))
-| &lt;p&gt;You said: &lt;script src="http://bad.com/nasty.js" /&gt;&lt;/p&gt;
</pre></div>

<p>The fundamental problem here is that both user data and the program
template are represented using strings.  This identity means that types
can’t help the programmer to make a distinction between these two, so
they get confused.
</p>
<p>There are a number of possible solutions, but perhaps the best is to
treat HTML not as strings, but as native s-expressions: as SXML.  The
basic idea is that HTML is either text, represented by a string, or an
element, represented as a tagged list.  So ‘<samp class="samp">foo</samp>’ becomes
‘<samp class="samp">"foo"</samp>’, and ‘<samp class="samp">&lt;b&gt;foo&lt;/b&gt;</samp>’ becomes ‘<samp class="samp">(b "foo")</samp>’.
Attributes, if present, go in a tagged list headed by ‘<samp class="samp">@</samp>’, like
‘<samp class="samp">(img (@ (src "http://example.com/foo.png")))</samp>’.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#SXML">SXML</a>, for
more information.
</p>
<p>The good thing about SXML is that HTML elements cannot be confused with
text.  Let’s make a new definition of <code class="code">para</code>:
</p>
<div class="example">
<pre class="example-preformatted">(define (para . contents)
  `(p ,@contents))

(use-modules (sxml simple))
(sxml-&gt;xml (you-said "Hi!"))
-| &lt;p&gt;You said: Hi!&lt;/p&gt;

(sxml-&gt;xml (you-said "&lt;i&gt;Rats, foiled again!&lt;/i&gt;"))
-| &lt;p&gt;You said: &amp;lt;i&amp;gt;Rats, foiled again!&amp;lt;/i&amp;gt;&lt;/p&gt;
</pre></div>

<p>So we see in the second example that HTML elements cannot be unwittingly
introduced into the output.  However it is now perfectly acceptable to
pass SXML to <code class="code">you-said</code>; in fact, that is the big advantage of SXML
over everything-as-a-string.
</p>
<div class="example">
<pre class="example-preformatted">(sxml-&gt;xml (you-said (you-said "&lt;Hi!&gt;")))
-| &lt;p&gt;You said: &lt;p&gt;You said: &amp;lt;Hi!&amp;gt;&lt;/p&gt;&lt;/p&gt;
</pre></div>

<p>The SXML types allow procedures to <em class="emph">compose</em>.  The types make
manifest which parts are HTML elements, and which are text.  So you
needn’t worry about escaping user input; the type transition back to a
string handles that for you.  <abbr class="acronym">XSS</abbr> vulnerabilities are a thing
of the past.
</p>
<p>Well.  That’s all very nice and opinionated and such, but how do I use
the thing?  Read on!
</p>
<hr>
</div>
<div class="subsection-level-extent" id="URIs">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP" accesskey="n" rel="next">The Hyper-Text Transfer Protocol</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Types-and-the-Web" accesskey="p" rel="prev">Types and the Web</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Universal-Resource-Identifiers">7.3.2 Universal Resource Identifiers</h4>

<p>Guile provides a standard data type for Universal Resource Identifiers
(URIs), as defined in RFC 3986.
</p>
<p>The generic URI syntax is as follows:
</p>
<div class="example">
<pre class="example-preformatted">URI-reference := [scheme ":"] ["//" [userinfo "@"] host [":" port]] path \
                 [ "?" query ] [ "#" fragment ]
</pre></div>

<p>For example, in the URI, ‘<code class="indicateurl">http://www.gnu.org/help/</code>’, the
scheme is <code class="code">http</code>, the host is <code class="code">www.gnu.org</code>, the path is
<code class="code">/help/</code>, and there is no userinfo, port, query, or fragment.
</p>
<p>Userinfo is something of an abstraction, as some legacy URI schemes
allowed userinfo of the form <code class="code"><var class="var">username</var>:<var class="var">passwd</var></code>.  But
since passwords do not belong in URIs, the RFC does not want to condone
this practice, so it calls anything before the <code class="code">@</code> sign
<em class="dfn">userinfo</em>.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web uri))
</pre></div>

<p>The following procedures can be found in the <code class="code">(web uri)</code>
module. Load it into your Guile, using a form like the above, to have
access to them.
</p>
<p>The most common way to build a URI from Scheme is with the
<code class="code">build-uri</code> function.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-build_002duri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">build-uri</strong> <var class="def-var-arguments">scheme        [#:userinfo=<code class="code">#f</code>] [#:host=<code class="code">#f</code>] [#:port=<code class="code">#f</code>]        [#:path=<code class="code">""</code>] [#:query=<code class="code">#f</code>] [#:fragment=<code class="code">#f</code>]        [#:validate?=<code class="code">#t</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-build_002duri"> ¶</a></span></dt>
<dd><p>Construct a URI.  <var class="var">scheme</var> should be a symbol, <var class="var">port</var> either a
positive, exact integer or <code class="code">#f</code>, and the rest of the fields are
either strings or <code class="code">#f</code>.  If <var class="var">validate?</var> is true, also run some
consistency checks to make sure that the constructed URI is valid.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-uri_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a URI.
</p></dd></dl>

<p>Guile, URIs are represented as URI records, with a number of associated
accessors.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-uri_002dscheme"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-scheme</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dscheme"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002duserinfo"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-userinfo</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002duserinfo"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002dhost"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-host</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dhost"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-port</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dport"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-path</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dpath"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002dquery"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-query</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dquery"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-uri_002dfragment"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-fragment</strong> <var class="def-var-arguments">uri</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dfragment"> ¶</a></span></dt>
<dd><p>Field accessors for the URI record type.  The URI scheme will be a
symbol, or <code class="code">#f</code> if the object is a relative-ref (see below).  The
port will be either a positive, exact integer or <code class="code">#f</code>, and the rest
of the fields will be either strings or <code class="code">#f</code> if not present.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003euri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;uri</strong> <var class="def-var-arguments">string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003euri"> ¶</a></span></dt>
<dd><p>Parse <var class="var">string</var> into a URI object.  Return <code class="code">#f</code> if the string
could not be parsed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-uri_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-&gt;string</strong> <var class="def-var-arguments">uri [#:include-fragment?=<code class="code">#t</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002d_003estring"> ¶</a></span></dt>
<dd><p>Serialize <var class="var">uri</var> to a string.  If the URI has a port that is the
default port for its scheme, the port is not included in the
serialization.  If <var class="var">include-fragment?</var> is given as false, the
resulting string will omit the fragment (if any).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-declare_002ddefault_002dport_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">declare-default-port!</strong> <var class="def-var-arguments">scheme port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-declare_002ddefault_002dport_0021"> ¶</a></span></dt>
<dd><p>Declare a default port for the given URI scheme.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-uri_002ddecode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-decode</strong> <var class="def-var-arguments">str [#:encoding=<code class="code">"utf-8"</code>] [#:decode-plus-to-space? #t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002ddecode"> ¶</a></span></dt>
<dd><p>Percent-decode the given <var class="var">str</var>, according to <var class="var">encoding</var>, which
should be the name of a character encoding.
</p>
<p>Note that this function should not generally be applied to a full URI
string. For paths, use <code class="code">split-and-decode-uri-path</code> instead. For
query strings, split the query on <code class="code">&amp;</code> and <code class="code">=</code> boundaries, and
decode the components separately.
</p>
<p>Note also that percent-encoded strings encode <em class="emph">bytes</em>, not
characters.  There is no guarantee that a given byte sequence is a valid
string encoding. Therefore this routine may signal an error if the
decoded bytes are not valid for the given encoding. Pass <code class="code">#f</code> for
<var class="var">encoding</var> if you want decoded bytes as a bytevector directly.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Ports"><code class="code">set-port-encoding!</code></a>, for more information on
character encodings.
</p>
<p>If <var class="var">decode-plus-to-space?</var> is true, which is the default, also
replace instances of the plus character ‘<samp class="samp">+</samp>’ with a space character.
This is needed when parsing <code class="code">application/x-www-form-urlencoded</code>
data.
</p>
<p>Returns a string of the decoded characters, or a bytevector if
<var class="var">encoding</var> was <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-uri_002dencode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-encode</strong> <var class="def-var-arguments">str [#:encoding=<code class="code">"utf-8"</code>] [#:unescaped-chars]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dencode"> ¶</a></span></dt>
<dd><p>Percent-encode any character not in the character set,
<var class="var">unescaped-chars</var>.
</p>
<p>The default character set includes alphanumerics from ASCII, as well as
the special characters ‘<samp class="samp">-</samp>’, ‘<samp class="samp">.</samp>’, ‘<samp class="samp">_</samp>’, and ‘<samp class="samp">~</samp>’.  Any
other character will be percent-encoded, by writing out the character to
a bytevector within the given <var class="var">encoding</var>, then encoding each byte as
<code class="code">%<var class="var">HH</var></code>, where <var class="var">HH</var> is the hexadecimal representation of
the byte.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-split_002dand_002ddecode_002duri_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">split-and-decode-uri-path</strong> <var class="def-var-arguments">path</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-split_002dand_002ddecode_002duri_002dpath"> ¶</a></span></dt>
<dd><p>Split <var class="var">path</var> into its components, and decode each component,
removing empty components.
</p>
<p>For example, <code class="code">"/foo/bar%20baz/"</code> decodes to the two-element list,
<code class="code">("foo" "bar baz")</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-encode_002dand_002djoin_002duri_002dpath"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">encode-and-join-uri-path</strong> <var class="def-var-arguments">parts</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-encode_002dand_002djoin_002duri_002dpath"> ¶</a></span></dt>
<dd><p>URI-encode each element of <var class="var">parts</var>, which should be a list of
strings, and join the parts together with <code class="code">/</code> as a delimiter.
</p>
<p>For example, the list <code class="code">("scrambled eggs" "biscuits&amp;gravy")</code> encodes
as <code class="code">"scrambled%20eggs/biscuits%26gravy"</code>.
</p></dd></dl>

<h4 class="subsubheading" id="Subtypes-of-URI">Subtypes of URI</h4>

<p>As we noted above, not all URI objects have a scheme.  You might have
noted in the “generic URI syntax” example that the left-hand side of
that grammar definition was URI-reference, not URI.  A
<em class="dfn">URI-reference</em> is a generalization of a URI where the scheme is
optional.  If no scheme is specified, it is taken to be relative to some
other related URI.  A common use of URI references is when you want to
be vague regarding the choice of HTTP or HTTPS – serving a web page
referring to <code class="code">/foo.css</code> will use HTTPS if loaded over HTTPS, or
HTTP otherwise.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-build_002duri_002dreference"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">build-uri-reference</strong> <var class="def-var-arguments">[#:scheme=<code class="code">#f</code>]       [#:userinfo=<code class="code">#f</code>] [#:host=<code class="code">#f</code>] [#:port=<code class="code">#f</code>]        [#:path=<code class="code">""</code>] [#:query=<code class="code">#f</code>] [#:fragment=<code class="code">#f</code>]        [#:validate?=<code class="code">#t</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-build_002duri_002dreference"> ¶</a></span></dt>
<dd><p>Like <code class="code">build-uri</code>, but with an optional scheme.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-uri_002dreference_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">uri-reference?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uri_002dreference_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a URI-reference.  This is the most
general URI predicate, as it includes not only full URIs that have
schemes (those that match <code class="code">uri?</code>) but also URIs without schemes.
</p></dd></dl>

<p>It’s also possible to build a <em class="dfn">relative-ref</em>: a URI-reference that
explicitly lacks a scheme.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-build_002drelative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">build-relative-ref</strong> <var class="def-var-arguments">[#:userinfo=<code class="code">#f</code>] [#:host=<code class="code">#f</code>] [#:port=<code class="code">#f</code>]        [#:path=<code class="code">""</code>] [#:query=<code class="code">#f</code>] [#:fragment=<code class="code">#f</code>]        [#:validate?=<code class="code">#t</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-build_002drelative_002dref"> ¶</a></span></dt>
<dd><p>Like <code class="code">build-uri</code>, but with no scheme.
</p></dd></dl>
<dl class="first-deffn">
<dt class="deffn" id="index-relative_002dref_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">relative-ref?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-relative_002dref_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a “relative-ref”: a URI-reference
that has no scheme.  Every URI-reference will either match <code class="code">uri?</code>
or <code class="code">relative-ref?</code> (but not both).
</p></dd></dl>

<p>In case it’s not clear from the above, the most general of these URI
types is the URI-reference, with <code class="code">build-uri-reference</code> as the most
general constructor.  <code class="code">build-uri</code> and <code class="code">build-relative-ref</code>
enforce enforce specific restrictions on the URI-reference.  The most
generic URI parser is then <code class="code">string-&gt;uri-reference</code>, and there is
also a parser for when you know that you want a relative-ref.
</p>
<p>Note that <code class="code">uri?</code> will only return <code class="code">#t</code> for URI objects that
have schemes; that is, it rejects relative-refs.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003euri_002dreference"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;uri-reference</strong> <var class="def-var-arguments">string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003euri_002dreference"> ¶</a></span></dt>
<dd><p>Parse <var class="var">string</var> into a URI object, while not requiring a scheme.
Return <code class="code">#f</code> if the string could not be parsed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003erelative_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;relative-ref</strong> <var class="def-var-arguments">string</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003erelative_002dref"> ¶</a></span></dt>
<dd><p>Parse <var class="var">string</var> into a URI object, while asserting that no scheme is
present.  Return <code class="code">#f</code> if the string could not be parsed.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="HTTP">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers" accesskey="n" rel="next">HTTP Headers</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#URIs" accesskey="p" rel="prev">Universal Resource Identifiers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="The-Hyper_002dText-Transfer-Protocol">7.3.3 The Hyper-Text Transfer Protocol</h4>

<p>The initial motivation for including web functionality in Guile, rather
than rely on an external package, was to establish a standard base on
which people can share code.  To that end, we continue the focus on data
types by providing a number of low-level parsers and unparsers for
elements of the HTTP protocol.
</p>
<p>If you are want to skip the low-level details for now and move on to web
pages, see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Client">Web Client</a>, and see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server">Web Server</a>.  Otherwise, load the
HTTP module, and read on.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web http))
</pre></div>

<p>The focus of the <code class="code">(web http)</code> module is to parse and unparse
standard HTTP headers, representing them to Guile as native data
structures.  For example, a <code class="code">Date:</code> header will be represented as a
SRFI-19 date record (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19">SRFI-19 - Time/Date Library</a>), rather than as a string.
</p>
<p>Guile tries to follow RFCs fairly strictly—the road to perdition being
paved with compatibility hacks—though some allowances are made for
not-too-divergent texts.
</p>
<p>Header names are represented as lower-case symbols.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-string_002d_003eheader"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">string-&gt;header</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003eheader"> ¶</a></span></dt>
<dd><p>Parse <var class="var">name</var> to a symbolic header name.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-header_002d_003estring"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">header-&gt;string</strong> <var class="def-var-arguments">sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-header_002d_003estring"> ¶</a></span></dt>
<dd><p>Return the string form for the header named <var class="var">sym</var>.
</p></dd></dl>

<p>For example:
</p>
<div class="example">
<pre class="example-preformatted">(string-&gt;header "Content-Length")
⇒ content-length
(header-&gt;string 'content-length)
⇒ "Content-Length"

(string-&gt;header "FOO")
⇒ foo
(header-&gt;string 'foo)
⇒ "Foo"
</pre></div>

<p>Guile keeps a registry of known headers, their string names, and some
parsing and serialization procedures.  If a header is unknown, its
string name is simply its symbol name in title-case.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-known_002dheader_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">known-header?</strong> <var class="def-var-arguments">sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-known_002dheader_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">sym</var> is a known header, with associated
parsers and serialization procedures, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-header_002dparser"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">header-parser</strong> <var class="def-var-arguments">sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-header_002dparser"> ¶</a></span></dt>
<dd><p>Return the value parser for headers named <var class="var">sym</var>.  The result is a
procedure that takes one argument, a string, and returns the parsed
value.  If the header isn’t known to Guile, a default parser is returned
that passes through the string unchanged.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-header_002dvalidator"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">header-validator</strong> <var class="def-var-arguments">sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-header_002dvalidator"> ¶</a></span></dt>
<dd><p>Return a predicate which returns <code class="code">#t</code> if the given value is valid
for headers named <var class="var">sym</var>.  The default validator for unknown headers
is <code class="code">string?</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-header_002dwriter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">header-writer</strong> <var class="def-var-arguments">sym</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-header_002dwriter"> ¶</a></span></dt>
<dd><p>Return a procedure that writes values for headers named <var class="var">sym</var> to a
port.  The resulting procedure takes two arguments: a value and a port.
The default writer is <code class="code">display</code>.
</p></dd></dl>

<p>For more on the set of headers that Guile knows about out of the box,
see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers">HTTP Headers</a>.  To add your own, use the <code class="code">declare-header!</code>
procedure:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-declare_002dheader_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">declare-header!</strong> <var class="def-var-arguments">name parser validator writer        [#:multiple?=<code class="code">#f</code>]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-declare_002dheader_0021"> ¶</a></span></dt>
<dd><p>Declare a parser, validator, and writer for a given header.
</p></dd></dl>

<p>For example, let’s say you are running a web server behind some sort of
proxy, and your proxy adds an <code class="code">X-Client-Address</code> header, indicating
the IPv4 address of the original client.  You would like for the HTTP
request record to parse out this header to a Scheme value, instead of
leaving it as a string.  You could register this header with Guile’s
HTTP stack like this:
</p>
<div class="example">
<pre class="example-preformatted">(declare-header! "X-Client-Address"
  (lambda (str)
    (inet-pton AF_INET str))
  (lambda (ip)
    (and (integer? ip) (exact? ip) (&lt;= 0 ip #xffffffff)))
  (lambda (ip port)
    (display (inet-ntop AF_INET ip) port)))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-declare_002dopaque_002dheader_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">declare-opaque-header!</strong> <var class="def-var-arguments">name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-declare_002dopaque_002dheader_0021"> ¶</a></span></dt>
<dd><p>A specialised version of <code class="code">declare-header!</code> for the case in which
you want a header’s value to be returned/written “as-is”.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-valid_002dheader_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">valid-header?</strong> <var class="def-var-arguments">sym val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-valid_002dheader_003f"> ¶</a></span></dt>
<dd><p>Return a true value if <var class="var">val</var> is a valid Scheme value for the header
with name <var class="var">sym</var>, or <code class="code">#f</code> otherwise.
</p></dd></dl>

<p>Now that we have a generic interface for reading and writing headers, we
do just that.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-read_002dheader"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-header</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dheader"> ¶</a></span></dt>
<dd><p>Read one HTTP header from <var class="var">port</var>. Return two values: the header
name and the parsed Scheme value. May raise an exception if the header
was known but the value was invalid.
</p>
<p>Returns the end-of-file object for both values if the end of the message
body was reached (i.e., a blank line).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dheader"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-header</strong> <var class="def-var-arguments">name val</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dheader"> ¶</a></span></dt>
<dd><p>Parse <var class="var">val</var>, a string, with the parser for the header named
<var class="var">name</var>.  Returns the parsed value.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dheader"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-header</strong> <var class="def-var-arguments">name val port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dheader"> ¶</a></span></dt>
<dd><p>Write the given header name and value to <var class="var">port</var>, using the writer
from <code class="code">header-writer</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dheaders"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-headers</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dheaders"> ¶</a></span></dt>
<dd><p>Read the headers of an HTTP message from <var class="var">port</var>, returning them
as an ordered alist.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dheaders"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-headers</strong> <var class="def-var-arguments">headers port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dheaders"> ¶</a></span></dt>
<dd><p>Write the given header alist to <var class="var">port</var>. Doesn’t write the final
‘<samp class="samp">\r\n</samp>’, as the user might want to add another header.
</p></dd></dl>

<p>The <code class="code">(web http)</code> module also has some utility procedures to read
and write request and response lines.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dhttp_002dmethod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-http-method</strong> <var class="def-var-arguments">str [start] [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dhttp_002dmethod"> ¶</a></span></dt>
<dd><p>Parse an HTTP method from <var class="var">str</var>. The result is an upper-case symbol,
like <code class="code">GET</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parse_002dhttp_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-http-version</strong> <var class="def-var-arguments">str [start] [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002dhttp_002dversion"> ¶</a></span></dt>
<dd><p>Parse an HTTP version from <var class="var">str</var>, returning it as a major–minor
pair. For example, <code class="code">HTTP/1.1</code> parses as the pair of integers,
<code class="code">(1 . 1)</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-parse_002drequest_002duri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">parse-request-uri</strong> <var class="def-var-arguments">str [start] [end]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-parse_002drequest_002duri"> ¶</a></span></dt>
<dd><p>Parse a URI from an HTTP request line. Note that URIs in requests do not
have to have a scheme or host name. The result is a URI object.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002drequest_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-request-line</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002drequest_002dline"> ¶</a></span></dt>
<dd><p>Read the first line of an HTTP request from <var class="var">port</var>, returning three
values: the method, the URI, and the version.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002drequest_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-request-line</strong> <var class="def-var-arguments">method uri version port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002drequest_002dline"> ¶</a></span></dt>
<dd><p>Write the first line of an HTTP request to <var class="var">port</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dresponse_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-response-line</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dresponse_002dline"> ¶</a></span></dt>
<dd><p>Read the first line of an HTTP response from <var class="var">port</var>, returning three
values: the HTTP version, the response code, and the “reason phrase”.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dresponse_002dline"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-response-line</strong> <var class="def-var-arguments">version code reason-phrase port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dresponse_002dline"> ¶</a></span></dt>
<dd><p>Write the first line of an HTTP response to <var class="var">port</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="HTTP-Headers">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Transfer-Codings" accesskey="n" rel="next">Transfer Codings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP" accesskey="p" rel="prev">The Hyper-Text Transfer Protocol</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="HTTP-Headers-1">7.3.4 HTTP Headers</h4>

<p>In addition to defining the infrastructure to parse headers, the
<code class="code">(web http)</code> module defines specific parsers and unparsers for all
headers defined in the HTTP/1.1 standard.
</p>
<p>For example, if you receive a header named ‘<samp class="samp">Accept-Language</samp>’ with a
value ‘<samp class="samp">en, es;q=0.8</samp>’, Guile parses it as a quality list (defined
below):
</p>
<div class="example">
<pre class="example-preformatted">(parse-header 'accept-language "en, es;q=0.8")
⇒ ((1000 . "en") (800 . "es"))
</pre></div>

<p>The format of the value for ‘<samp class="samp">Accept-Language</samp>’ headers is defined
below, along with all other headers defined in the HTTP standard.  (If
the header were unknown, the value would have been returned as a
string.)
</p>
<p>For brevity, the header definitions below are given in the form,
<var class="var">Type</var> <code class="code"><var class="var">name</var></code>, indicating that values for the header
<code class="code"><var class="var">name</var></code> will be of the given <var class="var">Type</var>.  Since Guile
internally treats header names in lower case, in this document we give
types title-cased names.  A short description of the each header’s
purpose and an example follow.
</p>
<p>For full details on the meanings of all of these headers, see the HTTP
1.1 standard, RFC 2616.
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Header-Types" accesskey="1">HTTP Header Types</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#General-Headers" accesskey="2">General Headers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Entity-Headers" accesskey="3">Entity Headers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Request-Headers" accesskey="4">Request Headers</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Response-Headers" accesskey="5">Response Headers</a></li>
</ul>
<div class="subsubsection-level-extent" id="HTTP-Header-Types">
<h4 class="subsubsection">7.3.4.1 HTTP Header Types</h4>

<p>Here we define the types that are used below, when defining headers.
</p>
<dl class="first-deftp">
<dt class="deftp" id="index-Date"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">Date</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-Date"> ¶</a></span></dt>
<dd><p>A SRFI-19 date.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-KVList"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">KVList</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-KVList"> ¶</a></span></dt>
<dd><p>A list whose elements are keys or key-value pairs.  Keys are parsed to
symbols.  Values are strings by default.  Non-string values are the
exception, and are mentioned explicitly below, as appropriate.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-SList"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">SList</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-SList"> ¶</a></span></dt>
<dd><p>A list of strings.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-Quality"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">Quality</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-Quality"> ¶</a></span></dt>
<dd><p>An exact integer between 0 and 1000.  Qualities are used to express
preference, given multiple options.  An option with a quality of 870,
for example, is preferred over an option with quality 500.
</p>
<p>(Qualities are written out over the wire as numbers between 0.0 and
1.0, but since the standard only allows three digits after the decimal,
it’s equivalent to integers between 0 and 1000, so that’s what Guile
uses.)
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-QList"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">QList</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-QList"> ¶</a></span></dt>
<dd><p>A quality list: a list of pairs, the car of which is a quality, and the
cdr a string.  Used to express a list of options, along with their
qualities.
</p></dd></dl>

<dl class="first-deftp">
<dt class="deftp" id="index-ETag"><span class="category-def">HTTP Header Type: </span><span><strong class="def-name">ETag</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ETag"> ¶</a></span></dt>
<dd><p>An entity tag, represented as a pair.  The car of the pair is an opaque
string, and the cdr is <code class="code">#t</code> if the entity tag is a “strong” entity
tag, and <code class="code">#f</code> otherwise.
</p></dd></dl>

</div>
<div class="subsubsection-level-extent" id="General-Headers">
<h4 class="subsubsection">7.3.4.2 General Headers</h4>

<p>General HTTP headers may be present in any HTTP message.
</p>
<dl class="first-deftypevr">
<dt class="deftypevr" id="index-cache_002dcontrol"><span class="category-def">HTTP Header: </span><span><code class="def-type">KVList</code> <strong class="def-name">cache-control</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cache_002dcontrol"> ¶</a></span></dt>
<dd><p>A key-value list of cache-control directives.  See RFC 2616, for more
details.
</p>
<p>If present, parameters to <code class="code">max-age</code>, <code class="code">max-stale</code>,
<code class="code">min-fresh</code>, and <code class="code">s-maxage</code> are all parsed as non-negative
integers.
</p>
<p>If present, parameters to <code class="code">private</code> and <code class="code">no-cache</code> are parsed
as lists of header names, as symbols.
</p>
<div class="example">
<pre class="example-preformatted">(parse-header 'cache-control "no-cache,no-store"
⇒ (no-cache no-store)
(parse-header 'cache-control "no-cache=\"Authorization,Date\",no-store"
⇒ ((no-cache . (authorization date)) no-store)
(parse-header 'cache-control "no-cache=\"Authorization,Date\",max-age=10"
⇒ ((no-cache . (authorization date)) (max-age . 10))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-connection"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">connection</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-connection"> ¶</a></span></dt>
<dd><p>A list of header names that apply only to this HTTP connection, as
symbols.  Additionally, the symbol ‘<samp class="samp">close</samp>’ may be present, to
indicate that the server should close the connection after responding to
the request.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'connection "close")
⇒ (close)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-date-2"><span class="category-def">HTTP Header: </span><span><code class="def-type">Date</code> <strong class="def-name">date</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date-2"> ¶</a></span></dt>
<dd><p>The date that a given HTTP message was originated.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'date "Tue, 15 Nov 1994 08:12:31 GMT")
⇒ #&lt;date ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-pragma"><span class="category-def">HTTP Header: </span><span><code class="def-type">KVList</code> <strong class="def-name">pragma</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pragma"> ¶</a></span></dt>
<dd><p>A key-value list of implementation-specific directives.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'pragma "no-cache, broccoli=tasty")
⇒ (no-cache (broccoli . "tasty"))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-trailer"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">trailer</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-trailer"> ¶</a></span></dt>
<dd><p>A list of header names which will appear after the message body, instead
of with the message headers.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'trailer "ETag")
⇒ (etag)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-transfer_002dencoding"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">transfer-encoding</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-transfer_002dencoding"> ¶</a></span></dt>
<dd><p>A list of transfer codings, expressed as key-value lists.  The only
transfer coding defined by the specification is <code class="code">chunked</code>.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'transfer-encoding "chunked")
⇒ ((chunked))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-upgrade"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">upgrade</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-upgrade"> ¶</a></span></dt>
<dd><p>A list of strings, indicating additional protocols that a server could use
in response to a request.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'upgrade "WebSocket")
⇒ ("WebSocket")
</pre></div>
</dd></dl>

<p>FIXME: parse out more fully?
</p><dl class="first-deftypevr">
<dt class="deftypevr" id="index-via"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">via</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-via"> ¶</a></span></dt>
<dd><p>A list of strings, indicating the protocol versions and hosts of
intermediate servers and proxies.  There may be multiple <code class="code">via</code>
headers in one message.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'via "1.0 venus, 1.1 mars")
⇒ ("1.0 venus" "1.1 mars")
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-warning"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">warning</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-warning"> ¶</a></span></dt>
<dd><p>A list of warnings given by a server or intermediate proxy.  Each
warning is a itself a list of four elements: a code, as an exact integer
between 0 and 1000, a host as a string, the warning text as a string,
and either <code class="code">#f</code> or a SRFI-19 date.
</p>
<p>There may be multiple <code class="code">warning</code> headers in one message.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'warning "123 foo \"core breach imminent\"")
⇒ ((123 "foo" "core-breach imminent" #f))
</pre></div>
</dd></dl>


</div>
<div class="subsubsection-level-extent" id="Entity-Headers">
<h4 class="subsubsection">7.3.4.3 Entity Headers</h4>

<p>Entity headers may be present in any HTTP message, and refer to the
resource referenced in the HTTP request or response.
</p>
<dl class="first-deftypevr">
<dt class="deftypevr" id="index-allow"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">allow</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-allow"> ¶</a></span></dt>
<dd><p>A list of allowed methods on a given resource, as symbols.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'allow "GET, HEAD")
⇒ (GET HEAD)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dencoding"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">content-encoding</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dencoding"> ¶</a></span></dt>
<dd><p>A list of content codings, as symbols.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-encoding "gzip")
⇒ (gzip)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dlanguage"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">content-language</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dlanguage"> ¶</a></span></dt>
<dd><p>The languages that a resource is in, as strings.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-language "en")
⇒ ("en")
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dlength"><span class="category-def">HTTP Header: </span><span><code class="def-type">UInt</code> <strong class="def-name">content-length</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dlength"> ¶</a></span></dt>
<dd><p>The number of bytes in a resource, as an exact, non-negative integer.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-length "300")
⇒ 300
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dlocation"><span class="category-def">HTTP Header: </span><span><code class="def-type">URI</code> <strong class="def-name">content-location</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dlocation"> ¶</a></span></dt>
<dd><p>The canonical URI for a resource, in the case that it is also accessible
from a different URI.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-location "http://example.com/foo")
⇒ #&lt;&lt;uri&gt; ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dmd5"><span class="category-def">HTTP Header: </span><span><code class="def-type">String</code> <strong class="def-name">content-md5</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dmd5"> ¶</a></span></dt>
<dd><p>The MD5 digest of a resource.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-md5 "ffaea1a79810785575e29e2bd45e2fa5")
⇒ "ffaea1a79810785575e29e2bd45e2fa5"
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002drange"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">content-range</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002drange"> ¶</a></span></dt>
<dd><p>Range specification as a list of three elements: the symbol
<code class="code">bytes</code>, either the symbol <code class="code">*</code> or a pair of integers
indicating the byte range, and either <code class="code">*</code> or an integer indicating
the instance length.  Used to indicate that a response only includes
part of a resource.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-range "bytes 10-20/*")
⇒ (bytes (10 . 20) *)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-content_002dtype"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">content-type</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-content_002dtype"> ¶</a></span></dt>
<dd><p>The MIME type of a resource, as a symbol, along with any parameters.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'content-type "text/plain")
⇒ (text/plain)
(parse-header 'content-type "text/plain;charset=utf-8")
⇒ (text/plain (charset . "utf-8"))
</pre></div>
<p>Note that the <code class="code">charset</code> parameter is something of a misnomer, and
the HTTP specification admits this.  It specifies the <em class="emph">encoding</em> of
the characters, not the character set.
</p></dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-expires"><span class="category-def">HTTP Header: </span><span><code class="def-type">Date</code> <strong class="def-name">expires</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-expires"> ¶</a></span></dt>
<dd><p>The date/time after which the resource given in a response is considered
stale.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'expires "Tue, 15 Nov 1994 08:12:31 GMT")
⇒ #&lt;date ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-last_002dmodified"><span class="category-def">HTTP Header: </span><span><code class="def-type">Date</code> <strong class="def-name">last-modified</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-last_002dmodified"> ¶</a></span></dt>
<dd><p>The date/time on which the resource given in a response was last
modified.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'expires "Tue, 15 Nov 1994 08:12:31 GMT")
⇒ #&lt;date ...&gt;
</pre></div>
</dd></dl>


</div>
<div class="subsubsection-level-extent" id="Request-Headers">
<h4 class="subsubsection">7.3.4.4 Request Headers</h4>

<p>Request headers may only appear in an HTTP request, not in a response.
</p>
<dl class="first-deftypevr">
<dt class="deftypevr" id="index-accept-1"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">accept</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept-1"> ¶</a></span></dt>
<dd><p>A list of preferred media types for a response.  Each element of the
list is itself a list, in the same format as <code class="code">content-type</code>.  
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept "text/html,text/plain;charset=utf-8")
⇒ ((text/html) (text/plain (charset . "utf-8")))
</pre></div>
<p>Preference is expressed with quality values:
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept "text/html;q=0.8,text/plain;q=0.6")
⇒ ((text/html (q . 800)) (text/plain (q . 600)))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-accept_002dcharset"><span class="category-def">HTTP Header: </span><span><code class="def-type">QList</code> <strong class="def-name">accept-charset</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept_002dcharset"> ¶</a></span></dt>
<dd><p>A quality list of acceptable charsets.  Note again that what HTTP calls
a “charset” is what Guile calls a “character encoding”.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept-charset "iso-8859-5, unicode-1-1;q=0.8")
⇒ ((1000 . "iso-8859-5") (800 . "unicode-1-1"))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-accept_002dencoding"><span class="category-def">HTTP Header: </span><span><code class="def-type">QList</code> <strong class="def-name">accept-encoding</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept_002dencoding"> ¶</a></span></dt>
<dd><p>A quality list of acceptable content codings.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept-encoding "gzip,identity=0.8")
⇒ ((1000 . "gzip") (800 . "identity"))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-accept_002dlanguage"><span class="category-def">HTTP Header: </span><span><code class="def-type">QList</code> <strong class="def-name">accept-language</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept_002dlanguage"> ¶</a></span></dt>
<dd><p>A quality list of acceptable languages.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept-language "cn,en=0.75")
⇒ ((1000 . "cn") (750 . "en"))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-authorization"><span class="category-def">HTTP Header: </span><span><code class="def-type">Pair</code> <strong class="def-name">authorization</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-authorization"> ¶</a></span></dt>
<dd><p>Authorization credentials.  The car of the pair indicates the
authentication scheme, like <code class="code">basic</code>.  For basic authentication, the
cdr of the pair will be the base64-encoded ‘<samp class="samp"><var class="var">user</var>:<var class="var">pass</var></samp>’
string.  For other authentication schemes, like <code class="code">digest</code>, the cdr
will be a key-value list of credentials.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'authorization "Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ=="
⇒ (basic . "QWxhZGRpbjpvcGVuIHNlc2FtZQ==")
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-expect-1"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">expect</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-expect-1"> ¶</a></span></dt>
<dd><p>A list of expectations that a client has of a server.  The expectations
are key-value lists.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'expect "100-continue")
⇒ ((100-continue))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-from"><span class="category-def">HTTP Header: </span><span><code class="def-type">String</code> <strong class="def-name">from</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-from"> ¶</a></span></dt>
<dd><p>The email address of a user making an HTTP request.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'from "bob@example.com")
⇒ "bob@example.com"
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-host"><span class="category-def">HTTP Header: </span><span><code class="def-type">Pair</code> <strong class="def-name">host</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-host"> ¶</a></span></dt>
<dd><p>The host for the resource being requested, as a hostname-port pair.  If
no port is given, the port is <code class="code">#f</code>.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'host "gnu.org:80")
⇒ ("gnu.org" . 80)
(parse-header 'host "gnu.org")
⇒ ("gnu.org" . #f)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-if_002dmatch"><span class="category-def">HTTP Header: </span><span><code class="def-type">*|List</code> <strong class="def-name">if-match</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if_002dmatch"> ¶</a></span></dt>
<dd><p>A set of etags, indicating that the request should proceed if and only
if the etag of the resource is in that set.  Either the symbol <code class="code">*</code>,
indicating any etag, or a list of entity tags.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'if-match "*")
⇒ *
(parse-header 'if-match "asdfadf")
⇒ (("asdfadf" . #t))
(parse-header 'if-match W/"asdfadf")
⇒ (("asdfadf" . #f))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-if_002dmodified_002dsince"><span class="category-def">HTTP Header: </span><span><code class="def-type">Date</code> <strong class="def-name">if-modified-since</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if_002dmodified_002dsince"> ¶</a></span></dt>
<dd><p>Indicates that a response should proceed if and only if the resource has
been modified since the given date.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'if-modified-since "Tue, 15 Nov 1994 08:12:31 GMT")
⇒ #&lt;date ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-if_002dnone_002dmatch"><span class="category-def">HTTP Header: </span><span><code class="def-type">*|List</code> <strong class="def-name">if-none-match</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if_002dnone_002dmatch"> ¶</a></span></dt>
<dd><p>A set of etags, indicating that the request should proceed if and only
if the etag of the resource is not in the set.  Either the symbol
<code class="code">*</code>, indicating any etag, or a list of entity tags.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'if-none-match "*")
⇒ *
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-if_002drange"><span class="category-def">HTTP Header: </span><span><code class="def-type">ETag|Date</code> <strong class="def-name">if-range</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if_002drange"> ¶</a></span></dt>
<dd><p>Indicates that the range request should proceed if and only if the
resource matches a modification date or an etag.  Either an entity tag,
or a SRFI-19 date.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'if-range "\"original-etag\"")
⇒ ("original-etag" . #t)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-if_002dunmodified_002dsince"><span class="category-def">HTTP Header: </span><span><code class="def-type">Date</code> <strong class="def-name">if-unmodified-since</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-if_002dunmodified_002dsince"> ¶</a></span></dt>
<dd><p>Indicates that a response should proceed if and only if the resource has
not been modified since the given date.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'if-not-modified-since "Tue, 15 Nov 1994 08:12:31 GMT")
⇒ #&lt;date ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-max_002dforwards"><span class="category-def">HTTP Header: </span><span><code class="def-type">UInt</code> <strong class="def-name">max-forwards</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-max_002dforwards"> ¶</a></span></dt>
<dd><p>The maximum number of proxy or gateway hops that a request should be
subject to.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'max-forwards "10")
⇒ 10
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-proxy_002dauthorization"><span class="category-def">HTTP Header: </span><span><code class="def-type">Pair</code> <strong class="def-name">proxy-authorization</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-proxy_002dauthorization"> ¶</a></span></dt>
<dd><p>Authorization credentials for a proxy connection.  See the documentation
for <code class="code">authorization</code> above for more information on the format.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'proxy-authorization "Digest foo=bar,baz=qux"
⇒ (digest (foo . "bar") (baz . "qux"))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-range"><span class="category-def">HTTP Header: </span><span><code class="def-type">Pair</code> <strong class="def-name">range</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-range"> ¶</a></span></dt>
<dd><p>A range request, indicating that the client wants only part of a
resource.  The car of the pair is the symbol <code class="code">bytes</code>, and the cdr
is a list of pairs. Each element of the cdr indicates a range; the car
is the first byte position and the cdr is the last byte position, as
integers, or <code class="code">#f</code> if not given.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'range "bytes=10-30,50-")
⇒ (bytes (10 . 30) (50 . #f))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-referer"><span class="category-def">HTTP Header: </span><span><code class="def-type">URI</code> <strong class="def-name">referer</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-referer"> ¶</a></span></dt>
<dd><p>The URI of the resource that referred the user to this resource.  The
name of the header is a misspelling, but we are stuck with it.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'referer "http://www.gnu.org/")
⇒ #&lt;uri ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-te"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">te</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-te"> ¶</a></span></dt>
<dd><p>A list of transfer codings, expressed as key-value lists.  A common
transfer coding is <code class="code">trailers</code>.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'te "trailers")
⇒ ((trailers))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-user_002dagent"><span class="category-def">HTTP Header: </span><span><code class="def-type">String</code> <strong class="def-name">user-agent</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-user_002dagent"> ¶</a></span></dt>
<dd><p>A string indicating the user agent making the request.  The
specification defines a structured format for this header, but it is
widely disregarded, so Guile does not attempt to parse strictly.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'user-agent "Mozilla/5.0")
⇒ "Mozilla/5.0"
</pre></div>
</dd></dl>


</div>
<div class="subsubsection-level-extent" id="Response-Headers">
<h4 class="subsubsection">7.3.4.5 Response Headers</h4>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-accept_002dranges"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">accept-ranges</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-accept_002dranges"> ¶</a></span></dt>
<dd><p>A list of range units that the server supports, as symbols.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'accept-ranges "bytes")
⇒ (bytes)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-age"><span class="category-def">HTTP Header: </span><span><code class="def-type">UInt</code> <strong class="def-name">age</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-age"> ¶</a></span></dt>
<dd><p>The age of a cached response, in seconds.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'age "3600")
⇒ 3600
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-etag"><span class="category-def">HTTP Header: </span><span><code class="def-type">ETag</code> <strong class="def-name">etag</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-etag"> ¶</a></span></dt>
<dd><p>The entity-tag of the resource.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'etag "\"foo\"")
⇒ ("foo" . #t)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-location-1"><span class="category-def">HTTP Header: </span><span><code class="def-type">URI-reference</code> <strong class="def-name">location</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-location-1"> ¶</a></span></dt>
<dd><p>A URI reference on which a request may be completed.  Used in
combination with a redirecting status code to perform client-side
redirection.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'location "http://example.com/other")
⇒ #&lt;uri ...&gt;
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-proxy_002dauthenticate"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">proxy-authenticate</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-proxy_002dauthenticate"> ¶</a></span></dt>
<dd><p>A list of challenges to a proxy, indicating the need for authentication.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'proxy-authenticate "Basic realm=\"foo\"")
⇒ ((basic (realm . "foo")))
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-retry_002dafter"><span class="category-def">HTTP Header: </span><span><code class="def-type">UInt|Date</code> <strong class="def-name">retry-after</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-retry_002dafter"> ¶</a></span></dt>
<dd><p>Used in combination with a server-busy status code, like 503, to
indicate that a client should retry later.  Either a number of seconds,
or a date.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'retry-after "60")
⇒ 60
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-server"><span class="category-def">HTTP Header: </span><span><code class="def-type">String</code> <strong class="def-name">server</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-server"> ¶</a></span></dt>
<dd><p>A string identifying the server.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'server "My first web server")
⇒ "My first web server"
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-vary"><span class="category-def">HTTP Header: </span><span><code class="def-type">*|List</code> <strong class="def-name">vary</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-vary"> ¶</a></span></dt>
<dd><p>A set of request headers that were used in computing this response.
Used to indicate that server-side content negotiation was performed, for
example in response to the <code class="code">accept-language</code> header.  Can also be
the symbol <code class="code">*</code>, indicating that all headers were considered.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'vary "Accept-Language, Accept")
⇒ (accept-language accept)
</pre></div>
</dd></dl>

<dl class="first-deftypevr">
<dt class="deftypevr" id="index-www_002dauthenticate"><span class="category-def">HTTP Header: </span><span><code class="def-type">List</code> <strong class="def-name">www-authenticate</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-www_002dauthenticate"> ¶</a></span></dt>
<dd><p>A list of challenges to a user, indicating the need for authentication.
</p><div class="example">
<pre class="example-preformatted">(parse-header 'www-authenticate "Basic realm=\"foo\"")
⇒ ((basic (realm . "foo")))
</pre></div>
</dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Transfer-Codings">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Requests" accesskey="n" rel="next">HTTP Requests</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers" accesskey="p" rel="prev">HTTP Headers</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Transfer-Codings-1">7.3.5 Transfer Codings</h4>

<p>HTTP 1.1 allows for various transfer codings to be applied to message
bodies. These include various types of compression, and HTTP chunked
encoding. Currently, only chunked encoding is supported by guile.
</p>
<p>Chunked coding is an optional coding that may be applied to message
bodies, to allow messages whose length is not known beforehand to be
returned. Such messages can be split into chunks, terminated by a final
zero length chunk.
</p>
<p>In order to make dealing with encodings more simple, guile provides
procedures to create ports that “wrap” existing ports, applying
transformations transparently under the hood.
</p>
<p>These procedures are in the <code class="code">(web http)</code> module.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web http))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dchunked_002dinput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-chunked-input-port</strong> <var class="def-var-arguments">port [#:keep-alive?=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dchunked_002dinput_002dport"> ¶</a></span></dt>
<dd><p>Returns a new port, that transparently reads and decodes chunk-encoded
data from <var class="var">port</var>. If no more chunk-encoded data is available, it
returns the end-of-file object. When the port is closed, <var class="var">port</var> will
also be closed, unless <var class="var">keep-alive?</var> is true.
</p>
<p>If the chunked input ends prematurely, a
<code class="code">&amp;chunked-input-ended-promaturely</code> exception will be raised.
</p></dd></dl>

<div class="example">
<pre class="example-preformatted">(use-modules (ice-9 rdelim))

(define s "5\r\nFirst\r\nA\r\n line\n Sec\r\n8\r\nond line\r\n0\r\n")
(define p (make-chunked-input-port (open-input-string s)))
(read-line s)
⇒ "First line"
(read-line s)
⇒ "Second line"
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dchunked_002doutput_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-chunked-output-port</strong> <var class="def-var-arguments">port [#:keep-alive?=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dchunked_002doutput_002dport"> ¶</a></span></dt>
<dd><p>Returns a new port, which transparently encodes data as chunk-encoded
before writing it to <var class="var">port</var>. Whenever a write occurs on this port,
it buffers it, until the port is flushed, at which point it writes a
chunk containing all the data written so far. When the port is closed,
the data remaining is written to <var class="var">port</var>, as is the terminating zero
chunk. It also causes <var class="var">port</var> to be closed, unless <var class="var">keep-alive?</var>
is true.
</p>
<p>Note. Forcing a chunked output port when there is no data is buffered
does not write a zero chunk, as this would cause the data to be
interpreted incorrectly by the client.
</p></dd></dl>

<div class="example">
<pre class="example-preformatted">(call-with-output-string
  (lambda (out)
    (define out* (make-chunked-output-port out #:keep-alive? #t))
    (display "first chunk" out*)
    (force-output out*)
    (force-output out*) ; note this does not write a zero chunk
    (display "second chunk" out*)
    (close-port out*)))
⇒ "b\r\nfirst chunk\r\nc\r\nsecond chunk\r\n0\r\n"
</pre></div>

<hr>
</div>
<div class="subsection-level-extent" id="Requests">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Responses" accesskey="n" rel="next">HTTP Responses</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Transfer-Codings" accesskey="p" rel="prev">Transfer Codings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="HTTP-Requests">7.3.6 HTTP Requests</h4>

<div class="example">
<pre class="example-preformatted">(use-modules (web request))
</pre></div>

<p>The request module contains a data type for HTTP requests.  
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#An-Important-Note-on-Character-Sets" accesskey="1">An Important Note on Character Sets</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Request-API" accesskey="2">Request API</a></li>
</ul>
<div class="subsubsection-level-extent" id="An-Important-Note-on-Character-Sets">
<h4 class="subsubsection">7.3.6.1 An Important Note on Character Sets</h4>

<p>HTTP requests consist of two parts: the request proper, consisting of a
request line and a set of headers, and (optionally) a body.  The body
might have a binary content-type, and even in the textual case its
length is specified in bytes, not characters.
</p>
<p>Therefore, HTTP is a fundamentally binary protocol.  However the request
line and headers are specified to be in a subset of ASCII, so they can
be treated as text, provided that the port’s encoding is set to an
ASCII-compatible one-byte-per-character encoding.  ISO-8859-1 (latin-1)
is just such an encoding, and happens to be very efficient for Guile.
</p>
<p>So what Guile does when reading requests from the wire, or writing them
out, is to set the port’s encoding to latin-1, and treating the request
headers as text.
</p>
<p>The request body is another issue.  For binary data, the data is
probably in a bytevector, so we use the R6RS binary output procedures to
write out the binary payload.  Textual data usually has to be written
out to some character encoding, usually UTF-8, and then the resulting
bytevector is written out to the port.
</p>
<p>In summary, Guile reads and writes HTTP over latin-1 sockets, without
any loss of generality.
</p>
</div>
<div class="subsubsection-level-extent" id="Request-API">
<h4 class="subsubsection">7.3.6.2 Request API</h4>

<dl class="first-deffn">
<dt class="deffn" id="index-request_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dmethod"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-method</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dmethod"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002duri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-uri</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002duri"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-version</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dheaders"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-headers</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dheaders"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dmeta"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-meta</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dmeta"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-port</strong> <var class="def-var-arguments">request</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dport"> ¶</a></span></dt>
<dd><p>A predicate and field accessors for the request type.  The fields are as
follows:
</p><dl class="table">
<dt><code class="code">method</code></dt>
<dd><p>The HTTP method, for example, <code class="code">GET</code>.
</p></dd>
<dt><code class="code">uri</code></dt>
<dd><p>The URI as a URI record.
</p></dd>
<dt><code class="code">version</code></dt>
<dd><p>The HTTP version pair, like <code class="code">(1 . 1)</code>.
</p></dd>
<dt><code class="code">headers</code></dt>
<dd><p>The request headers, as an alist of parsed values.
</p></dd>
<dt><code class="code">meta</code></dt>
<dd><p>An arbitrary alist of other data, for example information returned in
the <code class="code">sockaddr</code> from <code class="code">accept</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Network-Sockets-and-Communication">Network Sockets and Communication</a>).
</p></dd>
<dt><code class="code">port</code></dt>
<dd><p>The port on which to read or write a request body, if any.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002drequest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-request</strong> <var class="def-var-arguments">port [meta=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002drequest"> ¶</a></span></dt>
<dd><p>Read an HTTP request from <var class="var">port</var>, optionally attaching the given
metadata, <var class="var">meta</var>.
</p>
<p>As a side effect, sets the encoding on <var class="var">port</var> to ISO-8859-1
(latin-1), so that reading one character reads one byte. See the
discussion of character sets above, for more information.
</p>
<p>Note that the body is not part of the request.  Once you have read a
request, you may read the body separately, and likewise for writing
requests.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-build_002drequest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">build-request</strong> <var class="def-var-arguments">uri [#:method=’GET]        [#:version=’(1 . 1)] [#:headers=’()] [#:port=#f] [#:meta=’()]        [#:validate-headers?=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-build_002drequest"> ¶</a></span></dt>
<dd><p>Construct an HTTP request object. If <var class="var">validate-headers?</var> is true,
the headers are each run through their respective validators.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002drequest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-request</strong> <var class="def-var-arguments">r port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002drequest"> ¶</a></span></dt>
<dd><p>Write the given HTTP request to <var class="var">port</var>.
</p>
<p>Return a new request, whose <code class="code">request-port</code> will continue writing
on <var class="var">port</var>, perhaps using some transfer encoding.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002drequest_002dbody"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-request-body</strong> <var class="def-var-arguments">r</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002drequest_002dbody"> ¶</a></span></dt>
<dd><p>Reads the request body from <var class="var">r</var>, as a bytevector.  Return <code class="code">#f</code>
if there was no request body.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002drequest_002dbody"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-request-body</strong> <var class="def-var-arguments">r bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002drequest_002dbody"> ¶</a></span></dt>
<dd><p>Write <var class="var">bv</var>, a bytevector, to the port corresponding to the HTTP
request <var class="var">r</var>.
</p></dd></dl>

<p>The various headers that are typically associated with HTTP requests may
be accessed with these dedicated accessors.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers">HTTP Headers</a>, for
more information on the format of parsed headers.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-request_002daccept"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-accept</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002daccept"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002daccept_002dcharset"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-accept-charset</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002daccept_002dcharset"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002daccept_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-accept-encoding</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002daccept_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002daccept_002dlanguage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-accept-language</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002daccept_002dlanguage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dallow"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-allow</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dallow"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dauthorization"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-authorization</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dauthorization"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcache_002dcontrol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-cache-control</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcache_002dcontrol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dconnection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-connection</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dconnection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-encoding</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dlanguage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-language</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dlanguage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-length</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dlocation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-location</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dlocation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dmd5"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-md5</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dmd5"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002drange"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-range</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002drange"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dcontent_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-content-type</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dcontent_002dtype"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002ddate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-date</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002ddate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dexpect"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-expect</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dexpect"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dexpires"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-expires</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dexpires"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dfrom"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-from</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dfrom"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dhost"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-host</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dhost"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dif_002dmatch"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-if-match</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dif_002dmatch"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dif_002dmodified_002dsince"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-if-modified-since</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dif_002dmodified_002dsince"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dif_002dnone_002dmatch"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-if-none-match</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dif_002dnone_002dmatch"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dif_002drange"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-if-range</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dif_002drange"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dif_002dunmodified_002dsince"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-if-unmodified-since</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dif_002dunmodified_002dsince"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dlast_002dmodified"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-last-modified</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dlast_002dmodified"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dmax_002dforwards"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-max-forwards</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dmax_002dforwards"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dpragma"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-pragma</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dpragma"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dproxy_002dauthorization"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-proxy-authorization</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dproxy_002dauthorization"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002drange"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-range</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002drange"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dreferer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-referer</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dreferer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dte"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-te</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dte"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dtrailer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-trailer</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dtrailer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dtransfer_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-transfer-encoding</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dtransfer_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dupgrade"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-upgrade</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dupgrade"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002duser_002dagent"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-user-agent</strong> <var class="def-var-arguments">request [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002duser_002dagent"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dvia"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-via</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dvia"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-request_002dwarning"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-warning</strong> <var class="def-var-arguments">request [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dwarning"> ¶</a></span></dt>
<dd><p>Return the given request header, or <var class="var">default</var> if none was present.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-request_002dabsolute_002duri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">request-absolute-uri</strong> <var class="def-var-arguments">r [default-host=#f]        [default-port=#f] [default-scheme=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-request_002dabsolute_002duri"> ¶</a></span></dt>
<dd><p>A helper routine to determine the absolute URI of a request, using the
<code class="code">host</code> header and the default scheme, host and port.  If there is
no default scheme and the URI is not itself absolute, an error is
signalled.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="Responses">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Client" accesskey="n" rel="next">Web Client</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Requests" accesskey="p" rel="prev">HTTP Requests</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="HTTP-Responses">7.3.7 HTTP Responses</h4>

<div class="example">
<pre class="example-preformatted">(use-modules (web response))
</pre></div>

<p>As with requests (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Requests">HTTP Requests</a>), Guile offers a data type for HTTP
responses.  Again, the body is represented separately from the request.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-response_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-version</strong> <var class="def-var-arguments">response</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dversion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcode"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-code</strong> <var class="def-var-arguments">response</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcode"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dreason_002dphrase"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-reason-phrase</strong> <var class="def-var-arguments">response</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dreason_002dphrase"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dheaders"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-headers</strong> <var class="def-var-arguments">response</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dheaders"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-port</strong> <var class="def-var-arguments">response</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dport"> ¶</a></span></dt>
<dd><p>A predicate and field accessors for the response type.  The fields are as
follows:
</p><dl class="table">
<dt><code class="code">version</code></dt>
<dd><p>The HTTP version pair, like <code class="code">(1 . 1)</code>.
</p></dd>
<dt><code class="code">code</code></dt>
<dd><p>The HTTP response code, like <code class="code">200</code>.
</p></dd>
<dt><code class="code">reason-phrase</code></dt>
<dd><p>The reason phrase, or the standard reason phrase for the response’s
code.
</p></dd>
<dt><code class="code">headers</code></dt>
<dd><p>The response headers, as an alist of parsed values.
</p></dd>
<dt><code class="code">port</code></dt>
<dd><p>The port on which to read or write a response body, if any.
</p></dd>
</dl>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dresponse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-response</strong> <var class="def-var-arguments">port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dresponse"> ¶</a></span></dt>
<dd><p>Read an HTTP response from <var class="var">port</var>.
</p>
<p>As a side effect, sets the encoding on <var class="var">port</var> to ISO-8859-1
(latin-1), so that reading one character reads one byte. See the
discussion of character sets in <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Responses">HTTP Responses</a>, for more information.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-build_002dresponse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">build-response</strong> <var class="def-var-arguments">[#:version=’(1 . 1)] [#:code=200] [#:reason-phrase=#f] [#:headers=’()] [#:port=#f] [#:validate-headers?=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-build_002dresponse"> ¶</a></span></dt>
<dd><p>Construct an HTTP response object. If <var class="var">validate-headers?</var> is true,
the headers are each run through their respective validators.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-adapt_002dresponse_002dversion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">adapt-response-version</strong> <var class="def-var-arguments">response version</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-adapt_002dresponse_002dversion"> ¶</a></span></dt>
<dd><p>Adapt the given response to a different HTTP version.  Return a new HTTP
response.
</p>
<p>The idea is that many applications might just build a response for the
default HTTP version, and this method could handle a number of
programmatic transformations to respond to older HTTP versions (0.9 and
1.0). But currently this function is a bit heavy-handed, just updating
the version field.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dresponse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-response</strong> <var class="def-var-arguments">r port</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dresponse"> ¶</a></span></dt>
<dd><p>Write the given HTTP response to <var class="var">port</var>.
</p>
<p>Return a new response, whose <code class="code">response-port</code> will continue writing
on <var class="var">port</var>, perhaps using some transfer encoding.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-response_002dmust_002dnot_002dinclude_002dbody_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-must-not-include-body?</strong> <var class="def-var-arguments">r</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dmust_002dnot_002dinclude_002dbody_003f"> ¶</a></span></dt>
<dd><p>Some responses, like those with status code 304, are specified as never
having bodies.  This predicate returns <code class="code">#t</code> for those responses.
</p>
<p>Note also, though, that responses to <code class="code">HEAD</code> requests must also not
have a body.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-response_002dbody_002dport"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-body-port</strong> <var class="def-var-arguments">r [#:decode?=#t] [#:keep-alive?=#t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dbody_002dport"> ¶</a></span></dt>
<dd><p>Return an input port from which the body of <var class="var">r</var> can be read.  The encoding
of the returned port is set according to <var class="var">r</var>’s <code class="code">content-type</code> header,
when it’s textual, except if <var class="var">decode?</var> is <code class="code">#f</code>.  Return <code class="code">#f</code>
when no body is available.
</p>
<p>When <var class="var">keep-alive?</var> is <code class="code">#f</code>, closing the returned port also closes
<var class="var">r</var>’s response port.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dresponse_002dbody"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-response-body</strong> <var class="def-var-arguments">r</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dresponse_002dbody"> ¶</a></span></dt>
<dd><p>Read the response body from <var class="var">r</var>, as a bytevector.  Returns <code class="code">#f</code>
if there was no response body.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dresponse_002dbody"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-response-body</strong> <var class="def-var-arguments">r bv</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dresponse_002dbody"> ¶</a></span></dt>
<dd><p>Write <var class="var">bv</var>, a bytevector, to the port corresponding to the HTTP
response <var class="var">r</var>.
</p></dd></dl>

<p>As with requests, the various headers that are typically associated with
HTTP responses may be accessed with these dedicated accessors.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#HTTP-Headers">HTTP Headers</a>, for more information on the format of parsed
headers.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-response_002daccept_002dranges"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-accept-ranges</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002daccept_002dranges"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-age</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dallow"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-allow</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dallow"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcache_002dcontrol"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-cache-control</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcache_002dcontrol"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dconnection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-connection</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dconnection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-encoding</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dlanguage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-language</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dlanguage"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-length</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dlocation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-location</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dlocation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dmd5"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-md5</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dmd5"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002drange"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-range</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002drange"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dcontent_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-content-type</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dcontent_002dtype"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002ddate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-date</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002ddate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002detag"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-etag</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002detag"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dexpires"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-expires</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dexpires"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dlast_002dmodified"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-last-modified</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dlast_002dmodified"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dlocation"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-location</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dlocation"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dpragma"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-pragma</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dpragma"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dproxy_002dauthenticate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-proxy-authenticate</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dproxy_002dauthenticate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dretry_002dafter"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-retry-after</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dretry_002dafter"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-server</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dserver"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dtrailer"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-trailer</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dtrailer"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dtransfer_002dencoding"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-transfer-encoding</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dtransfer_002dencoding"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dupgrade"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-upgrade</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dupgrade"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dvary"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-vary</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dvary"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dvia"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-via</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dvia"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dwarning"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-warning</strong> <var class="def-var-arguments">response [default=’()]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dwarning"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-response_002dwww_002dauthenticate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">response-www-authenticate</strong> <var class="def-var-arguments">response [default=#f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-response_002dwww_002dauthenticate"> ¶</a></span></dt>
<dd><p>Return the given response header, or <var class="var">default</var> if none was present.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-text_002dcontent_002dtype_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">text-content-type?</strong> <var class="def-var-arguments"><var class="var">type</var></var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-text_002dcontent_002dtype_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">type</var>, a symbol as returned by
<code class="code">response-content-type</code>, represents a textual type such as
<code class="code">text/plain</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Web-Client">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server" accesskey="n" rel="next">Web Server</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Responses" accesskey="p" rel="prev">HTTP Responses</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Web-Client-1">7.3.8 Web Client</h4>

<p><code class="code">(web client)</code> provides a simple, synchronous HTTP client, built on
the lower-level HTTP, request, and response modules.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web client))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-open_002dsocket_002dfor_002duri"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-socket-for-uri</strong> <var class="def-var-arguments">uri [#:verify-certificate? #t]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dsocket_002dfor_002duri"> ¶</a></span></dt>
<dd><p>Return an open input/output port for a connection to URI.  Guile
dynamically loads Guile-GnuTLS for HTTPS support.
</p>
<p>See the <a class="uref" href="https://gitlab.com/gnutls/guile/">Web site of Guile-GnuTLS</a>, and
see <a data-manual="gnutls-guile" href="https://www.gnu.org/software/guile/manual/gnutls-guile.html#Guile-Preparations">how to install the GnuTLS bindings for Guile</a> in <cite class="cite">GnuTLS-Guile</cite>, for more information.
</p>
<a class="index-entry-id" id="index-certificate-verification_002c-for-HTTPS"></a>
<p>When <var class="var">verify-certificate?</var> is true, verify the server’s X.509
certificates against those read from <code class="code">x509-certificate-directory</code>.
When an error occurs—e.g., the server’s certificate has expired, or
its host name does not match—raise a <code class="code">tls-certificate-error</code>
exception.  The arguments to the <code class="code">tls-certificate-error</code> exception
are:
</p>
<ol class="enumerate">
<li> a symbol indicating the failure cause, <code class="code">host-mismatch</code> if the
certificate’s host name does not match the server’s host name, and
<code class="code">invalid-certificate</code> for other causes;

</li><li> the server’s X.509 certificate (see <a data-manual="gnutls-guile" href="https://www.gnu.org/software/guile/manual/gnutls-guile.html#Guile-Reference">GnuTLS Guile
reference</a> in <cite class="cite">GnuTLS-Guile</cite>);

</li><li> the server’s host name (a string);

</li><li> in the case of <code class="code">invalid-certificate</code> errors, a list of GnuTLS
certificate status values—one of the <code class="code">certificate-status/</code>
constants, such as <code class="code">certificate-status/signer-not-found</code> or
<code class="code">certificate-status/revoked</code>.
</li></ol>
</dd></dl>

<a class="anchor" id="http_002drequest"></a><dl class="first-deffn">
<dt class="deffn" id="index-http_002drequest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-request</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002drequest"> ¶</a></span></dt>
<dd>
<p>Connect to the server corresponding to <var class="var">uri</var> and make a request over
HTTP, using <var class="var">method</var> (<code class="code">GET</code>, <code class="code">HEAD</code>, <code class="code">POST</code>, etc.).
</p>
<p>The following keyword arguments allow you to modify the requests in
various ways, for example attaching a body to the request, or setting
specific headers.  The following table lists the keyword arguments and
their default values.
</p>
<dl class="table">
<dt><code class="code">#:method 'GET</code></dt>
<dt><code class="code">#:body #f</code></dt>
<dt><code class="code">#:verify-certificate? #t</code></dt>
<dt><code class="code">#:port (open-socket-for-uri <var class="var">uri</var> #:verify-certificate? <var class="var">verify-certificate?</var>)</code></dt>
<dt><code class="code">#:version '(1 . 1)</code></dt>
<dt><code class="code">#:keep-alive? #f</code></dt>
<dt><code class="code">#:headers '()</code></dt>
<dt><code class="code">#:decode-body? #t</code></dt>
<dt><code class="code">#:streaming? #f</code></dt>
</dl>

<p>If you already have a port open, pass it as <var class="var">port</var>.  Otherwise, a
connection will be opened to the server corresponding to <var class="var">uri</var>.  Any
extra headers in the alist <var class="var">headers</var> will be added to the request.
</p>
<p>If <var class="var">body</var> is not <code class="code">#f</code>, a message body will also be sent with
the HTTP request.  If <var class="var">body</var> is a string, it is encoded according to
the content-type in <var class="var">headers</var>, defaulting to UTF-8.  Otherwise
<var class="var">body</var> should be a bytevector, or <code class="code">#f</code> for no body.  Although a
message body may be sent with any request, usually only <code class="code">POST</code> and
<code class="code">PUT</code> requests have bodies.
</p>
<p>If <var class="var">decode-body?</var> is true, as is the default, the body of the
response will be decoded to string, if it is a textual content-type.
Otherwise it will be returned as a bytevector.
</p>
<p>However, if <var class="var">streaming?</var> is true, instead of eagerly reading the
response body from the server, this function only reads off the headers.
The response body will be returned as a port on which the data may be
read.
</p>
<p>Unless <var class="var">keep-alive?</var> is true, the port will be closed after the full
response body has been read.
</p>
<p>If <var class="var">port</var> is false, <var class="var">uri</var> denotes an HTTPS URL, and <var class="var">verify-certificate?</var> is
true, verify X.509 certificates against those available in
<code class="code">x509-certificate-directory</code>.
</p>
<p>Returns two values: the response read from the server, and the response
body as a string, bytevector, #f value, or as a port (if
<var class="var">streaming?</var> is true).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-http_002dget"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-get</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002dget"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002dhead"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-head</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002dhead"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002dpost"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-post</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002dpost"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002dput"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-put</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002dput"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-delete</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002ddelete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002dtrace"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-trace</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002dtrace"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-http_002doptions"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">http-options</strong> <var class="def-var-arguments"><var class="var">uri</var> <var class="var">arg</var>…</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http_002doptions"> ¶</a></span></dt>
<dd><p>Connect to the server corresponding to <var class="var">uri</var> and make a request over
HTTP, using the appropriate method (<code class="code">GET</code>, <code class="code">HEAD</code>,
<code class="code">POST</code>, etc.).
</p>
<p>These procedures are variants of <code class="code">http-request</code> specialized with a
specific <var class="var">method</var> argument, and have the same prototype: a URI
followed by an optional sequence of keyword arguments.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#http_002drequest">http-request</a>, for full documentation on the various keyword
arguments.
</p>
</dd></dl>

<dl class="first-defvr">
<dt class="defvr" id="index-x509_002dcertificate_002ddirectory"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">x509-certificate-directory</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-x509_002dcertificate_002ddirectory"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-X_002e509-certificate-directory"></a>
<a class="index-entry-id" id="index-HTTPS_002c-X_002e509-certificates"></a>
<a class="index-entry-id" id="index-certificates_002c-for-HTTPS"></a>
<p>This parameter gives the name of the directory where X.509 certificates
for HTTPS connections should be looked for.
</p>
<p>Its default value is one of:
</p>
<ul class="itemize mark-bullet">
<li><a class="index-entry-id" id="index-GUILE_005fTLS_005fCERTIFICATE_005fDIRECTORY"></a>
the value of the <code class="env">GUILE_TLS_CERTIFICATE_DIRECTORY</code> environment
variable;

</li><li><a class="index-entry-id" id="index-SSL_005fCERT_005fDIR"></a>
or the value of the <code class="env">SSL_CERT_DIR</code> environment variable (also
honored by the OpenSSL library);

</li><li>or, as a last resort, <code class="code">"/etc/ssl/certs"</code>.
</li></ul>

<p>X.509 certificates are used when authenticating the identity of a remote
site, when the <code class="code">#:verify-certificate?</code> argument to
<code class="code">open-socket-for-uri</code>, to <code class="code">http-request</code>, or to related
procedures is true.
</p></dd></dl>

<p><code class="code">http-get</code> is useful for making one-off requests to web sites.  If
you are writing a web spider or some other client that needs to handle a
number of requests in parallel, it’s better to build an event-driven URL
fetcher, similar in structure to the web server (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server">Web Server</a>).
</p>
<p>Another option, good but not as performant, would be to use threads,
possibly via par-map or futures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-current_002dhttp_002dproxy"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">current-http-proxy</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dhttp_002dproxy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-current_002dhttps_002dproxy"><span class="category-def">Scheme Parameter: </span><span><strong class="def-name">current-https-proxy</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dhttps_002dproxy"> ¶</a></span></dt>
<dd><p>Either <code class="code">#f</code> or a non-empty string containing the URL of the HTTP
or HTTPS proxy server to be used by the procedures in the <code class="code">(web client)</code>
module, including <code class="code">open-socket-for-uri</code>.  Its initial value is
based on the <code class="env">http_proxy</code> and <code class="env">https_proxy</code> environment variables.
</p>
<div class="example">
<pre class="example-preformatted">(current-http-proxy) ⇒ "http://localhost:8123/"
(parameterize ((current-http-proxy #f))
  (http-get "http://example.com/"))  ; temporarily bypass proxy
(current-http-proxy) ⇒ "http://localhost:8123/"
</pre></div>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="Web-Server">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Examples" accesskey="n" rel="next">Web Examples</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Client" accesskey="p" rel="prev">Web Client</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Web-Server-1">7.3.9 Web Server</h4>

<p><code class="code">(web server)</code> is a generic web server interface, along with a main
loop implementation for web servers controlled by Guile.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web server))
</pre></div>

<p>The lowest layer is the <code class="code">&lt;server-impl&gt;</code> object, which defines a set
of hooks to open a server, read a request from a client, write a
response to a client, and close a server.  These hooks – <code class="code">open</code>,
<code class="code">read</code>, <code class="code">write</code>, and <code class="code">close</code>, respectively – are bound
together in a <code class="code">&lt;server-impl&gt;</code> object.  Procedures in this module take a
<code class="code">&lt;server-impl&gt;</code> object, if needed.
</p>
<p>A <code class="code">&lt;server-impl&gt;</code> may also be looked up by name.  If you pass the
<code class="code">http</code> symbol to <code class="code">run-server</code>, Guile looks for a variable
named <code class="code">http</code> in the <code class="code">(web server http)</code> module, which should
be bound to a <code class="code">&lt;server-impl&gt;</code> object.  Such a binding is made by
instantiation of the <code class="code">define-server-impl</code> syntax.  In this way the
run-server loop can automatically load other backends if available.
</p>
<p>The life cycle of a server goes as follows:
</p>
<ol class="enumerate">
<li> The <code class="code">open</code> hook is called, to open the server. <code class="code">open</code> takes
zero or more arguments, depending on the backend, and returns an opaque
server socket object, or signals an error.

</li><li> The <code class="code">read</code> hook is called, to read a request from a new client.
The <code class="code">read</code> hook takes one argument, the server socket.  It should
return three values: an opaque client socket, the request, and the
request body. The request should be a <code class="code">&lt;request&gt;</code> object, from
<code class="code">(web request)</code>.  The body should be a string or a bytevector, or
<code class="code">#f</code> if there is no body.

<p>If the read failed, the <code class="code">read</code> hook may return #f for the client
socket, request, and body.
</p>
</li><li> A user-provided handler procedure is called, with the request and body
as its arguments.  The handler should return two values: the response,
as a <code class="code">&lt;response&gt;</code> record from <code class="code">(web response)</code>, and the
response body as bytevector, or <code class="code">#f</code> if not present.

<p>The respose and response body are run through <code class="code">sanitize-response</code>,
documented below.  This allows the handler writer to take some
convenient shortcuts: for example, instead of a <code class="code">&lt;response&gt;</code>, the
handler can simply return an alist of headers, in which case a default
response object is constructed with those headers.  Instead of a
bytevector for the body, the handler can return a string, which will be
serialized into an appropriate encoding; or it can return a procedure,
which will be called on a port to write out the data.  See the
<code class="code">sanitize-response</code> documentation, for more.
</p>
</li><li> The <code class="code">write</code> hook is called with three arguments: the client
socket, the response, and the body.  The <code class="code">write</code> hook returns no
values.

</li><li> At this point the request handling is complete. For a loop, we
loop back and try to read a new request.

</li><li> If the user interrupts the loop, the <code class="code">close</code> hook is called on
the server socket.
</li></ol>

<p>A user may define a server implementation with the following form:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dserver_002dimpl"><span class="category-def">Scheme Syntax: </span><span><strong class="def-name">define-server-impl</strong> <var class="def-var-arguments">name open read write close</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dserver_002dimpl"> ¶</a></span></dt>
<dd><p>Make a <code class="code">&lt;server-impl&gt;</code> object with the hooks <var class="var">open</var>,
<var class="var">read</var>, <var class="var">write</var>, and <var class="var">close</var>, and bind it to the symbol
<var class="var">name</var> in the current module.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lookup_002dserver_002dimpl"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lookup-server-impl</strong> <var class="def-var-arguments">impl</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lookup_002dserver_002dimpl"> ¶</a></span></dt>
<dd><p>Look up a server implementation.  If <var class="var">impl</var> is a server
implementation already, it is returned directly.  If it is a symbol, the
binding named <var class="var">impl</var> in the <code class="code">(web server <var class="var">impl</var>)</code> module is
looked up.  Otherwise an error is signaled.
</p>
<p>Currently a server implementation is a somewhat opaque type, useful only
for passing to other procedures in this module, like <code class="code">read-client</code>.
</p></dd></dl>

<p>The <code class="code">(web server)</code> module defines a number of routines that use
<code class="code">&lt;server-impl&gt;</code> objects to implement parts of a web server.  Given
that we don’t expose the accessors for the various fields of a
<code class="code">&lt;server-impl&gt;</code>, indeed these routines are the only procedures with
any access to the impl objects.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-open_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">open-server</strong> <var class="def-var-arguments">impl open-params</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-open_002dserver"> ¶</a></span></dt>
<dd><p>Open a server for the given implementation.  Return one value, the new
server object.  The implementation’s <code class="code">open</code> procedure is applied to
<var class="var">open-params</var>, which should be a list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-read_002dclient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">read-client</strong> <var class="def-var-arguments">impl server</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-read_002dclient"> ¶</a></span></dt>
<dd><p>Read a new client from <var class="var">server</var>, by applying the implementation’s
<code class="code">read</code> procedure to the server.  If successful, return three
values: an object corresponding to the client, a request object, and the
request body.  If any exception occurs, return <code class="code">#f</code> for all three
values.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-handle_002drequest"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">handle-request</strong> <var class="def-var-arguments">handler request body state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-handle_002drequest"> ¶</a></span></dt>
<dd><p>Handle a given request, returning the response and body.
</p>
<p>The response and response body are produced by calling the given
<var class="var">handler</var> with <var class="var">request</var> and <var class="var">body</var> as arguments.
</p>
<p>The elements of <var class="var">state</var> are also passed to <var class="var">handler</var> as
arguments, and may be returned as additional values.  The new
<var class="var">state</var>, collected from the <var class="var">handler</var>’s return values, is then
returned as a list.  The idea is that a server loop receives a handler
from the user, along with whatever state values the user is interested
in, allowing the user’s handler to explicitly manage its state.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-sanitize_002dresponse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sanitize-response</strong> <var class="def-var-arguments">request response body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sanitize_002dresponse"> ¶</a></span></dt>
<dd><p>“Sanitize” the given response and body, making them appropriate for
the given request.
</p>
<p>As a convenience to web handler authors, <var class="var">response</var> may be given as
an alist of headers, in which case it is used to construct a default
response.  Ensures that the response version corresponds to the request
version.  If <var class="var">body</var> is a string, encodes the string to a bytevector,
in an encoding appropriate for <var class="var">response</var>.  Adds a
<code class="code">content-length</code> and <code class="code">content-type</code> header, as necessary.
</p>
<p>If <var class="var">body</var> is a procedure, it is called with a port as an argument,
and the output collected as a bytevector.  In the future we might try to
instead use a compressing, chunk-encoded port, and call this procedure
later, in the write-client procedure.  Authors are advised not to rely on
the procedure being called at any particular time.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-write_002dclient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">write-client</strong> <var class="def-var-arguments">impl server client response body</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-write_002dclient"> ¶</a></span></dt>
<dd><p>Write an HTTP response and body to <var class="var">client</var>.  If the server and
client support persistent connections, it is the implementation’s
responsibility to keep track of the client thereafter, presumably by
attaching it to the <var class="var">server</var> argument somehow.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-close_002dserver"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">close-server</strong> <var class="def-var-arguments">impl server</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-close_002dserver"> ¶</a></span></dt>
<dd><p>Release resources allocated by a previous invocation of
<code class="code">open-server</code>.
</p></dd></dl>

<p>Given the procedures above, it is a small matter to make a web server:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-serve_002done_002dclient"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">serve-one-client</strong> <var class="def-var-arguments">handler impl server state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-serve_002done_002dclient"> ¶</a></span></dt>
<dd><p>Read one request from <var class="var">server</var>, call <var class="var">handler</var> on the request
and body, and write the response to the client.  Return the new state
produced by the handler procedure.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-run_002dserver-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">run-server</strong> <var class="def-var-arguments">handler                           [impl=’http] [open-params=’()]                           arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-run_002dserver-1"> ¶</a></span></dt>
<dd><p>Run Guile’s built-in web server.
</p>
<p><var class="var">handler</var> should be a procedure that takes two or more arguments,
the HTTP request and request body, and returns two or more values, the
response and response body.
</p>
<p>For examples, skip ahead to the next section, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Web-Examples">Web Examples</a>.
</p>
<p>The response and body will be run through <code class="code">sanitize-response</code>
before sending back to the client.
</p>
<p>Additional arguments to <var class="var">handler</var> are taken from <var class="var">arg</var>
<small class="enddots">...</small>.  These arguments comprise a <em class="dfn">state</em>.  Additional return
values are accumulated into a new state, which will be used for
subsequent requests.  In this way a handler can explicitly manage its
state.
</p></dd></dl>

<p>The default web server implementation is <code class="code">http</code>, which binds to a
socket, listening for request on that port.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-http"><span class="category-def">HTTP Implementation: </span><span><strong class="def-name">http</strong> <var class="def-var-arguments">[#:host=#f]                              [#:family=AF_INET]                              [#:addr=INADDR_LOOPBACK]                              [#:port 8080] [#:socket]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-http"> ¶</a></span></dt>
<dd><p>The default HTTP implementation.  We document it as a function with
keyword arguments, because that is precisely the way that it is – all
of the <var class="var">open-params</var> to <code class="code">run-server</code> get passed to the
implementation’s open function.
</p>
<div class="example">
<pre class="example-preformatted">;; The defaults: localhost:8080
(run-server handler)
;; Same thing
(run-server handler 'http '())
;; On a different port
(run-server handler 'http '(#:port 8081))
;; IPv6
(run-server handler 'http '(#:family AF_INET6 #:port 8081))
;; Custom socket
(run-server handler 'http `(#:socket ,(sudo-make-me-a-socket)))
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="Web-Examples">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web-Server" accesskey="p" rel="prev">Web Server</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="u" rel="up"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Web-Examples-1">7.3.10 Web Examples</h4>

<p>Well, enough about the tedious internals.  Let’s make a web application!
</p>
<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Hello_002c-World_0021" accesskey="1">Hello, World!</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Inspecting-the-Request" accesskey="2">Inspecting the Request</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Higher_002dLevel-Interfaces" accesskey="3">Higher-Level Interfaces</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Conclusion" accesskey="4">Conclusion</a></li>
</ul>
<div class="subsubsection-level-extent" id="Hello_002c-World_0021">
<h4 class="subsubsection">7.3.10.1 Hello, World!</h4>

<p>The first program we have to write, of course, is “Hello, World!”.
This means that we have to implement a web handler that does what we
want.
</p>
<p>Now we define a handler, a function of two arguments and two return
values:
</p>
<div class="example">
<pre class="example-preformatted">(define (handler request request-body)
  (values <var class="var">response</var> <var class="var">response-body</var>))
</pre></div>

<p>In this first example, we take advantage of a short-cut, returning an
alist of headers instead of a proper response object. The response body
is our payload:
</p>
<div class="example">
<pre class="example-preformatted">(define (hello-world-handler request request-body)
  (values '((content-type . (text/plain)))
          "Hello World!"))
</pre></div>

<p>Now let’s test it, by running a server with this handler. Load up the
web server module if you haven’t yet done so, and run a server with this
handler:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web server))
(run-server hello-world-handler)
</pre></div>

<p>By default, the web server listens for requests on
<code class="code">localhost:8080</code>.  Visit that address in your web browser to
test.  If you see the string, <code class="code">Hello World!</code>, sweet!
</p>
</div>
<div class="subsubsection-level-extent" id="Inspecting-the-Request">
<h4 class="subsubsection">7.3.10.2 Inspecting the Request</h4>

<p>The Hello World program above is a general greeter, responding to all
URIs.  To make a more exclusive greeter, we need to inspect the request
object, and conditionally produce different results.  So let’s load up
the request, response, and URI modules, and do just that.
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web server)) ; you probably did this already
(use-modules (web request)
             (web response)
             (web uri))

(define (request-path-components request)
  (split-and-decode-uri-path (uri-path (request-uri request))))

(define (hello-hacker-handler request body)
  (if (equal? (request-path-components request)
              '("hacker"))
      (values '((content-type . (text/plain)))
              "Hello hacker!")
      (not-found request)))

(run-server hello-hacker-handler)
</pre></div>

<p>Here we see that we have defined a helper to return the components of
the URI path as a list of strings, and used that to check for a request
to <code class="code">/hacker/</code>. Then the success case is just as before – visit
<code class="code">http://localhost:8080/hacker/</code> in your browser to check.
</p>
<p>You should always match against URI path components as decoded by
<code class="code">split-and-decode-uri-path</code>. The above example will work for
<code class="code">/hacker/</code>, <code class="code">//hacker///</code>, and <code class="code">/h%61ck%65r</code>.
</p>
<p>But we forgot to define <code class="code">not-found</code>!  If you are pasting these
examples into a REPL, accessing any other URI in your web browser will
drop your Guile console into the debugger:
</p>
<div class="example">
<pre class="example-preformatted">&lt;unnamed port&gt;:38:7: In procedure module-lookup:
&lt;unnamed port&gt;:38:7: Unbound variable: not-found

Entering a new prompt.  Type `,bt' for a backtrace or `,q' to continue.
scheme@(guile-user) [1]&gt; 
</pre></div>

<p>So let’s define the function, right there in the debugger.  As you
probably know, we’ll want to return a 404 response.
</p>
<div class="example">
<pre class="example-preformatted">;; Paste this in your REPL
(define (not-found request)
  (values (build-response #:code 404)
          (string-append "Resource not found: "
                         (uri-&gt;string (request-uri request)))))

;; Now paste this to let the web server keep going:
,continue
</pre></div>

<p>Now if you access <code class="code">http://localhost/foo/</code>, you get this error
message.  (Note that some popular web browsers won’t show
server-generated 404 messages, showing their own instead, unless the 404
message body is long enough.)
</p>
</div>
<div class="subsubsection-level-extent" id="Higher_002dLevel-Interfaces">
<h4 class="subsubsection">7.3.10.3 Higher-Level Interfaces</h4>

<p>The web handler interface is a common baseline that all kinds of Guile
web applications can use.  You will usually want to build something on
top of it, however, especially when producing HTML.  Here is a simple
example that builds up HTML output using SXML (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SXML">SXML</a>).
</p>
<p>First, load up the modules:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (web server)
             (web request)
             (web response)
             (sxml simple))
</pre></div>

<p>Now we define a simple templating function that takes a list of HTML
body elements, as SXML, and puts them in our super template:
</p>
<div class="example">
<pre class="example-preformatted">(define (templatize title body)
  `(html (head (title ,title))
         (body ,@body)))
</pre></div>

<p>For example, the simplest Hello HTML can be produced like this:
</p>
<div class="example">
<pre class="example-preformatted">(sxml-&gt;xml (templatize "Hello!" '((b "Hi!"))))
-|
&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;b&gt;Hi!&lt;/b&gt;&lt;/body&gt;&lt;/html&gt;
</pre></div>

<p>Much better to work with Scheme data types than to work with HTML as
strings. Now we define a little response helper:
</p>
<div class="example">
<pre class="example-preformatted">(define* (respond #:optional body #:key
                  (status 200)
                  (title "Hello hello!")
                  (doctype "&lt;!DOCTYPE html&gt;\n")
                  (content-type-params '((charset . "utf-8")))
                  (content-type 'text/html)
                  (extra-headers '())
                  (sxml (and body (templatize title body))))
  (values (build-response
           #:code status
           #:headers `((content-type
                        . (,content-type ,@content-type-params))
                       ,@extra-headers))
          (lambda (port)
            (if sxml
                (begin
                  (if doctype (display doctype port))
                  (sxml-&gt;xml sxml port))))))
</pre></div>

<p>Here we see the power of keyword arguments with default initializers. By
the time the arguments are fully parsed, the <code class="code">sxml</code> local variable
will hold the templated SXML, ready for sending out to the client.
</p>
<p>Also, instead of returning the body as a string, <code class="code">respond</code> gives a
procedure, which will be called by the web server to write out the
response to the client.
</p>
<p>Now, a simple example using this responder, which lays out the incoming
headers in an HTML table.
</p>
<div class="example">
<pre class="example-preformatted">(define (debug-page request body)
  (respond
   `((h1 "hello world!")
     (table
      (tr (th "header") (th "value"))
      ,@(map (lambda (pair)
               `(tr (td (tt ,(with-output-to-string
                               (lambda () (display (car pair))))))
                    (td (tt ,(with-output-to-string
                               (lambda ()
                                 (write (cdr pair))))))))
             (request-headers request))))))

(run-server debug-page)
</pre></div>

<p>Now if you visit any local address in your web browser, we actually see
some HTML, finally.
</p>
</div>
<div class="subsubsection-level-extent" id="Conclusion">
<h4 class="subsubsection">7.3.10.4 Conclusion</h4>

<p>Well, this is about as far as Guile’s built-in web support goes, for
now.  There are many ways to make a web application, but hopefully by
standardizing the most fundamental data types, users will be able to
choose the approach that suits them best, while also being able to
switch between implementations of the server.  This is a relatively new
part of Guile, so if you have feedback, let us know, and we can take it
into account.  Happy hacking on the web!
</p>

<hr>
</div>
</div>
</div>
<div class="section-level-extent" id="getopt_002dlong">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="n" rel="next">SRFI Support Modules</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Web" accesskey="p" rel="prev"><abbr class="acronym">HTTP</abbr>, the Web, and All That</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="u" rel="up">Guile Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="The-_0028ice_002d9-getopt_002dlong_0029-Module">7.4 The (ice-9 getopt-long) Module</h3>

<p>The <code class="code">(ice-9 getopt-long)</code> facility is designed to help parse
arguments that are passed to Guile programs on the command line, and is
modelled after the C library’s facility of the same name
(see <a data-manual="libc" href="http://www.gnu.org/software/libc/manual/html_mono/libc.html#Getopt">Getopt</a> in <cite class="cite">The GNU C Library Reference Manual</cite>).  For a more
low-level interface to command-line argument parsing, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d37">SRFI-37 - args-fold</a>.
</p>
<p>The <code class="code">(ice-9 getopt-long)</code> module exports two procedures:
<code class="code">getopt-long</code> and <code class="code">option-ref</code>.
</p>
<ul class="itemize mark-bullet">
<li><code class="code">getopt-long</code> takes a list of strings — the command line
arguments — an <em class="dfn">option specification</em>, and some optional keyword
parameters.  It parses the command line arguments according to the
option specification and keyword parameters, and returns a data
structure that encapsulates the results of the parsing.

</li><li><code class="code">option-ref</code> then takes the parsed data structure and a specific
option’s name, and returns information about that option in particular.
</li></ul>

<p>To make these procedures available to your Guile script, include the
expression <code class="code">(use-modules (ice-9 getopt-long))</code> somewhere near the
top, before the first usage of <code class="code">getopt-long</code> or <code class="code">option-ref</code>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Example" accesskey="1">A Short getopt-long Example</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Option-Specification" accesskey="2">How to Write an Option Specification</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Format" accesskey="3">Expected Command Line Format</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Reference" accesskey="4">Reference Documentation for <code class="code">getopt-long</code></a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#option_002dref-Reference" accesskey="5">Reference Documentation for <code class="code">option-ref</code></a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="getopt_002dlong-Example">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Option-Specification" accesskey="n" rel="next">How to Write an Option Specification</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="u" rel="up">The (ice-9 getopt-long) Module</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="A-Short-getopt_002dlong-Example">7.4.1 A Short getopt-long Example</h4>

<p>This section illustrates how <code class="code">getopt-long</code> is used by presenting
and dissecting a simple example.  The first thing that we need is an
<em class="dfn">option specification</em> that tells <code class="code">getopt-long</code> how to parse
the command line.  This specification is an association list with the
long option name as the key.  Here is how such a specification might
look:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define option-spec
  '((version (single-char #\v) (value #f))
    (help    (single-char #\h) (value #f))))
</pre></div>

<p>This alist tells <code class="code">getopt-long</code> that it should accept two long
options, called <em class="emph">version</em> and <em class="emph">help</em>, and that these options
can also be selected by the single-letter abbreviations <em class="emph">v</em> and
<em class="emph">h</em>, respectively.  The <code class="code">(value #f)</code> clauses indicate that
neither of the options accepts a value.
</p>
<p>With this specification we can use <code class="code">getopt-long</code> to parse a given
command line:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define options (getopt-long (command-line) option-spec))
</pre></div>

<p>After this call, <code class="code">options</code> contains the parsed command line and is
ready to be examined by <code class="code">option-ref</code>.  <code class="code">option-ref</code> is called
like this:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(option-ref options 'help #f)
</pre></div>

<p>It expects the parsed command line, a symbol indicating the option to
examine, and a default value.  The default value is returned if the
option was not present in the command line, or if the option was present
but without a value; otherwise the value from the command line is
returned.  Usually <code class="code">option-ref</code> is called once for each possible
option that a script supports.
</p>
<p>The following example shows a main program which puts all this together
to parse its command line and figure out what the user wanted.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define (main args)
  (let* ((option-spec '((version (single-char #\v) (value #f))
                        (help    (single-char #\h) (value #f))))
         (options (getopt-long args option-spec))
         (help-wanted (option-ref options 'help #f))
         (version-wanted (option-ref options 'version #f)))
    (if (or version-wanted help-wanted)
        (begin
          (if version-wanted
              (display "getopt-long-example version 0.3\n"))
          (if help-wanted
              (display "\
getopt-long-example [options]
  -v, --version    Display version
  -h, --help       Display this help
")))
        (begin
          (display "Hello, World!") (newline)))))
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="Option-Specification">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Format" accesskey="n" rel="next">Expected Command Line Format</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Example" accesskey="p" rel="prev">A Short getopt-long Example</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="u" rel="up">The (ice-9 getopt-long) Module</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="How-to-Write-an-Option-Specification">7.4.2 How to Write an Option Specification</h4>

<p>An option specification is an association list (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists">Association Lists</a>) with one list element for each supported option. The key of each
list element is a symbol that names the option, while the value is a
list of option properties:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">OPTION-SPEC ::=  '( (OPT-NAME1 (PROP-NAME PROP-VALUE) …)
                    (OPT-NAME2 (PROP-NAME PROP-VALUE) …)
                    (OPT-NAME3 (PROP-NAME PROP-VALUE) …)
                    …
                  )
</pre></div>

<p>Each <var class="var">opt-name</var> specifies the long option name for that option.  For
example, a list element with <var class="var">opt-name</var> <code class="code">background</code> specifies
an option that can be specified on the command line using the long
option <code class="code">--background</code>.  Further information about the option —
whether it takes a value, whether it is required to be present in the
command line, and so on — is specified by the option properties.
</p>
<p>In the example of the preceding section, we already saw that a long
option name can have a equivalent <em class="dfn">short option</em> character.  The
equivalent short option character can be set for an option by specifying
a <code class="code">single-char</code> property in that option’s property list.  For
example, a list element like <code class="code">'(output (single-char #\o) …)</code>
specifies an option with long name <code class="code">--output</code> that can also be
specified by the equivalent short name <code class="code">-o</code>.
</p>
<p>The <code class="code">value</code> property specifies whether an option requires or
accepts a value.  If the <code class="code">value</code> property is set to <code class="code">#t</code>, the
option requires a value: <code class="code">getopt-long</code> will signal an error if the
option name is present without a corresponding value.  If set to
<code class="code">#f</code>, the option does not take a value; in this case, a non-option
word that follows the option name in the command line will be treated as
a non-option argument.  If set to the symbol <code class="code">optional</code>, the option
accepts a value but does not require one: a non-option word that follows
the option name in the command line will be interpreted as that option’s
value.  If the option name for an option with <code class="code">'(value optional)</code>
is immediately followed in the command line by <em class="emph">another</em> option
name, the value for the first option is implicitly <code class="code">#t</code>.
</p>
<p>The <code class="code">required?</code> property indicates whether an option is required to
be present in the command line.  If the <code class="code">required?</code>  property is
set to <code class="code">#t</code>, <code class="code">getopt-long</code> will signal an error if the option
is not specified.
</p>
<p>Finally, the <code class="code">predicate</code> property can be used to constrain the
possible values of an option.  If used, the <code class="code">predicate</code> property
should be set to a procedure that takes one argument — the proposed
option value as a string — and returns either <code class="code">#t</code> or <code class="code">#f</code>
according as the proposed value is or is not acceptable.  If the
predicate procedure returns <code class="code">#f</code>, <code class="code">getopt-long</code> will signal an
error.
</p>
<p>By default, options do not have single-character equivalents, are not
required, and do not take values.  Where the list element for an option
includes a <code class="code">value</code> property but no <code class="code">predicate</code> property, the
option values are unconstrained.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="Command-Line-Format">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Reference" accesskey="n" rel="next">Reference Documentation for <code class="code">getopt-long</code></a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Option-Specification" accesskey="p" rel="prev">How to Write an Option Specification</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="u" rel="up">The (ice-9 getopt-long) Module</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Expected-Command-Line-Format">7.4.3 Expected Command Line Format</h4>

<p>In order for <code class="code">getopt-long</code> to correctly parse a command line, that
command line must conform to a standard set of rules for how command
line options are specified.  This section explains what those rules
are.
</p>
<p><code class="code">getopt-long</code> splits a given command line into several pieces.  All
elements of the argument list are classified to be either options or
normal arguments.  Options consist of two dashes and an option name
(so-called <em class="dfn">long</em> options), or of one dash followed by a single
letter (<em class="dfn">short</em> options).
</p>
<p>Options can behave as switches, when they are given without a value, or
they can be used to pass a value to the program.  The value for an
option may be specified using an equals sign, or else is simply the next
word in the command line, so the following two invocations are
equivalent:
</p>
<div class="example">
<pre class="example-preformatted">$ ./foo.scm --output=bar.txt
$ ./foo.scm --output bar.txt
</pre></div>

<p>Short options can be used instead of their long equivalents and can be
grouped together after a single dash.  For example, the following
commands are equivalent.
</p>
<div class="example">
<pre class="example-preformatted">$ ./foo.scm --version --help
$ ./foo.scm -v --help
$ ./foo.scm -vh
</pre></div>

<p>If an option requires a value, it can only be grouped together with other
short options if it is the last option in the group; the value is the
next argument.  So, for example, with the following option
specification —
</p>
<div class="example lisp">
<pre class="lisp-preformatted">((apples    (single-char #\a))
 (blimps    (single-char #\b) (value #t))
 (catalexis (single-char #\c) (value #t)))
</pre></div>

<p>— the following command lines would all be acceptable:
</p>
<div class="example">
<pre class="example-preformatted">$ ./foo.scm -a -b bang -c couth
$ ./foo.scm -ab bang -c couth
$ ./foo.scm -ac couth -b bang
</pre></div>

<p>But the next command line is an error, because <code class="code">-b</code> is not the last
option in its combination, and because a group of short options cannot
include two options that both require values:
</p>
<div class="example">
<pre class="example-preformatted">$ ./foo.scm -abc couth bang
</pre></div>

<p>If an option’s value is optional, <code class="code">getopt-long</code> decides whether the
option has a value by looking at what follows it in the argument list.
If the next element is a string, and it does not appear to be an option
itself, then that string is the option’s value.
</p>
<p>If the option <code class="code">--</code> appears in the argument list, argument parsing
stops there and subsequent arguments are returned as ordinary arguments,
even if they resemble options.  So, with the command line
</p>
<div class="example">
<pre class="example-preformatted">$ ./foo.scm --apples "Granny Smith" -- --blimp Goodyear
</pre></div>

<p><code class="code">getopt-long</code> will recognize the <code class="code">--apples</code> option as having
the value "Granny Smith", but will not treat <code class="code">--blimp</code> as an
option.  The strings <code class="code">--blimp</code> and <code class="code">Goodyear</code> will be returned
as ordinary argument strings.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="getopt_002dlong-Reference">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#option_002dref-Reference" accesskey="n" rel="next">Reference Documentation for <code class="code">option-ref</code></a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#Command-Line-Format" accesskey="p" rel="prev">Expected Command Line Format</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="u" rel="up">The (ice-9 getopt-long) Module</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Reference-Documentation-for-getopt_002dlong">7.4.4 Reference Documentation for <code class="code">getopt-long</code></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-getopt_002dlong"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">getopt-long</strong> <var class="def-var-arguments">args grammar [#:stop-at-first-non-option #f]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getopt_002dlong"> ¶</a></span></dt>
<dd><p>Parse the command line given in <var class="var">args</var> (which must be a list of
strings) according to the option specification <var class="var">grammar</var>.
</p>
<p>The <var class="var">grammar</var> argument is expected to be a list of this form:
</p>
<p><code class="code">((<var class="var">option</var> (<var class="var">property</var> <var class="var">value</var>) …) …)</code>
</p>
<p>where each <var class="var">option</var> is a symbol denoting the long option, but
without the two leading dashes (e.g. <code class="code">version</code> if the option is
called <code class="code">--version</code>).
</p>
<p>For each option, there may be list of arbitrarily many property/value
pairs.  The order of the pairs is not important, but every property may
only appear once in the property list.  The following table lists the
possible properties:
</p>
<dl class="table">
<dt><code class="code">(single-char <var class="var">char</var>)</code></dt>
<dd><p>Accept <code class="code">-<var class="var">char</var></code> as a single-character equivalent to
<code class="code">--<var class="var">option</var></code>.  This is how to specify traditional Unix-style
flags.
</p></dd>
<dt><code class="code">(required? <var class="var">bool</var>)</code></dt>
<dd><p>If <var class="var">bool</var> is true, the option is required.  <code class="code">getopt-long</code> will
raise an error if it is not found in <var class="var">args</var>.
</p></dd>
<dt><code class="code">(value <var class="var">bool</var>)</code></dt>
<dd><p>If <var class="var">bool</var> is <code class="code">#t</code>, the option accepts a value; if it is
<code class="code">#f</code>, it does not; and if it is the symbol <code class="code">optional</code>, the
option may appear in <var class="var">args</var> with or without a value.
</p></dd>
<dt><code class="code">(predicate <var class="var">func</var>)</code></dt>
<dd><p>If the option accepts a value (i.e. you specified <code class="code">(value #t)</code> for
this option), then <code class="code">getopt-long</code> will apply <var class="var">func</var> to the
value, and throw an exception if it returns <code class="code">#f</code>.  <var class="var">func</var>
should be a procedure which accepts a string and returns a boolean
value; you may need to use quasiquotes to get it into <var class="var">grammar</var>.
</p></dd>
</dl>

<p>The <code class="code">#:stop-at-first-non-option</code> keyword, if specified with any
true value, tells <code class="code">getopt-long</code> to stop when it gets to the first
non-option in the command line.  That is, at the first word which is
neither an option itself, nor the value of an option.  Everything in the
command line from that word onwards will be returned as non-option
arguments.
</p></dd></dl>

<p><code class="code">getopt-long</code>’s <var class="var">args</var> parameter is expected to be a list of
strings like the one returned by <code class="code">command-line</code>, with the first
element being the name of the command.  Therefore <code class="code">getopt-long</code>
ignores the first element in <var class="var">args</var> and starts argument
interpretation with the second element.
</p>
<p><code class="code">getopt-long</code> signals an error if any of the following conditions
hold.
</p>
<ul class="itemize mark-bullet">
<li>The option grammar has an invalid syntax.

</li><li>One of the options in the argument list was not specified by the
grammar.

</li><li>A required option is omitted.

</li><li>An option which requires an argument did not get one.

</li><li>An option that doesn’t accept an argument does get one (this can only
happen using the long option <code class="code">--opt=<var class="var">value</var></code> syntax).

</li><li>An option predicate fails.
</li></ul>

<p><code class="code">#:stop-at-first-non-option</code> is useful for command line invocations
like <code class="code">guild [--help | --version] [script [script-options]]</code>
and <code class="code">cvs [general-options] command [command-options]</code>, where there
are options at two levels: some generic and understood by the outer
command, and some that are specific to the particular script or command
being invoked.  To use <code class="code">getopt-long</code> in such cases, you would call
it twice: firstly with <code class="code">#:stop-at-first-non-option #t</code>, so as to
parse any generic options and identify the wanted script or sub-command;
secondly, and after trimming off the initial generic command words, with
a script- or sub-command-specific option grammar, so as to process those
specific options.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="option_002dref-Reference">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong-Reference" accesskey="p" rel="prev">Reference Documentation for <code class="code">getopt-long</code></a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="u" rel="up">The (ice-9 getopt-long) Module</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="Reference-Documentation-for-option_002dref">7.4.5 Reference Documentation for <code class="code">option-ref</code></h4>

<dl class="first-deffn">
<dt class="deffn" id="index-option_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option-ref</strong> <var class="def-var-arguments">options key default</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option_002dref"> ¶</a></span></dt>
<dd><p>Search <var class="var">options</var> for a command line option named <var class="var">key</var> and
return its value, if found.  If the option has no value, but was given,
return <code class="code">#t</code>.  If the option was not given, return <var class="var">default</var>.
<var class="var">options</var> must be the result of a call to <code class="code">getopt-long</code>.
</p></dd></dl>

<p><code class="code">option-ref</code> always succeeds, either by returning the requested
option value from the command line, or the default value.
</p>
<p>The special key <code class="code">'()</code> can be used to get a list of all
non-option arguments.
</p>
<hr>
</div>
</div>
<div class="section-level-extent" id="SRFI-Support">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#R6RS-Support" accesskey="n" rel="next">R6RS Support</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong" accesskey="p" rel="prev">The (ice-9 getopt-long) Module</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#Guile-Modules" accesskey="u" rel="up">Guile Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h3 class="section" id="SRFI-Support-Modules">7.5 SRFI Support Modules</h3>
<a class="index-entry-id" id="index-SRFI"></a>

<p>SRFI is an acronym for Scheme Request For Implementation.  The SRFI
documents define a lot of syntactic and procedure extensions to standard
Scheme as defined in R5RS.
</p>
<p>Guile has support for a number of SRFIs.  This chapter gives an overview
over the available SRFIs and some usage hints.  For complete
documentation, design rationales and further examples, we advise you to
get the relevant SRFI documents from the SRFI home page
<a class="url" href="http://srfi.schemers.org/">http://srfi.schemers.org/</a>.
</p>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#About-SRFI-Usage" accesskey="1">About SRFI Usage</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d0" accesskey="2">SRFI-0 - cond-expand</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="3">SRFI-1 - List library</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d2" accesskey="4">SRFI-2 - and-let*</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="5">SRFI-4 - Homogeneous numeric vector datatypes</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d6" accesskey="6">SRFI-6 - Basic String Ports</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d8" accesskey="7">SRFI-8 - receive</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9" accesskey="8">SRFI-9 - define-record-type</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d10" accesskey="9">SRFI-10 - Hash-Comma Reader Extension</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d11">SRFI-11 - let-values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d13">SRFI-13 - String Library</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d14">SRFI-14 - Character-set Library</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d16">SRFI-16 - case-lambda</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d17">SRFI-17 - Generalized set!</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18">SRFI-18 - Multithreading support</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19">SRFI-19 - Time/Date Library</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d23">SRFI-23 - Error Reporting</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d26">SRFI-26 - specializing parameters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27">SRFI-27 - Sources of Random Bits</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d28">SRFI-28 - Basic Format Strings</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d30">SRFI-30 - Nested Multi-line Comments</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d31">SRFI-31 - A special form ‘rec’ for recursive evaluation</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d34">SRFI-34 - Exception handling for programs</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d35">SRFI-35 - Conditions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d37">SRFI-37 - args-fold</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d38">SRFI-38 - External Representation for Data With Shared Structure</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d39">SRFI-39 - Parameters</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d41">SRFI-41 - Streams</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d42">SRFI-42 - Eager Comprehensions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d43">SRFI-43 - Vector Library</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d45">SRFI-45 - Primitives for Expressing Iterative Lazy Algorithms</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d46">SRFI-46 Basic syntax-rules Extensions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d55">SRFI-55 - Requiring Features</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d60">SRFI-60 - Integers as Bits</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d61">SRFI-61 - A more general <code class="code">cond</code> clause</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d62">SRFI-62 - S-expression comments.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d64">SRFI-64 - A Scheme API for test suites.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d67">SRFI-67 - Compare procedures</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d69">SRFI-69 - Basic hash tables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d71">SRFI-71 - Extended let-syntax for multiple values</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d87">SRFI-87 =&gt; in case clauses</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d88">SRFI-88 Keyword Objects</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d98">SRFI-98 Accessing environment variables.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d105">SRFI-105 Curly-infix expressions.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d111">SRFI-111 Boxes.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d171">Transducers</a></li>
</ul>
<hr>
<div class="subsection-level-extent" id="About-SRFI-Usage">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d0" accesskey="n" rel="next">SRFI-0 - cond-expand</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="About-SRFI-Usage-1">7.5.1 About SRFI Usage</h4>


<p>SRFI support in Guile is currently implemented partly in the core
library, and partly as add-on modules.  That means that some SRFIs are
automatically available when the interpreter is started, whereas the
other SRFIs require you to use the appropriate support module
explicitly.
</p>
<p>There are several reasons for this inconsistency.  First, the feature
checking syntactic form <code class="code">cond-expand</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d0">SRFI-0 - cond-expand</a>) must be
available immediately, because it must be there when the user wants to
check for the Scheme implementation, that is, before she can know that
it is safe to use <code class="code">use-modules</code> to load SRFI support modules.  The
second reason is that some features defined in SRFIs had been
implemented in Guile before the developers started to add SRFI
implementations as modules (for example SRFI-13 (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d13">SRFI-13 - String Library</a>)).  In
the future, it is possible that SRFIs in the core library might be
factored out into separate modules, requiring explicit module loading
when they are needed.  So you should be prepared to have to use
<code class="code">use-modules</code> someday in the future to access SRFI-13 bindings.  If
you want, you can do that already.  We have included the module
<code class="code">(srfi srfi-13)</code> in the distribution, which currently does nothing,
but ensures that you can write future-safe code.
</p>
<p>Generally, support for a specific SRFI is made available by using
modules named <code class="code">(srfi srfi-<var class="var">number</var>)</code>, where <var class="var">number</var> is the
number of the SRFI needed.  Another possibility is to use the command
line option <code class="code">--use-srfi</code>, which will load the necessary modules
automatically (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile">Invoking Guile</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d0">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="n" rel="next">SRFI-1 - List library</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#About-SRFI-Usage" accesskey="p" rel="prev">About SRFI Usage</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d0-_002d-cond_002dexpand">7.5.2 SRFI-0 - cond-expand</h4>
<a class="index-entry-id" id="index-SRFI_002d0"></a>

<p>This SRFI lets a portable Scheme program test for the presence of
certain features, and adapt itself by using different blocks of code,
or fail if the necessary features are not available.  There’s no
module to load, this is in the Guile core.
</p>
<p>A program designed only for Guile will generally not need this
mechanism, such a program can of course directly use the various
documented parts of Guile.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-cond_002dexpand"><span class="category-def">syntax: </span><span><strong class="def-name">cond-expand</strong> <var class="def-var-arguments">(feature body…) …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cond_002dexpand"> ¶</a></span></dt>
<dd><p>Expand to the <var class="var">body</var> of the first clause whose <var class="var">feature</var>
specification is satisfied.  It is an error if no <var class="var">feature</var> is
satisfied.
</p>
<p>Features are symbols such as <code class="code">srfi-1</code>, and a feature
specification can use <code class="code">and</code>, <code class="code">or</code> and <code class="code">not</code> forms to
test combinations.  The last clause can be an <code class="code">else</code>, to be used
if no other passes.
</p>
<p>For example, define a private version of <code class="code">alist-cons</code> if SRFI-1
is not available.
</p>
<div class="example">
<pre class="example-preformatted">(cond-expand (srfi-1
              )
             (else
              (define (alist-cons key val alist)
                (cons (cons key val) alist))))
</pre></div>

<p>Or demand a certain set of SRFIs (list operations, string ports,
<code class="code">receive</code> and string operations), failing if they’re not
available.
</p>
<div class="example">
<pre class="example-preformatted">(cond-expand ((and srfi-1 srfi-6 srfi-8 srfi-13)
              ))
</pre></div>
</dd></dl>

<p>The Guile core has the following features,
</p>
<div class="example">
<pre class="example-preformatted">guile
guile-2   ;; starting from Guile 2.x
guile-2.2 ;; starting from Guile 2.2
guile-3   ;; starting from Guile 3.x
guile-3.0 ;; starting from Guile 3.0
r5rs
r6rs
r7rs
exact-closed ieee-float full-unicode ratios ;; R7RS features
srfi-0
srfi-4
srfi-6
srfi-13
srfi-14
srfi-16
srfi-23
srfi-30
srfi-39
srfi-46
srfi-55
srfi-61
srfi-62
srfi-87
srfi-105
</pre></div>

<p>Other SRFI feature symbols are defined once their code has been loaded
with <code class="code">use-modules</code>, since only then are their bindings available.
</p>
<p>The ‘<samp class="samp">--use-srfi</samp>’ command line option (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Invoking-Guile">Invoking Guile</a>) is
a good way to load SRFIs to satisfy <code class="code">cond-expand</code> when running a
portable program.
</p>
<p>Testing the <code class="code">guile</code> feature allows a program to adapt itself to
the Guile module system, but still run on other Scheme systems.  For
example the following demands SRFI-8 (<code class="code">receive</code>), but also knows
how to load it with the Guile mechanism.
</p>
<div class="example">
<pre class="example-preformatted">(cond-expand (srfi-8
              )
             (guile
              (use-modules (srfi srfi-8))))
</pre></div>

<a class="index-entry-id" id="index-guile_002d2-SRFI_002d0-feature"></a>
<a class="index-entry-id" id="index-portability-between-2_002e0-and-older-versions"></a>
<p>Likewise, testing the <code class="code">guile-2</code> feature allows code to be portable
between Guile 2.<var class="var">x</var> and previous versions of Guile.  For instance, it
makes it possible to write code that accounts for Guile 2.<var class="var">x</var>’s compiler,
yet be correctly interpreted on 1.8 and earlier versions:
</p>
<div class="example">
<pre class="example-preformatted">(cond-expand (guile-2 (eval-when (compile)
                        ;; This must be evaluated at compile time.
                        (fluid-set! current-reader my-reader)))
             (guile
                      ;; Earlier versions of Guile do not have a
                      ;; separate compilation phase.
                      (fluid-set! current-reader my-reader)))
</pre></div>

<p>It should be noted that <code class="code">cond-expand</code> is separate from the
<code class="code">*features*</code> mechanism (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Feature-Tracking">Feature Tracking</a>), feature
symbols in one are unrelated to those in the other.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d1">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d2" accesskey="n" rel="next">SRFI-2 - and-let*</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d0" accesskey="p" rel="prev">SRFI-0 - cond-expand</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d1-_002d-List-library">7.5.3 SRFI-1 - List library</h4>
<a class="index-entry-id" id="index-SRFI_002d1"></a>
<a class="index-entry-id" id="index-list"></a>


<p>The list library defined in SRFI-1 contains a lot of useful list
processing procedures for construction, examining, destructuring and
manipulating lists and pairs.
</p>
<p>Since SRFI-1 also defines some procedures which are already contained
in R5RS and thus are supported by the Guile core library, some list
and pair procedures which appear in the SRFI-1 document may not appear
in this section.  So when looking for a particular list/pair
processing procedure, you should also have a look at the sections
<a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Lists">Lists</a> and <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Pairs">Pairs</a>.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Constructors" accesskey="1">Constructors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Predicates" accesskey="2">Predicates</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors" accesskey="3">Selectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Length-Append-etc" accesskey="4">Length, Append, Concatenate, etc.</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Fold-and-Map" accesskey="5">Fold, Unfold &amp; Map</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Filtering-and-Partitioning" accesskey="6">Filtering and Partitioning</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching" accesskey="7">Searching</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Deleting" accesskey="8">Deleting</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists" accesskey="9">Association Lists</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Set-Operations">Set Operations on Lists</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="SRFI_002d1-Constructors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Predicates" accesskey="n" rel="next">Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Constructors">7.5.3.1 Constructors</h4>
<a class="index-entry-id" id="index-list-constructor"></a>


<p>New lists can be constructed by calling one of the following
procedures.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-xcons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">xcons</strong> <var class="def-var-arguments">d a</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-xcons"> ¶</a></span></dt>
<dd><p>Like <code class="code">cons</code>, but with interchanged arguments.  Useful mostly when
passed to higher-order procedures.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dtabulate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-tabulate</strong> <var class="def-var-arguments">n init-proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dtabulate"> ¶</a></span></dt>
<dd><p>Return an <var class="var">n</var>-element list, where each list element is produced by
applying the procedure <var class="var">init-proc</var> to the corresponding list
index.  The order in which <var class="var">init-proc</var> is applied to the indices
is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dcopy-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-copy</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dcopy-1"> ¶</a></span></dt>
<dd><p>Return a new list containing the elements of the list <var class="var">lst</var>.
</p>
<p>This function differs from the core <code class="code">list-copy</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Constructors">List Constructors</a>) in accepting improper lists too.  And if <var class="var">lst</var> is
not a pair at all then it’s treated as the final tail of an improper
list and simply returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-circular_002dlist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">circular-list</strong> <var class="def-var-arguments">elt1 elt2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-circular_002dlist"> ¶</a></span></dt>
<dd><p>Return a circular list containing the given arguments <var class="var">elt1</var>
<var class="var">elt2</var> ….
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-iota"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">iota</strong> <var class="def-var-arguments">count [start step]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-iota"> ¶</a></span></dt>
<dd><p>Return a list containing <var class="var">count</var> numbers, starting from
<var class="var">start</var> and adding <var class="var">step</var> each time.  The default <var class="var">start</var>
is 0, the default <var class="var">step</var> is 1.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(iota 6)        ⇒ (0 1 2 3 4 5)
(iota 4 2.5 -2) ⇒ (2.5 0.5 -1.5 -3.5)
</pre></div>

<p>This function takes its name from the corresponding primitive in the
APL language.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Predicates">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors" accesskey="n" rel="next">Selectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Constructors" accesskey="p" rel="prev">Constructors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Predicates">7.5.3.2 Predicates</h4>
<a class="index-entry-id" id="index-list-predicate"></a>


<p>The procedures in this section test specific properties of lists.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-proper_002dlist_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">proper-list?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-proper_002dlist_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a proper list, or <code class="code">#f</code>
otherwise.  This is the same as the core <code class="code">list?</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Predicates">List Predicates</a>).
</p>
<p>A proper list is a list which ends with the empty list <code class="code">()</code> in
the usual way.  The empty list <code class="code">()</code> itself is a proper list too.
</p>
<div class="example">
<pre class="example-preformatted">(proper-list? '(1 2 3))  ⇒ #t
(proper-list? '())       ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-circular_002dlist_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">circular-list?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-circular_002dlist_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a circular list, or <code class="code">#f</code>
otherwise.
</p>
<p>A circular list is a list where at some point the <code class="code">cdr</code> refers
back to a previous pair in the list (either the start or some later
point), so that following the <code class="code">cdr</code>s takes you around in a
circle, with no end.
</p>
<div class="example">
<pre class="example-preformatted">(define x (list 1 2 3 4))
(set-cdr! (last-pair x) (cddr x))
x ⇒ (1 2 3 4 3 4 3 4 ...)
(circular-list? x)  ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-dotted_002dlist_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">dotted-list?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-dotted_002dlist_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a dotted list, or <code class="code">#f</code>
otherwise.
</p>
<p>A dotted list is a list where the <code class="code">cdr</code> of the last pair is not
the empty list <code class="code">()</code>.  Any non-pair <var class="var">obj</var> is also considered a
dotted list, with length zero.
</p>
<div class="example">
<pre class="example-preformatted">(dotted-list? '(1 2 . 3))  ⇒ #t
(dotted-list? 99)          ⇒ #t
</pre></div>
</dd></dl>

<p>It will be noted that any Scheme object passes exactly one of the
above three tests <code class="code">proper-list?</code>, <code class="code">circular-list?</code> and
<code class="code">dotted-list?</code>.  Non-lists are <code class="code">dotted-list?</code>, finite lists
are either <code class="code">proper-list?</code> or <code class="code">dotted-list?</code>, and infinite
lists are <code class="code">circular-list?</code>.
</p>
<br>
<dl class="first-deffn">
<dt class="deffn" id="index-null_002dlist_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">null-list?</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-null_002dlist_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">lst</var> is the empty list <code class="code">()</code>, <code class="code">#f</code>
otherwise.  If something else than a proper or circular list is passed
as <var class="var">lst</var>, an error is signalled.  This procedure is recommended
for checking for the end of a list in contexts where dotted lists are
not allowed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-not_002dpair_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">not-pair?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-not_002dpair_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> is <var class="var">obj</var> is not a pair, <code class="code">#f</code> otherwise.
This is shorthand notation <code class="code">(not (pair? <var class="var">obj</var>))</code> and is
supposed to be used for end-of-list checking in contexts where dotted
lists are allowed.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list=</strong> <var class="def-var-arguments">elt= list1 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_003d"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if all argument lists are equal, <code class="code">#f</code> otherwise.
List equality is determined by testing whether all lists have the same
length and the corresponding elements are equal in the sense of the
equality predicate <var class="var">elt=</var>.  If no or only one list is given,
<code class="code">#t</code> is returned.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Selectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Length-Append-etc" accesskey="n" rel="next">Length, Append, Concatenate, etc.</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Predicates" accesskey="p" rel="prev">Predicates</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Selectors">7.5.3.3 Selectors</h4>
<a class="index-entry-id" id="index-list-selector"></a>


<dl class="first-deffn">
<dt class="deffn" id="index-first"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">first</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-first"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-second"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">second</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-second"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-third"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">third</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-third"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fourth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fourth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fourth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fifth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fifth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fifth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-sixth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">sixth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-sixth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-seventh"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">seventh</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-seventh"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-eighth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">eighth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-eighth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-ninth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">ninth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-ninth"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-tenth"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">tenth</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-tenth"> ¶</a></span></dt>
<dd><p>These are synonyms for <code class="code">car</code>, <code class="code">cadr</code>, <code class="code">caddr</code>, ….
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-car_002bcdr"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">car+cdr</strong> <var class="def-var-arguments">pair</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-car_002bcdr"> ¶</a></span></dt>
<dd><p>Return two values, the <small class="sc">CAR</small> and the <small class="sc">CDR</small> of <var class="var">pair</var>.
</p></dd></dl>

<div class="example lisp">
<pre class="lisp-preformatted">(car+cdr '(0 1 2 3))
⇒
0
(1 2 3)
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-take"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">take</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-take"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-take_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">take!</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-take_0021"> ¶</a></span></dt>
<dd><p>Return a list containing the first <var class="var">i</var> elements of <var class="var">lst</var>.
</p>
<p><code class="code">take!</code> may modify the structure of the argument list <var class="var">lst</var>
in order to produce the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-drop"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">drop</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-drop"> ¶</a></span></dt>
<dd><p>Return a list containing all but the first <var class="var">i</var> elements of
<var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-take_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">take-right</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-take_002dright"> ¶</a></span></dt>
<dd><p>Return a list containing the <var class="var">i</var> last elements of <var class="var">lst</var>.
The return shares a common tail with <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-drop_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">drop-right</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-drop_002dright"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-drop_002dright_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">drop-right!</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-drop_002dright_0021"> ¶</a></span></dt>
<dd><p>Return a list containing all but the <var class="var">i</var> last elements of
<var class="var">lst</var>.
</p>
<p><code class="code">drop-right</code> always returns a new list, even when <var class="var">i</var> is
zero.  <code class="code">drop-right!</code> may modify the structure of the argument
list <var class="var">lst</var> in order to produce the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-split_002dat"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">split-at</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-split_002dat"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-split_002dat_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">split-at!</strong> <var class="def-var-arguments">lst i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-split_002dat_0021"> ¶</a></span></dt>
<dd><p>Return two values, a list containing the first <var class="var">i</var> elements of the
list <var class="var">lst</var> and a list containing the remaining elements.
</p>
<p><code class="code">split-at!</code> may modify the structure of the argument list
<var class="var">lst</var> in order to produce the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-last"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">last</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-last"> ¶</a></span></dt>
<dd><p>Return the last element of the non-empty, finite list <var class="var">lst</var>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Length-Append-etc">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Fold-and-Map" accesskey="n" rel="next">Fold, Unfold &amp; Map</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Selectors" accesskey="p" rel="prev">Selectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Length_002c-Append_002c-Concatenate_002c-etc_002e">7.5.3.4 Length, Append, Concatenate, etc.</h4>


<dl class="first-deffn">
<dt class="deffn" id="index-length_002b"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">length+</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-length_002b"> ¶</a></span></dt>
<dd><p>Return the length of the argument list <var class="var">lst</var>.  When <var class="var">lst</var> is a
circular list, <code class="code">#f</code> is returned.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-concatenate"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">concatenate</strong> <var class="def-var-arguments">list-of-lists</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-concatenate"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-concatenate_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">concatenate!</strong> <var class="def-var-arguments">list-of-lists</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-concatenate_0021"> ¶</a></span></dt>
<dd><p>Construct a list by appending all lists in <var class="var">list-of-lists</var>.
</p>
<p><code class="code">concatenate!</code> may modify the structure of the given lists in
order to produce the result.
</p>
<p><code class="code">concatenate</code> is the same as <code class="code">(apply append
<var class="var">list-of-lists</var>)</code>.  It exists because some Scheme implementations
have a limit on the number of arguments a function takes, which the
<code class="code">apply</code> might exceed.  In Guile there is no such limit.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-append_002dreverse"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append-reverse</strong> <var class="def-var-arguments">rev-head tail</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_002dreverse"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-append_002dreverse_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append-reverse!</strong> <var class="def-var-arguments">rev-head tail</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_002dreverse_0021"> ¶</a></span></dt>
<dd><p>Reverse <var class="var">rev-head</var>, append <var class="var">tail</var> to it, and return the
result.  This is equivalent to <code class="code">(append (reverse <var class="var">rev-head</var>)
<var class="var">tail</var>)</code>, but its implementation is more efficient.
</p>
<div class="example">
<pre class="example-preformatted">(append-reverse '(1 2 3) '(4 5 6)) ⇒ (3 2 1 4 5 6)
</pre></div>

<p><code class="code">append-reverse!</code> may modify <var class="var">rev-head</var> in order to produce
the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-zip"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">zip</strong> <var class="def-var-arguments">lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-zip"> ¶</a></span></dt>
<dd><p>Return a list as long as the shortest of the argument lists, where
each element is a list.  The first list contains the first elements of
the argument lists, the second list contains the second elements, and
so on.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unzip1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unzip1</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unzip1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-unzip2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unzip2</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unzip2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-unzip3"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unzip3</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unzip3"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-unzip4"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unzip4</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unzip4"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-unzip5"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unzip5</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unzip5"> ¶</a></span></dt>
<dd><p><code class="code">unzip1</code> takes a list of lists, and returns a list containing the
first elements of each list, <code class="code">unzip2</code> returns two lists, the
first containing the first elements of each lists and the second
containing the second elements of each lists, and so on.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-count"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">count</strong> <var class="def-var-arguments">pred lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-count"> ¶</a></span></dt>
<dd><p>Return a count of the number of times <var class="var">pred</var> returns true when
called on elements from the given lists.
</p>
<p><var class="var">pred</var> is called with <var class="var">N</var> parameters <code class="code">(<var class="var">pred</var>
<var class="var">elem1</var> … <var class="var">elemN</var> )</code>, each element being from the
corresponding list.  The first call is with the first element of each
list, the second with the second element from each, and so on.
</p>
<p>Counting stops when the end of the shortest list is reached.  At least
one list must be non-circular.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Fold-and-Map">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Filtering-and-Partitioning" accesskey="n" rel="next">Filtering and Partitioning</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Length-Append-etc" accesskey="p" rel="prev">Length, Append, Concatenate, etc.</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Fold_002c-Unfold-_0026-Map">7.5.3.5 Fold, Unfold &amp; Map</h4>
<a class="index-entry-id" id="index-list-fold"></a>
<a class="index-entry-id" id="index-list-map"></a>


<dl class="first-deffn">
<dt class="deffn" id="index-fold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fold</strong> <var class="def-var-arguments">proc init lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-fold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">fold-right</strong> <var class="def-var-arguments">proc init lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-fold_002dright"> ¶</a></span></dt>
<dd><p>Apply <var class="var">proc</var> to the elements of <var class="var">lst1</var> <var class="var">lst2</var> … to
build a result, and return that result.
</p>
<p>Each <var class="var">proc</var> call is <code class="code">(<var class="var">proc</var> <var class="var">elem1</var> <var class="var">elem2</var>
…  <var class="var">previous</var>)</code>, where <var class="var">elem1</var> is from <var class="var">lst1</var>,
<var class="var">elem2</var> is from <var class="var">lst2</var>, and so on.  <var class="var">previous</var> is the return
from the previous call to <var class="var">proc</var>, or the given <var class="var">init</var> for the
first call.  If any list is empty, just <var class="var">init</var> is returned.
</p>
<p><code class="code">fold</code> works through the list elements from first to last.  The
following shows a list reversal and the calls it makes,
</p>
<div class="example">
<pre class="example-preformatted">(fold cons '() '(1 2 3))

(cons 1 '())
(cons 2 '(1))
(cons 3 '(2 1)
⇒ (3 2 1)
</pre></div>

<p><code class="code">fold-right</code> works through the list elements from last to first,
ie. from the right.  So for example the following finds the longest
string, and the last among equal longest,
</p>
<div class="example">
<pre class="example-preformatted">(fold-right (lambda (str prev)
              (if (&gt; (string-length str) (string-length prev))
                  str
                  prev))
            ""
            '("x" "abc" "xyz" "jk"))
⇒ "xyz"
</pre></div>

<p>If <var class="var">lst1</var> <var class="var">lst2</var> … have different lengths, <code class="code">fold</code>
stops when the end of the shortest is reached; <code class="code">fold-right</code>
commences at the last element of the shortest.  Ie. elements past the
length of the shortest are ignored in the other <var class="var">lst</var>s.  At least
one <var class="var">lst</var> must be non-circular.
</p>
<p><code class="code">fold</code> should be preferred over <code class="code">fold-right</code> if the order of
processing doesn’t matter, or can be arranged either way, since
<code class="code">fold</code> is a little more efficient.
</p>
<p>The way <code class="code">fold</code> builds a result from iterating is quite general,
it can do more than other iterations like say <code class="code">map</code> or
<code class="code">filter</code>.  The following for example removes adjacent duplicate
elements from a list,
</p>
<div class="example">
<pre class="example-preformatted">(define (delete-adjacent-duplicates lst)
  (fold-right (lambda (elem ret)
                (if (equal? elem (first ret))
                    ret
                    (cons elem ret)))
              (list (last lst))
              lst))
(delete-adjacent-duplicates '(1 2 3 3 4 4 4 5))
⇒ (1 2 3 4 5)
</pre></div>

<p>Clearly the same sort of thing can be done with a <code class="code">for-each</code> and
a variable in which to build the result, but a self-contained
<var class="var">proc</var> can be re-used in multiple contexts, where a
<code class="code">for-each</code> would have to be written out each time.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pair_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pair-fold</strong> <var class="def-var-arguments">proc init lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pair_002dfold"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-pair_002dfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pair-fold-right</strong> <var class="def-var-arguments">proc init lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pair_002dfold_002dright"> ¶</a></span></dt>
<dd><p>The same as <code class="code">fold</code> and <code class="code">fold-right</code>, but apply <var class="var">proc</var> to
the pairs of the lists instead of the list elements.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-reduce"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reduce</strong> <var class="def-var-arguments">proc default lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reduce"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-reduce_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">reduce-right</strong> <var class="def-var-arguments">proc default lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-reduce_002dright"> ¶</a></span></dt>
<dd><p><code class="code">reduce</code> is a variant of <code class="code">fold</code>, where the first call to
<var class="var">proc</var> is on two elements from <var class="var">lst</var>, rather than one element
and a given initial value.
</p>
<p>If <var class="var">lst</var> is empty, <code class="code">reduce</code> returns <var class="var">default</var> (this is
the only use for <var class="var">default</var>).  If <var class="var">lst</var> has just one element
then that’s the return value.  Otherwise <var class="var">proc</var> is called on the
elements of <var class="var">lst</var>.
</p>
<p>Each <var class="var">proc</var> call is <code class="code">(<var class="var">proc</var> <var class="var">elem</var> <var class="var">previous</var>)</code>,
where <var class="var">elem</var> is from <var class="var">lst</var> (the second and subsequent elements
of <var class="var">lst</var>), and <var class="var">previous</var> is the return from the previous call
to <var class="var">proc</var>.  The first element of <var class="var">lst</var> is the <var class="var">previous</var>
for the first call to <var class="var">proc</var>.
</p>
<p>For example, the following adds a list of numbers, the calls made to
<code class="code">+</code> are shown.  (Of course <code class="code">+</code> accepts multiple arguments
and can add a list directly, with <code class="code">apply</code>.)
</p>
<div class="example">
<pre class="example-preformatted">(reduce + 0 '(5 6 7)) ⇒ 18

(+ 6 5)  ⇒ 11
(+ 7 11) ⇒ 18
</pre></div>

<p><code class="code">reduce</code> can be used instead of <code class="code">fold</code> where the <var class="var">init</var>
value is an “identity”, meaning a value which under <var class="var">proc</var>
doesn’t change the result, in this case 0 is an identity since
<code class="code">(+ 5 0)</code> is just 5.  <code class="code">reduce</code> avoids that unnecessary call.
</p>
<p><code class="code">reduce-right</code> is a similar variation on <code class="code">fold-right</code>,
working from the end (ie. the right) of <var class="var">lst</var>.  The last element
of <var class="var">lst</var> is the <var class="var">previous</var> for the first call to <var class="var">proc</var>,
and the <var class="var">elem</var> values go from the second last.
</p>
<p><code class="code">reduce</code> should be preferred over <code class="code">reduce-right</code> if the
order of processing doesn’t matter, or can be arranged either way,
since <code class="code">reduce</code> is a little more efficient.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unfold</strong> <var class="def-var-arguments">p f g seed [tail-gen]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unfold"> ¶</a></span></dt>
<dd><p><code class="code">unfold</code> is defined as follows:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(unfold p f g seed) =
   (if (p seed) (tail-gen seed)
       (cons (f seed)
             (unfold p f g (g seed))))
</pre></div>

<dl class="table">
<dt><var class="var">p</var></dt>
<dd><p>Determines when to stop unfolding.
</p>
</dd>
<dt><var class="var">f</var></dt>
<dd><p>Maps each seed value to the corresponding list element.
</p>
</dd>
<dt><var class="var">g</var></dt>
<dd><p>Maps each seed value to next seed value.
</p>
</dd>
<dt><var class="var">seed</var></dt>
<dd><p>The state value for the unfold.
</p>
</dd>
<dt><var class="var">tail-gen</var></dt>
<dd><p>Creates the tail of the list; defaults to <code class="code">(lambda (x) '())</code>.
</p></dd>
</dl>

<p><var class="var">g</var> produces a series of seed values, which are mapped to list
elements by <var class="var">f</var>.  These elements are put into a list in
left-to-right order, and <var class="var">p</var> tells when to stop unfolding.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-unfold_002dright"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">unfold-right</strong> <var class="def-var-arguments">p f g seed [tail]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-unfold_002dright"> ¶</a></span></dt>
<dd><p>Construct a list with the following loop.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let lp ((seed seed) (lis tail))
   (if (p seed) lis
       (lp (g seed)
           (cons (f seed) lis))))
</pre></div>

<dl class="table">
<dt><var class="var">p</var></dt>
<dd><p>Determines when to stop unfolding.
</p>
</dd>
<dt><var class="var">f</var></dt>
<dd><p>Maps each seed value to the corresponding list element.
</p>
</dd>
<dt><var class="var">g</var></dt>
<dd><p>Maps each seed value to next seed value.
</p>
</dd>
<dt><var class="var">seed</var></dt>
<dd><p>The state value for the unfold.
</p>
</dd>
<dt><var class="var">tail</var></dt>
<dd><p>The tail of the list; defaults to <code class="code">'()</code>.
</p></dd>
</dl>

</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-map-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">map</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-map-1"> ¶</a></span></dt>
<dd><p>Map the procedure over the list(s) <var class="var">lst1</var>, <var class="var">lst2</var>, … and
return a list containing the results of the procedure applications.
This procedure is extended with respect to R5RS, because the argument
lists may have different lengths.  The result list will have the same
length as the shortest argument lists.  The order in which <var class="var">f</var>
will be applied to the list element(s) is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-for_002deach-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">for-each</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-for_002deach-1"> ¶</a></span></dt>
<dd><p>Apply the procedure <var class="var">f</var> to each pair of corresponding elements of
the list(s) <var class="var">lst1</var>, <var class="var">lst2</var>, ….  The return value is not
specified.  This procedure is extended with respect to R5RS, because
the argument lists may have different lengths.  The shortest argument
list determines the number of times <var class="var">f</var> is called.  <var class="var">f</var> will
be applied to the list elements in left-to-right order.
</p>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-append_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append-map</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_002dmap"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-append_002dmap_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">append-map!</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-append_002dmap_0021"> ¶</a></span></dt>
<dd><p>Equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(apply append (map f clist1 clist2 ...))
</pre></div>

<p>and
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(apply append! (map f clist1 clist2 ...))
</pre></div>

<p>Map <var class="var">f</var> over the elements of the lists, just as in the <code class="code">map</code>
function. However, the results of the applications are appended
together to make the final result. <code class="code">append-map</code> uses
<code class="code">append</code> to append the results together; <code class="code">append-map!</code> uses
<code class="code">append!</code>.
</p>
<p>The dynamic order in which the various applications of <var class="var">f</var> are
made is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-map_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">map!</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-map_0021"> ¶</a></span></dt>
<dd><p>Linear-update variant of <code class="code">map</code> – <code class="code">map!</code> is allowed, but not
required, to alter the cons cells of <var class="var">lst1</var> to construct the
result list.
</p>
<p>The dynamic order in which the various applications of <var class="var">f</var> are
made is not specified. In the n-ary case, <var class="var">lst2</var>, <var class="var">lst3</var>,
… must have at least as many elements as <var class="var">lst1</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-pair_002dfor_002deach"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">pair-for-each</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-pair_002dfor_002deach"> ¶</a></span></dt>
<dd><p>Like <code class="code">for-each</code>, but applies the procedure <var class="var">f</var> to the pairs
from which the argument lists are constructed, instead of the list
elements.  The return value is not specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-filter_002dmap"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">filter-map</strong> <var class="def-var-arguments">f lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-filter_002dmap"> ¶</a></span></dt>
<dd><p>Like <code class="code">map</code>, but only results from the applications of <var class="var">f</var>
which are true are saved in the result list.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Filtering-and-Partitioning">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching" accesskey="n" rel="next">Searching</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Fold-and-Map" accesskey="p" rel="prev">Fold, Unfold &amp; Map</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Filtering-and-Partitioning">7.5.3.6 Filtering and Partitioning</h4>
<a class="index-entry-id" id="index-list-filter"></a>
<a class="index-entry-id" id="index-list-partition"></a>


<p>Filtering means to collect all elements from a list which satisfy a
specific condition.  Partitioning a list means to make two groups of
list elements, one which contains the elements satisfying a condition,
and the other for the elements which don’t.
</p>
<p>The <code class="code">filter</code> and <code class="code">filter!</code> functions are implemented in the
Guile core, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification">List Modification</a>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-partition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">partition</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-partition"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-partition_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">partition!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-partition_0021"> ¶</a></span></dt>
<dd><p>Split <var class="var">lst</var> into those elements which do and don’t satisfy the
predicate <var class="var">pred</var>.
</p>
<p>The return is two values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>), the first being a
list of all elements from <var class="var">lst</var> which satisfy <var class="var">pred</var>, the
second a list of those which do not.
</p>
<p>The elements in the result lists are in the same order as in <var class="var">lst</var>
but the order in which the calls <code class="code">(<var class="var">pred</var> elem)</code> are made on
the list elements is unspecified.
</p>
<p><code class="code">partition</code> does not change <var class="var">lst</var>, but one of the returned
lists may share a tail with it.  <code class="code">partition!</code> may modify
<var class="var">lst</var> to construct its return.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-remove"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">remove</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-remove"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-remove_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">remove!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-remove_0021"> ¶</a></span></dt>
<dd><p>Return a list containing all elements from <var class="var">lst</var> which do not
satisfy the predicate <var class="var">pred</var>.  The elements in the result list
have the same order as in <var class="var">lst</var>.  The order in which <var class="var">pred</var> is
applied to the list elements is not specified.
</p>
<p><code class="code">remove!</code> is allowed, but not required to modify the structure of
the input list.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Searching">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Deleting" accesskey="n" rel="next">Deleting</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Filtering-and-Partitioning" accesskey="p" rel="prev">Filtering and Partitioning</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Searching">7.5.3.7 Searching</h4>
<a class="index-entry-id" id="index-list-search"></a>


<p>The procedures for searching elements in lists either accept a
predicate or a comparison object for determining which elements are to
be searched.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-find"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">find</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-find"> ¶</a></span></dt>
<dd><p>Return the first element of <var class="var">lst</var> that satisfies the predicate
<var class="var">pred</var> and <code class="code">#f</code> if no such element is found.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-find_002dtail"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">find-tail</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-find_002dtail"> ¶</a></span></dt>
<dd><p>Return the first pair of <var class="var">lst</var> whose <small class="sc">CAR</small> satisfies the
predicate <var class="var">pred</var> and <code class="code">#f</code> if no such element is found.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-take_002dwhile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">take-while</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-take_002dwhile"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-take_002dwhile_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">take-while!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-take_002dwhile_0021"> ¶</a></span></dt>
<dd><p>Return the longest initial prefix of <var class="var">lst</var> whose elements all
satisfy the predicate <var class="var">pred</var>.
</p>
<p><code class="code">take-while!</code> is allowed, but not required to modify the input
list while producing the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-drop_002dwhile"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">drop-while</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-drop_002dwhile"> ¶</a></span></dt>
<dd><p>Drop the longest initial prefix of <var class="var">lst</var> whose elements all
satisfy the predicate <var class="var">pred</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-span"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">span</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-span"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-span_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">span!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-span_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-break-2"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">break</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-break-2"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-break_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">break!</strong> <var class="def-var-arguments">pred lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-break_0021"> ¶</a></span></dt>
<dd><p><code class="code">span</code> splits the list <var class="var">lst</var> into the longest initial prefix
whose elements all satisfy the predicate <var class="var">pred</var>, and the remaining
tail.  <code class="code">break</code> inverts the sense of the predicate.
</p>
<p><code class="code">span!</code> and <code class="code">break!</code> are allowed, but not required to modify
the structure of the input list <var class="var">lst</var> in order to produce the
result.
</p>
<p>Note that the name <code class="code">break</code> conflicts with the <code class="code">break</code>
binding established by <code class="code">while</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#while-do">Iteration mechanisms</a>).  Applications
wanting to use <code class="code">break</code> from within a <code class="code">while</code> loop will need
to make a new define under a different name.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-any"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any</strong> <var class="def-var-arguments">pred lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any"> ¶</a></span></dt>
<dd><p>Test whether any set of elements from <var class="var">lst1</var> <var class="var">lst2</var> …
satisfies <var class="var">pred</var>.  If so, the return value is the return value from
the successful <var class="var">pred</var> call, or if not, the return value is
<code class="code">#f</code>.
</p>
<p>If there are n list arguments, then <var class="var">pred</var> must be a predicate
taking n arguments.  Each <var class="var">pred</var> call is <code class="code">(<var class="var">pred</var>
<var class="var">elem1</var> <var class="var">elem2</var> … )</code> taking an element from each
<var class="var">lst</var>.  The calls are made successively for the first, second, etc.
elements of the lists, stopping when <var class="var">pred</var> returns non-<code class="code">#f</code>,
or when the end of the shortest list is reached.
</p>
<p>The <var class="var">pred</var> call on the last set of elements (i.e., when the end of
the shortest list has been reached), if that point is reached, is a
tail call.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-every"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">every</strong> <var class="def-var-arguments">pred lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-every"> ¶</a></span></dt>
<dd><p>Test whether every set of elements from <var class="var">lst1</var> <var class="var">lst2</var> …
satisfies <var class="var">pred</var>.  If so, the return value is the return from the
final <var class="var">pred</var> call, or if not, the return value is <code class="code">#f</code>.
</p>
<p>If there are n list arguments, then <var class="var">pred</var> must be a predicate
taking n arguments.  Each <var class="var">pred</var> call is <code class="code">(<var class="var">pred</var>
<var class="var">elem1</var> <var class="var">elem2 …</var>)</code> taking an element from each
<var class="var">lst</var>.  The calls are made successively for the first, second, etc.
elements of the lists, stopping if <var class="var">pred</var> returns <code class="code">#f</code>, or when
the end of any of the lists is reached.
</p>
<p>The <var class="var">pred</var> call on the last set of elements (i.e., when the end of
the shortest list has been reached) is a tail call.
</p>
<p>If one of <var class="var">lst1</var> <var class="var">lst2</var> …is empty then no calls to
<var class="var">pred</var> are made, and the return value is <code class="code">#t</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002dindex"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-index</strong> <var class="def-var-arguments">pred lst1 lst2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002dindex"> ¶</a></span></dt>
<dd><p>Return the index of the first set of elements, one from each of
<var class="var">lst1</var> <var class="var">lst2</var> …, which satisfies <var class="var">pred</var>.
</p>
<p><var class="var">pred</var> is called as <code class="code">(<var class="var">elem1</var> <var class="var">elem2 …</var>)</code>.
Searching stops when the end of the shortest <var class="var">lst</var> is reached.
The return index starts from 0 for the first set of elements.  If no
set of elements pass, then the return value is <code class="code">#f</code>.
</p>
<div class="example">
<pre class="example-preformatted">(list-index odd? '(2 4 6 9))      ⇒ 3
(list-index = '(1 2 3) '(3 1 2))  ⇒ #f
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-member-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">member</strong> <var class="def-var-arguments">x lst [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-member-1"> ¶</a></span></dt>
<dd><p>Return the first sublist of <var class="var">lst</var> whose <small class="sc">CAR</small> is equal to
<var class="var">x</var>.  If <var class="var">x</var> does not appear in <var class="var">lst</var>, return <code class="code">#f</code>.
</p>
<p>Equality is determined by <code class="code">equal?</code>, or by the equality predicate
<var class="var">=</var> if given.  <var class="var">=</var> is called <code class="code">(= <var class="var">x</var> elem)</code>,
ie. with the given <var class="var">x</var> first, so for example to find the first
element greater than 5,
</p>
<div class="example">
<pre class="example-preformatted">(member 5 '(3 5 1 7 2 9) &lt;) ⇒ (7 2 9)
</pre></div>

<p>This version of <code class="code">member</code> extends the core <code class="code">member</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Searching">List Searching</a>) by accepting an equality predicate.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Deleting">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists" accesskey="n" rel="next">Association Lists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Searching" accesskey="p" rel="prev">Searching</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Deleting">7.5.3.8 Deleting</h4>
<a class="index-entry-id" id="index-list-delete"></a>

<dl class="first-deffn">
<dt class="deffn" id="index-delete-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete</strong> <var class="def-var-arguments">x lst [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete-1"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-delete_0021-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete!</strong> <var class="def-var-arguments">x lst [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_0021-1"> ¶</a></span></dt>
<dd><p>Return a list containing the elements of <var class="var">lst</var> but with those
equal to <var class="var">x</var> deleted.  The returned elements will be in the same
order as they were in <var class="var">lst</var>.
</p>
<p>Equality is determined by the <var class="var">=</var> predicate, or <code class="code">equal?</code> if
not given.  An equality call is made just once for each element, but
the order in which the calls are made on the elements is unspecified.
</p>
<p>The equality calls are always <code class="code">(= x elem)</code>, ie. the given <var class="var">x</var>
is first.  This means for instance elements greater than 5 can be
deleted with <code class="code">(delete 5 lst &lt;)</code>.
</p>
<p><code class="code">delete</code> does not modify <var class="var">lst</var>, but the return might share a
common tail with <var class="var">lst</var>.  <code class="code">delete!</code> may modify the structure
of <var class="var">lst</var> to construct its return.
</p>
<p>These functions extend the core <code class="code">delete</code> and <code class="code">delete!</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#List-Modification">List Modification</a>) in accepting an equality predicate.  See
also <code class="code">lset-difference</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Set-Operations">Set Operations on Lists</a>) for
deleting multiple elements from a list.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-delete_002dduplicates"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete-duplicates</strong> <var class="def-var-arguments">lst [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_002dduplicates"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-delete_002dduplicates_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">delete-duplicates!</strong> <var class="def-var-arguments">lst [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-delete_002dduplicates_0021"> ¶</a></span></dt>
<dd><p>Return a list containing the elements of <var class="var">lst</var> but without
duplicates.
</p>
<p>When elements are equal, only the first in <var class="var">lst</var> is retained.
Equal elements can be anywhere in <var class="var">lst</var>, they don’t have to be
adjacent.  The returned list will have the retained elements in the
same order as they were in <var class="var">lst</var>.
</p>
<p>Equality is determined by the <var class="var">=</var> predicate, or <code class="code">equal?</code> if
not given.  Calls <code class="code">(= x y)</code> are made with element <var class="var">x</var> being
before <var class="var">y</var> in <var class="var">lst</var>.  A call is made at most once for each
combination, but the sequence of the calls across the elements is
unspecified.
</p>
<p><code class="code">delete-duplicates</code> does not modify <var class="var">lst</var>, but the return
might share a common tail with <var class="var">lst</var>.  <code class="code">delete-duplicates!</code>
may modify the structure of <var class="var">lst</var> to construct its return.
</p>
<p>In the worst case, this is an <em class="math">O(N^2)</em> algorithm because it must
check each element against all those preceding it.  For long lists it
is more efficient to sort and then compare only adjacent elements.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Association-Lists">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Set-Operations" accesskey="n" rel="next">Set Operations on Lists</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Deleting" accesskey="p" rel="prev">Deleting</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Association-Lists-2">7.5.3.9 Association Lists</h4>
<a class="index-entry-id" id="index-association-list"></a>
<a class="index-entry-id" id="index-alist-1"></a>


<p>Association lists are described in detail in section <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Association-Lists">Association Lists</a>.  The present section only documents the additional procedures
for dealing with association lists defined by SRFI-1.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-assoc-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">assoc</strong> <var class="def-var-arguments">key alist [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-assoc-1"> ¶</a></span></dt>
<dd><p>Return the pair from <var class="var">alist</var> which matches <var class="var">key</var>.  This
extends the core <code class="code">assoc</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Retrieving-Alist-Entries">Retrieving Alist Entries</a>) by
taking an optional <var class="var">=</var> comparison procedure.
</p>
<p>The default comparison is <code class="code">equal?</code>.  If an <var class="var">=</var> parameter is
given it’s called <code class="code">(<var class="var">=</var> <var class="var">key</var> <var class="var">alistcar</var>)</code>, i.e. the
given target <var class="var">key</var> is the first argument, and a <code class="code">car</code> from
<var class="var">alist</var> is second.
</p>
<p>For example a case-insensitive string lookup,
</p>
<div class="example">
<pre class="example-preformatted">(assoc "yy" '(("XX" . 1) ("YY" . 2)) string-ci=?)
⇒ ("YY" . 2)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alist_002dcons"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-cons</strong> <var class="def-var-arguments">key datum alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002dcons"> ¶</a></span></dt>
<dd><p>Cons a new association <var class="var">key</var> and <var class="var">datum</var> onto <var class="var">alist</var> and
return the result.  This is equivalent to
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(cons (cons <var class="var">key</var> <var class="var">datum</var>) <var class="var">alist</var>)
</pre></div>

<p><code class="code">acons</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Adding-or-Setting-Alist-Entries">Adding or Setting Alist Entries</a>) in the Guile
core does the same thing.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alist_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-copy</strong> <var class="def-var-arguments">alist</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002dcopy"> ¶</a></span></dt>
<dd><p>Return a newly allocated copy of <var class="var">alist</var>, that means that the
spine of the list as well as the pairs are copied.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-alist_002ddelete"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-delete</strong> <var class="def-var-arguments">key alist [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002ddelete"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-alist_002ddelete_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">alist-delete!</strong> <var class="def-var-arguments">key alist [=]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-alist_002ddelete_0021"> ¶</a></span></dt>
<dd><p>Return a list containing the elements of <var class="var">alist</var> but with those
elements whose keys are equal to <var class="var">key</var> deleted.  The returned
elements will be in the same order as they were in <var class="var">alist</var>.
</p>
<p>Equality is determined by the <var class="var">=</var> predicate, or <code class="code">equal?</code> if
not given.  The order in which elements are tested is unspecified, but
each equality call is made <code class="code">(= key alistkey)</code>, i.e. the given
<var class="var">key</var> parameter is first and the key from <var class="var">alist</var> second.
This means for instance all associations with a key greater than 5 can
be removed with <code class="code">(alist-delete 5 alist &lt;)</code>.
</p>
<p><code class="code">alist-delete</code> does not modify <var class="var">alist</var>, but the return might
share a common tail with <var class="var">alist</var>.  <code class="code">alist-delete!</code> may modify
the list structure of <var class="var">alist</var> to construct its return.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d1-Set-Operations">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1-Association-Lists" accesskey="p" rel="prev">Association Lists</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="u" rel="up">SRFI-1 - List library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Set-Operations-on-Lists">7.5.3.10 Set Operations on Lists</h4>
<a class="index-entry-id" id="index-list-set-operation"></a>

<p>Lists can be used to represent sets of objects.  The procedures in
this section operate on such lists as sets.
</p>
<p>Note that lists are not an efficient way to implement large sets.  The
procedures here typically take time <em class="math"><var class="var">m</var>x<var class="var">n</var></em> when
operating on <var class="var">m</var> and <var class="var">n</var> element lists.  Other data structures
like trees, bitsets (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bit-Vectors">Bit Vectors</a>) or hash tables (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">Hash Tables</a>) are faster.
</p>
<p>All these procedures take an equality predicate as the first argument.
This predicate is used for testing the objects in the list sets for
sameness.  This predicate must be consistent with <code class="code">eq?</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Equality">Equality</a>) in the sense that if two list elements are
<code class="code">eq?</code> then they must also be equal under the predicate.  This
simply means a given object must be equal to itself.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-lset_003c_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset&lt;=</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_003c_003d"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if each list is a subset of the one following it.
I.e., <var class="var">list1</var> is a subset of <var class="var">list2</var>, <var class="var">list2</var> is a subset of
<var class="var">list3</var>, etc., for as many lists as given.  If only one list or no
lists are given, the return value is <code class="code">#t</code>.
</p>
<p>A list <var class="var">x</var> is a subset of <var class="var">y</var> if each element of <var class="var">x</var> is
equal to some element in <var class="var">y</var>.  Elements are compared using the
given <var class="var">=</var> procedure, called as <code class="code">(<var class="var">=</var> xelem yelem)</code>.
</p>
<div class="example">
<pre class="example-preformatted">(lset&lt;= eq?)                      ⇒ #t
(lset&lt;= eqv? '(1 2 3) '(1))       ⇒ #f
(lset&lt;= eqv? '(1 3 2) '(4 3 1 2)) ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_003d"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset=</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_003d"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if all argument lists are set-equal.  <var class="var">list1</var> is
compared to <var class="var">list2</var>, <var class="var">list2</var> to <var class="var">list3</var>, etc., for as many
lists as given.  If only one list or no lists are given, the return
value is <code class="code">#t</code>.
</p>
<p>Two lists <var class="var">x</var> and <var class="var">y</var> are set-equal if each element of <var class="var">x</var>
is equal to some element of <var class="var">y</var> and conversely each element of
<var class="var">y</var> is equal to some element of <var class="var">x</var>.  The order of the
elements in the lists doesn’t matter.  Element equality is determined
with the given <var class="var">=</var> procedure, called as <code class="code">(<var class="var">=</var> xelem
yelem)</code>, but exactly which calls are made is unspecified.
</p>
<div class="example">
<pre class="example-preformatted">(lset= eq?)                      ⇒ #t
(lset= eqv? '(1 2 3) '(3 2 1))   ⇒ #t
(lset= string-ci=? '("a" "A" "b") '("B" "b" "a")) ⇒ #t
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002dadjoin"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-adjoin</strong> <var class="def-var-arguments">= list elem …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dadjoin"> ¶</a></span></dt>
<dd><p>Add to <var class="var">list</var> any of the given <var class="var">elem</var>s not already in the list.
<var class="var">elem</var>s are <code class="code">cons</code>ed onto the start of <var class="var">list</var> (so the
return value shares a common tail with <var class="var">list</var>), but the order that
the <var class="var">elem</var>s are added is unspecified.
</p>
<p>The given <var class="var">=</var> procedure is used for comparing elements, called as
<code class="code">(<var class="var">=</var> listelem elem)</code>, i.e., the second argument is one of
the given <var class="var">elem</var> parameters.
</p>
<div class="example">
<pre class="example-preformatted">(lset-adjoin eqv? '(1 2 3) 4 1 5) ⇒ (5 4 1 2 3)
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002dunion"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-union</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dunion"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lset_002dunion_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-union!</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dunion_0021"> ¶</a></span></dt>
<dd><p>Return the union of the argument list sets.  The result is built by
taking the union of <var class="var">list1</var> and <var class="var">list2</var>, then the union of
that with <var class="var">list3</var>, etc., for as many lists as given.  For one list
argument that list itself is the result, for no list arguments the
result is the empty list.
</p>
<p>The union of two lists <var class="var">x</var> and <var class="var">y</var> is formed as follows.  If
<var class="var">x</var> is empty then the result is <var class="var">y</var>.  Otherwise start with
<var class="var">x</var> as the result and consider each <var class="var">y</var> element (from first to
last).  A <var class="var">y</var> element not equal to something already in the result
is <code class="code">cons</code>ed onto the result.
</p>
<p>The given <var class="var">=</var> procedure is used for comparing elements, called as
<code class="code">(<var class="var">=</var> relem yelem)</code>.  The first argument is from the result
accumulated so far, and the second is from the list being union-ed in.
But exactly which calls are made is otherwise unspecified.
</p>
<p>Notice that duplicate elements in <var class="var">list1</var> (or the first non-empty
list) are preserved, but that repeated elements in subsequent lists
are only added once.
</p>
<div class="example">
<pre class="example-preformatted">(lset-union eqv?)                          ⇒ ()
(lset-union eqv? '(1 2 3))                 ⇒ (1 2 3)
(lset-union eqv? '(1 2 1 3) '(2 4 5) '(5)) ⇒ (5 4 1 2 1 3)
</pre></div>

<p><code class="code">lset-union</code> doesn’t change the given lists but the result may
share a tail with the first non-empty list.  <code class="code">lset-union!</code> can
modify all of the given lists to form the result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002dintersection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-intersection</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dintersection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lset_002dintersection_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-intersection!</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dintersection_0021"> ¶</a></span></dt>
<dd><p>Return the intersection of <var class="var">list1</var> with the other argument lists,
meaning those elements of <var class="var">list1</var> which are also in all of
<var class="var">list2</var> etc.  For one list argument, just that list is returned.
</p>
<p>The test for an element of <var class="var">list1</var> to be in the return is simply
that it’s equal to some element in each of <var class="var">list2</var> etc.  Notice
this means an element appearing twice in <var class="var">list1</var> but only once in
each of <var class="var">list2</var> etc will go into the return twice.  The return has
its elements in the same order as they were in <var class="var">list1</var>.
</p>
<p>The given <var class="var">=</var> procedure is used for comparing elements, called as
<code class="code">(<var class="var">=</var> elem1 elemN)</code>.  The first argument is from <var class="var">list1</var>
and the second is from one of the subsequent lists.  But exactly which
calls are made and in what order is unspecified.
</p>
<div class="example">
<pre class="example-preformatted">(lset-intersection eqv? '(x y))                        ⇒ (x y)
(lset-intersection eqv? '(1 2 3) '(4 3 2))             ⇒ (2 3)
(lset-intersection eqv? '(1 1 2 2) '(1 2) '(2 1) '(2)) ⇒ (2 2)
</pre></div>

<p>The return from <code class="code">lset-intersection</code> may share a tail with
<var class="var">list1</var>.  <code class="code">lset-intersection!</code> may modify <var class="var">list1</var> to form
its result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002ddifference"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-difference</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002ddifference"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lset_002ddifference_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-difference!</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002ddifference_0021"> ¶</a></span></dt>
<dd><p>Return <var class="var">list1</var> with any elements in <var class="var">list2</var>, <var class="var">list3</var> etc
removed (ie. subtracted).  For one list argument, just that list is
returned.
</p>
<p>The given <var class="var">=</var> procedure is used for comparing elements, called as
<code class="code">(<var class="var">=</var> elem1 elemN)</code>.  The first argument is from <var class="var">list1</var>
and the second from one of the subsequent lists.  But exactly which
calls are made and in what order is unspecified.
</p>
<div class="example">
<pre class="example-preformatted">(lset-difference eqv? '(x y))             ⇒ (x y)
(lset-difference eqv? '(1 2 3) '(3 1))    ⇒ (2)
(lset-difference eqv? '(1 2 3) '(3) '(2)) ⇒ (1)
</pre></div>

<p>The return from <code class="code">lset-difference</code> may share a tail with
<var class="var">list1</var>.  <code class="code">lset-difference!</code> may modify <var class="var">list1</var> to form
its result.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002ddiff_002bintersection"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-diff+intersection</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002ddiff_002bintersection"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lset_002ddiff_002bintersection_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-diff+intersection!</strong> <var class="def-var-arguments">= list1 list2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002ddiff_002bintersection_0021"> ¶</a></span></dt>
<dd><p>Return two values (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>), the difference and
intersection of the argument lists as per <code class="code">lset-difference</code> and
<code class="code">lset-intersection</code> above.
</p>
<p>For two list arguments this partitions <var class="var">list1</var> into those elements
of <var class="var">list1</var> which are in <var class="var">list2</var> and not in <var class="var">list2</var>.  (But
for more than two arguments there can be elements of <var class="var">list1</var> which
are neither part of the difference nor the intersection.)
</p>
<p>One of the return values from <code class="code">lset-diff+intersection</code> may share
a tail with <var class="var">list1</var>.  <code class="code">lset-diff+intersection!</code> may modify
<var class="var">list1</var> to form its results.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-lset_002dxor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-xor</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dxor"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-lset_002dxor_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">lset-xor!</strong> <var class="def-var-arguments">= list …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-lset_002dxor_0021"> ¶</a></span></dt>
<dd><p>Return an XOR of the argument lists.  For two lists this means those
elements which are in exactly one of the lists.  For more than two
lists it means those elements which appear in an odd number of the
lists.
</p>
<p>To be precise, the XOR of two lists <var class="var">x</var> and <var class="var">y</var> is formed by
taking those elements of <var class="var">x</var> not equal to any element of <var class="var">y</var>,
plus those elements of <var class="var">y</var> not equal to any element of <var class="var">x</var>.
Equality is determined with the given <var class="var">=</var> procedure, called as
<code class="code">(<var class="var">=</var> e1 e2)</code>.  One argument is from <var class="var">x</var> and the other
from <var class="var">y</var>, but which way around is unspecified.  Exactly which
calls are made is also unspecified, as is the order of the elements in
the result.
</p>
<div class="example">
<pre class="example-preformatted">(lset-xor eqv? '(x y))             ⇒ (x y)
(lset-xor eqv? '(1 2 3) '(4 3 2))  ⇒ (4 1)
</pre></div>

<p>The return from <code class="code">lset-xor</code> may share a tail with one of the list
arguments.  <code class="code">lset-xor!</code> may modify <var class="var">list1</var> to form its
result.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="SRFI_002d2">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="n" rel="next">SRFI-4 - Homogeneous numeric vector datatypes</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d1" accesskey="p" rel="prev">SRFI-1 - List library</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d2-_002d-and_002dlet_002a">7.5.4 SRFI-2 - and-let*</h4>
<a class="index-entry-id" id="index-SRFI_002d2"></a>

<p>The following syntax can be obtained with
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-2))
</pre></div>

<p>or alternatively
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (ice-9 and-let-star))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-and_002dlet_002a"><span class="category-def">library syntax: </span><span><strong class="def-name">and-let*</strong> <var class="def-var-arguments">(clause …) body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-and_002dlet_002a"> ¶</a></span></dt>
<dd><p>A combination of <code class="code">and</code> and <code class="code">let*</code>.
</p>
<p>Each <var class="var">clause</var> is evaluated in turn, and if <code class="code">#f</code> is obtained
then evaluation stops and <code class="code">#f</code> is returned.  If all are
non-<code class="code">#f</code> then <var class="var">body</var> is evaluated and the last form gives the
return value, or if <var class="var">body</var> is empty then the result is <code class="code">#t</code>.
Each <var class="var">clause</var> should be one of the following,
</p>
<dl class="table">
<dt><code class="code">(symbol expr)</code></dt>
<dd><p>Evaluate <var class="var">expr</var>, check for <code class="code">#f</code>, and bind it to <var class="var">symbol</var>.
Like <code class="code">let*</code>, that binding is available to subsequent clauses.
</p></dd>
<dt><code class="code">(expr)</code></dt>
<dd><p>Evaluate <var class="var">expr</var> and check for <code class="code">#f</code>.
</p></dd>
<dt><code class="code">symbol</code></dt>
<dd><p>Get the value bound to <var class="var">symbol</var> and check for <code class="code">#f</code>.
</p></dd>
</dl>

<p>Notice that <code class="code">(expr)</code> has an “extra” pair of parentheses, for
instance <code class="code">((eq? x y))</code>.  One way to remember this is to imagine
the <code class="code">symbol</code> in <code class="code">(symbol expr)</code> is omitted.
</p>
<p><code class="code">and-let*</code> is good for calculations where a <code class="code">#f</code> value means
termination, but where a non-<code class="code">#f</code> value is going to be needed in
subsequent expressions.
</p>
<p>The following illustrates this, it returns text between brackets
‘<samp class="samp">[...]</samp>’ in a string, or <code class="code">#f</code> if there are no such brackets
(ie. either <code class="code">string-index</code> gives <code class="code">#f</code>).
</p>
<div class="example">
<pre class="example-preformatted">(define (extract-brackets str)
  (and-let* ((start (string-index str #\[))
             (end   (string-index str #\] start)))
    (substring str (1+ start) end)))
</pre></div>

<p>The following shows plain variables and expressions tested too.
<code class="code">diagnostic-levels</code> is taken to be an alist associating a
diagnostic type with a level.  <code class="code">str</code> is printed only if the type
is known and its level is high enough.
</p>
<div class="example">
<pre class="example-preformatted">(define (show-diagnostic type str)
  (and-let* (want-diagnostics
             (level (assq-ref diagnostic-levels type))
             ((&gt;= level current-diagnostic-level)))
    (display str)))
</pre></div>

<p>The advantage of <code class="code">and-let*</code> is that an extended sequence of
expressions and tests doesn’t require lots of nesting as would arise
from separate <code class="code">and</code> and <code class="code">let*</code>, or from <code class="code">cond</code> with
<code class="code">=&gt;</code>.
</p>
</dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d4">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d6" accesskey="n" rel="next">SRFI-6 - Basic String Ports</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d2" accesskey="p" rel="prev">SRFI-2 - and-let*</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d4-_002d-Homogeneous-numeric-vector-datatypes">7.5.5 SRFI-4 - Homogeneous numeric vector datatypes</h4>
<a class="index-entry-id" id="index-SRFI_002d4"></a>

<p>SRFI-4 provides an interface to uniform numeric vectors: vectors whose elements
are all of a single numeric type. Guile offers uniform numeric vectors for
signed and unsigned 8-bit, 16-bit, 32-bit, and 64-bit integers, two sizes of
floating point values, and, as an extension to SRFI-4, complex floating-point
numbers of these two sizes.
</p>
<p>The standard SRFI-4 procedures and data types may be included via loading the
appropriate module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-4))
</pre></div>

<p>This module is currently a part of the default Guile environment, but it is a
good practice to explicitly import the module. In the future, using SRFI-4
procedures without importing the SRFI-4 module will cause a deprecation message
to be printed. (Of course, one may call the C functions at any time. Would that
C had modules!)
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Overview" accesskey="1">SRFI-4 - Overview</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-API" accesskey="2">SRFI-4 - API</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-and-Bytevectors" accesskey="3">SRFI-4 - Relation to bytevectors</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Extensions" accesskey="4">SRFI-4 - Guile extensions</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="SRFI_002d4-Overview">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-API" accesskey="n" rel="next">SRFI-4 - API</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="u" rel="up">SRFI-4 - Homogeneous numeric vector datatypes</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d4-_002d-Overview">7.5.5.1 SRFI-4 - Overview</h4>

<p>Uniform numeric vectors can be useful since they consume less memory
than the non-uniform, general vectors.  Also, since the types they can
store correspond directly to C types, it is easier to work with them
efficiently on a low level.  Consider image processing as an example,
where you want to apply a filter to some image.  While you could store
the pixels of an image in a general vector and write a general
convolution function, things are much more efficient with uniform
vectors: the convolution function knows that all pixels are unsigned
8-bit values (say), and can use a very tight inner loop.
</p>
<p>This is implemented in Scheme by having the compiler notice calls to the SRFI-4
accessors, and inline them to appropriate compiled code. From C you have access
to the raw array; functions for efficiently working with uniform numeric vectors
from C are listed at the end of this section.
</p>
<p>Uniform numeric vectors are the special case of one dimensional uniform
numeric arrays.
</p>
<p>There are 12 standard kinds of uniform numeric vectors, and they all have their
own complement of constructors, accessors, and so on. Procedures that operate on
a specific kind of uniform numeric vector have a “tag” in their name,
indicating the element type.
</p>
<dl class="table">
<dt><code class="code">u8</code></dt>
<dd><p>unsigned 8-bit integers
</p>
</dd>
<dt><code class="code">s8</code></dt>
<dd><p>signed 8-bit integers
</p>
</dd>
<dt><code class="code">u16</code></dt>
<dd><p>unsigned 16-bit integers
</p>
</dd>
<dt><code class="code">s16</code></dt>
<dd><p>signed 16-bit integers
</p>
</dd>
<dt><code class="code">u32</code></dt>
<dd><p>unsigned 32-bit integers
</p>
</dd>
<dt><code class="code">s32</code></dt>
<dd><p>signed 32-bit integers
</p>
</dd>
<dt><code class="code">u64</code></dt>
<dd><p>unsigned 64-bit integers
</p>
</dd>
<dt><code class="code">s64</code></dt>
<dd><p>signed 64-bit integers
</p>
</dd>
<dt><code class="code">f32</code></dt>
<dd><p>the C type <code class="code">float</code>
</p>
</dd>
<dt><code class="code">f64</code></dt>
<dd><p>the C type <code class="code">double</code>
</p>
</dd>
</dl>

<p>In addition, Guile supports uniform arrays of complex numbers, with the
nonstandard tags:
</p>
<dl class="table">
<dt><code class="code">c32</code></dt>
<dd><p>complex numbers in rectangular form with the real and imaginary part
being a <code class="code">float</code>
</p>
</dd>
<dt><code class="code">c64</code></dt>
<dd><p>complex numbers in rectangular form with the real and imaginary part
being a <code class="code">double</code>
</p>
</dd>
</dl>

<p>The external representation (ie. read syntax) for these vectors is
similar to normal Scheme vectors, but with an additional tag from the
tables above indicating the vector’s type.  For example,
</p>
<div class="example lisp">
<pre class="lisp-preformatted">#u16(1 2 3)
#f64(3.1415 2.71)
</pre></div>

<p>Note that the read syntax for floating-point here conflicts with
<code class="code">#f</code> for false.  In Standard Scheme one can write <code class="code">(1 #f3)</code>
for a three element list <code class="code">(1 #f 3)</code>, but for Guile <code class="code">(1 #f3)</code>
is invalid.  <code class="code">(1 #f 3)</code> is almost certainly what one should write
anyway to make the intention clear, so this is rarely a problem.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d4-API">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-and-Bytevectors" accesskey="n" rel="next">SRFI-4 - Relation to bytevectors</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Overview" accesskey="p" rel="prev">SRFI-4 - Overview</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="u" rel="up">SRFI-4 - Homogeneous numeric vector datatypes</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d4-_002d-API">7.5.5.2 SRFI-4 - API</h4>

<p>Note that the <code class="code">c32</code> and <code class="code">c64</code> functions are only available from
<code class="code">(srfi srfi-4 gnu)</code>.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005fp"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector_005fp"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector_p</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005fp"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a homogeneous numeric vector of the
indicated type.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002du8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-u8vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002du8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002ds8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-s8vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ds8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002du16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-u16vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002du16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002ds16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-s16vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ds16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002du32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-u32vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002du32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002ds32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-s32vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ds32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002du64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-u64vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002du64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002ds64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-s64vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ds64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002df32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-f32vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002df32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002df64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-f64vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002df64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dc32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-c32vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dc32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-make_002dc64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-c64vector</strong> <var class="def-var-arguments">n [value]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dc64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fu8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_u8vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fs8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_s8vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fs8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fu16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_u16vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fs16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_s16vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fs16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fu32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_u32vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fs32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_s32vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fs32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fu64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_u64vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fs64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_s64vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fs64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005ff32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_f32vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005ff32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005ff64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_f64vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005ff64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fc32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_c32vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fc32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fmake_005fc64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_make_c64vector</strong> <var class="def-var-arguments">(n, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fmake_005fc64vector"> ¶</a></span></dt>
<dd><p>Return a newly allocated homogeneous numeric vector holding <var class="var">n</var>
elements of the indicated type.  If <var class="var">value</var> is given, the vector
is initialized with that value, otherwise the contents are
unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector</strong> <var class="def-var-arguments">value …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector</strong> <var class="def-var-arguments">(values)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector"> ¶</a></span></dt>
<dd><p>Return a newly allocated homogeneous numeric vector of the indicated
type, holding the given parameter <var class="var">value</var>s.  The vector length is
the number of parameters given.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002dlength"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-length</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002dlength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005flength"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector_005flength"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector_length</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005flength"> ¶</a></span></dt>
<dd><p>Return the number of elements in <var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-ref</strong> <var class="def-var-arguments">vec i</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002dref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005fref"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector_005fref"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector_ref</strong> <var class="def-var-arguments">(vec, i)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005fref"> ¶</a></span></dt>
<dd><p>Return the element at index <var class="var">i</var> in <var class="var">vec</var>.  The first element
in <var class="var">vec</var> is index 0.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002dset_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-set!</strong> <var class="def-var-arguments">vec i value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002dset_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005fset_005fx"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector_005fset_005fx"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector_set_x</strong> <var class="def-var-arguments">(vec, i, value)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005fset_005fx"> ¶</a></span></dt>
<dd><p>Set the element at index <var class="var">i</var> in <var class="var">vec</var> to <var class="var">value</var>.  The
first element in <var class="var">vec</var> is index 0.  The return value is
unspecified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002d_003elist"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-&gt;list</strong> <var class="def-var-arguments">vec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002d_003elist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu8vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u8vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs8vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s8vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu16vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u16vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs16vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s16vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu32vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u32vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs32vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s32vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fu64vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_u64vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fs64vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_s64vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff32vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f32vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005ff64vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_f64vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc32vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c32vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005fto_005flist"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fc64vector_005fto_005flist"><span class="category-def">C Function: </span><span><strong class="def-name">scm_c64vector_to_list</strong> <var class="def-var-arguments">(vec)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005fto_005flist"> ¶</a></span></dt>
<dd><p>Return a newly allocated list holding all elements of <var class="var">vec</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-list_002d_003eu8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;u8vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003eu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003es8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;s8vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003es8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003eu16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;u16vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003eu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003es16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;s16vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003es16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003eu32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;u32vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003eu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003es32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;s32vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003es32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003eu64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;u64vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003eu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003es64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;s64vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003es64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003ef32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;f32vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003ef32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003ef64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;f64vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003ef64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003ec32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;c32vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003ec32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-list_002d_003ec64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">list-&gt;c64vector</strong> <var class="def-var-arguments">lst</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-list_002d_003ec64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fu8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_u8vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fs8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_s8vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fs8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fu16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_u16vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fs16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_s16vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fs16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fu32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_u32vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fs32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_s32vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fs32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fu64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_u64vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fs64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_s64vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fs64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005ff32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_f32vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005ff32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005ff64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_f64vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005ff64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fc32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_c32vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fc32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005flist_005fto_005fc64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_list_to_c64vector</strong> <var class="def-var-arguments">(lst)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005flist_005fto_005fc64vector"> ¶</a></span></dt>
<dd><p>Return a newly allocated homogeneous numeric vector of the indicated type,
initialized with the elements of the list <var class="var">lst</var>.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005ftake_005fu8vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_u8vector</strong> <code class="def-code-arguments">(const scm_t_uint8 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fu8vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fs8vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_s8vector</strong> <code class="def-code-arguments">(const scm_t_int8 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fs8vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fu16vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_u16vector</strong> <code class="def-code-arguments">(const scm_t_uint16 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fu16vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fs16vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_s16vector</strong> <code class="def-code-arguments">(const scm_t_int16 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fs16vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fu32vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_u32vector</strong> <code class="def-code-arguments">(const scm_t_uint32 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fu32vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fs32vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_s32vector</strong> <code class="def-code-arguments">(const scm_t_int32 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fs32vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fu64vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_u64vector</strong> <code class="def-code-arguments">(const scm_t_uint64 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fu64vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fs64vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_s64vector</strong> <code class="def-code-arguments">(const scm_t_int64 *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fs64vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005ff32vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_f32vector</strong> <code class="def-code-arguments">(const float *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005ff32vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005ff64vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_f64vector</strong> <code class="def-code-arguments">(const double *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005ff64vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fc32vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_c32vector</strong> <code class="def-code-arguments">(const float *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fc32vector"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ftake_005fc64vector"><span class="category-def">C Function: </span><span><code class="def-type">SCM</code> <strong class="def-name">scm_take_c64vector</strong> <code class="def-code-arguments">(const double *data, size_t len)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ftake_005fc64vector"> ¶</a></span></dt>
<dd><p>Return a new uniform numeric vector of the indicated type and length
that uses the memory pointed to by <var class="var">data</var> to store its elements.
This memory will eventually be freed with <code class="code">free</code>.  The argument
<var class="var">len</var> specifies the number of elements in <var class="var">data</var>, not its size
in bytes.
</p>
<p>The <code class="code">c32</code> and <code class="code">c64</code> variants take a pointer to a C array of
<code class="code">float</code>s or <code class="code">double</code>s.  The real parts of the complex numbers
are at even indices in that array, the corresponding imaginary parts are
at the following odd index.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fu8vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint8 *</code> <strong class="def-name">scm_u8vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs8vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int8 *</code> <strong class="def-name">scm_s8vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu16vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint16 *</code> <strong class="def-name">scm_u16vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs16vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int16 *</code> <strong class="def-name">scm_s16vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu32vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint32 *</code> <strong class="def-name">scm_u32vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs32vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int32 *</code> <strong class="def-name">scm_s32vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu64vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_uint64 *</code> <strong class="def-name">scm_u64vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs64vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const scm_t_int64 *</code> <strong class="def-name">scm_s64vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ff32vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const float *</code> <strong class="def-name">scm_f32vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ff64vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const double *</code> <strong class="def-name">scm_f64vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc32vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const float *</code> <strong class="def-name">scm_c32vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc64vector_005felements"><span class="category-def">C Function: </span><span><code class="def-type">const double *</code> <strong class="def-name">scm_c64vector_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_vector_elements</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C">Vector Accessing from C</a>), but
returns a pointer to the elements of a uniform numeric vector of the
indicated kind.
</p></dd></dl>

<dl class="first-deftypefn">
<dt class="deftypefn" id="index-scm_005fu8vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint8 *</code> <strong class="def-name">scm_u8vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu8vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs8vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int8 *</code> <strong class="def-name">scm_s8vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs8vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu16vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint16 *</code> <strong class="def-name">scm_u16vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu16vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs16vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int16 *</code> <strong class="def-name">scm_s16vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs16vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu32vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint32 *</code> <strong class="def-name">scm_u32vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu32vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs32vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int32 *</code> <strong class="def-name">scm_s32vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs32vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fu64vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_uint64 *</code> <strong class="def-name">scm_u64vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fu64vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fs64vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">scm_t_int64 *</code> <strong class="def-name">scm_s64vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fs64vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ff32vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">float *</code> <strong class="def-name">scm_f32vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff32vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005ff64vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">double *</code> <strong class="def-name">scm_f64vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005ff64vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc32vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">float *</code> <strong class="def-name">scm_c32vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc32vector_005fwritable_005felements"> ¶</a></span></dt>
<dt class="deftypefnx def-cmd-deftypefn" id="index-scm_005fc64vector_005fwritable_005felements"><span class="category-def">C Function: </span><span><code class="def-type">double *</code> <strong class="def-name">scm_c64vector_writable_elements</strong> <code class="def-code-arguments">(SCM vec, scm_t_array_handle *handle, size_t *lenp, ssize_t *incp)</code><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fc64vector_005fwritable_005felements"> ¶</a></span></dt>
<dd><p>Like <code class="code">scm_vector_writable_elements</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Vector-Accessing-from-C">Vector Accessing from C</a>),
but returns a pointer to the elements of a uniform numeric vector of the
indicated kind.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d4-and-Bytevectors">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-Extensions" accesskey="n" rel="next">SRFI-4 - Guile extensions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-API" accesskey="p" rel="prev">SRFI-4 - API</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="u" rel="up">SRFI-4 - Homogeneous numeric vector datatypes</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d4-_002d-Relation-to-bytevectors">7.5.5.3 SRFI-4 - Relation to bytevectors</h4>

<p>Guile implements SRFI-4 vectors using bytevectors (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>). Often
when you have a numeric vector, you end up wanting to write its bytes somewhere,
or have access to the underlying bytes, or read in bytes from somewhere else.
Bytevectors are very good at this sort of thing. But the SRFI-4 APIs are nicer
to use when doing number-crunching, because they are addressed by element and
not by byte.
</p>
<p>So as a compromise, Guile allows all bytevector functions to operate on numeric
vectors. They address the underlying bytes in the native endianness, as one
would expect.
</p>
<p>Following the same reasoning, that it’s just bytes underneath, Guile also allows
uniform vectors of a given type to be accessed as if they were of any type. One
can fill a <code class="code">u32vector</code>, and access its elements with
<code class="code">u8vector-ref</code>. One can use <code class="code">f64vector-ref</code> on bytevectors. It’s
all the same to Guile.
</p>
<p>In this way, uniform numeric vectors may be written to and read from
input/output ports using the procedures that operate on bytevectors.
</p>
<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Bytevectors">Bytevectors</a>, for more information.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d4-Extensions">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4-and-Bytevectors" accesskey="p" rel="prev">SRFI-4 - Relation to bytevectors</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="u" rel="up">SRFI-4 - Homogeneous numeric vector datatypes</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d4-_002d-Guile-extensions">7.5.5.4 SRFI-4 - Guile extensions</h4>

<p>Guile defines some useful extensions to SRFI-4, which are not available in the
default Guile environment. They may be imported by loading the extensions
module:
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-4 gnu))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-srfi_002d4_002dvector_002dtype_002dsize"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">srfi-4-vector-type-size</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-srfi_002d4_002dvector_002dtype_002dsize"> ¶</a></span></dt>
<dd><p>Return the size, in bytes, of each element of SRFI-4 vector
<var class="var">obj</var>. For example, <code class="code">(srfi-4-vector-type-size #u32())</code> returns
<code class="code">4</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-any_002d_003eu8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;u8vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003eu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003es8vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;s8vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003es8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003eu16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;u16vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003eu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003es16vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;s16vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003es16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003eu32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;u32vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003eu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003es32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;s32vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003es32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003eu64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;u64vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003eu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003es64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;s64vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003es64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003ef32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;f32vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003ef32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003ef64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;f64vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003ef64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003ec32vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;c32vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003ec32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-any_002d_003ec64vector"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">any-&gt;c64vector</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-any_002d_003ec64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fu8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_u8vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fu8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fs8vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_s8vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fs8vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fu16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_u16vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fu16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fs16vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_s16vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fs16vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fu32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_u32vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fu32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fs32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_s32vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fs32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fu64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_u64vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fu64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fs64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_s64vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fs64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005ff32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_f32vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005ff32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005ff64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_f64vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005ff64vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fc32vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_c32vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fc32vector"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-scm_005fany_005fto_005fc64vector"><span class="category-def">C Function: </span><span><strong class="def-name">scm_any_to_c64vector</strong> <var class="def-var-arguments">(obj)</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-scm_005fany_005fto_005fc64vector"> ¶</a></span></dt>
<dd><p>Return a (maybe newly allocated) uniform numeric vector of the indicated
type, initialized with the elements of <var class="var">obj</var>, which must be a list,
a vector, or a uniform vector.  When <var class="var">obj</var> is already a suitable
uniform numeric vector, it is returned unchanged.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002dcopy_0021"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002dcopy_0021"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-copy!</strong> <var class="def-var-arguments">dst at src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002dcopy_0021"> ¶</a></span></dt>
<dd><p>Copy a block of elements from <var class="var">src</var> to <var class="var">dst</var>, both of which must
be vectors of the indicated type, starting in <var class="var">dst</var> at <var class="var">at</var> and
starting in <var class="var">src</var> at <var class="var">start</var> and ending at <var class="var">end</var>.  It is an
error for <var class="var">dst</var> to have a length less than <var class="var">at</var> + (<var class="var">end</var> -
<var class="var">start</var>). <var class="var">at</var> and <var class="var">start</var> default to 0 and <var class="var">end</var>
defaults to the length of <var class="var">src</var>.
</p>
<p>If source and destination overlap, copying takes place as if the
source is first copied into a temporary vector and then into the
destination.
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dvector_002dcopy_0021"><code class="code">vector-copy!</code></a>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-u8vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u8vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u8vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s8vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s8vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s8vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u16vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u16vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u16vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s16vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s16vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s16vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u32vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u32vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u32vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s32vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s32vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s32vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-u64vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">u64vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-u64vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-s64vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">s64vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-s64vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f32vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f32vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f32vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-f64vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">f64vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-f64vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c32vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c32vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c32vector_002dcopy"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-c64vector_002dcopy"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">c64vector-copy</strong> <var class="def-var-arguments">src [start [end]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-c64vector_002dcopy"> ¶</a></span></dt>
<dd><p>Returns a freshly allocated vector of the indicated type, which must be
the same as that of <var class="var">src</var>, containing the elements of <var class="var">src</var>
between <var class="var">start</var> and <var class="var">end</var>. <var class="var">start</var> defaults to 0 and
<var class="var">end</var> defaults to the length of <var class="var">src</var>.
</p>
<p>See also <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#x_002dvector_002dcopy"><code class="code">vector-copy</code></a>.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="SRFI_002d6">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d8" accesskey="n" rel="next">SRFI-8 - receive</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d4" accesskey="p" rel="prev">SRFI-4 - Homogeneous numeric vector datatypes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d6-_002d-Basic-String-Ports">7.5.6 SRFI-6 - Basic String Ports</h4>
<a class="index-entry-id" id="index-SRFI_002d6"></a>

<p>SRFI-6 defines the procedures <code class="code">open-input-string</code>,
<code class="code">open-output-string</code> and <code class="code">get-output-string</code>.  These
procedures are included in the Guile core, so using this module does not
make any difference at the moment.  But it is possible that support for
SRFI-6 will be factored out of the core library in the future, so using
this module does not hurt, after all.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d8">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9" accesskey="n" rel="next">SRFI-9 - define-record-type</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d6" accesskey="p" rel="prev">SRFI-6 - Basic String Ports</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d8-_002d-receive">7.5.7 SRFI-8 - receive</h4>
<a class="index-entry-id" id="index-SRFI_002d8"></a>

<p><code class="code">receive</code> is a syntax for making the handling of multiple-value
procedures easier.  It is documented in See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Multiple-Values">Returning and Accepting Multiple Values</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d9">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d10" accesskey="n" rel="next">SRFI-10 - Hash-Comma Reader Extension</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d8" accesskey="p" rel="prev">SRFI-8 - receive</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d9-_002d-define_002drecord_002dtype">7.5.8 SRFI-9 - define-record-type</h4>

<p>This SRFI is a syntax for defining new record types and creating
predicate, constructor, and field getter and setter functions.  It is
documented in the “Data Types” section of the manual (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9-Records">SRFI-9 Records</a>).
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d10">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d11" accesskey="n" rel="next">SRFI-11 - let-values</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d9" accesskey="p" rel="prev">SRFI-9 - define-record-type</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d10-_002d-Hash_002dComma-Reader-Extension">7.5.9 SRFI-10 - Hash-Comma Reader Extension</h4>
<a class="index-entry-id" id="index-SRFI_002d10"></a>

<a class="index-entry-id" id="index-hash_002dcomma"></a>
<a class="index-entry-id" id="index-_0023_002c_0028_0029"></a>
<p>This SRFI implements a reader extension <code class="code">#,()</code> called hash-comma.
It allows the reader to give new kinds of objects, for use both in data
and as constants or literals in source code.  This feature is available
with
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-10))
</pre></div>

<p>The new read syntax is of the form
</p>
<div class="example">
<pre class="example-preformatted">#,(<var class="var">tag</var> <var class="var">arg</var>…)
</pre></div>

<p>where <var class="var">tag</var> is a symbol and the <var class="var">arg</var>s are objects taken as
parameters.  <var class="var">tag</var>s are registered with the following procedure.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dreader_002dctor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">define-reader-ctor</strong> <var class="def-var-arguments">tag proc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dreader_002dctor"> ¶</a></span></dt>
<dd><p>Register <var class="var">proc</var> as the constructor for a hash-comma read syntax
starting with symbol <var class="var">tag</var>, i.e. <code class="code">#,(<var class="var">tag</var> arg…)</code>.
<var class="var">proc</var> is called with the given arguments <code class="code">(<var class="var">proc</var>
arg…)</code> and the object it returns is the result of the read.
</p></dd></dl>

<p>For example, a syntax giving a list of <var class="var">N</var> copies of an object.
</p>
<div class="example">
<pre class="example-preformatted">(define-reader-ctor 'repeat
  (lambda (obj reps)
    (make-list reps obj)))

(display '#,(repeat 99 3))
-| (99 99 99)
</pre></div>

<p>Notice the quote <code class="code">'</code> when the <code class="code">#,( )</code> is used.  The
<code class="code">repeat</code> handler returns a list and the program must quote to use
it literally, the same as any other list.  Ie.
</p>
<div class="example">
<pre class="example-preformatted">(display '#,(repeat 99 3))
⇒
(display '(99 99 99))
</pre></div>

<p>When a handler returns an object which is self-evaluating, like a
number or a string, then there’s no need for quoting, just as there’s
no need when giving those directly as literals.  For example an
addition,
</p>
<div class="example">
<pre class="example-preformatted">(define-reader-ctor 'sum
  (lambda (x y)
    (+ x y)))
(display #,(sum 123 456)) -| 579
</pre></div>

<p>Once <code class="code">(srfi srfi-10)</code> has loaded, <code class="code">#,()</code> is available
globally, there’s no need to use <code class="code">(srfi srfi-10)</code> in later
modules.  Similarly the tags registered are global and can be used
anywhere once registered.
</p>
<p>We do not recommend <code class="code">#,()</code> reader extensions, however, and for
three reasons.
</p>
<p>First of all, this SRFI is not modular: the tag is matched by name, not
as an identifier within a scope.  Defining a reader extension in one
part of a program can thus affect unrelated parts of a program because
the tag is not scoped.
</p>
<p>Secondly, reader extensions can be hard to manage from a time
perspective: when does the reader extension take effect?  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Eval-When">Eval-when</a>, for more discussion.
</p>
<p>Finally, reader extensions can easily produce objects that can’t be
reified to an object file by the compiler.  For example if you define a
reader extension that makes a hash table (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Hash-Tables">Hash Tables</a>), then it
will work fine when run with the interpreter, and you think you have a
neat hack.  But then if you try to compile your program, after wrangling
with the <code class="code">eval-when</code> concerns mentioned above, the compiler will
carp that it doesn’t know how to serialize a hash table to disk.
</p>
<p>In the specific case of hash tables, it would be possible for Guile to
know how to pack hash tables into compiled files, but this doesn’t work
in general.  What if the object you produce is an instance of a record
type?  Guile would then have to serialize the record type to disk too,
and then what happens if the program independently loads the code that
defines the record type?  Does it define the same type or a different
type?  Guile’s record types are nominal, not structural, so the answer
is not clear at all.
</p>
<p>For all of these reasons we recommend macros over reader extensions.
Macros fulfill many of the same needs while preserving modular
composition, and their interaction with <code class="code">eval-when</code> is well-known.
If you need brevity, instead use <code class="code">read-hash-extend</code> and make your
reader extension expand to a macro invocation.  In that way we preserve
scoping as much as possible.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Reader-Extensions">Reader Extensions</a>.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d11">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d13" accesskey="n" rel="next">SRFI-13 - String Library</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d10" accesskey="p" rel="prev">SRFI-10 - Hash-Comma Reader Extension</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d11-_002d-let_002dvalues">7.5.10 SRFI-11 - let-values</h4>
<a class="index-entry-id" id="index-SRFI_002d11"></a>

<a class="index-entry-id" id="index-let_002dvalues"></a>
<a class="index-entry-id" id="index-let_002a_002dvalues"></a>
<p>This module implements the binding forms for multiple values
<code class="code">let-values</code> and <code class="code">let*-values</code>.  These forms are similar to
<code class="code">let</code> and <code class="code">let*</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Local-Bindings">Local Variable Bindings</a>), but they support
binding of the values returned by multiple-valued expressions.
</p>
<p>Write <code class="code">(use-modules (srfi srfi-11))</code> to make the bindings
available.
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let-values (((x y) (values 1 2))
             ((z f) (values 3 4)))
   (+ x y z f))
⇒
10
</pre></div>

<p><code class="code">let-values</code> performs all bindings simultaneously, which means that
no expression in the binding clauses may refer to variables bound in the
same clause list.  <code class="code">let*-values</code>, on the other hand, performs the
bindings sequentially, just like <code class="code">let*</code> does for single-valued
expressions.
</p>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d13">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d14" accesskey="n" rel="next">SRFI-14 - Character-set Library</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d11" accesskey="p" rel="prev">SRFI-11 - let-values</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d13-_002d-String-Library">7.5.11 SRFI-13 - String Library</h4>
<a class="index-entry-id" id="index-SRFI_002d13"></a>

<p>The SRFI-13 procedures are always available, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Strings">Strings</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d14">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d16" accesskey="n" rel="next">SRFI-16 - case-lambda</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d13" accesskey="p" rel="prev">SRFI-13 - String Library</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d14-_002d-Character_002dset-Library">7.5.12 SRFI-14 - Character-set Library</h4>
<a class="index-entry-id" id="index-SRFI_002d14"></a>

<p>The SRFI-14 data type and procedures are always available,
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Character-Sets">Character Sets</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d16">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d17" accesskey="n" rel="next">SRFI-17 - Generalized set!</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d14" accesskey="p" rel="prev">SRFI-14 - Character-set Library</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d16-_002d-case_002dlambda">7.5.13 SRFI-16 - case-lambda</h4>
<a class="index-entry-id" id="index-SRFI_002d16-1"></a>
<a class="index-entry-id" id="index-variable-arity-1"></a>
<a class="index-entry-id" id="index-arity_002c-variable-1"></a>

<p>SRFI-16 defines a variable-arity <code class="code">lambda</code> form,
<code class="code">case-lambda</code>. This form is available in the default Guile
environment. See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Case_002dlambda">Case-lambda</a>, for more information.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d17">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="n" rel="next">SRFI-18 - Multithreading support</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d16" accesskey="p" rel="prev">SRFI-16 - case-lambda</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d17-_002d-Generalized-set_0021">7.5.14 SRFI-17 - Generalized set!</h4>
<a class="index-entry-id" id="index-SRFI_002d17"></a>

<p>This SRFI implements a generalized <code class="code">set!</code>, allowing some
“referencing” functions to be used as the target location of a
<code class="code">set!</code>.  This feature is available from
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-17))
</pre></div>

<p>For example <code class="code">vector-ref</code> is extended so that
</p>
<div class="example">
<pre class="example-preformatted">(set! (vector-ref vec idx) new-value)
</pre></div>

<p>is equivalent to
</p>
<div class="example">
<pre class="example-preformatted">(vector-set! vec idx new-value)
</pre></div>

<p>The idea is that a <code class="code">vector-ref</code> expression identifies a location,
which may be either fetched or stored.  The same form is used for the
location in both cases, encouraging visual clarity.  This is similar
to the idea of an “lvalue” in C.
</p>
<p>The mechanism for this kind of <code class="code">set!</code> is in the Guile core
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</a>).  This module adds definitions of
the following functions as procedures with setters, allowing them to
be targets of a <code class="code">set!</code>,
</p>
<blockquote class="quotation">
<p><code class="code">car</code>, <code class="code">cdr</code>, <code class="code">caar</code>, <code class="code">cadr</code>,
<code class="code">cdar</code>, <code class="code">cddr</code>, <code class="code">caaar</code>, <code class="code">caadr</code>,
<code class="code">cadar</code>, <code class="code">caddr</code>, <code class="code">cdaar</code>, <code class="code">cdadr</code>,
<code class="code">cddar</code>, <code class="code">cdddr</code>, <code class="code">caaaar</code>, <code class="code">caaadr</code>,
<code class="code">caadar</code>, <code class="code">caaddr</code>, <code class="code">cadaar</code>, <code class="code">cadadr</code>,
<code class="code">caddar</code>, <code class="code">cadddr</code>, <code class="code">cdaaar</code>, <code class="code">cdaadr</code>,
<code class="code">cdadar</code>, <code class="code">cdaddr</code>, <code class="code">cddaar</code>, <code class="code">cddadr</code>,
<code class="code">cdddar</code>, <code class="code">cddddr</code>
</p>
<p><code class="code">string-ref</code>, <code class="code">vector-ref</code>
</p></blockquote>

<p>The SRFI specifies <code class="code">setter</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</a>) as
a procedure with setter, allowing the setter for a procedure to be
changed, eg. <code class="code">(set! (setter foo) my-new-setter-handler)</code>.
Currently Guile does not implement this, a setter can only be
specified on creation (<code class="code">getter-with-setter</code> below).
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-getter_002dwith_002dsetter"><span class="category-def">Function: </span><span><strong class="def-name">getter-with-setter</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-getter_002dwith_002dsetter"> ¶</a></span></dt>
<dd><p>The same as the Guile core <code class="code">make-procedure-with-setter</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Procedures-with-Setters">Procedures with Setters</a>).
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d18">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="n" rel="next">SRFI-19 - Time/Date Library</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d17" accesskey="p" rel="prev">SRFI-17 - Generalized set!</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d18-_002d-Multithreading-support">7.5.15 SRFI-18 - Multithreading support</h4>
<a class="index-entry-id" id="index-SRFI_002d18"></a>

<p>This is an implementation of the SRFI-18 threading and synchronization
library.  The functions and variables described here are provided by
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-18))
</pre></div>

<p>SRFI-18 defines facilities for threads, mutexes, condition variables,
time, and exception handling.  Because these facilities are at a higher
level than Guile’s primitives, they are implemented as a layer on top of
what Guile provides.  In particular this means that a Guile mutex is not
a SRFI-18 mutex, and a Guile thread is not a SRFI-18 thread, and so on.
Guile provides a set of primitives and SRFI-18 is one of the systems built in terms of those primitives.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Threads" accesskey="1">SRFI-18 Threads</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Mutexes" accesskey="2">SRFI-18 Mutexes</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Condition-variables" accesskey="3">SRFI-18 Condition variables</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time" accesskey="4">SRFI-18 Time</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Exceptions" accesskey="5">SRFI-18 Exceptions</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="SRFI_002d18-Threads">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Mutexes" accesskey="n" rel="next">SRFI-18 Mutexes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="u" rel="up">SRFI-18 - Multithreading support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d18-Threads-1">7.5.15.1 SRFI-18 Threads</h4>

<p>Threads created by SRFI-18 differ in two ways from threads created by 
Guile’s built-in thread functions.  First, a thread created by SRFI-18
<code class="code">make-thread</code> begins in a blocked state and will not start 
execution until <code class="code">thread-start!</code> is called on it.  Second, SRFI-18
threads are constructed with a top-level exception handler that 
captures any exceptions that are thrown on thread exit.
</p>
<p>SRFI-18 threads are disjoint from Guile’s primitive threads.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>, for more on Guile’s primitive facility.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dthread-1"><span class="category-def">Function: </span><span><strong class="def-name">current-thread</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dthread-1"> ¶</a></span></dt>
<dd><p>Returns the thread that called this function.  This is the same
procedure as the same-named built-in procedure <code class="code">current-thread</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_003f-1"><span class="category-def">Function: </span><span><strong class="def-name">thread?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_003f-1"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a thread, <code class="code">#f</code> otherwise.  This
is the same procedure as the same-named built-in procedure 
<code class="code">thread?</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002dthread-1"><span class="category-def">Function: </span><span><strong class="def-name">make-thread</strong> <var class="def-var-arguments">thunk [name]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dthread-1"> ¶</a></span></dt>
<dd><p>Call <code class="code">thunk</code> in a new thread and with a new dynamic state,
returning the new thread and optionally assigning it the object name
<var class="var">name</var>, which may be any Scheme object.
</p>
<p>Note that the name <code class="code">make-thread</code> conflicts with the 
<code class="code">(ice-9 threads)</code> function <code class="code">make-thread</code>.  Applications 
wanting to use both of these functions will need to refer to them by 
different names.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dname"><span class="category-def">Function: </span><span><strong class="def-name">thread-name</strong> <var class="def-var-arguments">thread</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dname"> ¶</a></span></dt>
<dd><p>Returns the name assigned to <var class="var">thread</var> at the time of its creation,
or <code class="code">#f</code> if it was not given a name.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dspecific"><span class="category-def">Function: </span><span><strong class="def-name">thread-specific</strong> <var class="def-var-arguments">thread</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dspecific"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-thread_002dspecific_002dset_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-specific-set!</strong> <var class="def-var-arguments">thread obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dspecific_002dset_0021"> ¶</a></span></dt>
<dd><p>Get or set the “object-specific” property of <var class="var">thread</var>.  In
Guile’s implementation of SRFI-18, this value is stored as an object
property, and will be <code class="code">#f</code> if not set.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dstart_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-start!</strong> <var class="def-var-arguments">thread</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dstart_0021"> ¶</a></span></dt>
<dd><p>Unblocks <var class="var">thread</var> and allows it to begin execution if it has not
done so already.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dyield_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-yield!</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dyield_0021"> ¶</a></span></dt>
<dd><p>If one or more threads are waiting to execute, calling 
<code class="code">thread-yield!</code> forces an immediate context switch to one of them.
Otherwise, <code class="code">thread-yield!</code> has no effect.  <code class="code">thread-yield!</code> 
behaves identically to the Guile built-in function <code class="code">yield</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dsleep_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-sleep!</strong> <var class="def-var-arguments">timeout</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dsleep_0021"> ¶</a></span></dt>
<dd><p>The current thread waits until the point specified by the time object
<var class="var">timeout</var> is reached (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time">SRFI-18 Time</a>).  This blocks the 
thread only if <var class="var">timeout</var> represents a point in the future.  it is 
an error for <var class="var">timeout</var> to be <code class="code">#f</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002dterminate_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-terminate!</strong> <var class="def-var-arguments">thread</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002dterminate_0021"> ¶</a></span></dt>
<dd><p>Causes an abnormal termination of <var class="var">thread</var>.  If <var class="var">thread</var> is
not already terminated, all mutexes owned by <var class="var">thread</var> become
unlocked/abandoned.  If <var class="var">thread</var> is the current thread, 
<code class="code">thread-terminate!</code> does not return.  Otherwise 
<code class="code">thread-terminate!</code> returns an unspecified value; the termination
of <var class="var">thread</var> will occur before <code class="code">thread-terminate!</code> returns.  
Subsequent attempts to join on <var class="var">thread</var> will cause a “terminated 
thread exception” to be raised.
</p>
<p><code class="code">thread-terminate!</code> is compatible with the thread cancellation
procedures in the core threads API (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Threads">Threads</a>) in that if a 
cleanup handler has been installed for the target thread, it will be 
called before the thread exits and its return value (or exception, if
any) will be stored for later retrieval via a call to 
<code class="code">thread-join!</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-thread_002djoin_0021"><span class="category-def">Function: </span><span><strong class="def-name">thread-join!</strong> <var class="def-var-arguments">thread [timeout [timeout-val]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-thread_002djoin_0021"> ¶</a></span></dt>
<dd><p>Wait for <var class="var">thread</var> to terminate and return its exit value.  When a 
time value <var class="var">timeout</var> is given, it specifies a point in time where
the waiting should be aborted.  When the waiting is aborted, 
<var class="var">timeout-val</var> is returned if it is specified; otherwise, a
<code class="code">join-timeout-exception</code> exception is raised 
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Exceptions">SRFI-18 Exceptions</a>).  Exceptions may also be raised if the 
thread was terminated by a call to <code class="code">thread-terminate!</code> 
(<code class="code">terminated-thread-exception</code> will be raised) or if the thread 
exited by raising an exception that was handled by the top-level 
exception handler (<code class="code">uncaught-exception</code> will be raised; the 
original exception can be retrieved using 
<code class="code">uncaught-exception-reason</code>).
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d18-Mutexes">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Condition-variables" accesskey="n" rel="next">SRFI-18 Condition variables</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Threads" accesskey="p" rel="prev">SRFI-18 Threads</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="u" rel="up">SRFI-18 - Multithreading support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d18-Mutexes-1">7.5.15.2 SRFI-18 Mutexes</h4>

<p>SRFI-18 mutexes are disjoint from Guile’s primitive mutexes.
See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables">Mutexes and Condition Variables</a>, for more on Guile’s primitive
facility.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002dmutex-1"><span class="category-def">Function: </span><span><strong class="def-name">make-mutex</strong> <var class="def-var-arguments">[name]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dmutex-1"> ¶</a></span></dt>
<dd><p>Returns a new mutex, optionally assigning it the object name <var class="var">name</var>,
which may be any Scheme object.  The returned mutex will be created with
the configuration described above.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dname"><span class="category-def">Function: </span><span><strong class="def-name">mutex-name</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dname"> ¶</a></span></dt>
<dd><p>Returns the name assigned to <var class="var">mutex</var> at the time of its creation, or
<code class="code">#f</code> if it was not given a name.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dspecific"><span class="category-def">Function: </span><span><strong class="def-name">mutex-specific</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dspecific"> ¶</a></span></dt>
<dd><p>Return the “object-specific” property of <var class="var">mutex</var>, or <code class="code">#f</code> if
none is set.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dspecific_002dset_0021"><span class="category-def">Function: </span><span><strong class="def-name">mutex-specific-set!</strong> <var class="def-var-arguments">mutex obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dspecific_002dset_0021"> ¶</a></span></dt>
<dd><p>Set the “object-specific” property of <var class="var">mutex</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dstate"><span class="category-def">Function: </span><span><strong class="def-name">mutex-state</strong> <var class="def-var-arguments">mutex</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dstate"> ¶</a></span></dt>
<dd><p>Returns information about the state of <var class="var">mutex</var>.  Possible values 
are:
</p><ul class="itemize mark-bullet">
<li>thread <var class="var">t</var>: the mutex is in the locked/owned state and thread
<var class="var">t</var> is the owner of the mutex
</li><li>symbol <code class="code">not-owned</code>: the mutex is in the locked/not-owned state
</li><li>symbol <code class="code">abandoned</code>: the mutex is in the unlocked/abandoned state
</li><li>symbol <code class="code">not-abandoned</code>: the mutex is in the 
unlocked/not-abandoned state 
</li></ul>
</dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dlock_0021"><span class="category-def">Function: </span><span><strong class="def-name">mutex-lock!</strong> <var class="def-var-arguments">mutex [timeout [thread]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dlock_0021"> ¶</a></span></dt>
<dd><p>Lock <var class="var">mutex</var>, optionally specifying a time object <var class="var">timeout</var>
after which to abort the lock attempt and a thread <var class="var">thread</var> giving
a new owner for <var class="var">mutex</var> different than the current thread.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-mutex_002dunlock_0021"><span class="category-def">Function: </span><span><strong class="def-name">mutex-unlock!</strong> <var class="def-var-arguments">mutex [condition-variable [timeout]]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-mutex_002dunlock_0021"> ¶</a></span></dt>
<dd><p>Unlock <var class="var">mutex</var>, optionally specifying a condition variable
<var class="var">condition-variable</var> on which to wait, either indefinitely or,
optionally, until the time object <var class="var">timeout</var> has passed, to be
signalled.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d18-Condition-variables">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time" accesskey="n" rel="next">SRFI-18 Time</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Mutexes" accesskey="p" rel="prev">SRFI-18 Mutexes</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="u" rel="up">SRFI-18 - Multithreading support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d18-Condition-variables-1">7.5.15.3 SRFI-18 Condition variables</h4>

<p>SRFI-18 does not specify a “wait” function for condition variables.
Waiting on a condition variable can be simulated using the SRFI-18
<code class="code">mutex-unlock!</code> function described in the previous section.
</p>
<p>SRFI-18 condition variables are disjoint from Guile’s primitive
condition variables.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Mutexes-and-Condition-Variables">Mutexes and Condition Variables</a>, for more
on Guile’s primitive facility.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-condition_002dvariable_003f-1"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_003f-1"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a condition variable, <code class="code">#f</code>
otherwise.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002dcondition_002dvariable-1"><span class="category-def">Function: </span><span><strong class="def-name">make-condition-variable</strong> <var class="def-var-arguments">[name]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcondition_002dvariable-1"> ¶</a></span></dt>
<dd><p>Returns a new condition variable, optionally assigning it the object
name <var class="var">name</var>, which may be any Scheme object.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-condition_002dvariable_002dname"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable-name</strong> <var class="def-var-arguments">condition-variable</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_002dname"> ¶</a></span></dt>
<dd><p>Returns the name assigned to <var class="var">condition-variable</var> at the time of its
creation, or <code class="code">#f</code> if it was not given a name.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-condition_002dvariable_002dspecific"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable-specific</strong> <var class="def-var-arguments">condition-variable</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_002dspecific"> ¶</a></span></dt>
<dd><p>Return the “object-specific” property of <var class="var">condition-variable</var>, or
<code class="code">#f</code> if none is set.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-condition_002dvariable_002dspecific_002dset_0021"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable-specific-set!</strong> <var class="def-var-arguments">condition-variable obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_002dspecific_002dset_0021"> ¶</a></span></dt>
<dd><p>Set the “object-specific” property of <var class="var">condition-variable</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-condition_002dvariable_002dsignal_0021"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable-signal!</strong> <var class="def-var-arguments">condition-variable</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_002dsignal_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-condition_002dvariable_002dbroadcast_0021"><span class="category-def">Function: </span><span><strong class="def-name">condition-variable-broadcast!</strong> <var class="def-var-arguments">condition-variable</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dvariable_002dbroadcast_0021"> ¶</a></span></dt>
<dd><p>Wake up one thread that is waiting for <var class="var">condition-variable</var>, in
the case of <code class="code">condition-variable-signal!</code>, or all threads waiting
for it, in the case of <code class="code">condition-variable-broadcast!</code>.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d18-Time">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Exceptions" accesskey="n" rel="next">SRFI-18 Exceptions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Condition-variables" accesskey="p" rel="prev">SRFI-18 Condition variables</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="u" rel="up">SRFI-18 - Multithreading support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d18-Time-1">7.5.15.4 SRFI-18 Time</h4>

<p>The SRFI-18 time functions manipulate time in two formats: a 
“time object” type that represents an absolute point in time in some 
implementation-specific way; and the number of seconds since some 
unspecified “epoch”.  In Guile’s implementation, the epoch is the
Unix epoch, 00:00:00 UTC, January 1, 1970.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dtime-1"><span class="category-def">Function: </span><span><strong class="def-name">current-time</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dtime-1"> ¶</a></span></dt>
<dd><p>Return the current time as a time object.  This procedure replaces 
the procedure of the same name in the core library, which returns the
current time in seconds since the epoch.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_003f"><span class="category-def">Function: </span><span><strong class="def-name">time?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is a time object, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002d_003eseconds"><span class="category-def">Function: </span><span><strong class="def-name">time-&gt;seconds</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002d_003eseconds"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-seconds_002d_003etime"><span class="category-def">Function: </span><span><strong class="def-name">seconds-&gt;time</strong> <var class="def-var-arguments">seconds</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-seconds_002d_003etime"> ¶</a></span></dt>
<dd><p>Convert between time objects and numerical values representing the
number of seconds since the epoch.  When converting from a time object 
to seconds, the return value is the number of seconds between 
<var class="var">time</var> and the epoch.  When converting from seconds to a time 
object, the return value is a time object that represents a time 
<var class="var">seconds</var> seconds after the epoch.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d18-Exceptions">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time" accesskey="p" rel="prev">SRFI-18 Time</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="u" rel="up">SRFI-18 - Multithreading support</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d18-Exceptions-1">7.5.15.5 SRFI-18 Exceptions</h4>

<p>SRFI-18 exceptions are identical to the exceptions provided by 
Guile’s implementation of SRFI-34.  The behavior of exception 
handlers invoked to handle exceptions thrown from SRFI-18 functions,
however, differs from the conventional behavior of SRFI-34 in that
the continuation of the handler is the same as that of the call to
the function.  Handlers are called in a tail-recursive manner; the
exceptions do not “bubble up”.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dexception_002dhandler"><span class="category-def">Function: </span><span><strong class="def-name">current-exception-handler</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dexception_002dhandler"> ¶</a></span></dt>
<dd><p>Returns the current exception handler.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-with_002dexception_002dhandler-1"><span class="category-def">Function: </span><span><strong class="def-name">with-exception-handler</strong> <var class="def-var-arguments">handler thunk</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-with_002dexception_002dhandler-1"> ¶</a></span></dt>
<dd><p>Installs <var class="var">handler</var> as the current exception handler and calls the
procedure <var class="var">thunk</var> with no arguments, returning its value as the 
value of the exception.  <var class="var">handler</var> must be a procedure that accepts
a single argument. The current exception handler at the time this 
procedure is called will be restored after the call returns.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-raise-1"><span class="category-def">Function: </span><span><strong class="def-name">raise</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-raise-1"> ¶</a></span></dt>
<dd><p>Raise <var class="var">obj</var> as an exception.  This is the same procedure as the
same-named procedure defined in SRFI 34.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-join_002dtimeout_002dexception_003f"><span class="category-def">Function: </span><span><strong class="def-name">join-timeout-exception?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-join_002dtimeout_002dexception_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is an exception raised as the result of 
performing a timed join on a thread that does not exit within the
specified timeout, <code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-abandoned_002dmutex_002dexception_003f"><span class="category-def">Function: </span><span><strong class="def-name">abandoned-mutex-exception?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-abandoned_002dmutex_002dexception_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is an exception raised as the result of
attempting to lock a mutex that has been abandoned by its owner thread,
<code class="code">#f</code> otherwise.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-terminated_002dthread_002dexception_003f"><span class="category-def">Function: </span><span><strong class="def-name">terminated-thread-exception?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-terminated_002dthread_002dexception_003f"> ¶</a></span></dt>
<dd><p>Returns <code class="code">#t</code> if <var class="var">obj</var> is an exception raised as the result of 
joining on a thread that exited as the result of a call to
<code class="code">thread-terminate!</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-uncaught_002dexception_003f"><span class="category-def">Function: </span><span><strong class="def-name">uncaught-exception?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uncaught_002dexception_003f"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-uncaught_002dexception_002dreason"><span class="category-def">Function: </span><span><strong class="def-name">uncaught-exception-reason</strong> <var class="def-var-arguments">exc</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-uncaught_002dexception_002dreason"> ¶</a></span></dt>
<dd><p><code class="code">uncaught-exception?</code> returns <code class="code">#t</code> if <var class="var">obj</var> is an 
exception thrown as the result of joining a thread that exited by
raising an exception that was handled by the top-level exception
handler installed by <code class="code">make-thread</code>.  When this occurs, the 
original exception is preserved as part of the exception thrown by
<code class="code">thread-join!</code> and can be accessed by calling 
<code class="code">uncaught-exception-reason</code> on that exception.  Note that
because this exception-preservation mechanism is a side-effect of
<code class="code">make-thread</code>, joining on threads that exited as described above
but were created by other means will not raise this 
<code class="code">uncaught-exception</code> error.
</p></dd></dl>


<hr>
</div>
</div>
<div class="subsection-level-extent" id="SRFI_002d19">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d23" accesskey="n" rel="next">SRFI-23 - Error Reporting</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18" accesskey="p" rel="prev">SRFI-18 - Multithreading support</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d19-_002d-Time_002fDate-Library">7.5.16 SRFI-19 - Time/Date Library</h4>
<a class="index-entry-id" id="index-SRFI_002d19"></a>
<a class="index-entry-id" id="index-time-1"></a>
<a class="index-entry-id" id="index-date"></a>

<p>This is an implementation of the SRFI-19 time/date library.  The
functions and variables described here are provided by
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-19))
</pre></div>


<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Introduction" accesskey="1">SRFI-19 Introduction</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time" accesskey="2">SRFI-19 Time</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date" accesskey="3">SRFI-19 Date</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time_002fDate-conversions" accesskey="4">SRFI-19 Time/Date conversions</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date-to-string" accesskey="5">SRFI-19 Date to string</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-String-to-date" accesskey="6">SRFI-19 String to date</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="SRFI_002d19-Introduction">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time" accesskey="n" rel="next">SRFI-19 Time</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-Introduction-1">7.5.16.1 SRFI-19 Introduction</h4>

<a class="index-entry-id" id="index-universal-time"></a>
<a class="index-entry-id" id="index-atomic-time"></a>
<a class="index-entry-id" id="index-UTC"></a>
<a class="index-entry-id" id="index-TAI"></a>
<p>This module implements time and date representations and calculations,
in various time systems, including Coordinated Universal Time (UTC)
and International Atomic Time (TAI).
</p>
<p>For those not familiar with these time systems, TAI is based on a
fixed length second derived from oscillations of certain atoms.  UTC
differs from TAI by an integral number of seconds, which is increased
or decreased at announced times to keep UTC aligned to a mean solar
day (the orbit and rotation of the earth are not quite constant).
</p>
<a class="index-entry-id" id="index-leap-second"></a>
<p>So far, only increases in the TAI
&lt;-&gt;
UTC difference have been needed.  Such an increase is a “leap
second”, an extra second of TAI introduced at the end of a UTC day.
When working entirely within UTC this is never seen, every day simply
has 86400 seconds.  But when converting from TAI to a UTC date, an
extra 23:59:60 is present, where normally a day would end at 23:59:59.
Effectively the UTC second from 23:59:59 to 00:00:00 has taken two TAI
seconds.
</p>
<a class="index-entry-id" id="index-system-clock"></a>
<p>In the current implementation, the system clock is assumed to be UTC,
and a table of leap seconds in the code converts to TAI.  See comments
in <samp class="file">srfi-19.scm</samp> for how to update this table.
</p>
<a class="index-entry-id" id="index-julian-day"></a>
<a class="index-entry-id" id="index-modified-julian-day"></a>
<p>Also, for those not familiar with the terminology, a <em class="dfn">Julian Day</em>
represents a point in time as a real number of days since
-4713-11-24T12:00:00Z, i.e. midday UT on 24 November 4714 BC in the
proleptic Gregorian calendar (1 January 4713 BC in the proleptic Julian
calendar).
</p>
<p>A <em class="dfn">Modified Julian Day</em> represents a point in time as a real number
of days since 1858-11-17T00:00:00Z, i.e. midnight UT on Wednesday 17
November AD 1858.  That time is julian day 2400000.5.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d19-Time">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date" accesskey="n" rel="next">SRFI-19 Date</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Introduction" accesskey="p" rel="prev">SRFI-19 Introduction</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-Time-1">7.5.16.2 SRFI-19 Time</h4>
<a class="index-entry-id" id="index-time-2"></a>

<p>A <em class="dfn">time</em> object has type, seconds and nanoseconds fields
representing a point in time starting from some epoch.  This is an
arbitrary point in time, not just a time of day.  Although times are
represented in nanoseconds, the actual resolution may be lower.
</p>
<p>The following variables hold the possible time types.  For instance
<code class="code">(current-time time-process)</code> would give the current CPU process
time.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dutc"><span class="category-def">Variable: </span><span><strong class="def-name">time-utc</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc"> ¶</a></span></dt>
<dd><p>Universal Coordinated Time (UTC).
<a class="index-entry-id" id="index-UTC-1"></a>
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dtai"><span class="category-def">Variable: </span><span><strong class="def-name">time-tai</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai"> ¶</a></span></dt>
<dd><p>International Atomic Time (TAI).
<a class="index-entry-id" id="index-TAI-1"></a>
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dmonotonic"><span class="category-def">Variable: </span><span><strong class="def-name">time-monotonic</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic"> ¶</a></span></dt>
<dd><p>Monotonic time, meaning a monotonically increasing time starting from
an unspecified epoch.
</p>
<p>Note that in the current implementation <code class="code">time-monotonic</code> is the
same as <code class="code">time-tai</code>, and unfortunately is therefore affected by
adjustments to the system clock.  Perhaps this will change in the
future.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dduration"><span class="category-def">Variable: </span><span><strong class="def-name">time-duration</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dduration"> ¶</a></span></dt>
<dd><p>A duration, meaning simply a difference between two times.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dprocess"><span class="category-def">Variable: </span><span><strong class="def-name">time-process</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dprocess"> ¶</a></span></dt>
<dd><p>CPU time spent in the current process, starting from when the process
began.
<a class="index-entry-id" id="index-process-time"></a>
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-time_002dthread"><span class="category-def">Variable: </span><span><strong class="def-name">time-thread</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dthread"> ¶</a></span></dt>
<dd><p>CPU time spent in the current thread.  Not currently implemented.
<a class="index-entry-id" id="index-thread-time"></a>
</p></dd></dl>

<br>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_003f-1"><span class="category-def">Function: </span><span><strong class="def-name">time?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003f-1"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a time object, or <code class="code">#f</code> if not.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002dtime"><span class="category-def">Function: </span><span><strong class="def-name">make-time</strong> <var class="def-var-arguments">type nanoseconds seconds</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dtime"> ¶</a></span></dt>
<dd><p>Create a time object with the given <var class="var">type</var>, <var class="var">seconds</var> and
<var class="var">nanoseconds</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002dtype"><span class="category-def">Function: </span><span><strong class="def-name">time-type</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtype"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dnanosecond"><span class="category-def">Function: </span><span><strong class="def-name">time-nanosecond</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dnanosecond"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dsecond"><span class="category-def">Function: </span><span><strong class="def-name">time-second</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dsecond"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-set_002dtime_002dtype_0021"><span class="category-def">Function: </span><span><strong class="def-name">set-time-type!</strong> <var class="def-var-arguments">time type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtime_002dtype_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-set_002dtime_002dnanosecond_0021"><span class="category-def">Function: </span><span><strong class="def-name">set-time-nanosecond!</strong> <var class="def-var-arguments">time nsec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtime_002dnanosecond_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-set_002dtime_002dsecond_0021"><span class="category-def">Function: </span><span><strong class="def-name">set-time-second!</strong> <var class="def-var-arguments">time sec</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-set_002dtime_002dsecond_0021"> ¶</a></span></dt>
<dd><p>Get or set the type, seconds or nanoseconds fields of a time object.
</p>
<p><code class="code">set-time-type!</code> merely changes the field, it doesn’t convert the
time value.  For conversions, see <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time_002fDate-conversions">SRFI-19 Time/Date conversions</a>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-copy_002dtime"><span class="category-def">Function: </span><span><strong class="def-name">copy-time</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-copy_002dtime"> ¶</a></span></dt>
<dd><p>Return a new time object, which is a copy of the given <var class="var">time</var>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dtime-2"><span class="category-def">Function: </span><span><strong class="def-name">current-time</strong> <var class="def-var-arguments">[type]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dtime-2"> ¶</a></span></dt>
<dd><p>Return the current time of the given <var class="var">type</var>.  The default
<var class="var">type</var> is <code class="code">time-utc</code>.
</p>
<p>Note that the name <code class="code">current-time</code> conflicts with the Guile core
<code class="code">current-time</code> function (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>) as well as the SRFI-18
<code class="code">current-time</code> function (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d18-Time">SRFI-18 Time</a>).  Applications 
wanting to use more than one of these functions will need to refer to
them by different names.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002dresolution"><span class="category-def">Function: </span><span><strong class="def-name">time-resolution</strong> <var class="def-var-arguments">[type]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dresolution"> ¶</a></span></dt>
<dd><p>Return the resolution, in nanoseconds, of the given time <var class="var">type</var>.
The default <var class="var">type</var> is <code class="code">time-utc</code>.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_003c_003d_003f"><span class="category-def">Function: </span><span><strong class="def-name">time&lt;=?</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003c_003d_003f"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_003c_003f"><span class="category-def">Function: </span><span><strong class="def-name">time&lt;?</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003c_003f"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_003d_003f"><span class="category-def">Function: </span><span><strong class="def-name">time=?</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003d_003f"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_003e_003d_003f"><span class="category-def">Function: </span><span><strong class="def-name">time&gt;=?</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003e_003d_003f"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_003e_003f"><span class="category-def">Function: </span><span><strong class="def-name">time&gt;?</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_003e_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> or <code class="code">#f</code> according to the respective relation
between time objects <var class="var">t1</var> and <var class="var">t2</var>.  <var class="var">t1</var> and <var class="var">t2</var>
must be the same time type.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002ddifference"><span class="category-def">Function: </span><span><strong class="def-name">time-difference</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002ddifference"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002ddifference_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-difference!</strong> <var class="def-var-arguments">t1 t2</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002ddifference_0021"> ¶</a></span></dt>
<dd><p>Return a time object of type <code class="code">time-duration</code> representing the
period between <var class="var">t1</var> and <var class="var">t2</var>.  <var class="var">t1</var> and <var class="var">t2</var> must be
the same time type.
</p>
<p><code class="code">time-difference</code> returns a new time object,
<code class="code">time-difference!</code> may modify <var class="var">t1</var> to form its return.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-add_002dduration"><span class="category-def">Function: </span><span><strong class="def-name">add-duration</strong> <var class="def-var-arguments">time duration</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dduration"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-add_002dduration_0021"><span class="category-def">Function: </span><span><strong class="def-name">add-duration!</strong> <var class="def-var-arguments">time duration</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-add_002dduration_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-subtract_002dduration"><span class="category-def">Function: </span><span><strong class="def-name">subtract-duration</strong> <var class="def-var-arguments">time duration</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-subtract_002dduration"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-subtract_002dduration_0021"><span class="category-def">Function: </span><span><strong class="def-name">subtract-duration!</strong> <var class="def-var-arguments">time duration</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-subtract_002dduration_0021"> ¶</a></span></dt>
<dd><p>Return a time object which is <var class="var">time</var> with the given <var class="var">duration</var>
added or subtracted.  <var class="var">duration</var> must be a time object of type
<code class="code">time-duration</code>.
</p>
<p><code class="code">add-duration</code> and <code class="code">subtract-duration</code> return a new time
object.  <code class="code">add-duration!</code> and <code class="code">subtract-duration!</code> may modify
the given <var class="var">time</var> to form their return.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d19-Date">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time_002fDate-conversions" accesskey="n" rel="next">SRFI-19 Time/Date conversions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time" accesskey="p" rel="prev">SRFI-19 Time</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-Date-1">7.5.16.3 SRFI-19 Date</h4>
<a class="index-entry-id" id="index-date-1"></a>

<p>A <em class="dfn">date</em> object represents a date in the Gregorian calendar and a
time of day on that date in some timezone.
</p>
<p>The fields are year, month, day, hour, minute, second, nanoseconds and
timezone.  A date object is immutable, its fields can be read but they
cannot be modified once the object is created.
</p>
<p>Historically, the Gregorian calendar was only used from the latter part
of the year 1582 onwards, and not until even later in many countries.
Prior to that most countries used the Julian calendar.  SRFI-19 does
not deal with the Julian calendar at all, and so does not reflect this
historical calendar reform.  Instead it projects the Gregorian calendar
back proleptically as far as necessary.  When dealing with historical
data, especially prior to the British Empire’s adoption of the Gregorian
calendar in 1752, one should be mindful of which calendar is used in
each context, and apply non-SRFI-19 facilities to convert where necessary.
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_003f"><span class="category-def">Function: </span><span><strong class="def-name">date?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_003f"> ¶</a></span></dt>
<dd><p>Return <code class="code">#t</code> if <var class="var">obj</var> is a date object, or <code class="code">#f</code> if not.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002ddate"><span class="category-def">Function: </span><span><strong class="def-name">make-date</strong> <var class="def-var-arguments">nsecs seconds minutes hours date month year zone-offset</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002ddate"> ¶</a></span></dt>
<dd><p>Create a new date object.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dnanosecond"><span class="category-def">Function: </span><span><strong class="def-name">date-nanosecond</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dnanosecond"> ¶</a></span></dt>
<dd><p>Nanoseconds, 0 to 999999999.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dsecond"><span class="category-def">Function: </span><span><strong class="def-name">date-second</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dsecond"> ¶</a></span></dt>
<dd><p>Seconds, 0 to 59, or 60 for a leap second.  60 is never seen when working
entirely within UTC, it’s only when converting to or from TAI.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dminute"><span class="category-def">Function: </span><span><strong class="def-name">date-minute</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dminute"> ¶</a></span></dt>
<dd><p>Minutes, 0 to 59.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dhour"><span class="category-def">Function: </span><span><strong class="def-name">date-hour</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dhour"> ¶</a></span></dt>
<dd><p>Hour, 0 to 23.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dday"><span class="category-def">Function: </span><span><strong class="def-name">date-day</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dday"> ¶</a></span></dt>
<dd><p>Day of the month, 1 to 31 (or less, according to the month).
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dmonth"><span class="category-def">Function: </span><span><strong class="def-name">date-month</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dmonth"> ¶</a></span></dt>
<dd><p>Month, 1 to 12.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dyear"><span class="category-def">Function: </span><span><strong class="def-name">date-year</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dyear"> ¶</a></span></dt>
<dd><p>Year, eg. 2003.  Dates B.C. are negative, eg. <em class="math">-46</em> is 46
B.C.  There is no year 0, year <em class="math">-1</em> is followed by year 1.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dzone_002doffset"><span class="category-def">Function: </span><span><strong class="def-name">date-zone-offset</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dzone_002doffset"> ¶</a></span></dt>
<dd><p>Time zone, an integer number of seconds east of Greenwich.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dyear_002dday"><span class="category-def">Function: </span><span><strong class="def-name">date-year-day</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dyear_002dday"> ¶</a></span></dt>
<dd><p>Day of the year, starting from 1 for 1st January.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dweek_002dday"><span class="category-def">Function: </span><span><strong class="def-name">date-week-day</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dweek_002dday"> ¶</a></span></dt>
<dd><p>Day of the week, starting from 0 for Sunday.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002dweek_002dnumber"><span class="category-def">Function: </span><span><strong class="def-name">date-week-number</strong> <var class="def-var-arguments">date dstartw</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002dweek_002dnumber"> ¶</a></span></dt>
<dd><p>Week of the year, ignoring a first partial week.  <var class="var">dstartw</var> is the
day of the week which is taken to start a week, 0 for Sunday, 1 for
Monday, etc.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002ddate"><span class="category-def">Function: </span><span><strong class="def-name">current-date</strong> <var class="def-var-arguments">[tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002ddate"> ¶</a></span></dt>
<dd><p>Return a date object representing the current date/time, in UTC offset
by <var class="var">tz-offset</var>.  <var class="var">tz-offset</var> is seconds east of Greenwich and
defaults to the local timezone.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002djulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">current-julian-day</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002djulian_002dday"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-julian-day-1"></a>
<p>Return the current Julian Day.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-current_002dmodified_002djulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">current-modified-julian-day</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-current_002dmodified_002djulian_002dday"> ¶</a></span></dt>
<dd><a class="index-entry-id" id="index-modified-julian-day-1"></a>
<p>Return the current Modified Julian Day.
</p></dd></dl>


<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d19-Time_002fDate-conversions">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date-to-string" accesskey="n" rel="next">SRFI-19 Date to string</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date" accesskey="p" rel="prev">SRFI-19 Date</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-Time_002fDate-conversions-1">7.5.16.4 SRFI-19 Time/Date conversions</h4>
<a class="index-entry-id" id="index-time-conversion"></a>
<a class="index-entry-id" id="index-date-conversion"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002d_003ejulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;julian-day</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003ejulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-date_002d_003emodified_002djulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;modified-julian-day</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003emodified_002djulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-date_002d_003etime_002dmonotonic"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;time-monotonic</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003etime_002dmonotonic"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-date_002d_003etime_002dtai"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;time-tai</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003etime_002dtai"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-date_002d_003etime_002dutc"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;time-utc</strong> <var class="def-var-arguments">date</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003etime_002dutc"> ¶</a></span></dt>
</dl>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-julian_002dday_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">julian-day-&gt;date</strong> <var class="def-var-arguments">jdn [tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-julian_002dday_002d_003edate"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-julian_002dday_002d_003etime_002dmonotonic"><span class="category-def">Function: </span><span><strong class="def-name">julian-day-&gt;time-monotonic</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-julian_002dday_002d_003etime_002dmonotonic"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-julian_002dday_002d_003etime_002dtai"><span class="category-def">Function: </span><span><strong class="def-name">julian-day-&gt;time-tai</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-julian_002dday_002d_003etime_002dtai"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-julian_002dday_002d_003etime_002dutc"><span class="category-def">Function: </span><span><strong class="def-name">julian-day-&gt;time-utc</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-julian_002dday_002d_003etime_002dutc"> ¶</a></span></dt>
</dl>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-modified_002djulian_002dday_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">modified-julian-day-&gt;date</strong> <var class="def-var-arguments">jdn [tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modified_002djulian_002dday_002d_003edate"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-modified_002djulian_002dday_002d_003etime_002dmonotonic"><span class="category-def">Function: </span><span><strong class="def-name">modified-julian-day-&gt;time-monotonic</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modified_002djulian_002dday_002d_003etime_002dmonotonic"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-modified_002djulian_002dday_002d_003etime_002dtai"><span class="category-def">Function: </span><span><strong class="def-name">modified-julian-day-&gt;time-tai</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modified_002djulian_002dday_002d_003etime_002dtai"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-modified_002djulian_002dday_002d_003etime_002dutc"><span class="category-def">Function: </span><span><strong class="def-name">modified-julian-day-&gt;time-utc</strong> <var class="def-var-arguments">jdn</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-modified_002djulian_002dday_002d_003etime_002dutc"> ¶</a></span></dt>
</dl>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002dmonotonic_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">time-monotonic-&gt;date</strong> <var class="def-var-arguments">time [tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic_002d_003edate"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dmonotonic_002d_003etime_002dtai"><span class="category-def">Function: </span><span><strong class="def-name">time-monotonic-&gt;time-tai</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic_002d_003etime_002dtai"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dmonotonic_002d_003etime_002dtai_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-monotonic-&gt;time-tai!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic_002d_003etime_002dtai_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dmonotonic_002d_003etime_002dutc"><span class="category-def">Function: </span><span><strong class="def-name">time-monotonic-&gt;time-utc</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic_002d_003etime_002dutc"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dmonotonic_002d_003etime_002dutc_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-monotonic-&gt;time-utc!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dmonotonic_002d_003etime_002dutc_0021"> ¶</a></span></dt>
</dl>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002dtai_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;date</strong> <var class="def-var-arguments">time [tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003edate"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003ejulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;julian-day</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003ejulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003emodified_002djulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;modified-julian-day</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003emodified_002djulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003etime_002dmonotonic"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;time-monotonic</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003etime_002dmonotonic"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003etime_002dmonotonic_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;time-monotonic!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003etime_002dmonotonic_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003etime_002dutc"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;time-utc</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003etime_002dutc"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dtai_002d_003etime_002dutc_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-tai-&gt;time-utc!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dtai_002d_003etime_002dutc_0021"> ¶</a></span></dt>
</dl>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-time_002dutc_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;date</strong> <var class="def-var-arguments">time [tz-offset]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003edate"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003ejulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;julian-day</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003ejulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003emodified_002djulian_002dday"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;modified-julian-day</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003emodified_002djulian_002dday"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003etime_002dmonotonic"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;time-monotonic</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003etime_002dmonotonic"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003etime_002dmonotonic_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;time-monotonic!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003etime_002dmonotonic_0021"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003etime_002dtai"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;time-tai</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003etime_002dtai"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-time_002dutc_002d_003etime_002dtai_0021"><span class="category-def">Function: </span><span><strong class="def-name">time-utc-&gt;time-tai!</strong> <var class="def-var-arguments">time</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-time_002dutc_002d_003etime_002dtai_0021"> ¶</a></span></dt>
<dd><br>
<p>Convert between dates, times and days of the respective types.  For
instance <code class="code">time-tai-&gt;time-utc</code> accepts a <var class="var">time</var> object of type
<code class="code">time-tai</code> and returns an object of type <code class="code">time-utc</code>.
</p>
<p>The <code class="code">!</code> variants may modify their <var class="var">time</var> argument to form
their return.  The plain functions create a new object.
</p>
<p>For conversions to dates, <var class="var">tz-offset</var> is seconds east of
Greenwich.  The default is the local timezone, at the given time, as
provided by the system, using <code class="code">localtime</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>).
</p>
<p>On 32-bit systems, <code class="code">localtime</code> is limited to a 32-bit
<code class="code">time_t</code>, so a default <var class="var">tz-offset</var> is only available for
times between Dec 1901 and Jan 2038.  For prior dates an application
might like to use the value in 1902, though some locations have zone
changes prior to that.  For future dates an application might like to
assume today’s rules extend indefinitely.  But for correct daylight
savings transitions it will be necessary to take an offset for the
same day and time but a year in range and which has the same starting
weekday and same leap/non-leap (to support rules like last Sunday in
October).
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d19-Date-to-string">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-String-to-date" accesskey="n" rel="next">SRFI-19 String to date</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Time_002fDate-conversions" accesskey="p" rel="prev">SRFI-19 Time/Date conversions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-Date-to-string-1">7.5.16.5 SRFI-19 Date to string</h4>
<a class="index-entry-id" id="index-date-to-string"></a>
<a class="index-entry-id" id="index-string_002c-from-date"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-date_002d_003estring"><span class="category-def">Function: </span><span><strong class="def-name">date-&gt;string</strong> <var class="def-var-arguments">date [format]</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-date_002d_003estring"> ¶</a></span></dt>
<dd><p>Convert a date to a string under the control of a format.
<var class="var">format</var> should be a string containing ‘<samp class="samp">~</samp>’ escapes, which
will be expanded as per the following conversion table.  The default
<var class="var">format</var> is ‘<samp class="samp">~c</samp>’, a locale-dependent date and time.
</p>
<p>Many of these conversion characters are the same as POSIX
<code class="code">strftime</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Time">Time</a>), but there are some extras and some
variations.
</p>
<table class="multitable">
<tbody><tr><td><code class="code">~~</code></td><td>literal ~</td></tr>
<tr><td><code class="code">~a</code></td><td>locale abbreviated weekday, eg. ‘<samp class="samp">Sun</samp>’</td></tr>
<tr><td><code class="code">~A</code></td><td>locale full weekday, eg. ‘<samp class="samp">Sunday</samp>’</td></tr>
<tr><td><code class="code">~b</code></td><td>locale abbreviated month, eg. ‘<samp class="samp">Jan</samp>’</td></tr>
<tr><td><code class="code">~B</code></td><td>locale full month, eg. ‘<samp class="samp">January</samp>’</td></tr>
<tr><td><code class="code">~c</code></td><td>locale date and time, eg. <br>
‘<samp class="samp">Fri Jul 14 20:28:42-0400 2000</samp>’</td></tr>
<tr><td><code class="code">~d</code></td><td>day of month, zero padded, ‘<samp class="samp">01</samp>’ to ‘<samp class="samp">31</samp>’</td></tr>
<tr><td><code class="code">~e</code></td><td>day of month, blank padded, ‘<samp class="samp"> 1</samp>’ to ‘<samp class="samp">31</samp>’</td></tr>
<tr><td><code class="code">~f</code></td><td>seconds and fractional seconds,
with locale decimal point, eg. ‘<samp class="samp">5.2</samp>’</td></tr>
<tr><td><code class="code">~h</code></td><td>same as <code class="code">~b</code></td></tr>
<tr><td><code class="code">~H</code></td><td>hour, 24-hour clock, zero padded, ‘<samp class="samp">00</samp>’ to ‘<samp class="samp">23</samp>’</td></tr>
<tr><td><code class="code">~I</code></td><td>hour, 12-hour clock, zero padded, ‘<samp class="samp">01</samp>’ to ‘<samp class="samp">12</samp>’</td></tr>
<tr><td><code class="code">~j</code></td><td>day of year, zero padded, ‘<samp class="samp">001</samp>’ to ‘<samp class="samp">366</samp>’</td></tr>
<tr><td><code class="code">~k</code></td><td>hour, 24-hour clock, blank padded, ‘<samp class="samp"> 0</samp>’ to ‘<samp class="samp">23</samp>’</td></tr>
<tr><td><code class="code">~l</code></td><td>hour, 12-hour clock, blank padded, ‘<samp class="samp"> 1</samp>’ to ‘<samp class="samp">12</samp>’</td></tr>
<tr><td><code class="code">~m</code></td><td>month, zero padded, ‘<samp class="samp">01</samp>’ to ‘<samp class="samp">12</samp>’</td></tr>
<tr><td><code class="code">~M</code></td><td>minute, zero padded, ‘<samp class="samp">00</samp>’ to ‘<samp class="samp">59</samp>’</td></tr>
<tr><td><code class="code">~n</code></td><td>newline</td></tr>
<tr><td><code class="code">~N</code></td><td>nanosecond, zero padded, ‘<samp class="samp">000000000</samp>’ to ‘<samp class="samp">999999999</samp>’</td></tr>
<tr><td><code class="code">~p</code></td><td>locale AM or PM</td></tr>
<tr><td><code class="code">~r</code></td><td>time, 12 hour clock, ‘<samp class="samp">~I:~M:~S ~p</samp>’</td></tr>
<tr><td><code class="code">~s</code></td><td>number of full seconds since “the epoch” in UTC</td></tr>
<tr><td><code class="code">~S</code></td><td>second, zero padded ‘<samp class="samp">00</samp>’ to ‘<samp class="samp">60</samp>’ <br>
(usual limit is 59, 60 is a leap second)</td></tr>
<tr><td><code class="code">~t</code></td><td>horizontal tab character</td></tr>
<tr><td><code class="code">~T</code></td><td>time, 24 hour clock, ‘<samp class="samp">~H:~M:~S</samp>’</td></tr>
<tr><td><code class="code">~U</code></td><td>week of year, Sunday first day of week,
‘<samp class="samp">00</samp>’ to ‘<samp class="samp">52</samp>’</td></tr>
<tr><td><code class="code">~V</code></td><td>week of year, Monday first day of week,
‘<samp class="samp">01</samp>’ to ‘<samp class="samp">53</samp>’</td></tr>
<tr><td><code class="code">~w</code></td><td>day of week, 0 for Sunday, ‘<samp class="samp">0</samp>’ to ‘<samp class="samp">6</samp>’</td></tr>
<tr><td><code class="code">~W</code></td><td>week of year, Monday first day of week,
‘<samp class="samp">00</samp>’ to ‘<samp class="samp">52</samp>’</td></tr>
<tr><td><code class="code">~y</code></td><td>year, two digits, ‘<samp class="samp">00</samp>’ to ‘<samp class="samp">99</samp>’</td></tr>
<tr><td><code class="code">~Y</code></td><td>year, full, eg. ‘<samp class="samp">2003</samp>’</td></tr>
<tr><td><code class="code">~z</code></td><td>time zone, RFC-822 style</td></tr>
<tr><td><code class="code">~Z</code></td><td>time zone symbol (not currently implemented)</td></tr>
<tr><td><code class="code">~1</code></td><td>ISO-8601 date, ‘<samp class="samp">~Y-~m-~d</samp>’</td></tr>
<tr><td><code class="code">~2</code></td><td>ISO-8601 time+zone, ‘<samp class="samp">~H:~M:~S~z</samp>’</td></tr>
<tr><td><code class="code">~3</code></td><td>ISO-8601 time, ‘<samp class="samp">~H:~M:~S</samp>’</td></tr>
<tr><td><code class="code">~4</code></td><td>ISO-8601 date/time+zone, ‘<samp class="samp">~Y-~m-~dT~H:~M:~S~z</samp>’</td></tr>
<tr><td><code class="code">~5</code></td><td>ISO-8601 date/time, ‘<samp class="samp">~Y-~m-~dT~H:~M:~S</samp>’</td></tr>
</tbody>
</table>
</dd></dl>

<p>Conversions ‘<samp class="samp">~D</samp>’, ‘<samp class="samp">~x</samp>’ and ‘<samp class="samp">~X</samp>’ are not currently
described here, since the specification and reference implementation
differ.
</p>
<p>Conversion is locale-dependent on systems that support it
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information">Accessing Locale Information</a>).  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales"><code class="code">setlocale</code></a>, for information on how to change the current
locale.
</p>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d19-String-to-date">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19-Date-to-string" accesskey="p" rel="prev">SRFI-19 Date to string</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="u" rel="up">SRFI-19 - Time/Date Library</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="SRFI_002d19-String-to-date-1">7.5.16.6 SRFI-19 String to date</h4>
<a class="index-entry-id" id="index-string-to-date"></a>
<a class="index-entry-id" id="index-date_002c-from-string"></a>


<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-string_002d_003edate"><span class="category-def">Function: </span><span><strong class="def-name">string-&gt;date</strong> <var class="def-var-arguments">input template</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-string_002d_003edate"> ¶</a></span></dt>
<dd><p>Convert an <var class="var">input</var> string to a date under the control of a
<var class="var">template</var> string.  Return a newly created date object.
</p>
<p>Literal characters in <var class="var">template</var> must match characters in
<var class="var">input</var> and ‘<samp class="samp">~</samp>’ escapes must match the input forms described
in the table below.  “Skip to” means characters up to one of the
given type are ignored, or “no skip” for no skipping.  “Read” is
what’s then read, and “Set” is the field affected in the date
object.
</p>
<p>For example ‘<samp class="samp">~Y</samp>’ skips input characters until a digit is reached,
at which point it expects a year and stores that to the year field of
the date.
</p>
<table class="multitable">
<tbody><tr><td></td><td>Skip to</td><td>Read</td><td>Set</td></tr>
<tr><td><code class="code">~~</code></td><td>no skip</td><td>literal ~</td><td>nothing</td></tr>
<tr><td><code class="code">~a</code></td><td><code class="code">char-alphabetic?</code></td><td>locale abbreviated weekday name</td><td>nothing</td></tr>
<tr><td><code class="code">~A</code></td><td><code class="code">char-alphabetic?</code></td><td>locale full weekday name</td><td>nothing</td></tr>
<tr><td><code class="code">~b</code></td><td><code class="code">char-alphabetic?</code></td><td>locale abbreviated month name</td><td><code class="code">date-month</code></td></tr>
<tr><td><code class="code">~B</code></td><td><code class="code">char-alphabetic?</code></td><td>locale full month name</td><td><code class="code">date-month</code></td></tr>
<tr><td><code class="code">~d</code></td><td><code class="code">char-numeric?</code></td><td>day of month</td><td><code class="code">date-day</code></td></tr>
<tr><td><code class="code">~e</code></td><td>no skip</td><td>day of month, blank padded</td><td><code class="code">date-day</code></td></tr>
<tr><td><code class="code">~h</code></td><td>same as ‘<samp class="samp">~b</samp>’</td></tr>
<tr><td><code class="code">~H</code></td><td><code class="code">char-numeric?</code></td><td>hour</td><td><code class="code">date-hour</code></td></tr>
<tr><td><code class="code">~k</code></td><td>no skip</td><td>hour, blank padded</td><td><code class="code">date-hour</code></td></tr>
<tr><td><code class="code">~m</code></td><td><code class="code">char-numeric?</code></td><td>month</td><td><code class="code">date-month</code></td></tr>
<tr><td><code class="code">~M</code></td><td><code class="code">char-numeric?</code></td><td>minute</td><td><code class="code">date-minute</code></td></tr>
<tr><td><code class="code">~N</code></td><td><code class="code">char-numeric?</code></td><td>nanosecond</td><td><code class="code">date-nanosecond</code></td></tr>
<tr><td><code class="code">~S</code></td><td><code class="code">char-numeric?</code></td><td>second</td><td><code class="code">date-second</code></td></tr>
<tr><td><code class="code">~y</code></td><td>no skip</td><td>2-digit year</td><td><code class="code">date-year</code> within 50 years</td></tr>
<tr><td><code class="code">~Y</code></td><td><code class="code">char-numeric?</code></td><td>year</td><td><code class="code">date-year</code></td></tr>
<tr><td><code class="code">~z</code></td><td>no skip</td><td>time zone</td><td>date-zone-offset</td></tr>
</tbody>
</table>

<p>Notice that the weekday matching forms don’t affect the date object
returned, instead the weekday will be derived from the day, month and
year.
</p>
<p>Conversion is locale-dependent on systems that support it
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Accessing-Locale-Information">Accessing Locale Information</a>).  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Locales"><code class="code">setlocale</code></a>, for information on how to change the current
locale.
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="SRFI_002d23">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d26" accesskey="n" rel="next">SRFI-26 - specializing parameters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d19" accesskey="p" rel="prev">SRFI-19 - Time/Date Library</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d23-_002d-Error-Reporting">7.5.17 SRFI-23 - Error Reporting</h4>
<a class="index-entry-id" id="index-SRFI_002d23"></a>

<p>The SRFI-23 <code class="code">error</code> procedure is always available.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d26">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27" accesskey="n" rel="next">SRFI-27 - Sources of Random Bits</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d23" accesskey="p" rel="prev">SRFI-23 - Error Reporting</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d26-_002d-specializing-parameters">7.5.18 SRFI-26 - specializing parameters</h4>
<a class="index-entry-id" id="index-SRFI_002d26"></a>
<a class="index-entry-id" id="index-parameter-specialize"></a>
<a class="index-entry-id" id="index-argument-specialize"></a>
<a class="index-entry-id" id="index-specialize-parameter"></a>

<p>This SRFI provides a syntax for conveniently specializing selected
parameters of a function.  It can be used with,
</p>
<div class="example">
<pre class="example-preformatted">(use-modules (srfi srfi-26))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-cut"><span class="category-def">library syntax: </span><span><strong class="def-name">cut</strong> <var class="def-var-arguments">slot1 slot2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cut"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-cute"><span class="category-def">library syntax: </span><span><strong class="def-name">cute</strong> <var class="def-var-arguments">slot1 slot2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-cute"> ¶</a></span></dt>
<dd><p>Return a new procedure which will make a call (<var class="var">slot1</var> <var class="var">slot2</var>
…) but with selected parameters specialized to given expressions.
</p>
<p>An example will illustrate the idea.  The following is a
specialization of <code class="code">write</code>, sending output to
<code class="code">my-output-port</code>,
</p>
<div class="example">
<pre class="example-preformatted">(cut write &lt;&gt; my-output-port)
⇒
(lambda (obj) (write obj my-output-port))
</pre></div>

<p>The special symbol <code class="code">&lt;&gt;</code> indicates a slot to be filled by an
argument to the new procedure.  <code class="code">my-output-port</code> on the other
hand is an expression to be evaluated and passed, ie. it specializes
the behaviour of <code class="code">write</code>.
</p>
<dl class="table">
<dt><code class="code">&lt;&gt;</code></dt>
<dd><p>A slot to be filled by an argument from the created procedure.
Arguments are assigned to <code class="code">&lt;&gt;</code> slots in the order they appear in
the <code class="code">cut</code> form, there’s no way to re-arrange arguments.
</p>
<p>The first argument to <code class="code">cut</code> is usually a procedure (or expression
giving a procedure), but <code class="code">&lt;&gt;</code> is allowed there too.  For example,
</p>
<div class="example">
<pre class="example-preformatted">(cut &lt;&gt; 1 2 3)
⇒
(lambda (proc) (proc 1 2 3))
</pre></div>

</dd>
<dt><code class="code">&lt;...&gt;</code></dt>
<dd><p>A slot to be filled by all remaining arguments from the new procedure.
This can only occur at the end of a <code class="code">cut</code> form.
</p>
<p>For example, a procedure taking a variable number of arguments like
<code class="code">max</code> but in addition enforcing a lower bound,
</p>
<div class="example">
<pre class="example-preformatted">(define my-lower-bound 123)

(cut max my-lower-bound &lt;...&gt;)
⇒
(lambda arglist (apply max my-lower-bound arglist))
</pre></div>
</dd>
</dl>

<p>For <code class="code">cut</code> the specializing expressions are evaluated each time
the new procedure is called.  For <code class="code">cute</code> they’re evaluated just
once, when the new procedure is created.  The name <code class="code">cute</code> stands
for “<code class="code">cut</code> with evaluated arguments”.  In all cases the
evaluations take place in an unspecified order.
</p>
<p>The following illustrates the difference between <code class="code">cut</code> and
<code class="code">cute</code>,
</p>
<div class="example">
<pre class="example-preformatted">(cut format &lt;&gt; "the time is ~s" (current-time))
⇒
(lambda (port) (format port "the time is ~s" (current-time)))

(cute format &lt;&gt; "the time is ~s" (current-time))
⇒
(let ((val (current-time)))
  (lambda (port) (format port "the time is ~s" val))
</pre></div>

<p>(There’s no provision for a mixture of <code class="code">cut</code> and <code class="code">cute</code>
where some expressions would be evaluated every time but others
evaluated only once.)
</p>
<p><code class="code">cut</code> is really just a shorthand for the sort of <code class="code">lambda</code>
forms shown in the above examples.  But notice <code class="code">cut</code> avoids the
need to name unspecialized parameters, and is more compact.  Use in
functional programming style or just with <code class="code">map</code>, <code class="code">for-each</code>
or similar is typical.
</p>
<div class="example">
<pre class="example-preformatted">(map (cut * 2 &lt;&gt;) '(1 2 3 4))         

(for-each (cut write &lt;&gt; my-port) my-list)  
</pre></div>
</dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d27">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d28" accesskey="n" rel="next">SRFI-28 - Basic Format Strings</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d26" accesskey="p" rel="prev">SRFI-26 - specializing parameters</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d27-_002d-Sources-of-Random-Bits">7.5.19 SRFI-27 - Sources of Random Bits</h4>
<a class="index-entry-id" id="index-SRFI_002d27"></a>

<p>This subsection is based on the
<a class="uref" href="http://srfi.schemers.org/srfi-27/srfi-27.html">specification of
SRFI-27</a> written by Sebastian Egner.
</p>





<p>This SRFI provides access to a (pseudo) random number generator; for
Guile’s built-in random number facilities, which SRFI-27 is implemented
upon, See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Random">Random Number Generation</a>.  With SRFI-27, random numbers are obtained from a
<em class="emph">random source</em>, which encapsulates a random number generation
algorithm and its state.
</p>

<ul class="mini-toc">
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Default-Random-Source" accesskey="1">The Default Random Source</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Sources" accesskey="2">Random Sources</a></li>
<li><a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Number-Generators" accesskey="3">Obtaining random number generator procedures</a></li>
</ul>
<hr>
<div class="subsubsection-level-extent" id="SRFI_002d27-Default-Random-Source">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Sources" accesskey="n" rel="next">Random Sources</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27" accesskey="u" rel="up">SRFI-27 - Sources of Random Bits</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="The-Default-Random-Source">7.5.19.1 The Default Random Source</h4>
<a class="index-entry-id" id="index-SRFI_002d27-1"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dinteger"><span class="category-def">Function: </span><span><strong class="def-name">random-integer</strong> <var class="def-var-arguments">n</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dinteger"> ¶</a></span></dt>
<dd><p>Return a random number between zero (inclusive) and <var class="var">n</var> (exclusive),
using the default random source.  The numbers returned have a uniform
distribution.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dreal"><span class="category-def">Function: </span><span><strong class="def-name">random-real</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dreal"> ¶</a></span></dt>
<dd><p>Return a random number in (0,1), using the default random source.  The
numbers returned have a uniform distribution.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-default_002drandom_002dsource"><span class="category-def">Function: </span><span><strong class="def-name">default-random-source</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-default_002drandom_002dsource"> ¶</a></span></dt>
<dd><p>A random source from which <code class="code">random-integer</code> and <code class="code">random-real</code>
have been derived using <code class="code">random-source-make-integers</code> and
<code class="code">random-source-make-reals</code> (see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Number-Generators">Obtaining random number generator procedures</a>
for those procedures).  Note that an assignment to
<code class="code">default-random-source</code> does not change <code class="code">random-integer</code> or
<code class="code">random-real</code>; it is also strongly recommended not to assign a new
value.
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d27-Random-Sources">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Number-Generators" accesskey="n" rel="next">Obtaining random number generator procedures</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Default-Random-Source" accesskey="p" rel="prev">The Default Random Source</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27" accesskey="u" rel="up">SRFI-27 - Sources of Random Bits</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Random-Sources">7.5.19.2 Random Sources</h4>
<a class="index-entry-id" id="index-SRFI_002d27-2"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-make_002drandom_002dsource"><span class="category-def">Function: </span><span><strong class="def-name">make-random-source</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002drandom_002dsource"> ¶</a></span></dt>
<dd><p>Create a new random source.  The stream of random numbers obtained from
each random source created by this procedure will be identical, unless
its state is changed by one of the procedures below.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_003f"><span class="category-def">Function: </span><span><strong class="def-name">random-source?</strong> <var class="def-var-arguments">object</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_003f"> ¶</a></span></dt>
<dd><p>Tests whether <var class="var">object</var> is a random source.  Random sources are a
disjoint type.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_002drandomize_0021"><span class="category-def">Function: </span><span><strong class="def-name">random-source-randomize!</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002drandomize_0021"> ¶</a></span></dt>
<dd><p>Attempt to set the state of the random source to a truly random value.
The current implementation uses a seed based on the current system time.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_002dpseudo_002drandomize_0021"><span class="category-def">Function: </span><span><strong class="def-name">random-source-pseudo-randomize!</strong> <var class="def-var-arguments">source i j</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dpseudo_002drandomize_0021"> ¶</a></span></dt>
<dd><p>Changes the state of the random source s into the initial state of the
(<var class="var">i</var>, <var class="var">j</var>)-th independent random source, where <var class="var">i</var> and
<var class="var">j</var> are non-negative integers.  This procedure provides a mechanism
to obtain a large number of independent random sources (usually all
derived from the same backbone generator), indexed by two integers. In
contrast to <code class="code">random-source-randomize!</code>, this procedure is entirely
deterministic.
</p></dd></dl>

<p>The state associated with a random state can be obtained an reinstated
with the following procedures:
</p>
<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_002dstate_002dref"><span class="category-def">Function: </span><span><strong class="def-name">random-source-state-ref</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dstate_002dref"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-random_002dsource_002dstate_002dset_0021"><span class="category-def">Function: </span><span><strong class="def-name">random-source-state-set!</strong> <var class="def-var-arguments">source state</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dstate_002dset_0021"> ¶</a></span></dt>
<dd><p>Get and set the state of a random source.  No assumptions should be made
about the nature of the state object, besides it having an external
representation (i.e. it can be passed to <code class="code">write</code> and subsequently
<code class="code">read</code> back).
</p></dd></dl>

<hr>
</div>
<div class="subsubsection-level-extent" id="SRFI_002d27-Random-Number-Generators">
<div class="nav-panel">
<p>
Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27-Random-Sources" accesskey="p" rel="prev">Random Sources</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27" accesskey="u" rel="up">SRFI-27 - Sources of Random Bits</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsubsection" id="Obtaining-random-number-generator-procedures">7.5.19.3 Obtaining random number generator procedures</h4>
<a class="index-entry-id" id="index-SRFI_002d27-3"></a>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_002dmake_002dintegers"><span class="category-def">Function: </span><span><strong class="def-name">random-source-make-integers</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dmake_002dintegers"> ¶</a></span></dt>
<dd><p>Obtains a procedure to generate random integers using the random source
<var class="var">source</var>.  The returned procedure takes a single argument <var class="var">n</var>,
which must be a positive integer, and returns the next uniformly
distributed random integer from the interval {0, ..., <var class="var">n</var>-1} by
advancing the state of <var class="var">source</var>.
</p>
<p>If an application obtains and uses several generators for the same
random source <var class="var">source</var>, a call to any of these generators advances
the state of <var class="var">source</var>.  Hence, the generators do not produce the
same sequence of random integers each but rather share a state. This
also holds for all other types of generators derived from a fixed random
sources.  
</p>
<p>While the SRFI text specifies that “Implementations that support
concurrency make sure that the state of a generator is properly
advanced”, this is currently not the case in Guile’s implementation of
SRFI-27, as it would cause a severe performance penalty.  So in
multi-threaded programs, you either must perform locking on random
sources shared between threads yourself, or use different random sources
for multiple threads.
</p></dd></dl>

<dl class="first-deffn first-defun-alias-first-deffn">
<dt class="deffn defun-alias-deffn" id="index-random_002dsource_002dmake_002dreals"><span class="category-def">Function: </span><span><strong class="def-name">random-source-make-reals</strong> <var class="def-var-arguments">source</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dmake_002dreals"> ¶</a></span></dt>
<dt class="deffnx defunx-alias-deffnx def-cmd-deffn" id="index-random_002dsource_002dmake_002dreals-1"><span class="category-def">Function: </span><span><strong class="def-name">random-source-make-reals</strong> <var class="def-var-arguments">source unit</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-random_002dsource_002dmake_002dreals-1"> ¶</a></span></dt>
<dd><p>Obtains a procedure to generate random real numbers <em class="math">0 &lt; x &lt; 1</em>
using the random source <var class="var">source</var>.  The procedure rand is called
without arguments.
</p>
<p>The optional parameter <var class="var">unit</var> determines the type of numbers being
produced by the returned procedure and the quantization of the output.
<var class="var">unit</var> must be a number such that <em class="math">0 &lt; <var class="var">unit</var> &lt; 1</em>.  The
numbers created by the returned procedure are of the same numerical type
as <var class="var">unit</var> and the potential output values are spaced by at most
<var class="var">unit</var>.  One can imagine rand to create numbers as <var class="var">x</var> *
<var class="var">unit</var> where <var class="var">x</var> is a random integer in {1, ...,
floor(1/unit)-1}.  Note, however, that this need not be the way the
values are actually created and that the actual resolution of rand can
be much higher than unit. In case <var class="var">unit</var> is absent it defaults to a
reasonably small value (related to the width of the mantissa of an
efficient number format).
</p></dd></dl>

<hr>
</div>
</div>
<div class="subsection-level-extent" id="SRFI_002d28">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d30" accesskey="n" rel="next">SRFI-30 - Nested Multi-line Comments</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d27" accesskey="p" rel="prev">SRFI-27 - Sources of Random Bits</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d28-_002d-Basic-Format-Strings">7.5.20 SRFI-28 - Basic Format Strings</h4>
<a class="index-entry-id" id="index-SRFI_002d28"></a>

<p>SRFI-28 provides a basic <code class="code">format</code> procedure that provides only
the <code class="code">~a</code>, <code class="code">~s</code>, <code class="code">~%</code>, and <code class="code">~~</code> format specifiers.
You can import this procedure by using:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-28))
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-format"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">format</strong> <var class="def-var-arguments">message arg …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-format"> ¶</a></span></dt>
<dd><p>Returns a formatted message, using <var class="var">message</var> as the format string,
which can contain the following format specifiers:
</p>
<dl class="table">
<dt><code class="code">~a</code></dt>
<dd><p>Insert the textual representation of the next <var class="var">arg</var>, as if printed
by <code class="code">display</code>.
</p>
</dd>
<dt><code class="code">~s</code></dt>
<dd><p>Insert the textual representation of the next <var class="var">arg</var>, as if printed
by <code class="code">write</code>.
</p>
</dd>
<dt><code class="code">~%</code></dt>
<dd><p>Insert a newline.
</p>
</dd>
<dt><code class="code">~~</code></dt>
<dd><p>Insert a tilde.
</p></dd>
</dl>

<p>This procedure is the same as calling <code class="code">simple-format</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Simple-Output">Simple Textual Output</a>) with <code class="code">#f</code> as the destination.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d30">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d31" accesskey="n" rel="next">SRFI-31 - A special form ‘rec’ for recursive evaluation</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d28" accesskey="p" rel="prev">SRFI-28 - Basic Format Strings</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d30-_002d-Nested-Multi_002dline-Comments">7.5.21 SRFI-30 - Nested Multi-line Comments</h4>
<a class="index-entry-id" id="index-SRFI_002d30"></a>

<p>Starting from version 2.0, Guile’s <code class="code">read</code> supports SRFI-30/R6RS
nested multi-line comments by default, <a class="ref" href="https://www.gnu.org/software/guile/manual/guile.html#Block-Comments">Block Comments</a>.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d31">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d34" accesskey="n" rel="next">SRFI-34 - Exception handling for programs</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d30" accesskey="p" rel="prev">SRFI-30 - Nested Multi-line Comments</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d31-_002d-A-special-form-_0060rec_0027-for-recursive-evaluation">7.5.22 SRFI-31 - A special form ‘rec’ for recursive evaluation</h4>
<a class="index-entry-id" id="index-SRFI_002d31"></a>
<a class="index-entry-id" id="index-recursive-expression"></a>
<a class="index-entry-id" id="index-rec"></a>

<p>SRFI-31 defines a special form that can be used to create
self-referential expressions more conveniently.  The syntax is as
follows:
</p>
<div class="example">
<div class="group"><pre class="example-preformatted">&lt;rec expression&gt; --&gt; (rec &lt;variable&gt; &lt;expression&gt;)
&lt;rec expression&gt; --&gt; (rec (&lt;variable&gt;+) &lt;body&gt;)
</pre></div></div>

<p>The first syntax can be used to create self-referential expressions,
for example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  guile&gt; (define tmp (rec ones (cons 1 (delay ones))))
</pre></div>

<p>The second syntax can be used to create anonymous recursive functions:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">  guile&gt; (define tmp (rec (display-n item n)
                       (if (positive? n)
                           (begin (display n) (display-n (- n 1))))))
  guile&gt; (tmp 42 3)
  424242
  guile&gt;
</pre></div>


<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d34">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d35" accesskey="n" rel="next">SRFI-35 - Conditions</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d31" accesskey="p" rel="prev">SRFI-31 - A special form ‘rec’ for recursive evaluation</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d34-_002d-Exception-handling-for-programs">7.5.23 SRFI-34 - Exception handling for programs</h4>

<a class="index-entry-id" id="index-SRFI_002d34"></a>
<p>Guile provides an implementation of
<a class="uref" href="http://srfi.schemers.org/srfi-34/srfi-34.html">SRFI-34’s exception
handling mechanisms</a> as an alternative to its own built-in mechanisms
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#Exceptions">Exceptions</a>).  It can be made available as follows:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-34))
</pre></div>

<p>See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Raising-and-Handling-Exceptions">Raising and Handling Exceptions</a>, for more on
<code class="code">with-exception-handler</code> and <code class="code">raise</code> (known as
<code class="code">raise-exception</code> in core Guile).
</p>
<p>SRFI-34’s <code class="code">guard</code> form is syntactic sugar over
<code class="code">with-exception-handler</code>:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-guard"><span class="category-def">Syntax: </span><span><strong class="def-name">guard</strong> <var class="def-var-arguments">(var clause …) body …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-guard"> ¶</a></span></dt>
<dd><p>Evaluate <var class="var">body</var> with an exception handler that binds the raised
object to <var class="var">var</var> and within the scope of that binding evaluates
<var class="var">clause</var>… as if they were the clauses of a cond expression.
That implicit cond expression is evaluated with the continuation and
dynamic environment of the guard expression.
</p>
<p>If every <var class="var">clause</var>’s test evaluates to false and there is no
<code class="code">else</code> clause, then <code class="code">raise</code> is re-invoked on the raised object
within the dynamic environment of the original call to <code class="code">raise</code>
except that the current exception handler is that of the <code class="code">guard</code>
expression.
</p></dd></dl>


<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d35">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d37" accesskey="n" rel="next">SRFI-37 - args-fold</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d34" accesskey="p" rel="prev">SRFI-34 - Exception handling for programs</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d35-_002d-Conditions">7.5.24 SRFI-35 - Conditions</h4>

<a class="index-entry-id" id="index-SRFI_002d35"></a>
<a class="index-entry-id" id="index-conditions"></a>
<a class="index-entry-id" id="index-exceptions"></a>

<p><a class="uref" href="http://srfi.schemers.org/srfi-35/srfi-35.html">SRFI-35</a> defines
<em class="dfn">conditions</em>, a data structure akin to records designed to convey
information about exceptional conditions between parts of a program.  It
is normally used in conjunction with SRFI-34’s <code class="code">raise</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(raise (condition (&amp;message
                    (message "An error occurred"))))
</pre></div>

<p>Users can define <em class="dfn">condition types</em> containing arbitrary information.
Condition types may inherit from one another.  This allows the part of
the program that handles (or “catches”) conditions to get accurate
information about the exceptional condition that arose.
</p>
<p>SRFI-35 conditions are made available using:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-35))
</pre></div>

<p>The procedures available to manipulate condition types are the
following:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcondition_002dtype"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-condition-type</strong> <var class="def-var-arguments">id parent field-names</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcondition_002dtype"> ¶</a></span></dt>
<dd><p>Return a new condition type named <var class="var">id</var>, inheriting from
<var class="var">parent</var>, and with the fields whose names are listed in
<var class="var">field-names</var>.  <var class="var">field-names</var> must be a list of symbols and must
not contain names already used by <var class="var">parent</var> or one of its supertypes.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition_002dtype_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">condition-type?</strong> <var class="def-var-arguments">obj</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dtype_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">obj</var> is a condition type.
</p></dd></dl>

<p>Conditions can be created and accessed with the following procedures:
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcondition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-condition</strong> <var class="def-var-arguments">type . field+value</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcondition"> ¶</a></span></dt>
<dd><p>Return a new condition of type <var class="var">type</var> with fields initialized as
specified by <var class="var">field+value</var>, a sequence of field names (symbols) and
values as in the following example:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(let ((&amp;ct (make-condition-type 'foo &amp;condition '(a b c))))
  (make-condition &amp;ct 'a 1 'b 2 'c 3))
</pre></div>

<p>Note that all fields of <var class="var">type</var> and its supertypes must be specified.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-make_002dcompound_002dcondition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">make-compound-condition</strong> <var class="def-var-arguments">condition1 condition2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-make_002dcompound_002dcondition"> ¶</a></span></dt>
<dd><p>Return a new compound condition composed of <var class="var">condition1</var>
<var class="var">condition2</var> <small class="enddots">...</small>.  The returned condition has the type of
each condition of condition1 condition2 … (per
<code class="code">condition-has-type?</code>).
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition_002dhas_002dtype_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">condition-has-type?</strong> <var class="def-var-arguments">c type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dhas_002dtype_003f"> ¶</a></span></dt>
<dd><p>Return true if condition <var class="var">c</var> has type <var class="var">type</var>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition_002dref"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">condition-ref</strong> <var class="def-var-arguments">c field-name</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dref"> ¶</a></span></dt>
<dd><p>Return the value of the field named <var class="var">field-name</var> from condition <var class="var">c</var>.
</p>
<p>If <var class="var">c</var> is a compound condition and several underlying condition
types contain a field named <var class="var">field-name</var>, then the value of the
first such field is returned, using the order in which conditions were
passed to <code class="code">make-compound-condition</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-extract_002dcondition"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">extract-condition</strong> <var class="def-var-arguments">c type</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-extract_002dcondition"> ¶</a></span></dt>
<dd><p>Return a condition of condition type <var class="var">type</var> with the field values
specified by <var class="var">c</var>.
</p>
<p>If <var class="var">c</var> is a compound condition, extract the field values from the
subcondition belonging to <var class="var">type</var> that appeared first in the call to
<code class="code">make-compound-condition</code> that created the condition.
</p></dd></dl>

<p>Convenience macros are also available to create condition types and
conditions.
</p>
<dl class="first-deffn">
<dt class="deffn" id="index-define_002dcondition_002dtype"><span class="category-def">library syntax: </span><span><strong class="def-name">define-condition-type</strong> <var class="def-var-arguments">type supertype predicate field-spec...</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-define_002dcondition_002dtype"> ¶</a></span></dt>
<dd><p>Define a new condition type named <var class="var">type</var> that inherits from
<var class="var">supertype</var>.  In addition, bind <var class="var">predicate</var> to a type predicate
that returns true when passed a condition of type <var class="var">type</var> or any of
its subtypes.  <var class="var">field-spec</var> must have the form <code class="code">(field
accessor)</code> where <var class="var">field</var> is the name of field of <var class="var">type</var> and
<var class="var">accessor</var> is the name of a procedure to access field <var class="var">field</var> in
conditions of type <var class="var">type</var>.
</p>
<p>The example below defines condition type <code class="code">&amp;foo</code>, inheriting from
<code class="code">&amp;condition</code> with fields <code class="code">a</code>, <code class="code">b</code> and <code class="code">c</code>:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(define-condition-type &amp;foo &amp;condition
  foo-condition?
  (a  foo-a)
  (b  foo-b)
  (c  foo-c))
</pre></div>
</dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition"><span class="category-def">library syntax: </span><span><strong class="def-name">condition</strong> <var class="def-var-arguments">type-field-binding1 type-field-binding2 …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition"> ¶</a></span></dt>
<dd><p>Return a new condition or compound condition, initialized according to
<var class="var">type-field-binding1</var> <var class="var">type-field-binding2</var> <small class="enddots">...</small>.  Each
<var class="var">type-field-binding</var> must have the form <code class="code">(type
field-specs...)</code>, where <var class="var">type</var> is the name of a variable bound to a
condition type; each <var class="var">field-spec</var> must have the form
<code class="code">(field-name value)</code> where <var class="var">field-name</var> is a symbol denoting
the field being initialized to <var class="var">value</var>.  As for
<code class="code">make-condition</code>, all fields must be specified.
</p>
<p>The following example returns a simple condition:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(condition (&amp;message (message "An error occurred")))
</pre></div>

<p>The one below returns a compound condition:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(condition (&amp;message (message "An error occurred"))
           (&amp;serious))
</pre></div>
</dd></dl>

<p>Finally, SRFI-35 defines a several standard condition types.
</p>
<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0026condition-1"><span class="category-def">Variable: </span><span><strong class="def-name">&amp;condition</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026condition-1"> ¶</a></span></dt>
<dd><p>This condition type is the root of all condition types.  It has no
fields.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0026message-2"><span class="category-def">Variable: </span><span><strong class="def-name">&amp;message</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026message-2"> ¶</a></span></dt>
<dd><p>A condition type that carries a message describing the nature of the
condition to humans.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-message_002dcondition_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">message-condition?</strong> <var class="def-var-arguments">c</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-message_002dcondition_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">c</var> is of type <code class="code">&amp;message</code> or one of its
subtypes.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-condition_002dmessage"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">condition-message</strong> <var class="def-var-arguments">c</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-condition_002dmessage"> ¶</a></span></dt>
<dd><p>Return the message associated with message condition <var class="var">c</var>.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0026serious-1"><span class="category-def">Variable: </span><span><strong class="def-name">&amp;serious</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026serious-1"> ¶</a></span></dt>
<dd><p>This type describes conditions serious enough that they cannot safely be
ignored.  It has no fields.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-serious_002dcondition_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">serious-condition?</strong> <var class="def-var-arguments">c</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-serious_002dcondition_003f"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">c</var> is of type <code class="code">&amp;serious</code> or one of its
subtypes.
</p></dd></dl>

<dl class="first-defvr first-defvar-alias-first-defvr">
<dt class="defvr defvar-alias-defvr" id="index-_0026error-2"><span class="category-def">Variable: </span><span><strong class="def-name">&amp;error</strong><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-_0026error-2"> ¶</a></span></dt>
<dd><p>This condition describes errors, typically caused by something that has
gone wrong in the interaction of the program with the external world or
the user.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-error_003f-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">error?</strong> <var class="def-var-arguments">c</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-error_003f-1"> ¶</a></span></dt>
<dd><p>Return true if <var class="var">c</var> is of type <code class="code">&amp;error</code> or one of its subtypes.
</p></dd></dl>

<p>As an implementation note, condition objects in Guile are the same as
“exception objects”.  See <a class="xref" href="https://www.gnu.org/software/guile/manual/guile.html#Exception-Objects">Exception Objects</a>.  The
<code class="code">&amp;condition</code>, <code class="code">&amp;serious</code>, and <code class="code">&amp;error</code> condition types
are known in core Guile as <code class="code">&amp;exception</code>, <code class="code">&amp;error</code>, and
<code class="code">&amp;external-error</code>, respectively.
</p>
<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d37">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d38" accesskey="n" rel="next">SRFI-38 - External Representation for Data With Shared Structure</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d35" accesskey="p" rel="prev">SRFI-35 - Conditions</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d37-_002d-args_002dfold">7.5.25 SRFI-37 - args-fold</h4>
<a class="index-entry-id" id="index-SRFI_002d37"></a>

<p>This is a processor for GNU <code class="code">getopt_long</code>-style program
arguments.  It provides an alternative, less declarative interface
than <code class="code">getopt-long</code> in <code class="code">(ice-9 getopt-long)</code>
(see <a class="pxref" href="https://www.gnu.org/software/guile/manual/guile.html#getopt_002dlong">The (ice-9 getopt-long) Module</a>).  Unlike
<code class="code">getopt-long</code>, it supports repeated options and any number of
short and long names per option.  Access it with:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(use-modules (srfi srfi-37))
</pre></div>

<p><abbr class="acronym">SRFI</abbr>-37 principally provides an <code class="code">option</code> type and the
<code class="code">args-fold</code> function.  To use the library, create a set of
options with <code class="code">option</code> and use it as a specification for invoking
<code class="code">args-fold</code>.
</p>
<p>Here is an example of a simple argument processor for the typical
‘<samp class="samp">--version</samp>’ and ‘<samp class="samp">--help</samp>’ options, which returns a backwards
list of files given on the command line:
</p>
<div class="example lisp">
<pre class="lisp-preformatted">(args-fold (cdr (program-arguments))
           (let ((display-and-exit-proc
                  (lambda (msg)
                    (lambda (opt name arg loads)
                      (display msg) (quit)))))
             (list (option '(#\v "version") #f #f
                           (display-and-exit-proc "Foo version 42.0\n"))
                   (option '(#\h "help") #f #f
                           (display-and-exit-proc
                            "Usage: foo scheme-file ..."))))
           (lambda (opt name arg loads)
             (error "Unrecognized option `~A'" name))
           (lambda (op loads) (cons op loads))
           '())
</pre></div>

<dl class="first-deffn">
<dt class="deffn" id="index-option-1"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option</strong> <var class="def-var-arguments">names required-arg? optional-arg? processor</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option-1"> ¶</a></span></dt>
<dd><p>Return an object that specifies a single kind of program option.
</p>
<p><var class="var">names</var> is a list of command-line option names, and should consist of
characters for traditional <code class="code">getopt</code> short options and strings for
<code class="code">getopt_long</code>-style long options.
</p>
<p><var class="var">required-arg?</var> and <var class="var">optional-arg?</var> are mutually exclusive;
one or both must be <code class="code">#f</code>.  If <var class="var">required-arg?</var>, the option
must be followed by an argument on the command line, such as
‘<samp class="samp">--opt=value</samp>’ for long options, or an error will be signalled.
If <var class="var">optional-arg?</var>, an argument will be taken if available.
</p>
<p><var class="var">processor</var> is a procedure that takes at least 3 arguments, called
when <code class="code">args-fold</code> encounters the option: the containing option
object, the name used on the command line, and the argument given for
the option (or <code class="code">#f</code> if none).  The rest of the arguments are
<code class="code">args-fold</code> “seeds”, and the <var class="var">processor</var> should return
seeds as well.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-option_002dnames"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option-names</strong> <var class="def-var-arguments">opt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option_002dnames"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-option_002drequired_002darg_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option-required-arg?</strong> <var class="def-var-arguments">opt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option_002drequired_002darg_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-option_002doptional_002darg_003f"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option-optional-arg?</strong> <var class="def-var-arguments">opt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option_002doptional_002darg_003f"> ¶</a></span></dt>
<dt class="deffnx def-cmd-deffn" id="index-option_002dprocessor"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">option-processor</strong> <var class="def-var-arguments">opt</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-option_002dprocessor"> ¶</a></span></dt>
<dd><p>Return the specified field of <var class="var">opt</var>, an option object, as
described above for <code class="code">option</code>.
</p></dd></dl>

<dl class="first-deffn">
<dt class="deffn" id="index-args_002dfold"><span class="category-def">Scheme Procedure: </span><span><strong class="def-name">args-fold</strong> <var class="def-var-arguments">args options unrecognized-option-proc operand-proc seed …</var><a class="copiable-link" href="https://www.gnu.org/software/guile/manual/guile.html#index-args_002dfold"> ¶</a></span></dt>
<dd><p>Process <var class="var">args</var>, a list of program arguments such as that returned by
<code class="code">(cdr (program-arguments))</code>, in order against <var class="var">options</var>, a list
of option objects as described above.  All functions called take the
“seeds”, or the last multiple-values as multiple arguments, starting
with <var class="var">seed</var> …, and must return the new seeds.  Return the
final seeds.
</p>
<p>Call <code class="code">unrecognized-option-proc</code>, which is like an option object’s
processor, for any options not found in <var class="var">options</var>.
</p>
<p>Call <code class="code">operand-proc</code> with any items on the command line that are
not named options.  This includes arguments after ‘<samp class="samp">--</samp>’.  It is
called with the argument in question, as well as the seeds.
</p></dd></dl>

<hr>
</div>
<div class="subsection-level-extent" id="SRFI_002d38">
<div class="nav-panel">
<p>
Next: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d39" accesskey="n" rel="next">SRFI-39 - Parameters</a>, Previous: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI_002d37" accesskey="p" rel="prev">SRFI-37 - args-fold</a>, Up: <a href="https://www.gnu.org/software/guile/manual/guile.html#SRFI-Support" accesskey="u" rel="up">SRFI Support Modules</a> &nbsp; [<a href="https://www.gnu.org/software/guile/manual/guile.html#SEC_Contents" title="Table of contents" rel="contents">Contents</a>][<a href="https://www.gnu.org/software/guile/manual/guile.html#Concept-Index" title="Index" rel="index">Index</a>]</p>
</div>
<h4 class="subsection" id="SRFI_002d38-_002d-External-Representation-for-Data-With-Shared-Structure">7.5.26 SRFI-38 - External Representation for Data With Shared Structure</h4>
<a class="index-entry-id" id="index-SRFI_002d38"></a>

<p>This subsection is based on
<a class="uref" href="http://srfi.schemers.org/srfi-38/srfi-38.html">the specification
of SRFI-38</a> written by Ray Dillinger.
</p>




<p>This SRFI creates an alternative external representation for data
written and read using <code class="code">write-with-shared-structure</code> and
<code class="code">read-with-shared-structure</code>.  It is identical to the grammar for
external representation for data written and read with <code class="code">write</code> and
<code class="code">read</code> given in section 7 of R5RS, except that the single
production
</p>
<div class="example">
<pre class="example-preformatted">&lt;datum&gt; --&gt; &lt;simple datum&gt; | &lt;compound datum&gt; 
</pre></div>

<p>is replaced by the following five </p></div></div></div></div></body></html>